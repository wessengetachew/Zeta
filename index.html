<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gap-Class Decomposition of Œ∂(2) ‚Äî Wessen Getachew</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400;1,500&family=JetBrains+Mono:wght@300;400;500&family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300;1,400&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --ink:#1a1814; --ink2:#3d3830; --ink3:#6b6358;
    --paper:#f7f4ef; --cream:#ede9e2; --rule:#c8c0b4;
    --gold:#8b6914; --goldl:#b8960f; --red:#8b1a1a;
    --blue:#1a3a6b; --green:#1a4a2a;
    --def-bg:#f2f4f8; --thm-bg:#f2f6f3;
  }
  html.dark {
    --ink:#e0d9ce; --ink2:#a89f94; --ink3:#6e665c;
    --paper:#131210; --cream:#1c1a17; --rule:#2a2824;
    --gold:#c9a23a; --goldl:#e0bc50; --red:#c05050;
    --blue:#6b9fd4; --green:#4a9a60;
    --def-bg:#14161e; --thm-bg:#131a15;
  }
  html, body, .abstract, .math-block, .definition, .theorem, .remark, .data-table, canvas, .bar-track {
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }
  html { background: var(--paper); color: var(--ink); }
  html.dark .definition { background: var(--def-bg); }
  html.dark .theorem    { background: var(--thm-bg); }
  html.dark canvas      { background: var(--cream); }

  #themeToggle {
    position: fixed; top: 22px; right: 26px; z-index: 200;
    width: 36px; height: 36px; border-radius: 50%;
    border: 1px solid var(--rule); background: var(--cream);
    color: var(--ink3); font-size: 1rem; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: background 0.3s, border-color 0.3s, color 0.3s, transform 0.15s;
    box-shadow: 0 2px 10px rgba(0,0,0,.10);
  }
  #themeToggle:hover { border-color: var(--gold); color: var(--gold); transform: scale(1.1); }

  body {
    font-family: 'EB Garamond', Georgia, serif;
    font-size: 19px; line-height: 1.75;
    max-width: 800px; margin: 0 auto; padding: 80px 40px 120px;
  }

  /* Header */
  .paper-header { text-align:center; border-bottom:1px solid var(--rule); padding-bottom:48px; margin-bottom:52px; }
  .paper-title { font-family:'Cormorant Garamond',Georgia,serif; font-size:2.6rem; font-weight:300; line-height:1.2; letter-spacing:-0.01em; color:var(--ink); margin-bottom:12px; }
  .paper-subtitle { font-family:'EB Garamond',serif; font-style:italic; font-size:1.1rem; color:var(--ink3); margin-bottom:28px; }
  .paper-meta { font-family:'JetBrains Mono',monospace; font-size:0.72rem; letter-spacing:0.06em; color:var(--ink3); text-transform:uppercase; }
  .paper-meta span { margin:0 12px; }
  .paper-msc { font-family:'JetBrains Mono',monospace; font-size:0.65rem; letter-spacing:0.05em; color:var(--ink3); margin-top:18px; line-height:1.9; }

  /* Tool link flash */
  @keyframes toolFlash {
    0%,100% { color:var(--gold); box-shadow:none; background:transparent; }
    50%      { color:var(--paper); background:var(--gold); box-shadow:0 0 12px rgba(139,105,20,.55); }
  }
  .tool-link {
    display:inline-block; padding:3px 10px; border-radius:3px;
    animation:toolFlash 1.4s ease-in-out infinite;
    text-decoration:none !important; border-bottom:none !important;
    font-weight:500; letter-spacing:0.03em; transition:none;
  }
  .tool-link:hover { animation-play-state:paused; color:var(--paper) !important; background:var(--gold); }

  /* Abstract */
  .abstract { background:var(--cream); border-left:3px solid var(--gold); padding:24px 32px; margin:0 0 52px; font-size:0.95rem; line-height:1.8; }
  .abstract-label { font-family:'JetBrains Mono',monospace; font-size:0.65rem; letter-spacing:0.12em; text-transform:uppercase; color:var(--gold); margin-bottom:10px; }

  /* Sections */
  h2 { font-family:'Cormorant Garamond',serif; font-weight:400; font-size:1.55rem; letter-spacing:0.01em; color:var(--ink); margin:56px 0 18px; padding-bottom:6px; border-bottom:1px solid var(--rule); }
  h2 .sec-num { font-family:'JetBrains Mono',monospace; font-size:0.75rem; color:var(--ink3); margin-right:12px; vertical-align:middle; letter-spacing:0.04em; }
  h3 { font-family:'EB Garamond',serif; font-weight:600; font-size:1.05rem; color:var(--ink2); margin:32px 0 10px; }
  p { margin-bottom:18px; }

  /* Math */
  .math-block { background:var(--cream); border:1px solid var(--rule); border-radius:3px; padding:22px 32px; margin:24px 0; text-align:center; font-family:'JetBrains Mono',monospace; font-size:0.88rem; line-height:1.9; color:var(--ink); overflow-x:auto; }
  .math-label { font-family:'JetBrains Mono',monospace; font-size:0.62rem; color:var(--ink3); letter-spacing:0.08em; text-transform:uppercase; display:block; text-align:right; margin-top:8px; }
  .math-inline { font-family:'JetBrains Mono',monospace; font-size:0.84em; background:var(--cream); padding:1px 5px; border-radius:2px; color:var(--blue); }

  /* Definition */
  .definition { border:1px solid var(--rule); border-top:3px solid var(--blue); padding:20px 28px; margin:28px 0; background:var(--def-bg); }
  .definition-label { font-family:'JetBrains Mono',monospace; font-size:0.65rem; letter-spacing:0.1em; text-transform:uppercase; color:var(--blue); margin-bottom:8px; }
  .definition p { margin-bottom:0; font-size:0.95rem; }

  /* Theorem */
  .theorem { border:1px solid var(--rule); border-top:3px solid var(--green); padding:20px 28px; margin:28px 0; background:var(--thm-bg); }
  .theorem-label { font-family:'JetBrains Mono',monospace; font-size:0.65rem; letter-spacing:0.1em; text-transform:uppercase; color:var(--green); margin-bottom:8px; }
  .theorem p { margin-bottom:0; font-size:0.95rem; }

  /* Remark */
  .remark { border-left:2px solid var(--gold); padding:14px 24px; margin:24px 0; color:var(--ink2); font-style:italic; font-size:0.95rem; }
  .remark-label { font-style:normal; font-family:'JetBrains Mono',monospace; font-size:0.62rem; letter-spacing:0.08em; text-transform:uppercase; color:var(--gold); display:block; margin-bottom:4px; }

  /* Interactive table controls */
  .table-controls { display:flex; gap:14px; align-items:center; flex-wrap:wrap; margin-bottom:12px; font-family:'JetBrains Mono',monospace; font-size:0.72rem; color:var(--ink3); }
  .table-controls label { display:flex; align-items:center; gap:6px; }
  .table-controls input[type="number"] {
    width:120px; padding:4px 8px;
    font-family:'JetBrains Mono',monospace; font-size:0.72rem;
    background:var(--cream); border:1px solid var(--rule); border-radius:2px; color:var(--ink);
    transition:border-color 0.2s;
  }
  .table-controls input[type="number"]:focus { outline:none; border-color:var(--gold); }
  .table-controls button.compute-btn {
    padding:4px 14px; font-family:'JetBrains Mono',monospace; font-size:0.68rem;
    letter-spacing:0.06em; text-transform:uppercase;
    background:var(--gold); color:var(--paper); border:none; border-radius:2px; cursor:pointer; transition:opacity 0.2s;
  }
  .table-controls button.compute-btn:hover { opacity:0.82; }
  .table-controls button.compute-btn:disabled { opacity:0.4; cursor:not-allowed; }
  .range-note { color:var(--ink3); font-size:0.62rem; }

  /* Progress bar */
  .progress-wrap { margin:8px 0; display:none; }
  .progress-bar { height:3px; background:var(--cream); border-radius:2px; overflow:hidden; }
  .progress-fill { height:100%; background:var(--gold); width:0%; transition:width 0.1s; border-radius:2px; }
  .progress-label { font-family:'JetBrains Mono',monospace; font-size:0.62rem; color:var(--gold); margin-top:4px; letter-spacing:0.05em; }

  /* Scrollable table wrapper */
  .table-scroll {
    max-height: 320px;
    overflow-y: auto;
    border: 1px solid var(--rule);
    border-radius: 3px;
    margin-bottom: 6px;
  }
  .table-scroll .data-table { margin: 0; }
  .table-scroll .data-table thead th {
    position: sticky; top: 0;
    background: var(--paper); z-index: 2;
    border-bottom: 2px solid var(--ink2);
  }
  html.dark .table-scroll .data-table thead th { background: var(--paper); }
  .table-scroll::-webkit-scrollbar { width: 6px; }
  .table-scroll::-webkit-scrollbar-track { background: var(--cream); }
  .table-scroll::-webkit-scrollbar-thumb { background: var(--rule); border-radius: 3px; }

  /* Stats bar */
  .table-stats {
    display: flex; gap: 20px; flex-wrap: wrap;
    font-family: 'JetBrains Mono', monospace; font-size: 0.68rem;
    color: var(--ink3); margin-bottom: 10px; letter-spacing: 0.03em;
  }
  .table-stats .stat { display: flex; flex-direction: column; gap: 2px; }
  .table-stats .stat-val { color: var(--gold); font-size: 0.8rem; font-weight: 500; }
  .table-stats .stat-lbl { font-size: 0.60rem; text-transform: uppercase; letter-spacing: 0.07em; }

  /* Decimal selector */
  .decimal-row {
    display: flex; align-items: center; gap: 8px;
    font-family: 'JetBrains Mono', monospace; font-size: 0.65rem;
    color: var(--ink3); margin-bottom: 10px;
  }
  .decimal-row span { text-transform: uppercase; letter-spacing: 0.06em; }
  .dec-btn {
    padding: 2px 8px; border-radius: 2px; cursor: pointer;
    font-family: 'JetBrains Mono', monospace; font-size: 0.65rem;
    border: 1px solid var(--rule); background: var(--cream); color: var(--ink2);
    transition: border-color 0.15s, color 0.15s;
  }
  .dec-btn:hover { border-color: var(--gold); color: var(--gold); }
  .dec-btn.active { border-color: var(--gold); background: var(--gold); color: var(--paper); }

  /* Data table */
  .data-table { width:100%; border-collapse:collapse; font-family:'JetBrains Mono',monospace; font-size:0.75rem; margin:0; color:var(--ink); }
  .data-table thead tr { border-bottom:2px solid var(--ink2); }
  .data-table th { padding:8px 12px; text-align:left; font-weight:500; letter-spacing:0.04em; color:var(--ink2); font-size:0.65rem; text-transform:uppercase; }
  .data-table td { padding:7px 12px; border-bottom:1px solid var(--cream); }
  .data-table tbody tr:hover { background:var(--cream); }
  .data-table .num { text-align:right; }
  .data-table .hi  { color:var(--blue); font-weight:500; }
  .data-table .gold { color:var(--gold); font-weight:500; }

  /* Bar chart */
  .bar-chart { margin:20px 0 0; }
  .bar-row { display:flex; align-items:center; gap:12px; margin-bottom:7px; font-family:'JetBrains Mono',monospace; font-size:0.72rem; }
  .bar-lbl { width:54px; color:var(--ink3); text-align:right; flex-shrink:0; }
  .bar-track { flex:1; height:14px; background:var(--cream); border-radius:2px; overflow:hidden; }
  .bar-fill { height:100%; border-radius:2px; transition:width 0.6s ease; }
  .bar-val { width:60px; color:var(--ink2); flex-shrink:0; }

  /* Fig caption */
  .fig-caption { font-size:0.82rem; color:var(--ink3); font-style:italic; text-align:center; margin-top:4px; margin-bottom:28px; }

  /* Canvas */
  canvas { display:block; width:100%; border:1px solid var(--rule); border-radius:3px; margin:20px 0 8px; background:var(--cream); }

  /* Ack */
  .ack { font-size:0.88rem; color:var(--ink3); border-top:1px solid var(--rule); padding-top:28px; margin-top:56px; line-height:1.9; }
  .ack-label { font-family:'JetBrains Mono',monospace; font-size:0.65rem; letter-spacing:0.1em; text-transform:uppercase; color:var(--ink3); margin-bottom:8px; display:block; }

  /* References */
  .references { font-size:0.82rem; border-top:1px solid var(--rule); padding-top:32px; margin-top:72px; color:var(--ink3); line-height:1.9; }
  .references h2 { font-size:1.2rem; margin-top:0; }
  .ref-item { display:flex; gap:16px; margin-bottom:10px; }
  .ref-num { font-family:'JetBrains Mono',monospace; font-size:0.68rem; color:var(--gold); flex-shrink:0; padding-top:2px; }

  /* Responsive */
  @media (max-width:600px) {
    body { padding:40px 20px 80px; font-size:17px; }
    .paper-title { font-size:2rem; }
    .math-block { padding:16px 18px; font-size:0.78rem; }
    .table-controls { flex-direction:column; align-items:flex-start; }
  }

  /* Animations */
  @keyframes fadeUp { from { opacity:0; transform:translateY(12px); } to { opacity:1; transform:translateY(0); } }
  .paper-header { animation:fadeUp 0.7s ease both; }
  .abstract     { animation:fadeUp 0.7s ease 0.15s both; }
  main          { animation:fadeUp 0.7s ease 0.25s both; }

  @media print {
    body { padding:40px; font-size:11pt; }
    .paper-title { font-size:1.8rem; }
    h2 { page-break-after:avoid; }
    .math-block, .definition, .theorem { page-break-inside:avoid; }
    .table-controls, .show-all-btn, .progress-wrap { display:none !important; }
    .extra-rows { display:table-row-group !important; }
  }
</style>
</head>
<body>

<button id="themeToggle" title="Toggle dark / light mode" aria-label="Toggle dark mode">üåô</button>

<header class="paper-header">
  <h1 class="paper-title">Gap-Class Decomposition<br>of Œ∂(2) = œÄ¬≤/6</h1>
  <p class="paper-subtitle">A partition of the Euler product by prime gap families</p>
  <p style="margin-top:10px;font-size:0.85rem;font-family:'JetBrains Mono',monospace;">
    <a href="https://wessengetachew.github.io/Quant/" target="_blank" rel="noopener" class="tool-link">
      ‚Üí Explore the interactive analysis tool
    </a>
  </p>
  <div class="paper-meta" style="margin-top:20px">
    <span>Wessen Getachew</span><span>¬∑</span>
    <span>Independent Researcher</span><span>¬∑</span>
    <span>2026</span><span>¬∑</span><span>Preprint</span>
  </div>
  <div class="paper-msc">
    <div><strong>MSC 2020:</strong> 11M06 ¬∑ 11N05 ¬∑ 11N36</div>
    <div style="margin-top:4px"><strong>Keywords:</strong> Riemann zeta function ¬∑ prime gaps ¬∑ Euler product ¬∑ gap-class sub-products ¬∑ Hardy-Littlewood conjecture ¬∑ twin primes</div>
  </div>
</header>

<div class="abstract">
  <div class="abstract-label">Abstract</div>
  The Euler product for Œ∂(2) = œÄ¬≤/6 is ordinarily indexed by individual primes. This paper reindexes it by prime gap size, grouping each prime with others that share the same forward gap. The construction yields a family of sub-products <em>P<sub>g</sub></em>, one per gap class, whose full product recovers Œ∂(2). It is shown that twin primes (gap 2) account for approximately 34.79% of log Œ∂(2) at N = 4 √ó 10<sup>8</sup> ‚Äî second only to the prime 2 itself ‚Äî and that the Hardy-Littlewood singular series, classically a density prediction for prime pairs, determines the asymptotic ratio of log-weights between any two gap classes. The framework extends to Œ∂(s) for all Re(s) > 1.
</div>

<main>

<h2><span class="sec-num">1.</span> Introduction</h2>

<p>
  Euler's 1734 resolution of the Basel problem establishes the identity connecting Œ∂(2) to an infinite product over primes:
</p>

<div class="math-block">
  Œ∂(2) &nbsp;=&nbsp; Œ£<sub>n=1</sub><sup>‚àû</sup> 1/n¬≤
  &nbsp;=&nbsp;
  ‚àè<sub>p prime</sub> p¬≤/(p¬≤‚àí1)
  &nbsp;=&nbsp; œÄ¬≤/6
  &nbsp;‚âà&nbsp; 1.6449340668‚Ä¶
  <span class="math-label">Euler (1734)</span>
</div>

<p>
  The Euler product organizes the contribution of each prime individually, without regard to its arithmetic relationship with neighboring primes. This paper pursues a different factorization: primes are grouped by the <em>forward gap</em> to the next prime. Twin primes (gap 2), cousin primes (gap 4), and sexy primes (gap 6) each constitute a natural family under this classification. The central question is what multiplicative weight each family carries in the product for Œ∂(2), and whether those weights admit a theoretical explanation.
</p>

<p>
  Since the Euler product converges absolutely for Re(s) > 1, any rearrangement of its factors is permitted and converges to the same value. Grouping factors by gap class is therefore valid, and the resulting sub-products are well-defined. Less obvious are the numerical magnitudes, the rate of convergence when gap classes are added sequentially, and whether the relative sizes of sub-products can be derived from existing number-theoretic predictions. The sections that follow address each of these questions in turn.
</p>

<h2><span class="sec-num">2.</span> Definitions and Decomposition</h2>

<div class="definition">
  <div class="definition-label">Definition 1 ‚Äî Forward gap</div>
  <p>
    For a prime <em>p<sub>n</sub></em>, the <strong>forward gap</strong>
    <span class="math-inline">gap(p<sub>n</sub>) = p<sub>n+1</sub> ‚àí p<sub>n</sub></span>
    is the distance to the next prime. The set of all forward gaps partitions the primes into disjoint <strong>gap classes</strong>; in any finite computation to N, the largest prime is assigned to a residual class whose contribution vanishes as N ‚Üí ‚àû.
  </p>
</div>

<div class="definition">
  <div class="definition-label">Definition 2 ‚Äî Gap-class sub-product</div>
  <p>
    For each gap size <em>g</em> ‚àà {1, 2, 4, 6, 8, ‚Ä¶}, the <strong>gap-class sub-product</strong> at exponent <em>s</em> is:
  </p>
</div>

<div class="math-block">
  P<sub>g</sub>(s) &nbsp;=&nbsp;
  ‚àè<sub>{ p : gap(p) = g }</sub>
  p<sup>s</sup> / (p<sup>s</sup> ‚àí 1)
</div>

<p>
  Gap class <em>g</em> = 1 contains only the prime 2, contributing the fixed factor 4/3. Every other realized gap size is even, since all primes beyond 2 are odd.
</p>

<div class="theorem">
  <div class="theorem-label">Observation ‚Äî Decomposition</div>
  <p>
    For Re(s) > 1, the Euler product for Œ∂(s) admits the gap-class factorization Œ∂(s) = ‚àè<sub>g ‚àà G</sub> P<sub>g</sub>(s), where G = {1, 2, 4, 6, 8, ‚Ä¶} is the set of all prime gap sizes. This follows directly from absolute convergence, which permits arbitrary rearrangement of the factors.
  </p>
</div>

<div class="remark">
  <span class="remark-label">Remark</span>
  This factorization carries no deeper analytic content beyond what absolute convergence guarantees. Its interest lies entirely in what the numerical magnitudes and their theoretical ratios reveal about prime gap structure.
</div>

<h2><span class="sec-num">3.</span> Log-Weights and Numerical Evidence</h2>

<p>
  To measure the contribution of each gap class to Œ∂(s), define the <strong>log-weight</strong>
</p>

<div class="math-block">
  w<sub>g</sub>(s) &nbsp;=&nbsp; log P<sub>g</sub>(s) &nbsp;=&nbsp;
  Œ£<sub>{ p : gap(p)=g }</sub> log( p<sup>s</sup> / (p<sup>s</sup>‚àí1) )
</div>

<p>
  Since log Œ∂(s) = Œ£<sub>g</sub> w<sub>g</sub>(s), the <strong>percentage contribution</strong> of gap class <em>g</em> is defined as
  <span class="math-inline">C<sub>g</sub>(s) = w<sub>g</sub>(s) / log Œ∂(s) √ó 100%</span>.
  Table 1 reports these quantities at <em>s</em> = 2, computed by a segmented sieve over all primes up to the selected bound N. The computation runs directly in the browser; for N above ~200M results are estimated from precomputed data scaled to the correct prime density.
</p>

<!-- TABLE 1 controls -->
<div class="table-controls">
  <label>N (upper bound):
    <input type="number" id="t1-n" value="400000000" min="100000" max="500000000" step="1000000">
  </label>
  <button class="compute-btn" id="t1-btn" onclick="runSieve('t1')">Compute</button>
  <span class="range-note">1M ‚Äì 500M (above 50M uses scaled estimates)</span>
</div>
<div class="progress-wrap" id="t1-progress">
  <div class="progress-bar"><div class="progress-fill" id="t1-fill"></div></div>
  <div class="progress-label" id="t1-label">Sieving‚Ä¶</div>
</div>

<!-- Stats bar -->
<div class="table-stats" id="t1-stats" style="display:none">
  <div class="stat"><span class="stat-val" id="t1-stat-gaps">‚Äî</span><span class="stat-lbl">Gap classes found</span></div>
  <div class="stat"><span class="stat-val" id="t1-stat-maxgap">‚Äî</span><span class="stat-lbl">Largest gap</span></div>
  <div class="stat"><span class="stat-val" id="t1-stat-primes">‚Äî</span><span class="stat-lbl">Total primes</span></div>
  <div class="stat"><span class="stat-val" id="t1-stat-coverage">‚Äî</span><span class="stat-lbl">Top-2 coverage</span></div>
</div>

<!-- Decimal selector -->
<div class="decimal-row" id="t1-dec-row" style="display:none">
  <span>Decimals:</span>
  <button class="dec-btn" onclick="setDecimals('t1',4)" data-t="t1" data-d="4">4</button>
  <button class="dec-btn" onclick="setDecimals('t1',6)" data-t="t1" data-d="6">6</button>
  <button class="dec-btn active" onclick="setDecimals('t1',7)" data-t="t1" data-d="7">7</button>
  <button class="dec-btn" onclick="setDecimals('t1',10)" data-t="t1" data-d="10">10</button>
  <button class="dec-btn" onclick="setDecimals('t1',15)" data-t="t1" data-d="15">15</button>
</div>

<div class="table-scroll">
  <table class="data-table">
    <thead>
      <tr>
        <th>Gap g</th>
        <th>Family name</th>
        <th class="num">Prime count</th>
        <th class="num">log P<sub>g</sub></th>
        <th class="num">% of log Œ∂(2)</th>
        <th class="num">P<sub>g</sub> value</th>
      </tr>
    </thead>
    <tbody id="t1-body"></tbody>
  </table>
</div>
<p class="fig-caption" id="t1-caption">Table 1. Gap-class contributions to log Œ∂(2) at selected N.</p>

<div class="bar-chart" id="barChart"></div>
<p class="fig-caption" id="bar-caption" style="display:none">Fig. 1. Log-weight distribution of gap classes at s = 2 for selected N.</p>

<h2><span class="sec-num">4.</span> Convergence to Œ∂(2)</h2>

<p>
  When gap classes are added sequentially ‚Äî in order of increasing gap size ‚Äî the cumulative product converges monotonically to œÄ¬≤/6. The first two steps alone (gap 1 and gap 2) recover over 93% of the limiting value at large N, reflecting the arithmetic dominance of small primes. Table 2 tracks the cumulative product and its distance from œÄ¬≤/6 at each step.
</p>

<!-- TABLE 2 controls -->
<div class="table-controls">
  <label>N (upper bound):
    <input type="number" id="t2-n" value="400000000" min="100000" max="500000000" step="1000000">
  </label>
  <button class="compute-btn" id="t2-btn" onclick="runSieve('t2')">Compute</button>
  <span class="range-note">Shares computation with Table 1 when N matches</span>
</div>
<div class="progress-wrap" id="t2-progress">
  <div class="progress-bar"><div class="progress-fill" id="t2-fill"></div></div>
  <div class="progress-label" id="t2-label">Sieving‚Ä¶</div>
</div>

<!-- Stats bar -->
<div class="table-stats" id="t2-stats" style="display:none">
  <div class="stat"><span class="stat-val" id="t2-stat-steps">‚Äî</span><span class="stat-lbl">Convergence steps</span></div>
  <div class="stat"><span class="stat-val" id="t2-stat-after2">‚Äî</span><span class="stat-lbl">Product after gap 2</span></div>
  <div class="stat"><span class="stat-val" id="t2-stat-finalerr">‚Äî</span><span class="stat-lbl">Final relative error</span></div>
</div>

<!-- Decimal selector -->
<div class="decimal-row" id="t2-dec-row" style="display:none">
  <span>Decimals:</span>
  <button class="dec-btn" onclick="setDecimals('t2',4)" data-t="t2" data-d="4">4</button>
  <button class="dec-btn" onclick="setDecimals('t2',6)" data-t="t2" data-d="6">6</button>
  <button class="dec-btn active" onclick="setDecimals('t2',9)" data-t="t2" data-d="9">9</button>
  <button class="dec-btn" onclick="setDecimals('t2',12)" data-t="t2" data-d="12">12</button>
  <button class="dec-btn" onclick="setDecimals('t2',15)" data-t="t2" data-d="15">15</button>
</div>

<div class="table-scroll">
  <table class="data-table">
    <thead>
      <tr>
        <th>Step</th>
        <th>Gap added</th>
        <th class="num">Cumulative product</th>
        <th class="num">Absolute error</th>
        <th class="num">Relative error</th>
      </tr>
    </thead>
    <tbody id="t2-body"></tbody>
  </table>
</div>
<p class="fig-caption" id="t2-caption">Table 2. Cumulative product at s = 2 for selected N.</p>

<canvas id="convCanvas" height="200"></canvas>
<p class="fig-caption">Fig. 2. Convergence of the cumulative gap-class product to œÄ¬≤/6 ‚âà 1.6449.</p>

<h2><span class="sec-num">5.</span> Connection to Hardy-Littlewood</h2>

<p>
  Hardy-Littlewood Conjecture B (1923) predicts that the count of prime pairs (p, p + g) for even g satisfies
</p>

<div class="math-block">
  œÄ<sub>g</sub>(x) &nbsp;~&nbsp; S(g) ¬∑ li<sub>2</sub>(x)
  &nbsp;&nbsp; as x ‚Üí ‚àû
  <span class="math-label">Hardy-Littlewood Conjecture B (1923)</span>
</div>

<p>
  where the <strong>singular series</strong> is
  <span class="math-inline">S(g) = 2C<sub>2</sub> ¬∑ ‚àè<sub>p|g, p‚â•3</sub> (p‚àí1)/(p‚àí2)</span>
  and C<sub>2</sub> ‚âà 0.6601618‚Ä¶ is the twin prime constant:
</p>

<div class="math-block">
  C<sub>2</sub> &nbsp;=&nbsp; ‚àè<sub>p ‚â• 3</sub> p(p‚àí2)/(p‚àí1)¬≤
  &nbsp;‚âà&nbsp; 0.6601618158468695‚Ä¶
</div>

<p>
  In the gap-class framework, S(g) serves a different role: because the count of primes with forward gap g governs the size of P<sub>g</sub>(s), and S(g) governs that count asymptotically, the singular series determines the asymptotic <em>ratio of log-weights</em> ‚Äî a statement about the Euler product rather than about pair counts.
</p>

<div class="theorem">
  <div class="theorem-label">Proposition 1 ‚Äî Hardy-Littlewood predicts log-weight ratios</div>
  <p>
    Conditional on Hardy-Littlewood Conjecture B, as N ‚Üí ‚àû the ratio of log-weights of any two gap classes g, h converges:
    w<sub>g</sub>(s) / w<sub>h</sub>(s) ‚Üí S(g) / S(h).
  </p>
</div>

<p>
  Table 3 presents the numerical evidence. Since S(2) = S(4) = 2C<sub>2</sub>, twin primes and cousin primes are predicted to carry equal asymptotic log-weight ‚Äî and at N = 400M their prime counts differ by fewer than 800, a ratio of 0.9999. Since S(6) = 4C<sub>2</sub> = 2¬∑S(2), sexy primes are predicted to be twice as dense as twin primes asymptotically; the observed ratio at N = 400M is 1.71, still approaching 2.
</p>

<table class="data-table">
  <thead>
    <tr>
      <th>Gap g</th>
      <th>Odd prime divisors of g</th>
      <th class="num">S(g)</th>
      <th class="num">S(g)/S(2)</th>
      <th class="num">Observed ratio (400M)</th>
      <th class="num">Limiting value</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>2</td><td>none</td><td class="num">2C‚ÇÇ ‚âà 1.3203</td><td class="num gold">1.000</td><td class="num">1.000</td><td class="num">1.000</td></tr>
    <tr><td>4</td><td>none</td><td class="num">2C‚ÇÇ ‚âà 1.3203</td><td class="num">1.000</td><td class="num">0.9999</td><td class="num">1.000</td></tr>
    <tr><td>6</td><td>3 ‚Üí √ó2</td><td class="num">4C‚ÇÇ ‚âà 2.6406</td><td class="num">2.000</td><td class="num">1.712</td><td class="num">2.000</td></tr>
    <tr><td>10</td><td>5 ‚Üí √ó4/3</td><td class="num">8C‚ÇÇ/3 ‚âà 1.760</td><td class="num">1.333</td><td class="num">1.178</td><td class="num">1.333</td></tr>
    <tr><td>30</td><td>3, 5 ‚Üí √ó8/3</td><td class="num">16C‚ÇÇ/3 ‚âà 3.521</td><td class="num">2.667</td><td class="num">2.312</td><td class="num">2.667</td></tr>
  </tbody>
</table>
<p class="fig-caption">Table 3. Singular series values and observed prime-count ratios relative to gap 2, at N = 400M.</p>

<div class="remark">
  <span class="remark-label">Remark</span>
  The factor of 2 between S(6) and S(2) has a transparent arithmetic explanation. For any prime p, the pair (p, p+6) satisfies p ‚â° p+6 (mod 3), so neither element is forced to be divisible by 3; this frees an extra residue class and doubles the admissible pair count. Gap 4 carries no analogous bonus: since 3 does not divide 4, the residue constraint at p = 3 applies in full, giving S(4) = S(2).
</div>

<h2><span class="sec-num">6.</span> Generalization to Œ∂(s)</h2>

<p>
  The sub-product decomposition extends to all Re(s) > 1. As s increases, the factor p<sup>s</sup>/(p<sup>s</sup>‚àí1) decays to 1 faster for large primes than for small ones, so P<sub>1</sub>(s) ‚Äî the contribution of the prime 2 alone ‚Äî becomes increasingly dominant. As s ‚Üí ‚àû, P<sub>1</sub>(s) ‚Üí 4/3 while all other P<sub>g</sub>(s) ‚Üí 1, so the dominant contribution to Œ∂(s) is the single factor 2<sup>s</sup>/(2<sup>s</sup>‚àí1). Table 4 quantifies this shift.
</p>

<table class="data-table">
  <thead>
    <tr>
      <th>s</th>
      <th class="num">Gap 1 (p=2)</th>
      <th class="num">Gap 2 (twins)</th>
      <th class="num">Gap 4 (cousins)</th>
      <th class="num">All remaining</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>1.5</td><td class="num">44.8%</td><td class="num">39.2%</td><td class="num">9.1%</td><td class="num">6.9%</td></tr>
    <tr><td class="gold">2</td><td class="num gold">58.4%</td><td class="num gold">34.8%</td><td class="num gold">4.5%</td><td class="num gold">2.3%</td></tr>
    <tr><td>3</td><td class="num">74.2%</td><td class="num">21.6%</td><td class="num">2.8%</td><td class="num">1.4%</td></tr>
    <tr><td>4</td><td class="num">82.1%</td><td class="num">15.3%</td><td class="num">1.7%</td><td class="num">0.9%</td></tr>
    <tr><td>10</td><td class="num">95.8%</td><td class="num">3.8%</td><td class="num">0.3%</td><td class="num">0.1%</td></tr>
  </tbody>
</table>
<p class="fig-caption">Table 4. Log-weight percentages by exponent s, estimated at N = 10M.</p>

<h2><span class="sec-num">7.</span> The Finiteness Question for P<sub>2</sub>(s)</h2>

<p>
  If the set of twin primes were finite, P<sub>2</sub>(s) would be a finite Euler product ‚Äî a rational function of e<sup>‚àís</sup> ‚Äî with poles at s = 2œÄik/log p for each twin prime p. These poles lie on Re(s) = 0, outside the domain of absolute convergence, but their analytic implications constrain the full product: Œ∂(s) = P<sub>1</sub>(s) ¬∑ P<sub>2</sub>(s) ¬∑ ‚àè<sub>g‚â•4</sub> P<sub>g</sub>(s) must remain entire on Re(s) > 1 and consistent with the known analytic structure of Œ∂(s).
</p>

<p>
  For this to hold, the poles introduced by a finite P<sub>2</sub>(s) would have to be cancelled exactly by corresponding zeros in the remaining sub-products. Whether such cancellation is compatible with the non-vanishing of Œ∂(s) on Re(s) = 1 is not immediately clear. If it is not, the gap-class decomposition would yield a new obstruction to the finiteness of twin primes, independent of sieve methods and of the Riemann hypothesis.
</p>

<h2><span class="sec-num">8.</span> Open Problems</h2>

<p>
  <strong>Q1 (Closed form for P<sub>2</sub>(2)).</strong> Numerically P<sub>2</sub>(2) ‚âà 1.18689‚Ä¶. No relation to œÄ, C<sub>2</sub>, or other standard constants is apparent. The analogous question for the full Euler product was resolved by Euler; for individual gap-class sub-products it remains open.
</p>

<p>
  <strong>Q2 (Tail asymptotics).</strong> The partial products in Table 2 suggest the relative error decays roughly as 1/g after the first few gap families. A precise asymptotic for the tail |Œ∂(s) ‚àí ‚àè<sub>g ‚â§ G</sub> P<sub>g</sub>(s)| as G ‚Üí ‚àû has not been established.
</p>

<p>
  <strong>Q3 (Optimal ordering).</strong> Ordering gap classes by size is natural but not provably optimal for convergence speed. An ordering by log-weight or prime density may achieve faster convergence to Œ∂(s).
</p>

<p>
  <strong>Q4 (Analytic obstruction to finiteness).</strong> As discussed in Section 7: if the analytic constraints on Œ∂(s) are incompatible with a rational P<sub>2</sub>(s), the gap-class decomposition provides a new obstruction to the finiteness of twin primes. Making this argument precise is the principal open problem raised by this work.
</p>

<h2><span class="sec-num">9.</span> Conclusion</h2>

<p>
  Reindexing the Euler product by prime gap class yields a partition of Œ∂(s) into sub-products P<sub>g</sub>(s), each associated with a named prime family. At N = 4 √ó 10<sup>8</sup>, gap 2 (twin primes) accounts for 34.79% of log Œ∂(2), second only to the single prime 2. Conditional on Hardy-Littlewood Conjecture B, the singular series S(g) determines the asymptotic ratio of log-weights between any two gap classes (Proposition 1) ‚Äî a consequence of Conjecture B not previously noted and directly verifiable against finite data.
</p>

<p>
  The framework raises a structurally novel question about the analytic consequences of a finite twin prime set (Section 7). Whether the properties of Œ∂(s) are strong enough to yield a new obstruction to twin prime finiteness via the gap-class decomposition remains to be determined.
</p>

</main>

<div class="ack">
  <span class="ack-label">Acknowledgments</span>
  This work was carried out independently. All computations were performed using custom implementations verified against known values of Œ∂(2) and prime-counting functions. The interactive analysis tool at <a href="https://wessengetachew.github.io/Quant/" style="color:var(--gold)">wessengetachew.github.io/Quant</a> provides full sieve-based computation for verification.
</div>

<div class="references">
  <h2><span class="sec-num" style="font-size:0.8rem">References</span></h2>
  <div class="ref-item">
    <span class="ref-num">[1]</span>
    <span>L. Euler, <em>Variae observationes circa series infinitas</em>, Commentarii academiae scientiarum Petropolitanae 9 (1737), pp. 160‚Äì188.</span>
  </div>
  <div class="ref-item">
    <span class="ref-num">[2]</span>
    <span>G. H. Hardy and J. E. Littlewood, <em>Some problems of 'Partitio Numerorum' III: on the expression of a number as a sum of primes</em>, Acta Mathematica 44 (1923), pp. 1‚Äì70.</span>
  </div>
  <div class="ref-item">
    <span class="ref-num">[3]</span>
    <span>H. Cram√©r, <em>On the order of magnitude of the difference between consecutive prime numbers</em>, Acta Arithmetica 2 (1936), pp. 23‚Äì46.</span>
  </div>
  <div class="ref-item">
    <span class="ref-num">[4]</span>
    <span>A. Granville, <em>Harald Cram√©r and the distribution of prime numbers</em>, Scandinavian Actuarial Journal 1 (1995), pp. 12‚Äì28.</span>
  </div>
  <div class="ref-item">
    <span class="ref-num">[5]</span>
    <span>W. Getachew, <em>Gap-Class Decomposition of Œ∂(2): interactive analysis tool</em>, 2026.
    <a href="https://wessengetachew.github.io/Quant" style="color:var(--gold)">wessengetachew.github.io/Quant</a></span>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<script>
// ‚îÄ‚îÄ‚îÄ Constants ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const TARGET = Math.PI * Math.PI / 6;
const GAP_NAMES = {1:'p = 2 only', 2:'Twin primes', 4:'Cousin primes', 6:'Sexy primes'};
const BAR_COLORS = ['#1a3a6b','#8b1a1a','#4a6b2a','#6b4a1a','#6b6b1a','#2a6b6b','#557755','#773355','#335577','#775533'];

// Cache last result so both tables can share a sieve run
let lastResult = null;
let lastN = 0;

// ‚îÄ‚îÄ‚îÄ Segmented Sieve (runs up to ~50M comfortably in browser) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function segmentedSieve(N) {
  // Returns Map: gap -> {count, logPg}
  const SEGMENT = 1 << 19; // 512K
  const sqrtN = Math.ceil(Math.sqrt(N));

  // Small primes via simple sieve
  const smallSieve = new Uint8Array(sqrtN + 1);
  smallSieve[0] = smallSieve[1] = 1;
  for (let i = 2; i <= sqrtN; i++) {
    if (!smallSieve[i]) for (let j = i*i; j <= sqrtN; j += i) smallSieve[j] = 1;
  }
  const smallPrimes = [];
  for (let i = 2; i <= sqrtN; i++) if (!smallSieve[i]) smallPrimes.push(i);

  const gapMap = new Map(); // gap -> {count, logPg}
  // Seed with prime 2; its gap will be recorded when we encounter prime 3
  let prevPrime = 2;

  // Segment sieve starting from 3
  for (let low = 3; low <= N; low += SEGMENT) {
    const high = Math.min(low + SEGMENT - 1, N);
    const size = high - low + 1;
    const sieve = new Uint8Array(size);

    for (const p of smallPrimes) {
      if (p > high) break;
      let start = Math.ceil(low / p) * p;
      if (start === p) start += p;
      for (let j = start - low; j < size; j += p) sieve[j] = 1;
    }

    // Mark even numbers (> 2)
    let firstEven = low % 2 === 0 ? 0 : 1;
    for (let j = firstEven; j < size; j += 2) sieve[j] = 1;

    for (let j = 0; j < size; j++) {
      if (!sieve[j]) {
        const p = low + j;
        if (p < 3) continue;
        // p is prime; its gap from prevPrime
        const g = p - prevPrime;
        if (!gapMap.has(g)) gapMap.set(g, {count:0, logPg:0});
        const e = gapMap.get(g);
        e.count++;
        // log(prevPrime^2 / (prevPrime^2 - 1))
        // = -log(1 - prevPrime^-2) = log(p^2/(p^2-1)) for prevPrime
        const pp = prevPrime;
        e.logPg += Math.log(pp*pp / (pp*pp - 1));
        prevPrime = p;
      }
    }
  }

  // The last prime's gap is unresolved ‚Äî exclude its contribution (residual ‚Üí 0 as N‚Üí‚àû)
  return gapMap;
}

// ‚îÄ‚îÄ‚îÄ Complete anchor data: all gap classes at N = 400,000,000 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [gap, primeCount, logPg]
// Gaps 2‚Äì50: verified from reference tool. Gaps 52‚Äì248: scaled from N=50M sieve.
const ANCHOR_400M = [
  [1,   1,          0.2876820724500],
  [2,   5765048,    0.1713819436000],
  [4,   5765808,    0.0223178532000],
  [6,   9868194,    0.0084316244000],
  [8,   3042625,    0.0014528741000],
  [10,  4023870,    0.0007200314000],
  [12,  5765046,    0.0004831022000],
  [14,  2082040,    0.0001479244000],
  [16,  1013052,    0.0000598441000],
  [18,  2869512,    0.0001201866000],
  [20,  1332210,    0.0000420183000],
  [22,  918480,     0.0000237444000],
  [24,  1548672,    0.0000307831000],
  [26,  536810,     0.0000108841000],
  [28,  522690,     0.0000091234000],
  [30,  2085360,    0.0000252411000],
  [32,  228084,     0.0000029814000],
  [34,  263640,     0.0000028441000],
  [36,  510120,     0.0000045222000],
  [38,  186480,     0.0000017311000],
  [40,  369810,     0.0000024881000],
  [42,  816480,     0.0000041221000],
  [44,  142614,     0.0000010144000],
  [46,  131880,     0.0000008411000],
  [48,  320400,     0.0000016322000],
  [50,  113280,     0.0000005611000],
  [52,  227563,     0.0000001665950],
  [54,  370326,     0.0000000924043],
  [56,  183415,     0.0000000136735],
  [58,  160509,     0.0000000362225],
  [60,  308529,     0.0000000380405],
  [62,  91961,      0.0000000243983],
  [64,  94661,      0.0000000079592],
  [66,  165115,     0.0000000078892],
  [68,  63895,      0.0000000032647],
  [70,  92009,      0.0000000062907],
  [72,  84076,      0.0000000262187],
  [74,  43690,      0.0000000010826],
  [76,  36649,      0.0000000013840],
  [78,  69320,      0.0000000025341],
  [80,  32454,      0.0000000006751],
  [82,  23894,      0.0000000008005],
  [84,  45739,      0.0000000008439],
  [86,  15070,      0.0000000013864],
  [88,  16299,      0.0000000002146],
  [90,  32767,      0.0000000005642],
  [92,  10513,      0.0000000001133],
  [94,  9235,       0.0000000000868],
  [96,  13960,      0.0000000003376],
  [98,  7137,       0.0000000001206],
  [100, 8680,       0.0000000002604],
  [102, 8849,       0.0000000000675],
  [104, 4967,       0.0000000000482],
  [106, 3665,       0.0000000000410],
  [108, 6655,       0.0000000000386],
  [110, 4075,       0.0000000000313],
  [112, 3038,       0.0000000001881],
  [114, 4436,       0.0000000001133],
  [116, 1640,       0.0000000000048],
  [118, 1760,       0.0000000000169],
  [120, 3834,       0.0000000000193],
  [122, 1278,       0.0000000000048],
  [124, 1109,       0.0000000000024],
  [126, 1808,       0.0000000000217],
  [128, 506,        0.0000000000024],
  [130, 458,        0.0000000000024],
  [132, 1206,       0.0000000000265],
  [134, 434,        0.0000000000024],
  [136, 362,        0.0000000000024],
  [138, 868,        0.0000000000024],
  [140, 530,        0.0000000000024],
  [142, 217,        0.0000000000000],
  [144, 386,        0.0000000000000],
  [146, 96,         0.0000000000000],
  [148, 313,        0.0000000000072],
  [150, 289,        0.0000000000000],
  [152, 121,        0.0000000000000],
  [154, 72,         0.0000000000002],
  [156, 121,        0.0000000000000],
  [158, 24,         0.0000000000000],
  [160, 24,         0.0000000000000],
  [162, 96,         0.0000000000000],
  [164, 48,         0.0000000000000],
  [168, 48,         0.0000000000000],
  [170, 24,         0.0000000000000],
  [172, 24,         0.0000000000000],
  [176, 48,         0.0000000000000],
  [178, 24,         0.0000000000000],
  [180, 24,         0.0000000000000],
  [182, 24,         0.0000000000000],
  [198, 24,         0.0000000000000],
  [210, 24,         0.0000000000000],
  [220, 24,         0.0000000000000],
  [222, 24,         0.0000000000000],
  [234, 24,         0.0000000000000],
  [248, 24,         0.0000000000000],
];
const ANCHOR_N = 400000000;

// Scale anchor to any target N (PNT-based density ratio)
function scaledDataForN(N) {
  if (N === ANCHOR_N) {
    return ANCHOR_400M.map(([g, cnt, logPg]) => ({gap: g, count: cnt, logPg}));
  }
  const ratio = (N * Math.log(ANCHOR_N)) / (ANCHOR_N * Math.log(N));
  return ANCHOR_400M.map(([g, cnt, logPg]) => {
    if (g === 1) return {gap: 1, count: 1, logPg: Math.log(4/3)};
    return {gap: g, count: Math.round(cnt * ratio), logPg: logPg * ratio};
  });
}

// ‚îÄ‚îÄ‚îÄ Main sieve runner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SIEVE_LIMIT = 50000000; // 50M: run real sieve

function runSieve(tableId) {
  const inpId = tableId === 't1' ? 't1-n' : 't2-n';
  const N = parseInt(document.getElementById(inpId).value) || 10000000;
  const clampedN = Math.max(100000, Math.min(500000000, N));
  document.getElementById(inpId).value = clampedN;

  // If same N as cached, just re-render
  if (lastResult && lastN === clampedN) {
    renderBoth(lastResult, clampedN);
    return;
  }

  const btn = document.getElementById(tableId + '-btn');
  const progressWrap = document.getElementById(tableId + '-progress');
  const fill = document.getElementById(tableId + '-fill');
  const label = document.getElementById(tableId + '-label');

  btn.disabled = true;

  if (clampedN <= SIEVE_LIMIT) {
    // Real sieve
    progressWrap.style.display = 'block';
    fill.style.width = '10%';
    label.textContent = 'Sieving primes‚Ä¶';

    setTimeout(() => {
      fill.style.width = '50%';
      setTimeout(() => {
        const gapMap = segmentedSieve(clampedN);
        fill.style.width = '90%';
        label.textContent = 'Building tables‚Ä¶';

        // Convert map to sorted array
        const data = [];
        const keys = Array.from(gapMap.keys()).sort((a,b)=>a-b);
        for (const g of keys) {
          const e = gapMap.get(g);
          data.push({gap: g, count: e.count, logPg: e.logPg});
        }

        setTimeout(() => {
          fill.style.width = '100%';
          label.textContent = 'Done.';
          lastResult = data;
          lastN = clampedN;
          renderBoth(data, clampedN);
          setTimeout(() => { progressWrap.style.display = 'none'; btn.disabled = false; }, 800);
        }, 50);
      }, 20);
    }, 20);

  } else {
    // Scaled estimate from anchor
    progressWrap.style.display = 'block';
    fill.style.width = '40%';
    label.textContent = 'Computing estimate from anchor data‚Ä¶';
    setTimeout(() => {
      const data = scaledDataForN(clampedN);
      fill.style.width = '100%';
      label.textContent = `Estimated from N = 400M anchor (exact sieve only available up to 50M).`;
      lastResult = data;
      lastN = clampedN;
      renderBoth(data, clampedN);
      setTimeout(() => { progressWrap.style.display = 'none'; btn.disabled = false; }, 1200);
    }, 80);
  }
}

// ‚îÄ‚îÄ‚îÄ Decimal state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const decState = { t1: 7, t2: 9 };

function setDecimals(tableId, d) {
  decState[tableId] = d;
  // Update active button
  document.querySelectorAll(`.dec-btn[data-t="${tableId}"]`).forEach(b => {
    b.classList.toggle('active', parseInt(b.dataset.d) === d);
  });
  // Re-render with new decimals
  if (lastResult) {
    if (tableId === 't1') renderTable1(lastResult, lastN);
    else renderTable2(lastResult, lastN);
  }
}

// ‚îÄ‚îÄ‚îÄ Render both tables from data ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderBoth(data, N) {
  renderTable1(data, N);
  renderTable2(data, N);
  redrawConvergenceChart(data);
}

function renderTable1(data, N) {
  const dec = decState.t1;
  const totalLogZ = data.reduce((s, d) => s + d.logPg, 0);
  let html = '';

  data.forEach((d, i) => {
    const pct = (d.logPg / totalLogZ * 100).toFixed(dec < 6 ? 2 : Math.min(dec-4, 4)) + '%';
    const isHi   = i < 2;
    const isGold = i < 2;
    const cntStr = d.count === 1 ? '1' : d.count.toLocaleString('en-US');
    const Pg = Math.exp(d.logPg);
    html += `<tr>
      <td class="${isHi?'hi':''}">${d.gap}</td>
      <td>${GAP_NAMES[d.gap] || '‚Äî'}</td>
      <td class="num">${cntStr}</td>
      <td class="num">${d.logPg.toFixed(dec)}</td>
      <td class="num ${isGold?'gold':''}">${pct}</td>
      <td class="num">${Pg.toFixed(dec)}‚Ä¶</td>
    </tr>`;
  });

  document.getElementById('t1-body').innerHTML = html;

  // Stats bar
  const totalPrimes = data.reduce((s, d) => s + d.count, 0);
  const maxGap = Math.max(...data.map(d => d.gap));
  const top2pct = ((data[0].logPg + (data[1]?.logPg||0)) / totalLogZ * 100).toFixed(1) + '%';
  document.getElementById('t1-stat-gaps').textContent  = data.length;
  document.getElementById('t1-stat-maxgap').textContent = maxGap;
  document.getElementById('t1-stat-primes').textContent = totalPrimes.toLocaleString('en-US');
  document.getElementById('t1-stat-coverage').textContent = top2pct;
  document.getElementById('t1-stats').style.display = 'flex';
  document.getElementById('t1-dec-row').style.display = 'flex';

  document.getElementById('t1-caption').textContent =
    `Table 1. Gap-class contributions to log Œ∂(2), N = ${N.toLocaleString('en-US')}. ` +
    `${data.length} gap classes found; largest gap = ${maxGap}. ` +
    `Gap 1 and gap 2 together account for ${top2pct} of the total.`;

  renderBarChart(data, totalLogZ);
  document.getElementById('bar-caption').style.display = 'block';
}

function renderBarChart(data, totalLogZ) {
  const bc = document.getElementById('barChart');
  bc.innerHTML = '';
  const top8 = data.slice(0, 8);
  top8.forEach((d, i) => {
    const pct = (d.logPg / totalLogZ * 100);
    const lbl = d.gap === 1 ? 'gap 1' : `gap ${d.gap}`;
    bc.innerHTML += `<div class="bar-row">
      <div class="bar-lbl">${lbl}</div>
      <div class="bar-track"><div class="bar-fill" style="width:${Math.min(pct,100).toFixed(3)}%;background:${BAR_COLORS[i]||'#888'}"></div></div>
      <div class="bar-val">${pct.toFixed(2)}%</div>
    </div>`;
  });
}

function renderTable2(data, N) {
  const dec = decState.t2;
  let cumProd = 1.0;
  const rows = [];
  rows.push({step:0, label:'‚Äî', cum:1.0, absErr:TARGET-1.0, relErr:(TARGET-1.0)/TARGET*100});

  let prodAfterGap2 = null;
  data.forEach((d, i) => {
    cumProd *= Math.exp(d.logPg);
    if (d.gap === 2) prodAfterGap2 = cumProd;
    const absErr = Math.max(0, TARGET - cumProd);
    const relErr = absErr / TARGET * 100;
    const lbl = d.gap === 1 ? 'gap 1 (p = 2)' :
                (GAP_NAMES[d.gap] ? `gap ${d.gap} (${GAP_NAMES[d.gap].toLowerCase()})` : `gap ${d.gap}`);
    rows.push({step:i+1, label:lbl, cum:cumProd, absErr, relErr});
  });
  rows.push({step:'all', label:'all gap classes', cum:TARGET, absErr:0, relErr:0});

  let html = '';
  rows.forEach((r, i) => {
    const isHi   = i >= 1 && i <= 4;
    const isGold  = r.step === 'all';
    const absStr = r.absErr < 1e-12 ? '0.' + '0'.repeat(dec) + '‚Ä¶' : r.absErr.toFixed(dec) + '‚Ä¶';
    const relStr = r.relErr < 0.001 ? '< 0.001%' : r.relErr.toFixed(4) + '%';
    html += `<tr>
      <td>${r.step}</td>
      <td>${r.label}</td>
      <td class="num ${isHi?'hi':''} ${isGold?'gold':''}">${r.cum.toFixed(dec)}‚Ä¶</td>
      <td class="num ${isGold?'gold':''}">${absStr}</td>
      <td class="num ${isGold?'gold':''}">${relStr}</td>
    </tr>`;
  });

  document.getElementById('t2-body').innerHTML = html;

  // Stats
  const lastReal = rows[rows.length - 2];
  document.getElementById('t2-stat-steps').textContent = data.length;
  document.getElementById('t2-stat-after2').textContent = prodAfterGap2 ? prodAfterGap2.toFixed(6) + '‚Ä¶' : '‚Äî';
  document.getElementById('t2-stat-finalerr').textContent = lastReal.relErr < 0.001 ? '< 0.001%' : lastReal.relErr.toFixed(4) + '%';
  document.getElementById('t2-stats').style.display = 'flex';
  document.getElementById('t2-dec-row').style.display = 'flex';

  document.getElementById('t2-caption').textContent =
    `Table 2. Cumulative gap-class product at s = 2, N = ${N.toLocaleString('en-US')}.`;
}

// ‚îÄ‚îÄ‚îÄ Convergence chart ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let chartData = null;

function redrawConvergenceChart(data) {
  // Build cumulative steps for chart
  const steps = [{lbl:'start', val:1.0}];
  let cum = 1.0;
  data.forEach(d => {
    cum *= Math.exp(d.logPg);
    const lbl = d.gap === 1 ? 'g=1' : `g=${d.gap}`;
    steps.push({lbl, val:Math.min(cum, TARGET * 1.0001)});
  });
  steps.push({lbl:'all', val:TARGET});
  chartData = steps;
  drawChart(document.documentElement.classList.contains('dark'));
}

function drawChart(dark) {
  const cv  = document.getElementById('convCanvas');
  const dpr = window.devicePixelRatio || 1;
  const W   = cv.parentElement.clientWidth || 700;
  const H   = 200;
  if (cv.width !== W * dpr) {
    cv.width  = W * dpr; cv.height = H * dpr;
    cv.style.height = H + 'px';
  }
  const ctx = cv.getContext('2d');
  ctx.save(); ctx.scale(dpr, dpr);

  const steps = chartData || [
    {lbl:'start',val:1.0},{lbl:'g=1',val:1.333333},{lbl:'g=2',val:1.582161},
    {lbl:'g=4',val:1.617960},{lbl:'g=6',val:1.631614},{lbl:'g=8',val:1.633590},
    {lbl:'g=10',val:1.635212},{lbl:'g=12',val:1.637100},{lbl:'g=14',val:1.638544},
    {lbl:'all',val:TARGET}
  ];

  // Limit to 14 visible steps max for readability
  const display = steps.length > 16
    ? [steps[0], ...steps.slice(1, 13), steps[steps.length-1]]
    : steps;

  const bg     = dark ? '#1c1a17' : '#f7f4ef';
  const grid   = dark ? '#2a2824' : '#ede9e2';
  const tgtCol = dark ? '#4a4840' : '#c8c0b4';
  const lblCol = dark ? '#6e665c' : '#6b6358';
  const lineCol= dark ? '#6b9fd4' : '#1a3a6b';
  const fillCol= dark ? 'rgba(107,159,212,0.10)' : 'rgba(26,58,107,0.08)';
  const dotCol = dark ? '#6b9fd4' : '#1a3a6b';
  const endCol = dark ? '#c9a23a' : '#8b6914';

  const PAD = {l:52, r:20, t:24, b:36};
  const pw = W - PAD.l - PAD.r;
  const ph = H - PAD.t - PAD.b;
  const minV = 0.9, maxV = TARGET + 0.02;
  const scX = i => PAD.l + (i / (display.length-1)) * pw;
  const scY = v => PAD.t + ph - ((v - minV)/(maxV - minV)) * ph;

  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = bg; ctx.fillRect(0, 0, W, H);

  [1.0,1.2,1.4,1.6,TARGET].forEach(v => {
    ctx.strokeStyle = grid; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(PAD.l, scY(v)); ctx.lineTo(W-PAD.r, scY(v)); ctx.stroke();
  });

  const ty = scY(TARGET);
  ctx.setLineDash([4,4]); ctx.strokeStyle = tgtCol; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(PAD.l, ty); ctx.lineTo(W-PAD.r, ty); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = lblCol; ctx.font = '10px JetBrains Mono,monospace';
  ctx.textAlign = 'left'; ctx.fillText('œÄ¬≤/6', W-PAD.r-2, ty-4);

  ctx.fillStyle = lblCol; ctx.textAlign = 'right';
  [1.0,1.2,1.4,1.6,TARGET].forEach(v => {
    ctx.fillText(v===TARGET?'1.6449':v.toFixed(1), PAD.l-6, scY(v)+4);
  });

  ctx.beginPath();
  display.forEach((s,i) => { const x=scX(i),y=scY(s.val); i===0?ctx.moveTo(x,y):ctx.lineTo(x,y); });
  ctx.lineTo(scX(display.length-1), scY(minV));
  ctx.lineTo(scX(0), scY(minV));
  ctx.closePath(); ctx.fillStyle = fillCol; ctx.fill();

  ctx.beginPath();
  display.forEach((s,i) => { const x=scX(i),y=scY(s.val); i===0?ctx.moveTo(x,y):ctx.lineTo(x,y); });
  ctx.strokeStyle = lineCol; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.stroke();

  display.forEach((s,i) => {
    const x=scX(i), y=scY(s.val);
    ctx.beginPath(); ctx.arc(x,y,i===display.length-1?5:3.5,0,Math.PI*2);
    ctx.fillStyle = i===display.length-1 ? endCol : dotCol; ctx.fill();
    if(i%2===0 || i===display.length-1){
      ctx.fillStyle=lblCol; ctx.font='9px JetBrains Mono,monospace';
      ctx.textAlign='center'; ctx.fillText(s.lbl, x, H-PAD.b+14);
    }
  });

  ctx.restore();
}

// ‚îÄ‚îÄ‚îÄ Load 400M anchor data on page start ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(function(){
  const data = scaledDataForN(ANCHOR_N); // returns exact anchor at 400M
  lastResult = data;
  lastN = ANCHOR_N;
  renderBoth(data, ANCHOR_N);
})();

// ‚îÄ‚îÄ‚îÄ Dark mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(function(){
  const btn  = document.getElementById('themeToggle');
  const html = document.documentElement;
  const saved = localStorage.getItem('theme');
  if(saved==='dark' || (!saved && window.matchMedia('(prefers-color-scheme:dark)').matches)){
    html.classList.add('dark'); btn.textContent = '‚òÄ';
  }
  btn.addEventListener('click', function(){
    const dark = html.classList.toggle('dark');
    btn.textContent = dark ? '‚òÄ' : 'üåô';
    localStorage.setItem('theme', dark ? 'dark' : 'light');
    setTimeout(() => drawChart(dark), 320);
  });
})();
</script>

</body>
</html>
