<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gap-Class Decomposition of ζ(2) = π²/6 | Mathematical Research Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', system-ui, sans-serif; 
            background: #0a0a0f; 
            color: #e0e0e0;
            line-height: 1.6;
        }
        
        .header { 
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); 
            padding: 40px;
            border-bottom: 2px solid #2a2a4a;
        }
        .header h1 { 
            font-size: 2.2rem; 
            color: #ffd700; 
            margin-bottom: 12px;
            letter-spacing: -0.5px;
        }
        .header .subtitle { 
            color: #aaa; 
            font-size: 1.1rem; 
            margin-bottom: 8px;
        }
        .header .author { 
            color: #888; 
            font-size: 0.95rem;
        }
        
        .introduction {
            max-width: 1400px;
            margin: 40px auto;
            padding: 0 40px;
        }
        
        .intro-section {
            background: #12121a;
            border-radius: 8px;
            border: 1px solid #2a2a4a;
            padding: 32px;
            margin-bottom: 24px;
        }
        
        .intro-section h2 {
            color: #ffd700;
            font-size: 1.6rem;
            margin-bottom: 20px;
            border-bottom: 2px solid #2a2a4a;
            padding-bottom: 10px;
        }
        
        .intro-section h3 {
            color: #ffd700;
            font-size: 1.2rem;
            margin: 24px 0 12px 0;
        }
        
        .intro-section p {
            margin-bottom: 16px;
            color: #ccc;
            font-size: 1rem;
        }
        
        .intro-section ul {
            margin-left: 24px;
            margin-bottom: 16px;
            color: #ccc;
        }
        
        .intro-section li {
            margin-bottom: 10px;
        }
        
        .formula-box {
            background: #1a1a2a;
            padding: 20px;
            border-radius: 6px;
            font-family: 'Times New Roman', serif;
            font-size: 1.3rem;
            text-align: center;
            color: #ffd700;
            margin: 20px 0;
            border-left: 4px solid #ffd700;
        }
        
        .research-question {
            background: linear-gradient(135deg, #1a1a2a 0%, #2a1a1a 100%);
            padding: 24px;
            border-radius: 6px;
            border-left: 4px solid #ff6464;
            margin: 20px 0;
        }
        
        .research-question h3 {
            color: #ff6464;
            margin-bottom: 12px;
        }
        
        .controls-container {
            max-width: 1400px;
            margin: 0 auto 30px auto;
            padding: 0 40px;
        }
        
        .control-panel {
            background: #12121a;
            border-radius: 8px;
            border: 1px solid #2a2a4a;
            padding: 24px;
            margin-bottom: 20px;
        }
        
        .control-panel h3 {
            color: #ffd700;
            font-size: 1.1rem;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid #2a2a4a;
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
        }
        
        .control-value {
            color: #ffd700;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        input[type="number"], select {
            width: 100%;
            padding: 10px;
            background: #1a1a2a;
            border: 1px solid #3a3a5a;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 0.9rem;
        }
        
        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #ffd700;
        }
        
        .btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%);
            border: none;
            border-radius: 4px;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.2s;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: #2a2a4a;
            color: #e0e0e0;
        }
        
        .btn-secondary:hover {
            background: #3a3a5a;
            box-shadow: none;
        }

        /* Collapsible Dropdown Styles */
        .dropdown-section {
            background: #12121a;
            border-radius: 8px;
            border: 1px solid #2a2a4a;
            margin-bottom: 16px;
            overflow: hidden;
        }
        
        .dropdown-header {
            padding: 16px 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
            user-select: none;
        }
        
        .dropdown-header:hover {
            background: linear-gradient(135deg, #1e1e32 0%, #1a2542 100%);
        }
        
        .dropdown-header h3 {
            color: #ffd700;
            font-size: 1.1rem;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .dropdown-icon {
            color: #ffd700;
            font-size: 1.2rem;
            transition: transform 0.3s;
        }
        
        .dropdown-section.active .dropdown-icon {
            transform: rotate(180deg);
        }
        
        .dropdown-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding: 0 20px;
        }
        
        .dropdown-section.active .dropdown-content {
            max-height: 3000px;
            padding: 20px;
            transition: max-height 0.5s ease-in;
        }
        
        .dropdown-badge {
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .preset-btn {
            padding: 6px 12px;
            background: #1e40af;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: #2563eb;
            transform: scale(1.05);
        }

        .preset-btn:active {
            transform: scale(0.98);
        }
        
        /* Collapsible Section Styles */
        .collapsible-section {
            background: #12121a;
            border-radius: 8px;
            border: 1px solid #2a2a4a;
            margin-bottom: 16px;
            overflow: hidden;
        }
        
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            cursor: pointer;
            background: #1a1a2a;
            transition: all 0.2s;
            user-select: none;
        }
        
        .collapsible-header:hover {
            background: #222232;
        }
        
        .collapsible-header h3 {
            margin: 0;
            color: #ffd700;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .collapsible-icon {
            font-size: 1.5rem;
            color: #ffd700;
            transition: transform 0.3s;
        }
        
        .collapsible-section.active .collapsible-icon {
            transform: rotate(180deg);
        }
        
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding: 0 20px;
        }
        
        .collapsible-section.active .collapsible-content {
            max-height: 3000px;
            padding: 20px;
            transition: max-height 0.5s ease-in;
        }
        
        .section-description {
            color: #94a3b8;
            font-size: 0.9rem;
            margin-bottom: 16px;
            line-height: 1.5;
        }
        
        .button-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .charts-container {
            max-width: 3840px;
            margin: 0 auto;
            padding: 0 40px 40px 40px;
        }
        
        .chart-wrapper {
            background: #12121a;
            border-radius: 8px;
            border: 1px solid #2a2a4a;
            padding: 20px;
            margin-bottom: 24px;
            position: relative;
        }
        
        .chart-title {
            color: #ffd700;
            font-size: 1.2rem;
            margin-bottom: 16px;
            font-weight: 600;
        }
        
        .chart-animation-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(26, 26, 42, 0.95);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #3a3a5a;
            z-index: 10;
        }
        
        .chart-play-pause-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            border: none;
            border-radius: 4px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            min-width: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .chart-play-pause-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
        }
        
        .chart-play-pause-btn.playing {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }
        
        .chart-play-pause-btn.playing:hover {
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }
        
        .chart-speed-control {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .chart-speed-label {
            font-size: 0.75rem;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chart-speed-value {
            color: #ffd700;
            font-family: monospace;
            font-size: 0.75rem;
        }
        
        .chart-speed-slider {
            width: 100%;
            height: 6px;
            background: #1a1a2a;
            border: 1px solid #3a3a5a;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .chart-speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
        }
        
        .chart-speed-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
            border: none;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: auto;
            background: #0a0a10;
            border-radius: 4px;
        }
        
        .status-bar {
            background: #1a1a2a;
            padding: 12px 20px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        .status-bar.computing {
            color: #ffd700;
            border-left: 4px solid #ffd700;
        }
        
        .status-bar.complete {
            color: #64ff64;
            border-left: 4px solid #64ff64;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: #1a1a2a;
            padding: 16px;
            border-radius: 6px;
            border-left: 3px solid #ffd700;
        }
        
        .stat-label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }
        
        .stat-value {
            font-size: 1.4rem;
            color: #ffd700;
            font-family: monospace;
        }
        
        .toggle-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
        }
        
        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            inset: 0;
            background: #2a2a4a;
            border-radius: 13px;
            cursor: pointer;
            transition: 0.3s;
        }
        
        .toggle-slider:before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            left: 3px;
            top: 3px;
            background: #666;
            border-radius: 50%;
            transition: 0.3s;
        }
        
        .toggle input:checked + .toggle-slider {
            background: #ffd700;
        }
        
        .toggle input:checked + .toggle-slider:before {
            transform: translateX(24px);
            background: #000;
        }
        
        .animation-controls {
            background: #1a1a2a;
            padding: 16px;
            border-radius: 6px;
            margin-top: 16px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #2a2a4a;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 12px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ffaa00);
            width: 0%;
            transition: width 0.3s;
        }
        
        .stats-table-wrapper {
            background: #1a1a2a;
            border-radius: 6px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .stats-table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #3a3a5a;
        }
        
        .stats-table-title {
            color: #ffd700;
            font-size: 1rem;
            font-weight: 600;
        }
        
        .precision-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .precision-control label {
            color: #aaa;
            font-size: 0.85rem;
        }
        
        .precision-control select {
            width: 80px;
            padding: 6px;
            background: #12121a;
            border: 1px solid #3a3a5a;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 0.85rem;
        }
        
        .show-all-toggle {
            background: #2a2a4a;
            color: #e0e0e0;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }
        
        .show-all-toggle:hover {
            background: #3a3a5a;
        }
        
        .stats-table-container {
            max-height: 300px;
            overflow-y: auto;
            border-radius: 4px;
        }
        
        .stats-table-container.expanded {
            max-height: 800px;
        }
        
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        .stats-table thead {
            position: sticky;
            top: 0;
            background: #12121a;
            z-index: 10;
        }
        
        .stats-table th {
            padding: 12px;
            text-align: left;
            color: #ffd700;
            font-weight: 600;
            border-bottom: 2px solid #3a3a5a;
        }
        
        .stats-table th:first-child {
            text-align: center;
        }
        
        .stats-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #2a2a4a;
            color: #ccc;
        }
        
        .stats-table td:first-child {
            text-align: center;
            color: #ffd700;
            font-weight: 600;
        }
        
        .stats-table tr:hover {
            background: #1a1a2a;
        }
        
        .stats-table tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }
        
        .prime-list {
            max-width: 400px;
            color: #888;
            font-size: 0.85rem;
        }
        
        .stats-table-container::-webkit-scrollbar {
            width: 10px;
        }
        
        .stats-table-container::-webkit-scrollbar-track {
            background: #12121a;
            border-radius: 4px;
        }
        
        .stats-table-container::-webkit-scrollbar-thumb {
            background: #3a3a5a;
            border-radius: 4px;
        }
        
        .stats-table-container::-webkit-scrollbar-thumb:hover {
            background: #4a4a6a;
        }

        /* TAB SYSTEM */
        .tab-navigation {
            display: flex;
            gap: 4px;
            background: #12121a;
            padding: 8px;
            border-radius: 8px 8px 0 0;
            border-bottom: 2px solid #2a2a4a;
        }

        .tab-btn {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: #888;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px 6px 0 0;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .tab-btn:hover {
            background: rgba(255, 215, 0, 0.1);
            color: #ccc;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #ffd700 0%, #ffaa00 100%);
            color: #000;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: #12121a;
        }

        .data-table th {
            background: #1a1a2a;
            color: #ffd700;
            padding: 12px;
            text-align: left;
            border-bottom: 2px solid #2a2a4a;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .data-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #2a2a4a;
            color: #ccc;
        }

        .data-table tr:hover {
            background: #1a1a2a;
            cursor: pointer;
        }

        .data-table tr.highlighted {
            background: rgba(255, 215, 0, 0.3);
            border-left: 4px solid #ffd700;
        }

        .stats-table tr {
            cursor: pointer;
            transition: all 0.2s;
        }

        .stats-table tr.highlighted {
            background: rgba(255, 215, 0, 0.3);
            border-left: 4px solid #ffd700;
        }

        .data-table tbody {
            max-height: 600px;
            overflow-y: auto;
        }

        .copy-btn {
            padding: 6px 12px;
            background: #3b82f6;
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: #2563eb;
        }

        .data-container {
            background: #12121a;
            border-radius: 8px;
            padding: 24px;
            margin: 20px 0;
        }

        .chart-description {
            background: rgba(255, 215, 0, 0.1);
            padding: 16px;
            border-radius: 6px;
            border-left: 4px solid #ffd700;
            margin-bottom: 20px;
            color: #ccc;
            line-height: 1.6;
        }
        
        .export-row {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #3a3a5a;
        }
        
        .export-btn {
            flex: 1;
            padding: 8px 12px;
            background: #2a2a4a;
            color: #e0e0e0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .export-btn:hover {
            background: #3a3a5a;
            transform: translateY(-1px);
        }
        
        .export-btn.csv {
            background: linear-gradient(135deg, #64ff64 0%, #32aa32 100%);
            color: #000;
        }
        
        .export-btn.csv:hover {
            box-shadow: 0 2px 8px rgba(100, 255, 100, 0.3);
        }
        
        .export-btn.png {
            background: linear-gradient(135deg, #64ffff 0%, #32aaaa 100%);
            color: #000;
        }
        
        .export-btn.png:hover {
            box-shadow: 0 2px 8px rgba(100, 255, 255, 0.3);
        }
        
        .section-divider {
            height: 1px;
            background: #3a3a5a;
            margin: 24px 0;
        }
        /* Modal Popup Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            backdrop-filter: blur(4px);
        }
        
        .modal-overlay.active {
            display: flex;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.2s;
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #ffd700;
            border-radius: 12px;
            padding: 32px;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid #ffd700;
        }
        
        .modal-title {
            color: #ffd700;
            font-size: 1.8rem;
            font-weight: bold;
        }
        
        .modal-close {
            background: #ff4444;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .modal-close:hover {
            background: #cc0000;
        }
        
        .modal-screenshot {
            background: #4ecdc4;
            color: #0a0a10;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .modal-screenshot:hover {
            background: #3ab8af;
        }
        
        .modal-section {
            margin-bottom: 24px;
        }
        
        .modal-section-title {
            color: #4ecdc4;
            font-size: 1.3rem;
            font-weight: bold;
            margin-bottom: 12px;
        }
        
        .modal-stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .modal-stat-item {
            background: rgba(255, 215, 0, 0.05);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid #ffd700;
        }
        
        .modal-stat-label {
            color: #aaa;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }
        
        .modal-stat-value {
            color: #fff;
            font-size: 1.3rem;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        .modal-prime-list {
            background: rgba(78, 205, 196, 0.05);
            padding: 16px;
            border-radius: 6px;
            border-left: 3px solid #4ecdc4;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .modal-prime-list::-webkit-scrollbar {
            width: 10px;
        }
        
        .modal-prime-list::-webkit-scrollbar-track {
            background: rgba(78, 205, 196, 0.1);
            border-radius: 5px;
        }
        
        .modal-prime-list::-webkit-scrollbar-thumb {
            background: #4ecdc4;
            border-radius: 5px;
        }
        
        .modal-prime-list::-webkit-scrollbar-thumb:hover {
            background: #3ab8af;
        }
        
        .modal-prime-list code {
            color: #4ecdc4;
            font-size: 0.95rem;
            line-height: 1.8;
            word-wrap: break-word;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes slideDown {
            from {
                max-height: 0;
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                max-height: 500px;
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes slideUp {
            from {
                max-height: 500px;
                opacity: 1;
            }
            to {
                max-height: 0;
                opacity: 0;
            }
        }
        
        /* ========== RESPONSIVE MOBILE STYLES ========== */
        @media screen and (max-width: 768px) {
            /* Reduce padding on mobile */
            .charts-container {
                padding: 0 16px 20px 16px;
            }
            
            .chart-wrapper {
                padding: 12px;
            }
            
            .introduction {
                padding: 0 16px;
            }
            
            .controls-container {
                padding: 0 16px;
            }
            
            .header {
                padding: 24px 16px;
            }
            
            .header h1 {
                font-size: 1.6rem;
            }
            
            .header .subtitle {
                font-size: 0.95rem;
            }
            
            /* Make control grids single column on mobile */
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            /* Reduce intro section padding */
            .intro-section {
                padding: 20px 16px;
            }
            
            /* Make chart animation controls full width on small screens */
            .chart-animation-controls {
                position: static;
                width: 100%;
                margin-bottom: 12px;
            }
            
            /* Adjust chart title size */
            .chart-title {
                font-size: 1rem;
            }
            
            /* Make modal more mobile-friendly */
            .modal-content {
                width: 95%;
                max-height: 90vh;
                padding: 16px;
            }
            
            .modal-header {
                padding: 16px;
            }
            
            .modal-body {
                padding: 16px;
            }
            
            /* Stack modal stats on mobile */
            .modal-stat-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            /* Adjust button sizes */
            .btn {
                padding: 10px 16px;
                font-size: 0.9rem;
            }
            
            /* Make tables scrollable on mobile */
            .stats-table-container {
                overflow-x: auto;
            }
        }
        
        @media screen and (max-width: 480px) {
            /* Extra small screens */
            .header h1 {
                font-size: 1.3rem;
            }
            
            .chart-wrapper {
                padding: 8px;
            }
            
            .charts-container {
                padding: 0 8px 16px 8px;
            }
            
            .modal-content {
                width: 98%;
                padding: 12px;
            }
        }
        /* Hardy-Littlewood Deep Dive styles */
        .hl-preset-btn { padding:6px 12px; background:#1a1a2a; border:1px solid #3a3a5a; border-radius:4px; color:#e0e0e0; cursor:pointer; font-size:.8rem; transition:background .2s, border-color .2s; }
        .hl-preset-btn:hover { background:#2a1a3a; border-color:#e879f9; color:#e879f9; }
        .hl-step-block { background:#12121a; border-radius:6px; padding:14px 18px; margin-bottom:10px; border-left:3px solid #a855f7; }
        .hl-step-num { color:#a855f7; font-size:.73rem; font-weight:700; text-transform:uppercase; letter-spacing:.08em; margin-bottom:6px; }
        .hl-step-math { font-family:'Times New Roman',serif; font-size:1.05rem; color:#ffd700; margin-bottom:4px; line-height:1.6; }
        .hl-step-explain { color:#888; font-size:.82rem; line-height:1.6; }
        .hl-result-box { background:linear-gradient(135deg,#1a1a2a,#2a1a2a); border:2px solid #e879f9; border-radius:8px; padding:18px; margin-top:16px; text-align:center; }
    </style>
</head>
<body>
    <header class="header">
        <h1>Gap-Class Decomposition of ζ(2) = π²/6</h1>
        <div class="subtitle">A Partition of the Euler Product by Prime Gap Class: Numerical Evidence and Open Questions</div>
        <div class="author">Wessen Getachew &nbsp;·&nbsp; Independent Mathematical Researcher &nbsp;·&nbsp; 2026</div>
        <div class="author" style="margin-top: 6px; font-size: 0.82rem; color: #666;">
            MSC 2020: 11M06, 11N05, 11A41 &nbsp;·&nbsp;
            <a href="https://wessengetachew.github.io/G/" target="_blank" style="color: #4ecdc4; text-decoration: none; border-bottom: 1px dotted #4ecdc4;">Interactive Tool</a>
            &nbsp;·&nbsp;
            <a href="https://wessengetachew.github.io/Primes/" target="_blank" style="color: #4ecdc4; text-decoration: none; border-bottom: 1px dotted #4ecdc4;">Modular Sieve Calculator</a>
        </div>
    </header>
    
    <div class="introduction">
        <div class="intro-section">
            <h2>Abstract</h2>

            <p>Euler's product formula expresses ζ(2) = π²/6 as an infinite product over all primes. Because the product converges absolutely, its factors may be collected in any order without changing the value. This tool implements a specific collection: prime factors are grouped by the <em>forward gap</em> of each prime — the distance to the next prime — yielding a factorization ζ(2) = ∏<sub>g</sub> P<sub>g</sub> indexed by gap class. This regrouping is a direct consequence of absolute convergence, not a new theorem. Its interest lies in what the resulting numerical magnitudes reveal about prime gap structure.</p>

            <p>At N = 400 million, gap class 1 (the prime 2 alone) contributes 57.8% of log ζ(2), and gap class 2 (twin primes) contributes a further 34.8% — together accounting for over 92% of the total. A consequence of the Hardy-Littlewood Conjecture B is that the singular series S(g) predicts the asymptotic ratio of log-weights between any two gap classes: S(g)/S(h) → w<sub>g</sub>/w<sub>h</sub> as N → ∞. This follows from Conjecture B and is directly testable against finite data; it does not appear to have been stated in this form previously. The framework also raises a structural question: if twin primes were finite, P<sub>2</sub>(s) would be a rational function of e<sup>−s</sup> — what analytic constraints would that place on the remaining sub-products via the product identity with ζ(s)?</p>

            <div class="formula-box">
                ζ(2) = ∏<sub>p prime</sub> p²/(p²−1) &nbsp;=&nbsp; ∏<sub>g ∈ G</sub> P<sub>g</sub> &nbsp;=&nbsp; π²/6 ≈ 1.644934066848…
            </div>

            <p style="color:#888;font-size:0.88rem;margin-top:-8px;text-align:center;">G = {1, 2, 4, 6, 8, …} is the set of all realized prime gap sizes. &nbsp; P<sub>g</sub> = ∏<sub>{p : gap(p)=g}</sub> p²/(p²−1).</p>

            <h3>Gap-Class Partition</h3>

            <p>Define gap(p<sub>n</sub>) = p<sub>n+1</sub> − p<sub>n</sub>. By absolute convergence of the Euler product, its factors may be partitioned by gap class:</p>

            <div class="formula-box">
                P<sub>g</sub> &nbsp;=&nbsp; ∏<sub>{p : gap(p) = g}</sub> p²/(p²−1)
            </div>

            <p>Gap class g = 1 contains only the prime 2, since gap(2) = 3 − 2 = 1, contributing the fixed factor 4/3. Every other realized gap size is even, because all primes beyond 2 are odd.</p>

            <h3>Gap Classification</h3>

            <ul>
                <li><strong>Gap 1:</strong> {2} — the prime 2 alone; gap(2) = 3 − 2 = 1</li>
                <li><strong>Gap 2 (Twin Primes):</strong> {3, 5, 11, 17, 29, 41, 59, 71, 101, 107, …} — primes p with forward gap 2</li>
                <li><strong>Gap 4 (Cousin Primes):</strong> {7, 13, 19, 37, 43, 67, 79, 97, 103, 109, …}</li>
                <li><strong>Gap 6 (Sexy Primes):</strong> {23, 31, 47, 53, 61, 73, 83, 89, 113, …}</li>
                <li><strong>Larger even gaps:</strong> g = 8, 10, 12, … all contribute progressively smaller P<sub>g</sub></li>
            </ul>

            <h3>Key Questions This Tool Investigates</h3>

            <ol>
                <li><strong>Quantitative contributions:</strong> What fraction of log ζ(2) does each gap class account for? At N = 400M, gaps 1 and 2 together exceed 92%.</li>
                <li><strong>Hardy-Littlewood log-weight ratios:</strong> Conditional on Conjecture B, S(g)/S(h) predicts the limiting ratio w<sub>g</sub>/w<sub>h</sub>. S(2) = S(4), so twins and cousins have equal asymptotic density. S(6) = 2·S(2), so gap 6 is asymptotically twice as frequent as gap 2 — the observed ratio at 400M is 1.73, converging toward 2.</li>
                <li><strong>Closed form for P<sub>2</sub>(2):</strong> Numerically P<sub>2</sub>(2) ≈ 1.18689… No relation to π, C<sub>2</sub>, or known constants is apparent. Open question.</li>
                <li><strong>Finiteness obstruction:</strong> A finite twin prime set would make P<sub>2</sub>(s) a rational function of e<sup>−s</sup> with poles on Re(s) = 0. Compatibility with ζ(s)'s analytic structure on Re(s) > 1 then requires precise cancellation by remaining sub-products — whether this is possible is open.</li>
                <li><strong>Generalization to ζ(s):</strong> The decomposition extends to all Re(s) > 1. As s grows, P<sub>1</sub>(s) = 2<sup>s</sup>/(2<sup>s</sup>−1) dominates increasingly; at s = 10 it accounts for ~96% of log ζ(10).</li>
                <li><strong>Asymptotic tail:</strong> The partial product ∏<sub>g ≤ G</sub> P<sub>g</sub> converges to ζ(2) as G → ∞, but the precise rate has not been established.</li>
            </ol>

            <h3>What This Framework Does Not Claim</h3>

            <p style="color:#ff9966;">The gap-class factorization is a rearrangement of Euler's product, valid by absolute convergence. It contains no new analytic content in itself. The Hardy-Littlewood ratio observation and the finiteness question are presented as research directions supported by computational evidence at finite N — not proofs of any conjecture.</p>

            <h3>Performance &amp; Browser Limits</h3>

            <ul>
                <li><strong>Sieving:</strong> Segmented sieve in 1M-number chunks — only ~50 MB during generation regardless of range</li>
                <li><strong>Storage (the real cap):</strong> After sieving, all primes must be held in memory. At 300M that is ~16M primes ≈ 340 MB total.</li>
                <li><strong>Safe range:</strong> Up to ~200M reliably; up to ~300M on most machines with few other tabs open</li>
                <li><strong>Above 300M:</strong> Expect freezing or out-of-memory errors. For N = 400M and above, use the companion Python script, which processes primes incrementally at constant ~50 MB RAM.</li>
            </ul>
        </div>
    </div>
    
    <div class="controls-container">
        <!-- Computation Parameters (NOT in dropdown - on main page) -->
        <div class="control-panel">
            <h3>Computation Parameters</h3>
            <div class="control-grid">
                <div class="control-group">
                    <label>
                        Maximum Prime
                        <span class="control-value" id="maxPrimeDisplay">10,000,000</span>
                    </label>
                    <input type="number" id="maxPrime" value="10000000" min="1000" max="300000000" step="1000000"
                           oninput="updateMaxPrimeDisplay()">
                    <div style="margin-top: 8px; font-size: 0.85rem; color: #888;">
                        Note: Values > 100M may take several minutes
                    </div>
                    <div style="margin-top: 4px; font-size: 0.75rem; color: #ffa500;">
                        Browser limit: ~300M (use Python script for 400M-1B+)
                    </div>
                </div>
                
                <div class="control-group">
                    <label style="display: block; margin-bottom: 8px; color: #ffd700; font-size: 1rem;">
                        Gap Range Filter
                    </label>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="radio" name="gapRangeMode" value="auto" checked 
                                   onchange="updateGapRangeMode()" style="width: auto;">
                            <span style="color: #ccc;">Auto (all gaps found)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="radio" name="gapRangeMode" value="manual" 
                                   onchange="updateGapRangeMode()" style="width: auto;">
                            <span style="color: #ccc;">Manual range</span>
                        </label>
                    </div>
                    <div id="manualGapRangeControls" style="display: none; margin-top: 12px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <label style="font-size: 0.85rem; color: #888; margin-bottom: 4px; display: block;">
                                    Min Gap (even)
                                </label>
                                <input type="number" id="minGapRange" value="0" min="0" step="2"
                                       oninput="validateGapRange()">
                            </div>
                            <div>
                                <label style="font-size: 0.85rem; color: #888; margin-bottom: 4px; display: block;">
                                    Max Gap (even)
                                </label>
                                <input type="number" id="maxGapRange" value="50" min="2" step="2"
                                       oninput="validateGapRange()">
                            </div>
                        </div>
                        <div id="gapRangeError" style="margin-top: 6px; font-size: 0.8rem; color: #ff6464; display: none;">
                            Min gap must be less than max gap. Both must be even numbers (or 0 for gap-1).
                        </div>
                    </div>
                </div>
                
            <div class="button-row" style="margin-top: 20px;">
                <button class="btn" onclick="runAnalysis()">Run Analysis</button>
                <button class="btn btn-secondary" onclick="exportAllData()">Export All Data (CSV)</button>
                <button class="btn btn-secondary" onclick="exportAllCharts()">Export All Charts (PNG)</button>
            </div>
        </div>

        <!-- Advanced Controls Dropdown (Collapsed by default) -->
        <div class="dropdown-section">
            <div class="dropdown-header" onclick="toggleSection(this)">
                <h3>Advanced Controls</h3>
                <span class="dropdown-icon">v</span>
            </div>
            <div class="dropdown-content">
                <!-- Research Presets -->
                <div style="margin-bottom: 24px; padding-bottom: 24px; border-bottom: 1px solid #2a2a4a;">
                    <h4 style="color: #ffd700; margin: 0 0 12px 0; font-size: 1.1rem;">Research Presets</h4>
                    <p class="section-description">
                        Quick configurations for common research scenarios
                    </p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        <button onclick="applyResearchPreset('complete')" class="preset-btn" style="background: #ffd700; color: #000; padding: 10px;">
                            <strong>Complete Analysis</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">Primes: 10M, All Gaps</span>
                        </button>
                        <button onclick="applyResearchPreset('twins')" class="preset-btn" style="background: #dc2626; padding: 10px;">
                            <strong>Twin Prime Focus</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">Primes: 100K, Gaps: 2-10</span>
                        </button>
                        <button onclick="applyResearchPreset('goldbach')" class="preset-btn" style="background: #ea580c; padding: 10px;">
                            <strong>Goldbach Range</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">Primes: 500K, Gaps: 2-30</span>
                        </button>
                        <button onclick="applyResearchPreset('topology')" class="preset-btn" style="background: #7c3aed; padding: 10px;">
                            <strong>Large Gap Topology</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">Primes: 1M, Gaps: 30-90</span>
                        </button>
                        <button onclick="applyResearchPreset('extreme')" class="preset-btn" style="background: #c026d3; padding: 10px;">
                            <strong>Extreme Range</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">Primes: 5M, Gaps: 100+</span>
                        </button>
                        <button onclick="applyResearchPreset('full')" class="preset-btn" style="background: #059669; padding: 10px;">
                            <strong>Full Spectrum</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">Primes: 1M, All Gaps</span>
                        </button>
                        <button onclick="applyResearchPreset('rh')" class="preset-btn" style="background: #0891b2; padding: 10px;">
                            <strong>Riemann Hypothesis Analysis</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">High-precision: 2M primes</span>
                        </button>
                    </div>
                </div>

                <!-- Zeta Exponent -->
                <div style="border: 2px solid #8b5cf6; padding: 16px; border-radius: 8px; background: rgba(139, 92, 246, 0.05); margin-bottom: 20px;">
                    <label style="color: #8b5cf6; font-weight: 600; display: block; margin-bottom: 12px;">
                        Zeta Exponent (s)
                        <span class="control-value" id="zetaSDisplay" style="color: #ffd700;">2.00</span>
                    </label>
                    <input type="range" id="zetaS" value="2" min="1.01" max="20" step="0.01"
                           style="width: 100%;" oninput="updateZetaSDisplay()" onchange="updateZetaSDisplay()">
                    
                    <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 6px; margin-top: 12px;">
                        <button onclick="setZetaS(1.5)" class="preset-btn" style="background: #7c3aed; padding: 6px; font-size: 0.8rem;">s=1.5</button>
                        <button onclick="setZetaS(2)" class="preset-btn" style="background: #7c3aed; padding: 6px; font-size: 0.8rem;">s=2</button>
                        <button onclick="setZetaS(3)" class="preset-btn" style="background: #7c3aed; padding: 6px; font-size: 0.8rem;">s=3</button>
                        <button onclick="setZetaS(4)" class="preset-btn" style="background: #7c3aed; padding: 6px; font-size: 0.8rem;">s=4</button>
                        <button onclick="setZetaS(5)" class="preset-btn" style="background: #7c3aed; padding: 6px; font-size: 0.8rem;">s=5</button>
                        <button onclick="setZetaS(10)" class="preset-btn" style="background: #7c3aed; padding: 6px; font-size: 0.8rem;">s=10</button>
                    </div>
                    
                    <div style="margin-top: 12px; padding: 12px; background: rgba(255, 215, 0, 0.05); border-radius: 6px;">
                        <div id="zetaSInfo" style="font-weight: 600; color: #ffd700;">ζ(2) = π²/6 ≈ 1.6449</div>
                        <div id="zetaSBehavior" style="margin-top: 8px; color: #888; font-size: 0.8rem;">
                            Twin primes dominate at s=2
                        </div>
                        <div style="margin-top: 4px; color: #888; font-size: 0.75rem;">
                            Formula: ζ(s) = ∏ p^s/(p^s-1)
                        </div>
                    </div>
                </div>

                <!-- Gap Range Filter -->
                <div style="border: 2px solid #3b82f6; padding: 16px; border-radius: 8px; background: rgba(59, 130, 246, 0.05); margin-bottom: 20px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <h4 style="margin: 0; color: #3b82f6; font-size: 1rem;">Gap Range Filter (Zoom)</h4>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 0.9rem;">
                            <input type="checkbox" id="enableGapFilter" style="width: auto;" onchange="toggleGapFilter()">
                            <span style="color: #60a5fa; font-weight: 600;">Enable Filter</span>
                        </label>
                    </div>
                    
                    <div id="gapFilterControls" style="display: none;">
                        <p style="font-size: 0.85rem; color: #94a3b8; margin: 0 0 12px 0;">
                            Filter which gaps appear in all charts. Perfect for examining larger gaps without small gaps dominating.
                        </p>

                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                            <div>
                                <label style="display: block; font-size: 0.85rem; margin-bottom: 4px; color: #94a3b8;">Min Gap</label>
                                <input type="number" id="minGapFilter" value="2" min="0" max="1000" step="2" 
                                       style="width: 100%; padding: 6px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0;"
                                       onchange="updateGapFilterDisplay()">
                            </div>
                            <div>
                                <label style="display: block; font-size: 0.85rem; margin-bottom: 4px; color: #94a3b8;">Max Gap</label>
                                <input type="number" id="maxGapFilter" value="50" min="2" max="1000" step="2" 
                                       style="width: 100%; padding: 6px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0;"
                                       onchange="updateGapFilterDisplay()">
                            </div>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <label style="display: block; font-size: 0.85rem; margin-bottom: 6px; color: #94a3b8;">Quick Presets:</label>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                <button onclick="setGapRange(2, 10)" class="preset-btn">Tiny (2-10)</button>
                                <button onclick="setGapRange(2, 20)" class="preset-btn">Small (2-20)</button>
                                <button onclick="setGapRange(20, 50)" class="preset-btn">Medium (20-50)</button>
                                <button onclick="setGapRange(30, 90)" class="preset-btn">Large (30-90)</button>
                                <button onclick="setGapRange(50, 150)" class="preset-btn">Huge (50-150)</button>
                                <button onclick="setGapRangeToLast(20)" class="preset-btn" style="background: #ea580c;">Last 20</button>
                                <button onclick="setGapRangeToLast(10)" class="preset-btn" style="background: #ea580c;">Last 10</button>
                                <button onclick="resetGapFilter()" class="preset-btn" style="background: #475569;">Reset</button>
                            </div>
                        </div>

                        <div style="background: rgba(34, 197, 94, 0.1); padding: 10px; border-radius: 6px; border-left: 3px solid #22c55e;">
                            <p style="margin: 0; font-size: 0.85rem; color: #4ade80;">
                                <strong>Active:</strong> <span id="gapFilterStatus">Showing all gaps</span>
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Animation Controls -->
                <div style="border: 2px solid #f59e0b; padding: 16px; border-radius: 8px; background: rgba(245, 158, 11, 0.05); margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: #f59e0b; font-size: 1rem;">Animation Speed (ms delay)</h4>
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 6px;">
                            <span style="color: #94a3b8;">Delay: </span>
                            <span class="control-value" id="animSpeedDisplay">100</span>
                            <span style="color: #888; font-size: 0.75rem;"> (Lower = Faster, Higher = Slower)</span>
                        </label>
                        <input type="range" id="animSpeed" min="10" max="500" value="100" step="10"
                               style="width: 100%;" oninput="document.getElementById('animSpeedDisplay').textContent = this.value">
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="useMaxPrimeForAnim" style="width: auto;" checked>
                            <span>Animate from 0 to Max Prime</span>
                        </label>
                        <div style="margin-top: 4px; font-size: 0.75rem; color: #888;">
                            Uncheck to set custom range below
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                        <div>
                            <label style="display: block; font-size: 0.85rem; margin-bottom: 4px; color: #94a3b8;">
                                Custom Start
                                <span class="control-value" id="animStartDisplay">1</span>
                            </label>
                            <input type="number" id="animStart" value="1" min="1" max="10000000" step="100"
                                   style="width: 100%; padding: 6px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0;">
                        </div>
                        <div>
                            <label style="display: block; font-size: 0.85rem; margin-bottom: 4px; color: #94a3b8;">
                                Custom End
                                <span class="control-value" id="animEndDisplay">10000000</span>
                            </label>
                            <input type="number" id="animEnd" value="10000000" min="1000" max="10000000" step="1000"
                                   style="width: 100%; padding: 6px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0;">
                        </div>
                    </div>

                    <div style="display: flex; gap: 12px;">
                        <button class="btn btn-secondary" onclick="startAnimation()" style="flex: 1;">Start Animation</button>
                        <button class="btn btn-secondary" onclick="stopAnimation()" style="flex: 1;">Stop Animation</button>
                    </div>
                </div>

                <!-- Alternative Data Sources -->
                <div style="margin-top: 20px; padding: 16px; background: rgba(78, 205, 196, 0.05); border-radius: 8px; border-left: 4px solid #4ecdc4;">
                    <h4 style="color: #4ecdc4; margin: 0 0 12px 0; font-size: 1rem;">Alternative Data Sources</h4>
                    <p style="font-size: 0.85rem; color: #94a3b8; margin-bottom: 12px;">
                        To use pre-computed prime lists — note the same ~300M browser limit applies to uploaded files
                    </p>
                    
                    <div style="display: grid; gap: 12px;">
                        <div>
                            <label style="display: block; margin-bottom: 6px; font-size: 0.9rem; color: #e0e0e0;">
                                Upload Prime List (CSV/TXT)
                            </label>
                            <input type="file" id="primeFileUpload" accept=".txt,.csv" 
                                   style="width: 100%; padding: 8px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0;"
                                   onchange="handlePrimeFileUpload(event)">
                            <div style="font-size: 0.75rem; color: #666; margin-top: 4px;">
                                Format: One prime per line or comma-separated<br>
                                Sources: <a href="https://primes.utm.edu/lists/" target="_blank" style="color: #4ecdc4;">Prime Pages</a> | 
                                <a href="https://oeis.org/A000040/b000040.txt" target="_blank" style="color: #4ecdc4;">OEIS A000040</a>
                            </div>
                        </div>
                        
                        <div>
                            <label style="display: block; margin-bottom: 6px; font-size: 0.9rem; color: #e0e0e0;">
                                OEIS A000040 (Prime Numbers Database)
                            </label>
                            <div style="display: flex; gap: 8px; align-items: flex-end;">
                                <div style="flex: 1;">
                                    <label style="display: block; font-size: 0.75rem; color: #888; margin-bottom: 4px;">
                                        Fetch first N primes
                                    </label>
                                    <input type="number" id="oeisCount" value="100000" min="1000" max="1000000" step="10000"
                                           style="width: 100%; padding: 6px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0;">
                                </div>
                                <button class="btn btn-secondary" onclick="fetchFromOEIS()" style="flex-shrink: 0;">
                                    Fetch from OEIS
                                </button>
                            </div>
                            <div style="font-size: 0.75rem; color: #666; margin-top: 4px;">
                                OEIS API provides up to 1M primes. File upload: same ~300M browser limit applies.
                            </div>
                        </div>
                    </div>
                    
                    <div id="uploadStatus" style="margin-top: 12px; padding: 8px; background: rgba(255, 215, 0, 0.1); border-radius: 4px; display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: #ffd700; font-size: 0.85rem;"></span>
                            <button class="btn btn-secondary" onclick="clearCustomPrimes()" style="padding: 4px 12px; font-size: 0.75rem;">
                                Clear & Use Sieve
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Comparison Mode -->
                <div style="margin-top: 20px; margin-bottom: 20px; padding: 16px; background: rgba(139, 92, 246, 0.05); border-radius: 8px; border-left: 4px solid #8b5cf6;">
                    <h4 style="margin: 0 0 12px 0; color: #8b5cf6; font-size: 1rem;">Comparison Mode</h4>
                    <label style="display: flex; align-items: start; gap: 12px; cursor: pointer;">
                        <input type="checkbox" id="enableComparison" style="width: auto; margin-top: 4px;">
                        <div>
                            <span style="color: #e0e0e0; font-weight: 600; font-size: 0.95rem;">Enable Comparison Mode</span>
                            <div style="font-size: 0.85rem; color: #888; margin-top: 4px;">
                                Compare how gap contributions change across different exponent values: s = [1.5, 2, 3, 4, 5, 10]. This generates multiple overlayed analyses to study how varying the zeta exponent affects the relative importance of different gap classes.
                            </div>
                        </div>
                    </label>
                </div>

                <!-- Chart Options -->
                <div style="padding: 16px; background: rgba(59, 130, 246, 0.05); border-radius: 8px; border-left: 4px solid #3b82f6;">
                    <h4 style="margin: 0 0 16px 0; color: #3b82f6; font-size: 1rem;">Chart Options</h4>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showGapContributions" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Gap Contributions Chart</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showConvergence" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Progressive Convergence</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showGapDistribution" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Gap Distribution</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showPercentageContrib" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Percentage Contributions</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showErrorAnalysis" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Error Analysis</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showLogScale" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Log-Scale Product Analysis</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showGapRatio" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Gap Ratio Analysis (Twin Prime Evidence)</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showDecimalConvergence" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Decimal Convergence Analysis</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showCustomGapCompare" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Custom Gap Comparison</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Analysis Statistics (Fixed toggle) -->
        <div id="statsPanel" class="dropdown-section" style="display: none; border: 2px solid #22c55e;">
            <div class="dropdown-header" onclick="toggleSection(this)" style="background: rgba(34, 197, 94, 0.1);">
                <h3 style="color: #22c55e;">Analysis Statistics</h3>
                <span class="dropdown-icon" style="color: #22c55e;">v</span>
            </div>
            <div class="dropdown-content">
                <div class="stats-grid" id="statsGrid"></div>
            </div>
        </div>
        
        <div id="statusBar" class="status-bar" style="display: none;">
            Ready to compute...
        </div>
        
        <div id="progressContainer" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
    </div>
    
    
    <div class="charts-container">
        <div class="chart-wrapper" id="convergenceWrapper">
            <div class="chart-title">Progressive Convergence to ζ(2) = π²/6</div>
            <div class="chart-description">
                Shows how the cumulative product P₁ × P₂ × P₄ × ... converges to the target value π²/6 ≈ 1.6449 as we add more gap families. Each gap family's product contributes multiplicatively toward the final value.
            </div>
            <canvas id="convergenceChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Progressive Convergence Data</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="convergencePrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('convergenceTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="convergenceTable">
                    <table class="stats-table" id="convergenceTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('convergence')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('convergenceChart', 'convergence')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: #3b82f6;">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('convergenceChart', 'convergence')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="gapContribWrapper">
            <div class="chart-title">Individual Gap Family Products P<sub>g</sub></div>
            <div class="chart-description">
                Displays the individual contribution of each gap family. Each bar shows P_g = ∏_{p: gap(p)=g} p²/(p²-1), the product over all primes with that specific gap size. Larger values indicate gap families that contribute more to ζ(2).
            </div>
            <canvas id="gapContribChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Gap Family Product Values <span style="font-size: 0.75rem; color: #888; font-weight: normal;">(Click row for details)</span></div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="gapContribPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('gapContribTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="gapContribTable" data-chart="gapContribChart">
                    <table class="stats-table" id="gapContribTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('gapContrib')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('gapContribChart', 'gap_contributions')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: #3b82f6;">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('gapContribChart', 'gap_contributions')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="gapDistWrapper">
            <div class="chart-title">Prime Distribution by Gap Class</div>
            <div class="chart-description">
                Shows how many primes belong to each gap family. Twin primes (gap 2) and cousin primes (gap 4) typically have the most members, while larger gaps become progressively rarer.
            </div>
            <canvas id="gapDistChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Prime Count and Distribution <span style="font-size: 0.75rem; color: #888; font-weight: normal;">(Click row for details)</span></div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="gapDistPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('gapDistTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="gapDistTable" data-chart="gapDistChart">
                    <table class="stats-table" id="gapDistTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('gapDist')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('gapDistChart', 'gap_distribution')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: #3b82f6;">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('gapDistChart', 'gap_distribution')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="percentageWrapper">
            <div class="chart-title">Percentage Contribution to ζ(2) by Gap Family</div>
            <div class="chart-description">
                Shows each gap family's contribution as a percentage of log(ζ(2)). This reveals which gap sizes are most important for building up the final value. Typically gap 1 and gap 2 (twin primes) dominate.
            </div>
            <canvas id="percentageChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Contribution Percentages <span style="font-size: 0.75rem; color: #888; font-weight: normal;">(Click row for details)</span></div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="percentagePrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('percentageTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="percentageTable" data-chart="percentageChart">
                    <table class="stats-table" id="percentageTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('percentage')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('percentageChart', 'percentage_contributions')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: #3b82f6;">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('percentageChart', 'percentage_contributions')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="errorWrapper">
            <div class="chart-title">Convergence Error Analysis</div>
            <div class="chart-description">
                Tracks both absolute and relative error between the cumulative product and the target π²/6. As more gap families are included, the error decreases exponentially, showing convergence.
            </div>
            <canvas id="errorChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Error Metrics by Gap</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="errorPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('errorTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="errorTable">
                    <table class="stats-table" id="errorTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('error')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('errorChart', 'error_analysis')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: #3b82f6;">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('errorChart', 'error_analysis')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="logScaleWrapper">
            <div class="chart-title">Log-Scale Product Growth P<sub>g</sub></div>
            <div class="chart-description">
                Displays log(P_g) for each gap family, making it easier to compare contributions across many orders of magnitude. Since products become multiplicative in log space, this shows additive contributions to log(ζ(2)).
            </div>
            <canvas id="logScaleChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Logarithmic Product Analysis</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="logScalePrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('logScaleTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="logScaleTable">
                    <table class="stats-table" id="logScaleTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('logScale')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('logScaleChart', 'log_scale_products')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: #3b82f6;">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('logScaleChart', 'log_scale_products')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="gapRatioWrapper">
            <div class="chart-title">Gap Ratio Analysis: Twin Prime Conjecture Evidence</div>
            <div class="chart-description">
                Tracks Count(gap=2)/Count(gap=4) and other gap ratios. Hardy-Littlewood predicts twin primes (gap 2) and cousin primes (gap 4) have <em>identical</em> singular series constants, so their ratio should approach 1.0 as N→∞. Gap 6 (sexy primes) has a 2× larger constant due to the p=3 factor — so it is asymptotically <em>twice as frequent</em> as gap 2 or gap 4, not equal.
            </div>
            <canvas id="gapRatioChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Gap Ratio Data</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="gapRatioPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6" selected>6</option>
                            <option value="8">8</option>
                            <option value="10">10</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('gapRatioTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="gapRatioTable">
                    <table class="stats-table" id="gapRatioTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('gapRatio')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('gapRatioChart', 'gap_ratio_analysis')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: #3b82f6;">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('gapRatioChart', 'gap_ratio_analysis')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <!-- ═══════════════════════════════════════════════════════════════════ -->
        <!-- HARDY-LITTLEWOOD DEEP DIVE SECTION                                  -->
        <!-- ═══════════════════════════════════════════════════════════════════ -->
        <div class="chart-wrapper" id="hlDeepDiveWrapper" style="border: 2px solid #a855f7;">
            <div class="chart-title" style="color: #a855f7; font-size: 1.5rem; border-bottom-color: #a855f7;">
                Hardy-Littlewood Conjecture B: Step-by-Step Calculations for Every Gap Family
            </div>
            <div class="chart-description" style="border-left-color: #a855f7;">
                Full derivation of the singular series S(h), the logarithmic integral li₂(x), and the predicted prime-pair count
                for each gap family — with every arithmetic step shown and compared against your observed data.
            </div>

            <!-- PART 1: THE FORMULA -->
            <div style="background:#0d0d1a;border:1px solid #a855f7;border-radius:10px;padding:28px;margin-bottom:24px;">
                <h3 style="color:#a855f7;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 1 — The Hardy-Littlewood Formula</h3>
                <p style="color:#ccc;margin-bottom:16px;line-height:1.8;">Hardy &amp; Littlewood's Conjecture B (1923): for any even integer h ≥ 2, the count of primes p ≤ x where p+h is also prime satisfies:</p>
                <div class="formula-box" style="font-size:1.4rem;margin:20px 0;">π<sub>h</sub>(x) &nbsp;~&nbsp; S(h) · li<sub>2</sub>(x)</div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:20px;">
                    <div style="background:rgba(168,85,247,.08);border-left:3px solid #a855f7;padding:16px;border-radius:6px;">
                        <div style="color:#a855f7;font-weight:700;margin-bottom:10px;">S(h) — The Singular Series</div>
                        <div style="color:#e0e0e0;font-family:'Times New Roman',serif;font-size:1.1rem;line-height:2.2;">S(h) = 2C<sub>2</sub> · ∏<sub>p | h, p odd prime</sub> (p−1)/(p−2)</div>
                        <div style="color:#888;font-size:.85rem;margin-top:8px;">Encodes how divisibility of h by small primes opens extra residue classes, making some gaps more probable than others.</div>
                    </div>
                    <div style="background:rgba(78,205,196,.08);border-left:3px solid #4ecdc4;padding:16px;border-radius:6px;">
                        <div style="color:#4ecdc4;font-weight:700;margin-bottom:10px;">li<sub>2</sub>(x) — The Logarithmic Integral</div>
                        <div style="color:#e0e0e0;font-family:'Times New Roman',serif;font-size:1.1rem;line-height:2.2;">li<sub>2</sub>(x) = ∫<sub>2</sub><sup>x</sup> dt / ln²(t)</div>
                        <div style="color:#888;font-size:.85rem;margin-top:8px;">The density baseline — how many prime pairs would exist if distributed purely by logarithm. S(h) scales this per gap.</div>
                    </div>
                </div>
            </div>

            <!-- PART 2: C2 CONSTANT -->
            <div style="background:#0d0d1a;border:1px solid #ffd700;border-radius:10px;padding:28px;margin-bottom:24px;">
                <h3 style="color:#ffd700;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 2 — Where Does C₂ = 0.6601618… Come From?</h3>
                <p style="color:#ccc;margin-bottom:16px;line-height:1.8;">C₂ is the <strong style="color:#ffd700">twin prime constant</strong> — an infinite Euler product over all primes p ≥ 3, measuring how residue-class constraints reduce the density of twin primes relative to a random model:</p>
                <div class="formula-box">C<sub>2</sub> = ∏<sub>p ≥ 3</sub> p(p−2) / (p−1)²</div>
                <p style="color:#ccc;margin:0 0 16px 0;line-height:1.7;font-size:.9rem;">Each factor p(p−2)/(p−1)² &lt; 1 accounts for the fact that for a prime p, there is one forbidden residue class mod p for each element of a twin-prime pair. The infinite product converges slowly to ≈ 0.66016. Below: partial products through the first 20 primes.</p>
                <div style="background:#12121a;border-radius:8px;padding:20px;overflow-x:auto;">
                    <table style="width:100%;border-collapse:collapse;font-family:monospace;font-size:.83rem;min-width:600px;">
                        <thead><tr style="background:#1a1a2a;">
                            <th style="padding:8px 12px;text-align:left;color:#ffd700;border-bottom:1px solid #2a2a4a;">Prime p</th>
                            <th style="padding:8px 12px;text-align:left;color:#ffd700;border-bottom:1px solid #2a2a4a;">p(p−2)/(p−1)²</th>
                            <th style="padding:8px 12px;text-align:left;color:#ffd700;border-bottom:1px solid #2a2a4a;">Factor value</th>
                            <th style="padding:8px 12px;text-align:left;color:#ffd700;border-bottom:1px solid #2a2a4a;">Running C₂ product</th>
                            <th style="padding:8px 12px;text-align:left;color:#ffd700;border-bottom:1px solid #2a2a4a;">% of final C₂</th>
                        </tr></thead>
                        <tbody id="hl_c2_table_body"></tbody>
                    </table>
                </div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:16px;">
                    <div style="background:rgba(255,215,0,.07);border:1px solid #ffd700;border-radius:6px;padding:14px;text-align:center;">
                        <div style="color:#888;font-size:.78rem;margin-bottom:4px;">C₂ (full precision)</div>
                        <div style="color:#ffd700;font-family:monospace;font-size:.9rem;">0.6601618158468695…</div>
                    </div>
                    <div style="background:rgba(255,215,0,.07);border:1px solid #ffd700;border-radius:6px;padding:14px;text-align:center;">
                        <div style="color:#888;font-size:.78rem;margin-bottom:4px;">2·C₂ = S(2) = S(4) = S(8)</div>
                        <div style="color:#ffd700;font-family:monospace;font-size:.9rem;">1.3203236316937390…</div>
                    </div>
                    <div style="background:rgba(255,215,0,.07);border:1px solid #ffd700;border-radius:6px;padding:14px;text-align:center;">
                        <div style="color:#888;font-size:.78rem;margin-bottom:4px;">4·C₂ = S(6) = S(12) = S(18)</div>
                        <div style="color:#ffd700;font-family:monospace;font-size:.9rem;">2.6406472633874780…</div>
                    </div>
                </div>
            </div>

            <!-- PART 3: SINGULAR SERIES TABLE -->
            <div style="background:#0d0d1a;border:1px solid #22c55e;border-radius:10px;padding:28px;margin-bottom:24px;">
                <h3 style="color:#22c55e;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 3 — Singular Series S(h) for the First 30 Even Gaps: Full Derivation</h3>
                <p style="color:#ccc;margin-bottom:16px;line-height:1.8;">For each gap h, we compute S(h) = 2C₂ · ∏<sub>(odd prime p | h)</sub> (p−1)/(p−2). The table below shows the factorisation of h, which odd primes divide it, each correction factor, and the final S(h). <strong style="color:#22c55e;">Only odd prime factors count</strong> — p=2 always divides even h but contributes no correction because 2 is already handled in the baseline C₂ Euler product.</p>
                <div style="background:#12121a;border-radius:8px;padding:20px;overflow-x:auto;">
                    <table style="width:100%;border-collapse:collapse;font-size:.82rem;min-width:900px;">
                        <thead><tr style="background:#1a1a2a;">
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">Gap h</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">h = 2^a × odd</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">Odd prime factors</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">Correction factors (p−1)/(p−2)</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">Product</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">S(h) = 2C₂ × product</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">S(h)/S(2)</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">Name</th>
                        </tr></thead>
                        <tbody id="hl_singular_table_body"></tbody>
                    </table>
                </div>
                <div style="background:rgba(34,197,94,.07);border-left:4px solid #22c55e;padding:16px;border-radius:6px;margin-top:16px;">
                    <div style="color:#22c55e;font-weight:700;margin-bottom:8px;">The key insight: why gap 6 is twice as common as gap 2</div>
                    <div style="color:#ccc;font-size:.88rem;line-height:1.8;">
                        Gap 2: h=2, no odd prime factors → correction product = 1 → S(2) = 2C₂ ≈ 1.3203<br>
                        Gap 4: h=4=2², no odd prime factors → S(4) = 2C₂ <em>identical to gap 2</em><br>
                        Gap 6: h=6=2×3, odd factor p=3 → correction = (3−1)/(3−2) = 2/1 = <strong style="color:#ffd700">2</strong> → S(6) = 2 × 2C₂ = 4C₂ ≈ 2.6406<br><br>
                        Gap 30: h=30=2×3×5, corrections: (2/1)×(4/3) = 8/3 → S(30) = (8/3)×2C₂ = <strong style="color:#ffd700">16C₂/3 ≈ 3.5209</strong><br><br>
                        Because 3 | 6, the pair {p, p+6} satisfies p ≡ p+6 (mod 3), so <em>neither element is forced to be divisible by 3</em>.
                        This doubles admissible residue pairs. At 400M your data shows gap6/gap2 = 1.767 — converging toward the limit of 2.0.
                    </div>
                </div>
            </div>

            <!-- PART 4: li2 EXPANSION -->
            <div style="background:#0d0d1a;border:1px solid #4ecdc4;border-radius:10px;padding:28px;margin-bottom:24px;">
                <h3 style="color:#4ecdc4;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 4 — The li₂(x) Expansion: Every Correction Term Analysed</h3>
                <p style="color:#ccc;margin-bottom:16px;line-height:1.8;">The integral li₂(x)=∫dt/ln²(t) has an asymptotic expansion. Each correction term below reduces prediction error. Change x to see how the terms' magnitudes shift with your analysis range.</p>
                <div class="formula-box" style="font-size:1.05rem;">li₂(x) = (x/ln²x) · [ 1 + 2/ln x + 6/ln²x + 24/ln³x + 120/ln⁴x + … ]&nbsp;&nbsp;&nbsp;(k-th coefficient = (k+1)!)</div>
                <div style="background:#12121a;border-radius:8px;padding:14px;margin:16px 0;display:flex;align-items:center;gap:14px;flex-wrap:wrap;">
                    <label style="color:#4ecdc4;font-size:.9rem;">Compute at x =</label>
                    <input type="number" id="hl_li2_x_input" value="400000000" min="1000" max="10000000000" step="1000000"
                           oninput="hl_updateLi2Table()"
                           style="padding:8px 12px;background:#1a1a2a;border:1px solid #3a3a5a;border-radius:4px;color:#e0e0e0;font-size:.9rem;width:180px;">
                    <div id="hl_li2_lnx_display" style="color:#888;font-size:.82rem;"></div>
                </div>
                <div style="background:#12121a;border-radius:8px;padding:20px;overflow-x:auto;">
                    <table style="width:100%;border-collapse:collapse;font-family:monospace;font-size:.82rem;min-width:750px;">
                        <thead><tr style="background:#1a1a2a;">
                            <th style="padding:8px 12px;text-align:left;color:#4ecdc4;border-bottom:1px solid #2a2a4a;">Terms used</th>
                            <th style="padding:8px 12px;text-align:left;color:#4ecdc4;border-bottom:1px solid #2a2a4a;">Formula</th>
                            <th style="padding:8px 12px;text-align:left;color:#4ecdc4;border-bottom:1px solid #2a2a4a;">li₂(x) value</th>
                            <th style="padding:8px 12px;text-align:left;color:#4ecdc4;border-bottom:1px solid #2a2a4a;">2C₂·li₂ prediction</th>
                            <th style="padding:8px 12px;text-align:left;color:#4ecdc4;border-bottom:1px solid #2a2a4a;">Gain from prev term</th>
                            <th style="padding:8px 12px;text-align:left;color:#4ecdc4;border-bottom:1px solid #2a2a4a;">Error vs obs twins*</th>
                        </tr></thead>
                        <tbody id="hl_li2_table_body"></tbody>
                    </table>
                    <div style="color:#555;font-size:.75rem;margin-top:8px;">*Observed twin count auto-populated from your last analysis run; otherwise uses 1,507,733 (400M baseline)</div>
                </div>
                <div style="background:rgba(78,205,196,.07);border-left:4px solid #4ecdc4;padding:14px;border-radius:6px;margin-top:16px;">
                    <div style="color:#4ecdc4;font-weight:700;margin-bottom:6px;">Why the corrections are large at practical ranges</div>
                    <div style="color:#ccc;font-size:.85rem;line-height:1.7;">At x=400M, ln(x) ≈ 19.8, so the first correction 2/ln(x) ≈ 10.1% — far from negligible. The k-th term has coefficient (k+1)!, so the corrections form a divergent asymptotic series — accuracy peaks around the 4th–5th term for x in the billions, then worsens. The 4-term formula gives &lt;0.1% error at 400M.</div>
                </div>
            </div>

            <!-- PART 5: PER-GAP FULL TABLE (live from analysis) -->
            <div style="background:#0d0d1a;border:1px solid #f59e0b;border-radius:10px;padding:28px;margin-bottom:24px;">
                <h3 style="color:#f59e0b;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 5 — Full Gap-by-Gap H-L Prediction vs Your Observed Data</h3>
                <p style="color:#ccc;margin-bottom:16px;line-height:1.8;">Every gap family in your analysis: S(h) derived step-by-step, li₂ prediction computed, compared against your observed count. The obs/pred ratio converges to 1.0 as x→∞.</p>
                <div style="background:#12121a;border-radius:8px;padding:14px;margin-bottom:16px;display:flex;align-items:center;gap:14px;flex-wrap:wrap;">
                    <div style="color:#f59e0b;font-size:.9rem;">Analysis range:</div>
                    <div id="hl_range_display" style="color:#ffd700;font-family:monospace;font-size:.95rem;font-weight:700;">Run analysis above first</div>
                </div>
                <div style="background:#12121a;border-radius:8px;padding:20px;overflow-x:auto;">
                    <table style="width:100%;border-collapse:collapse;font-size:.8rem;min-width:1050px;">
                        <thead><tr style="background:#1a1a2a;">
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Gap h</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Name</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Odd prime factors of h</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">S(h)</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">S(h)/S(2)</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Predicted</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Observed</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Obs/Pred</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Error %</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Convergence</th>
                        </tr></thead>
                        <tbody id="hl_full_table_body">
                            <tr><td colspan="10" style="padding:20px;text-align:center;color:#888;font-style:italic;">Run the prime analysis above to populate this table</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- PART 6: INTERACTIVE WALKTHROUGH -->
            <div style="background:#0d0d1a;border:1px solid #e879f9;border-radius:10px;padding:28px;margin-bottom:24px;">
                <h3 style="color:#e879f9;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 6 — Interactive: Full Arithmetic Walkthrough for Any Gap</h3>
                <p style="color:#ccc;margin-bottom:20px;line-height:1.8;">Select any gap to see every single arithmetic step: prime factorisation of h, identifying correction primes, computing each (p−1)/(p−2) factor, building S(h), expanding li₂(x) term by term, and arriving at the final prediction.</p>
                <div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:20px;align-items:flex-end;">
                    <div style="display:flex;flex-direction:column;gap:6px;">
                        <label style="color:#e879f9;font-size:.85rem;">Gap h</label>
                        <input type="number" id="hl_gap_input" value="6" min="2" max="500" step="2"
                               style="padding:8px 12px;background:#1a1a2a;border:1px solid #3a3a5a;border-radius:4px;color:#e0e0e0;font-size:.9rem;width:100px;">
                    </div>
                    <div style="display:flex;flex-direction:column;gap:6px;">
                        <label style="color:#e879f9;font-size:.85rem;">At x =</label>
                        <input type="number" id="hl_x_input" value="400000000" min="1000" max="10000000000" step="1000000"
                               style="padding:8px 12px;background:#1a1a2a;border:1px solid #3a3a5a;border-radius:4px;color:#e0e0e0;font-size:.9rem;width:180px;">
                    </div>
                    <button onclick="hl_computeWalkthrough()"
                            style="padding:10px 24px;background:linear-gradient(135deg,#e879f9,#a855f7);border:none;border-radius:6px;color:#fff;font-weight:700;cursor:pointer;font-size:.95rem;">
                        Compute Step by Step
                    </button>
                    <div style="display:flex;gap:8px;flex-wrap:wrap;">
                        <button onclick="hl_setGap(2)"  class="hl-preset-btn">Gap 2 (twins)</button>
                        <button onclick="hl_setGap(4)"  class="hl-preset-btn">Gap 4 (cousins)</button>
                        <button onclick="hl_setGap(6)"  class="hl-preset-btn">Gap 6 (sexy)</button>
                        <button onclick="hl_setGap(10)" class="hl-preset-btn">Gap 10</button>
                        <button onclick="hl_setGap(12)" class="hl-preset-btn">Gap 12</button>
                        <button onclick="hl_setGap(30)" class="hl-preset-btn">Gap 30</button>
                        <button onclick="hl_setGap(210)" class="hl-preset-btn">Gap 210 (2×3×5×7)</button>
                    </div>
                </div>
                <div id="hl_walkthrough_output" style="background:#0a0a10;border-radius:8px;padding:24px;border:1px solid #2a2a4a;min-height:80px;">
                    <div style="color:#666;font-style:italic;">Click "Compute Step by Step" to see the full arithmetic</div>
                </div>
            </div>

            <!-- PART 7: RATIO CONVERGENCE TABLE -->
            <div style="background:#0d0d1a;border:1px solid #64748b;border-radius:10px;padding:28px;">
                <h3 style="color:#94a3b8;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 7 — Convergence of Count Ratios to Theoretical Limits</h3>
                <p style="color:#ccc;margin-bottom:16px;line-height:1.8;">As x→∞, Count(gap=a)/Count(gap=b) → S(a)/S(b). This table shows current ratios from your data vs the theoretical limits, with a convergence bar showing how close you are.</p>
                <div style="background:#12121a;border-radius:8px;padding:20px;overflow-x:auto;">
                    <table style="width:100%;border-collapse:collapse;font-size:.83rem;min-width:750px;">
                        <thead><tr style="background:#1a1a2a;">
                            <th style="padding:8px 12px;text-align:left;color:#94a3b8;border-bottom:1px solid #2a2a4a;">Ratio</th>
                            <th style="padding:8px 12px;text-align:left;color:#94a3b8;border-bottom:1px solid #2a2a4a;">Why this limit</th>
                            <th style="padding:8px 12px;text-align:left;color:#94a3b8;border-bottom:1px solid #2a2a4a;">Theoretical limit</th>
                            <th style="padding:8px 12px;text-align:left;color:#94a3b8;border-bottom:1px solid #2a2a4a;">Current value</th>
                            <th style="padding:8px 12px;text-align:left;color:#94a3b8;border-bottom:1px solid #2a2a4a;">% of limit reached</th>
                            <th style="padding:8px 12px;text-align:left;color:#94a3b8;border-bottom:1px solid #2a2a4a;">Visual</th>
                        </tr></thead>
                        <tbody id="hl_ratio_table_body">
                            <tr><td colspan="6" style="padding:20px;text-align:center;color:#888;font-style:italic;">Run analysis above to populate</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        <!-- ── end hl deep dive section ── -->

        <div class="chart-wrapper" id="customGapCompareWrapper">
            <div class="chart-title">Custom Gap Family Comparison</div>
            <div class="chart-description">
                Compare specific gap families you choose. Test hypotheses like "gaps divisible by 6 have more primes" 
                or "gap 6n > gap 6n±k for all k". Select up to 10 gaps to visualize side-by-side.
            </div>
            
            <!-- Gap Selection Controls -->
            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px; border-left: 4px solid #3b82f6; margin-bottom: 20px;">
                <h4 style="color: #3b82f6; margin: 0 0 16px 0;">Select Gaps to Compare</h4>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 6px; color: #aaa; font-size: 0.9rem;">
                        Enter gaps (comma-separated, even numbers only):
                    </label>
                    <input type="text" id="compareGapsInput" placeholder="e.g., 2, 4, 6, 8, 10, 12, 18, 24, 30"
                           style="width: 100%; padding: 12px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0; font-size: 1rem;">
                    <div style="margin-top: 6px; font-size: 0.75rem; color: #666;">
                        Enter any even numbers separated by commas. Example: 6, 12, 18, 24, 30
                    </div>
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 6px; color: #aaa; font-size: 0.9rem;">Quick Presets:</label>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        <button onclick="loadGapPreset('twins_cousins')" class="preset-btn">Twins vs Cousins (2,4)</button>
                        <button onclick="loadGapPreset('small_gaps')" class="preset-btn">Small Gaps (2,4,6,8,10)</button>
                        <button onclick="loadGapPreset('mod6')" class="preset-btn">Gaps ≡ 0 (mod 6)</button>
                        <button onclick="loadGapPreset('mod6_nearby')" class="preset-btn">6n vs 6n±2 vs 6n±4</button>
                        <button onclick="loadGapPreset('powers_of_2')" class="preset-btn">Powers: 2,4,8,16,32</button>
                        <button onclick="loadGapPreset('clear')" class="preset-btn" style="background: #475569;">Clear</button>
                    </div>
                </div>
                
                <button onclick="renderCustomGapComparison()" class="btn" style="width: 100%;">
                    Compare Selected Gaps
                </button>
            </div>
            
            <canvas id="customGapCompareChart" width="3840" height="2160"></canvas>
            
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Comparison Statistics</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="customGapComparePrecision" onchange="renderCustomGapComparison()">
                            <option value="4">4</option>
                            <option value="6" selected>6</option>
                            <option value="8">8</option>
                            <option value="10">10</option>
                        </select>
                    </div>
                </div>
                <div class="stats-table-container" id="customGapCompareTable">
                    <table class="stats-table" id="customGapCompareTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportCustomGapCompareCSV()">Export Comparison CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('customGapCompareChart', 'custom_gap_comparison')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: #3b82f6;">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('customGapCompareChart', 'custom_gap_comparison')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="stepByStepWrapper">
            <div class="chart-title">Step-by-Step Gap Accumulation: ζ(2) = P<sub>0</sub> × P<sub>2</sub> × P<sub>4</sub> × ...</div>
            <div class="chart-description">
                Shows the progressive buildup of the cumulative product as each gap family is added. This table view complements the convergence chart by providing exact numerical values at each step.
            </div>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Progressive Product Construction</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="stepByStepPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8">8</option>
                            <option value="10">10</option>
                            <option value="12" selected>12</option>
                            <option value="15">15</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('stepByStepTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container expanded" id="stepByStepTable">
                    <table class="stats-table" id="stepByStepTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('stepByStep')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportStepByStepTablePNG()">Export Table PNG</button>
                </div>
            </div>
        </div>
        
        <!-- COMPARISON CHART (Only shown when comparison mode enabled) -->
        <div class="chart-wrapper" id="comparisonWrapper" style="display: none;">
            <div class="chart-title">Gap Contribution Evolution Across ζ(s)</div>
            <canvas id="comparisonChart" width="3840" height="2400"></canvas>
            <div class="stats-table-wrapper">
                <div class="chart-description" style="background: rgba(139, 92, 246, 0.1); padding: 16px; border-radius: 6px; border-left: 4px solid #8b5cf6;">
                    <strong>How Gap Contributions Change with s:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>s → 1:</strong> All gaps contribute equally (divergent series)</li>
                        <li><strong>s = 1.5:</strong> Gap 1 (45%), Gap 2 (39%) - Balanced</li>
                        <li><strong>s = 2:</strong> Gap 1 (58%), Gap 2 (35%) - Current tool focus</li>
                        <li><strong>s = 4:</strong> Gap 1 (82%), Gap 2 (18%) - Gap 1 dominant</li>
                        <li><strong>s = 10:</strong> Gap 1 (98%), Gap 2 (2%) - Almost entirely Gap 1</li>
                    </ul>
                    <p style="margin-top: 12px; color: #a78bfa;">
                        <strong>Key Insight:</strong> Twin primes (Gap 2) dominate at s=2, but prime 2 (Gap 1) dominates at higher s values!
                    </p>
                </div>
                <div id="comparisonTableDiv"></div>
                <div class="export-row">
                    <button class="export-btn png" onclick="exportComparisonPNG()">Export Comparison PNG</button>
                </div>
            </div>
        </div>
        
        <!-- DECIMAL CONVERGENCE ANALYSIS -->
        <div class="chart-wrapper" id="decimalConvergenceWrapper">
            <div class="chart-title">Decimal Place Convergence Analysis: Weight Decay & Marginal Contribution</div>
            <div class="chart-description" style="background: rgba(34, 197, 94, 0.1); padding: 16px; border-radius: 6px; border-left: 4px solid #22c55e; margin-bottom: 20px;">
                <strong>Understanding Weight Decay:</strong> As primes get larger, the factor p²/(p²-1) approaches 1.0, so later primes contribute less. 
                For example, prime 2 contributes 4/3 = 1.333... (fixed), but prime 1,000,003 contributes ≈1.000000000004.
                This analysis shows <strong>which primes "lock in" each decimal place</strong> of convergence for each gap family.
            </div>
            
            <canvas id="decimalConvergenceChart" width="3840" height="2160"></canvas>
            
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Per-Prime Marginal Contribution</div>
                    <div class="precision-control">
                        <label>Gap to Analyze:</label>
                        <select id="decimalGapSelect" onchange="updateDecimalAnalysis()">
                            <option value="1">Gap 1</option>
                            <option value="2" selected>Gap 2 (Twin Primes)</option>
                            <option value="4">Gap 4 (Cousin Primes)</option>
                            <option value="6">Gap 6 (Sexy Primes)</option>
                            <option value="8">Gap 8</option>
                            <option value="10">Gap 10</option>
                            <option value="12">Gap 12</option>
                        </select>
                        <label style="margin-left: 20px;">Show:</label>
                        <select id="decimalDetailLevel" onchange="updateDecimalAnalysis()">
                            <option value="summary" selected>Summary (First 20 primes)</option>
                            <option value="detailed">Detailed (First 100 primes)</option>
                            <option value="full">Full (All primes in gap)</option>
                        </select>
                        <label style="margin-left: 20px;">Decimals:</label>
                        <select id="decimalConvergencePrecision" onchange="updateDecimalAnalysis()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8">8</option>
                            <option value="10">10</option>
                            <option value="12" selected>12</option>
                            <option value="15">15</option>
                        </select>
                    </div>
                </div>
                <div class="stats-table-container" id="decimalAnalysisTable">
                    <table class="stats-table" id="decimalAnalysisTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportDecimalAnalysisCSV()">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('decimalConvergenceChart', 'decimal_convergence')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: #3b82f6;">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('decimalConvergenceChart', 'decimal_convergence')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <!-- GAP RATIO ANALYSIS CHART -->
    </div>
    
    <div class="controls-container">
        <div class="control-panel">
            <h3>Composite Screenshot Export</h3>
            <p style="color: #aaa; font-size: 0.9rem; margin-bottom: 20px;">
                Generate a comprehensive image combining selected charts with analysis summary and mathematical narrative
            </p>
            
            <div style="background: rgba(78, 205, 196, 0.05); padding: 16px; border-radius: 8px; border-left: 4px solid #4ecdc4; margin-bottom: 20px;">
                <h4 style="color: #4ecdc4; margin: 0 0 12px 0; font-size: 1rem;">Global Export Settings</h4>
                <p style="margin: 0 0 12px 0; color: #888; font-size: 0.85rem;">
                    These settings apply to ALL chart exports (individual and composite)
                </p>
                
                <div class="control-grid" style="grid-template-columns: 1fr;">
                    <div class="control-group">
                        <label>Data Rows in Exported Tables</label>
                        <select id="globalExportRows">
                            <option value="5">5 rows</option>
                            <option value="10">10 rows</option>
                            <option value="15" selected>15 rows</option>
                            <option value="20">20 rows</option>
                            <option value="25">25 rows</option>
                            <option value="30">30 rows</option>
                            <option value="40">40 rows</option>
                            <option value="50">50 rows</option>
                            <option value="all">All rows (may be very large)</option>
                        </select>
                        <div style="margin-top: 4px; font-size: 0.75rem; color: #888;">
                            Applies to all chart PNG exports (individual and composite screenshots)
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="control-grid" style="grid-template-columns: repeat(3, 1fr);">
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotConvergence" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Progressive Convergence</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotGapContrib" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Gap Products</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotGapDist" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Gap Distribution</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotPercentage" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Percentage Contributions</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotError" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Error Analysis</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotLogScale" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Log-Scale Products</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotGapRatio" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Gap Ratio Analysis</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotDecimalConv">
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Decimal Convergence</span>
                </div>
            </div>
            
            <div class="section-divider"></div>
            
            <div class="control-group">
                <label>Main Title</label>
                <input type="text" id="screenshotTitle" value="Gap-Class Decomposition of ζ(2) = π²/6">
            </div>
            
            <div class="control-group">
                <label>Subtitle</label>
                <input type="text" id="screenshotSubtitle" value="Analytical Partition of the Euler Product">
            </div>
            
            <div class="control-group">
                <label>Layout</label>
                <select id="screenshotLayout">
                    <option value="grid">Grid (2×3)</option>
                    <option value="vertical">Vertical Stack</option>
                    <option value="horizontal">Horizontal (2 rows)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Resolution</label>
                <select id="screenshotResolution">
                    <option value="1920">HD (1920×1080)</option>
                    <option value="2560">QHD (2560×1440)</option>
                    <option value="3840" selected>4K (3840×2160)</option>
                    <option value="7680">8K (7680×4320)</option>
                </select>
            </div>
            
            <div class="section-divider"></div>
            
            <button class="btn" onclick="generateCompositeScreenshot()" style="width: 100%; margin-bottom: 12px;">
                Generate Composite Screenshot
            </button>
            
            <div id="screenshotStatus" class="status-bar" style="display: none; margin-top: 12px;">
                Generating screenshot...
            </div>
        </div>
    </div>
    
    <!-- MERTENS FUNCTION SECTION -->
    <div class="controls-container" style="margin-top: 40px;">
        <div class="dropdown-section" style="border: 2px solid #4ecdc4;">
            <div class="dropdown-header" onclick="toggleSection(this)" style="background: linear-gradient(135deg, #0d1f2d 0%, #0a1628 100%);">
                <h3 style="color: #4ecdc4; display: flex; align-items: center; gap: 12px;">
                    <span>⟨μ⟩</span> Mertens Function & Riemann Hypothesis Connection
                    <span style="background: rgba(78,205,196,0.2); color: #4ecdc4; padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600;">Companion Analysis</span>
                </h3>
                <span class="dropdown-icon" style="color: #4ecdc4;">v</span>
            </div>
            <div class="dropdown-content">

                <!-- Mathematical Bridge -->
                <div style="background: linear-gradient(135deg, #0d1f2d, #0a1628); border: 1px solid #4ecdc4; border-radius: 8px; padding: 24px; margin-bottom: 20px;">
                    <h4 style="color: #4ecdc4; margin: 0 0 14px 0; font-size: 1.1rem;">Connection to the Gap-Class Decomposition</h4>
                    <p style="color: #ccc; margin-bottom: 12px; line-height: 1.7;">
                        The gap-class decomposition above reorganises the Euler product <strong style="color:#ffd700;">ζ(2) = ∏ p²/(p²−1)</strong> by prime gap families. 
                        The Mertens function below probes the <em>same prime landscape</em> from a different angle: the Möbius function μ(n) encodes the exact prime-factorisation structure that drives those products, 
                        with μ(n) = ±1 for square-free n and 0 otherwise.
                    </p>
                    <p style="color: #ccc; margin-bottom: 12px; line-height: 1.7;">
                        Their deep link is the Riemann Hypothesis. The RH is equivalent to both:
                    </p>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                        <div style="background: rgba(255,215,0,0.07); border-left: 3px solid #ffd700; padding: 12px; border-radius: 4px;">
                            <div style="color: #ffd700; font-family: 'Times New Roman', serif; font-size: 1.1rem; margin-bottom: 6px;">|M(n)| = O(n^(½+ε))</div>
                            <div style="color: #aaa; font-size: 0.85rem;">The Mertens wave stays within the ±√n boundary — visible in the chart below</div>
                        </div>
                        <div style="background: rgba(78,205,196,0.07); border-left: 3px solid #4ecdc4; padding: 12px; border-radius: 4px;">
                            <div style="color: #4ecdc4; font-family: 'Times New Roman', serif; font-size: 1.1rem; margin-bottom: 6px;">log ζ(s) = Σ<sub>g</sub> log P<sub>g</sub></div>
                            <div style="color: #aaa; font-size: 0.85rem;">The gap decomposition converges — witnessed by the error charts above</div>
                        </div>
                    </div>
                    <p style="color: #888; font-size: 0.9rem; line-height: 1.6;">
                        Both functions are ultimately measuring whether primes are distributed "fairly" — without systematic bias toward any particular factorisation pattern. 
                        The tight convergence in the gap products above and M(n) staying within ±√n below are two faces of the same conjecture.
                    </p>
                </div>

                <!-- Mertens Stats Grid -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-bottom: 20px;">
                    <div style="background: linear-gradient(135deg, #0d1f2d, #0a1628); border: 1px solid #4ecdc4; padding: 16px; border-radius: 8px;">
                        <div style="color: #888; font-size: 0.8rem; margin-bottom: 4px;">Current Range</div>
                        <div style="color: #4ecdc4; font-size: 1.3rem; font-weight: bold;" id="m_statRange">n = 1 to 2,000</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #0d1f2d, #0a1628); border: 1px solid #22c55e; padding: 16px; border-radius: 8px;">
                        <div style="color: #888; font-size: 0.8rem; margin-bottom: 4px;">Maximum Peak</div>
                        <div style="color: #22c55e; font-size: 1.3rem; font-weight: bold;" id="m_statMax">—</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #0d1f2d, #0a1628); border: 1px solid #ef4444; padding: 16px; border-radius: 8px;">
                        <div style="color: #888; font-size: 0.8rem; margin-bottom: 4px;">Minimum Dip</div>
                        <div style="color: #ef4444; font-size: 1.3rem; font-weight: bold;" id="m_statMin">—</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #0d1f2d, #0a1628); border: 1px solid #a855f7; padding: 16px; border-radius: 8px;">
                        <div style="color: #888; font-size: 0.8rem; margin-bottom: 4px;">Zero Crossings</div>
                        <div style="color: #a855f7; font-size: 1.3rem; font-weight: bold;" id="m_statZeros">—</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #0d1f2d, #0a1628); border: 1px solid #f59e0b; padding: 16px; border-radius: 8px;">
                        <div style="color: #888; font-size: 0.8rem; margin-bottom: 4px;">Square-Free</div>
                        <div style="color: #f59e0b; font-size: 1.3rem; font-weight: bold;" id="m_statSquareFree">—</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #0d1f2d, #0a1628); border: 1px solid #4ecdc4; padding: 16px; border-radius: 8px;">
                        <div style="color: #888; font-size: 0.8rem; margin-bottom: 4px;">Within ±√n</div>
                        <div style="color: #4ecdc4; font-size: 1.3rem; font-weight: bold;" id="m_statBoundary">—</div>
                    </div>
                </div>

                <!-- Controls -->
                <div style="display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-end; margin-bottom: 16px; padding: 16px; background: #12121a; border-radius: 8px; border: 1px solid #2a2a4a;">
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <label style="color: #aaa; font-size: 0.85rem;">Range: n = 1 to <span style="color: #ffd700;" id="m_rangeValue">2000</span></label>
                        <input type="range" id="m_rangeSlider" min="100" max="10000" value="2000" step="100"
                               oninput="m_onRangeSlider(this.value)"
                               style="width: 220px; accent-color: #4ecdc4;">
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <label style="color: #aaa; font-size: 0.85rem;">Set n manually</label>
                        <input type="number" id="m_manualInput" min="100" max="100000" value="2000" step="1"
                               oninput="m_onManualInput(this.value)"
                               style="padding: 8px 12px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0; font-size: 0.9rem; width: 110px;">
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <label style="color: #aaa; font-size: 0.85rem;">Animation</label>
                        <div style="display: flex; gap: 8px;">
                            <button id="m_playBtn" onclick="m_startAnimation()"
                                    style="padding: 8px 16px; background: linear-gradient(135deg,#22c55e,#16a34a); border: none; border-radius: 4px; color: #fff; font-weight: 600; cursor: pointer; font-size: 0.85rem;">▶ Play</button>
                            <button id="m_pauseBtn" onclick="m_stopAnimation()"
                                    style="display:none; padding: 8px 16px; background: linear-gradient(135deg,#f59e0b,#d97706); border: none; border-radius: 4px; color: #fff; font-weight: 600; cursor: pointer; font-size: 0.85rem;">⏸ Pause</button>
                            <button onclick="m_startBackwardAnimation()"
                                    style="padding: 8px 16px; background: linear-gradient(135deg,#6366f1,#4f46e5); border: none; border-radius: 4px; color: #fff; font-weight: 600; cursor: pointer; font-size: 0.85rem;">◀ Rewind</button>
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <label style="color: #aaa; font-size: 0.85rem;">Speed: <span style="color: #ffd700;" id="m_speedValue">50</span>ms</label>
                        <input type="range" id="m_speedSlider" min="10" max="200" value="50" step="10"
                               oninput="m_onSpeedSlider(this.value)"
                               style="width: 140px; accent-color: #4ecdc4;">
                    </div>
                    <div style="display: flex; gap: 16px; align-items: center;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #ccc; font-size: 0.85rem;">
                            <input type="checkbox" id="m_showBounds" checked onchange="m_drawGraph()" style="accent-color: #4ecdc4;"> ±√n boundary
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #ccc; font-size: 0.85rem;">
                            <input type="checkbox" id="m_showZeros" checked onchange="m_drawGraph()" style="accent-color: #4ecdc4;"> Zero crossings
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #ccc; font-size: 0.85rem;">
                            <input type="checkbox" id="m_loopAnim" style="accent-color: #4ecdc4;"> Loop
                        </label>
                    </div>
                </div>

                <!-- Canvas -->
                <div style="position: relative; background: #0a0a10; border-radius: 8px; padding: 16px; margin-bottom: 20px; border: 1px solid #2a2a4a;">
                    <canvas id="m_graphCanvas" width="1400" height="500" style="display:block; width:100%; height:auto; background:#0a0a10; border-radius:4px; cursor:crosshair;"></canvas>
                    <div id="m_tooltip" style="position:absolute; background:rgba(0,0,0,0.92); color:#e0e0e0; padding:10px 14px; border-radius:6px; font-size:0.85rem; pointer-events:none; opacity:0; transition:opacity 0.15s; z-index:1000; border:1px solid #3a3a5a; max-width:260px;"></div>
                </div>

                <!-- Data Table -->
                <div style="background: #12121a; border-radius: 8px; padding: 16px; border: 1px solid #2a2a4a;">
                    <h4 style="color: #ffd700; margin: 0 0 12px 0;">Data Table</h4>
                    <div style="display: flex; gap: 12px; margin-bottom: 12px; flex-wrap: wrap; align-items: center;">
                        <input type="text" id="m_searchInput" placeholder="Search by n value…" oninput="m_populateTable()"
                               style="padding: 8px 12px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0; font-size: 0.85rem; width: 180px;">
                        <select id="m_filterType" onchange="m_populateTable()"
                                style="padding: 8px 12px; background: #1a1a2a; border: 1px solid #3a3a5a; border-radius: 4px; color: #e0e0e0; font-size: 0.85rem;">
                            <option value="all">Show All</option>
                            <option value="zeros">Zero Crossings Only</option>
                            <option value="positive">Positive Only</option>
                            <option value="negative">Negative Only</option>
                            <option value="square-free">Square-Free Only</option>
                        </select>
                        <button onclick="m_exportCSV()"
                                style="padding: 8px 16px; background: #2a2a4a; border: none; border-radius: 4px; color: #e0e0e0; cursor: pointer; font-size: 0.85rem;">Export CSV</button>
                    </div>
                    <div style="max-height: 400px; overflow: auto; border-radius: 6px;">
                        <table style="width:100%; border-collapse:collapse; background:#0a0a10; font-size:0.82rem;">
                            <thead style="position:sticky; top:0; background:#1a1a2a; z-index:5;">
                                <tr>
                                    <th onclick="m_sortTable('n')" style="padding:10px 12px; text-align:left; color:#ffd700; cursor:pointer; border-bottom:1px solid #2a2a4a;">n</th>
                                    <th onclick="m_sortTable('mu')" style="padding:10px 12px; text-align:left; color:#ffd700; cursor:pointer; border-bottom:1px solid #2a2a4a;">μ(n)</th>
                                    <th onclick="m_sortTable('M')" style="padding:10px 12px; text-align:left; color:#ffd700; cursor:pointer; border-bottom:1px solid #2a2a4a;">M(n)</th>
                                    <th onclick="m_sortTable('delta')" style="padding:10px 12px; text-align:left; color:#ffd700; cursor:pointer; border-bottom:1px solid #2a2a4a;">ΔM</th>
                                    <th onclick="m_sortTable('sqFree')" style="padding:10px 12px; text-align:left; color:#ffd700; cursor:pointer; border-bottom:1px solid #2a2a4a;">Square-Free</th>
                                    <th onclick="m_sortTable('factors')" style="padding:10px 12px; text-align:left; color:#ffd700; cursor:pointer; border-bottom:1px solid #2a2a4a;">Prime Factors</th>
                                    <th onclick="m_sortTable('distance')" style="padding:10px 12px; text-align:left; color:#ffd700; cursor:pointer; border-bottom:1px solid #2a2a4a;">|M(n)|</th>
                                    <th onclick="m_sortTable('within')" style="padding:10px 12px; text-align:left; color:#ffd700; cursor:pointer; border-bottom:1px solid #2a2a4a;">Within ±√n</th>
                                    <th style="padding:10px 12px; text-align:left; color:#ffd700; border-bottom:1px solid #2a2a4a;">Status</th>
                                </tr>
                            </thead>
                            <tbody id="m_tableBody"></tbody>
                            <tfoot style="position:sticky; bottom:0; background:#1a1a2a;">
                                <tr>
                                    <td colspan="2" style="padding:10px 12px; color:#aaa; font-size:0.8rem;">Σμ(n) = <span id="m_sumMu" style="color:#ffd700;">—</span></td>
                                    <td style="padding:10px 12px; color:#aaa; font-size:0.8rem;">Final: <span id="m_finalM" style="color:#ffd700;">—</span></td>
                                    <td colspan="2" style="padding:10px 12px; color:#aaa; font-size:0.8rem;">Sq-Free: <span id="m_sqFreeCount" style="color:#ffd700;">—</span></td>
                                    <td style="padding:10px 12px; color:#aaa; font-size:0.8rem;">Avg |M|: <span id="m_avgDist" style="color:#ffd700;">—</span></td>
                                    <td colspan="2" style="padding:10px 12px; color:#aaa; font-size:0.8rem;">Within bound: <span id="m_withinCount" style="color:#ffd700;">—</span></td>
                                    <td style="padding:10px 12px; color:#aaa; font-size:0.8rem;">Zeros: <span id="m_zeroCount" style="color:#ffd700;">—</span></td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- CREDITS SECTION -->
    <div class="controls-container" style="margin-top: 40px;">
        <div class="dropdown-section" style="border: 2px solid #ffd700;">
            <div class="dropdown-header" onclick="toggleSection(this)" style="background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1a 100%);">
                <h3 style="color: #ffd700;">Credits &amp; Attribution</h3>
                <span class="dropdown-icon" style="color: #ffd700;">v</span>
            </div>
            <div class="dropdown-content">
                <div style="display: grid; gap: 20px;">

                    <!-- Author -->
                    <div style="background: rgba(255, 215, 0, 0.05); padding: 20px; border-radius: 8px; border-left: 4px solid #ffd700;">
                        <h4 style="color: #ffd700; margin: 0 0 12px 0; font-size: 1.1rem;">Author</h4>
                        <p style="margin: 0; color: #e0e0e0; line-height: 2.0;">
                            <strong>Wessen Getachew</strong><br>
                            Independent Mathematical Researcher<br>
                            Twitter/X: <a href="https://twitter.com/7dview" target="_blank" style="color: #4ecdc4; text-decoration: none;">@7dview</a><br>
                            GitHub: <a href="https://wessengetachew.github.io/Quant" target="_blank" style="color: #4ecdc4; text-decoration: none;">wessengetachew.github.io/Quant</a>
                        </p>
                    </div>

                    <!-- Mathematical Context -->
                    <div style="background: rgba(139, 92, 246, 0.05); padding: 20px; border-radius: 8px; border-left: 4px solid #8b5cf6;">
                        <h4 style="color: #8b5cf6; margin: 0 0 12px 0; font-size: 1.1rem;">Mathematical Context</h4>
                        <p style="margin: 0 0 12px 0; color: #ccc; line-height: 1.8;">
                            This work builds on Euler's 1737 product formula for ζ(2) = π²/6 (Basel problem, first solved by Euler in 1734).
                            The gap-class factorization ζ(2) = ∏<sub>g</sub> P<sub>g</sub> follows directly from absolute convergence of the Euler product —
                            it is a reorganization of a known result, not a new theorem. Its value is computational and structural.
                        </p>
                        <p style="margin: 0 0 12px 0; color: #ccc; line-height: 1.8;">
                            Hardy-Littlewood Conjecture B (1923) predicts asymptotic counts for prime pairs with fixed gap g via the singular
                            series S(g). The observation that S(g)/S(h) predicts the asymptotic ratio of log-weights w<sub>g</sub>/w<sub>h</sub>
                            in this decomposition follows from Conjecture B and is directly verifiable at finite N.
                            This consequence does not appear to have been stated explicitly in the literature.
                        </p>
                        <p style="margin: 0; color: #ccc; line-height: 1.8;">
                            The question of whether a finite twin prime set would be analytically incompatible with ζ(s)'s structure
                            via this product identity is raised as an open structural question — not a proof of the Twin Prime Conjecture.
                        </p>
                    </div>

                    <!-- What Is Known vs What Is New -->
                    <div style="background: rgba(255, 100, 100, 0.04); padding: 20px; border-radius: 8px; border-left: 4px solid #ff6464;">
                        <h4 style="color: #ff9966; margin: 0 0 12px 0; font-size: 1.1rem;">What Is Established vs. What Is New Here</h4>
                        <p style="margin: 0 0 10px 0; color: #aaa; font-size: 0.9rem; line-height: 1.7;">
                            <strong style="color:#ccc;">Established (prior literature):</strong> Euler product for ζ(s) (Euler, 1737); Basel problem solution π²/6
                            (Euler, 1734); Hardy-Littlewood Conjecture B and singular series (1923); twin prime constant C<sub>2</sub> ≈ 0.66016;
                            Cramér's model for prime gaps (1936).
                        </p>
                        <p style="margin: 0 0 10px 0; color: #aaa; font-size: 0.9rem; line-height: 1.7;">
                            <strong style="color:#ccc;">This work:</strong> The specific partition of the Euler product by forward gap class and its numerical analysis;
                            the observation that S(g)/S(h) governs log-weight ratios conditional on Conjecture B;
                            the structural question about analytic obstructions to a finite twin prime set via the product identity;
                            computational data at N up to 300M (browser) with verified estimates to 400M.
                        </p>
                        <p style="margin: 0; color: #666; font-size: 0.85rem; line-height: 1.6;">
                            The author makes no claim that these observations constitute a proof of any unsolved conjecture.
                            They are presented as computational evidence and structural observations for further investigation.
                        </p>
                    </div>

                    <!-- References -->
                    <div style="background: rgba(255,255,255,0.02); padding: 20px; border-radius: 8px; border: 1px solid #2a2a4a;">
                        <h4 style="color: #aaa; margin: 0 0 14px 0; font-size: 1.1rem;">References</h4>
                        <div style="color: #888; font-size: 0.88rem; line-height: 2.2; font-family: serif;">
                            [1] L. Euler, <em>Variae observationes circa series infinitas</em>, Comm. Acad. Sci. Petrop. 9 (1737), 160–188.<br>
                            [2] G. H. Hardy &amp; J. E. Littlewood, <em>Some problems of 'Partitio Numerorum' III</em>, Acta Math. 44 (1923), 1–70.<br>
                            [3] H. Cramér, <em>On the order of magnitude of the difference between consecutive prime numbers</em>, Acta Arith. 2 (1936), 23–46.<br>
                            [4] A. Granville, <em>Harald Cramér and the distribution of prime numbers</em>, Scand. Actuarial J. 1 (1995), 12–28.<br>
                            [5] W. Getachew, <em>Gap-Class Decomposition of ζ(2): interactive analysis tool</em>, 2026.
                            &nbsp;<a href="https://wessengetachew.github.io/Quant" target="_blank" style="color: #4ecdc4; text-decoration: none;">wessengetachew.github.io/Quant</a>
                        </div>
                    </div>

                    <!-- License -->
                    <div style="background: rgba(255,255,255,0.02); padding: 16px; border-radius: 8px; border: 1px solid #1a1a2a;">
                        <h4 style="color: #555; margin: 0 0 10px 0; font-size: 0.95rem;">License &amp; Usage</h4>
                        <p style="margin: 0; color: #555; font-size: 0.85rem; line-height: 1.6;">
                            Provided for educational and research purposes. If you use this tool or cite its findings in academic work,
                            please attribute <strong style="color:#777;">Wessen Getachew</strong> and reference the gap-class decomposition framework.
                        </p>
                    </div>

                    <!-- Build Info -->
                    <div style="text-align: center; padding: 12px; color: #333; font-size: 0.82rem; border-top: 1px solid #1a1a2a; font-family: monospace; letter-spacing: 0.04em;">
                        Gap-Class Decomposition Explorer v2.1 &nbsp;·&nbsp; February 2026 &nbsp;·&nbsp; MSC 2020: 11M06, 11N05, 11A41
                    </div>

                </div>
            </div>
        </div>
    </div>
    
    <canvas id="compositeCanvas" style="display: none;"></canvas>
    
    <!-- Modal Popup for Gap Details -->
    <div class="modal-overlay" id="gapModal" onclick="closeGapModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Gap Details</h2>
                <div style="display: flex; gap: 12px;">
                    <button class="modal-screenshot" onclick="screenshotModalPart1()" style="font-size: 0.85rem; padding: 8px 12px;">Part 1 (4K)</button>
                    <button class="modal-screenshot" onclick="screenshotModalPart2()" style="font-size: 0.85rem; padding: 8px 12px;">Part 2 (4K)</button>
                    <button class="modal-close" onclick="closeGapModal()">Close</button>
                </div>
            </div>
            <div id="modalBody"></div>
        </div>
    </div>
    
    </div>
    <!-- END TAB: Main -->

    <script>
        // Collapsible section toggle function
        function toggleSection(header) {
            const section = header.parentElement;
            section.classList.toggle('active');
        }
        // Dropdown toggle functionality
        function toggleDropdown(sectionId) {
            const section = document.getElementById(sectionId);
            section.classList.toggle('active');
        }
        
// Gap Decomposition Analyzer v2.1 - Fixed xPos scope issue
        // Global variables
        let analysisResults = null;
        let animationId = null;
        let isAnimating = false;

        // Gap filter functions
        function toggleGapFilter() {
            const enabled = document.getElementById('enableGapFilter').checked;
            const controls = document.getElementById('gapFilterControls');
            controls.style.display = enabled ? 'block' : 'none';
            
            if (enabled) {
                updateGapFilterDisplay();
            } else {
                document.getElementById('gapFilterStatus').textContent = 'Showing all gaps';
            }
            
            if (analysisResults) {
                renderAllCharts();
            }
        }

        function setGapRange(min, max) {
            document.getElementById('minGapFilter').value = min;
            document.getElementById('maxGapFilter').value = max;
            document.getElementById('enableGapFilter').checked = true;
            toggleGapFilter();
            if (analysisResults) {
                renderAllCharts();
            }
        }

        function setGapRangeToLast(count) {
            if (!analysisResults || !analysisResults.evenGaps) {
                alert('Please run analysis first');
                return;
            }
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const lastGaps = gaps.slice(-count);
            const min = Math.min(...lastGaps);
            const max = Math.max(...lastGaps);
            
            setGapRange(min, max);
        }

        function resetGapFilter() {
            document.getElementById('minGapFilter').value = 2;
            document.getElementById('maxGapFilter').value = 50;
            document.getElementById('enableGapFilter').checked = false;
            toggleGapFilter();
        }

        function updateGapFilterDisplay() {
            const min = parseInt(document.getElementById('minGapFilter').value);
            const max = parseInt(document.getElementById('maxGapFilter').value);
            document.getElementById('gapFilterStatus').textContent = `Showing gaps ${min} to ${max}`;
            
            if (analysisResults) {
                renderAllCharts();
            }
        }

        function getFilteredGaps() {
            if (!analysisResults) return [];
            
            const filterEnabled = document.getElementById('enableGapFilter').checked;
            if (!filterEnabled) {
                return analysisResults.evenGaps;
            }
            
            const min = parseInt(document.getElementById('minGapFilter').value);
            const max = parseInt(document.getElementById('maxGapFilter').value);
            
            return analysisResults.evenGaps.filter(g => g >= min && g <= max);
        }

        function getFilteredProgressiveProducts() {
            if (!analysisResults) return [];
            
            const filteredGaps = getFilteredGaps();
            return analysisResults.progressiveProducts.filter(p => filteredGaps.includes(p.gap));
        }

        function getFilteredGapProducts() {
            if (!analysisResults) return {};
            
            const filteredGaps = getFilteredGaps();
            const filtered = {};
            filteredGaps.forEach(gap => {
                if (analysisResults.gapProducts[gap]) {
                    filtered[gap] = analysisResults.gapProducts[gap];
                }
            });
            return filtered;
        }
        
        // Segmented Sieve of Eratosthenes
        // NOTE: This solves the SIEVING memory problem (constant ~50 MB during generation).
        // The STORAGE problem remains — JavaScript must still hold all primes found.
        // Browser limit: ~300M (~16M primes, ~340 MB). Above that, use the Python script.
        function sievePrimes(max, progressCallback = null) {
            // If custom prime list is loaded, use it instead of computing
            if (customPrimeList && customPrimeList.length > 0) {
                // Filter to primes <= max
                return customPrimeList.filter(p => p <= max);
            }
            
            // For small ranges (< 10M), use simple sieve for speed
            if (max < 10000000) {
                return simpleSieve(max, progressCallback);
            }
            
            // For larger ranges, use segmented sieve (reduces sieving memory only)
            return segmentedSieve(max, progressCallback);
        }
        
        // Simple sieve for smaller ranges
        function simpleSieve(max, progressCallback = null) {
            const sieve = new Array(max + 1).fill(true);
            sieve[0] = sieve[1] = false;
            
            for (let i = 2; i * i <= max; i++) {
                if (sieve[i]) {
                    for (let j = i * i; j <= max; j += i) {
                        sieve[j] = false;
                    }
                }
            }
            
            const primes = [];
            for (let i = 2; i <= max; i++) {
                if (sieve[i]) primes.push(i);
            }
            
            if (progressCallback) {
                progressCallback(100, 100, primes.length);
            }
            
            return primes;
        }
        
        // Segmented sieve for memory-efficient large range processing
        function segmentedSieve(max, progressCallback = null) {
            // Generate small primes up to sqrt(max)
            const sqrtMax = Math.floor(Math.sqrt(max)) + 1;
            const smallPrimes = simpleSieve(sqrtMax);
            
            // Process in segments
            const segmentSize = 1000000; // 1 million per segment
            const primes = [];
            
            let currentSegmentStart = 0;
            let currentSegmentEnd = Math.min(segmentSize, max);
            
            while (currentSegmentStart <= max) {
                // Create segment
                const segmentLength = currentSegmentEnd - currentSegmentStart + 1;
                const segment = new Array(segmentLength).fill(true);
                
                // Mark composites in this segment using small primes
                for (let i = 0; i < smallPrimes.length; i++) {
                    const p = smallPrimes[i];
                    
                    // Find first multiple of p in segment
                    let start = Math.max(p * p, Math.ceil(currentSegmentStart / p) * p);
                    
                    // Mark multiples as composite
                    for (let j = start; j <= currentSegmentEnd; j += p) {
                        segment[j - currentSegmentStart] = false;
                    }
                }
                
                // Collect primes from this segment
                for (let i = 0; i < segmentLength; i++) {
                    const num = currentSegmentStart + i;
                    if (num >= 2 && segment[i]) {
                        primes.push(num);
                    }
                }
                
                // Report progress
                if (progressCallback) {
                    const percentComplete = Math.min(100, (currentSegmentEnd / max) * 100);
                    progressCallback(currentSegmentEnd, max, primes.length);
                }
                
                // Move to next segment
                currentSegmentStart = currentSegmentEnd + 1;
                currentSegmentEnd = Math.min(currentSegmentStart + segmentSize - 1, max);
                
                // Break if we've processed everything
                if (currentSegmentStart > max) break;
            }
            
            return primes;
        }
        
        // Core analysis function
        function computeGapDecomposition(maxPrime, gapRangeFilter = null, progressCallback = null) {
            const primes = sievePrimes(maxPrime, progressCallback);
            const targetZeta2 = Math.PI * Math.PI / 6;
            
            // Calculate gaps and classify primes
            const gapFamilies = {}; // Will be populated by loop - gap 1 gets prime 2 from 3-2=1
            const gaps = [];
            
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i + 1] - primes[i];
                gaps.push(gap);
                
                if (!gapFamilies[gap]) {
                    gapFamilies[gap] = [];
                }
                gapFamilies[gap].push(primes[i]);
            }
            
            // Calculate products for each gap family
            const gapProducts = {};
            
            // Find all unique gaps that actually exist in the data
            const uniqueGaps = new Set(gaps);
            let evenGaps = Array.from(uniqueGaps).sort((a, b) => a - b);
            
            // Apply gap range filter if specified
            if (gapRangeFilter && gapRangeFilter.mode === 'manual') {
                const minGap = gapRangeFilter.min;
                const maxGap = gapRangeFilter.max;
                evenGaps = evenGaps.filter(gap => gap >= minGap && gap <= maxGap);
            }
            
            evenGaps.forEach(gap => {
                if (gapFamilies[gap] && gapFamilies[gap].length > 0) {
                    let product = 1;
                    let logProduct = 0;
                    
                    gapFamilies[gap].forEach(p => {
                        const factor = (p * p) / (p * p - 1);
                        product *= factor;
                        logProduct += Math.log(factor);
                    });
                    
                    gapProducts[gap] = {
                        product: product,
                        logProduct: logProduct,
                        count: gapFamilies[gap].length,
                        primes: gapFamilies[gap] // Store ALL primes
                    };
                }
            });
            
            // Calculate progressive convergence
            const progressiveProducts = [];
            let cumulative = 1;
            let cumulativeLog = 0;
            
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    cumulative *= gapProducts[gap].product;
                    cumulativeLog += gapProducts[gap].logProduct;
                    
                    progressiveProducts.push({
                        gap: gap,
                        value: cumulative,
                        logValue: cumulativeLog,
                        error: Math.abs(cumulative - targetZeta2),
                        relativeError: Math.abs(cumulative - targetZeta2) / targetZeta2
                    });
                }
            });
            
            // Include the last prime's contribution (it has no gap after it, but still contributes to ζ(2))
            if (primes.length > 0) {
                const lastPrime = primes[primes.length - 1];
                const lastFactor = (lastPrime * lastPrime) / (lastPrime * lastPrime - 1);
                cumulative *= lastFactor;
                cumulativeLog += Math.log(lastFactor);
            }
            
            // Calculate total primes actually included in analysis (those with gaps in filtered range)
            const totalPrimesInAnalysis = evenGaps.reduce((sum, gap) => {
                return sum + (gapProducts[gap]?.count || 0);
            }, 0);
            
            // Calculate percentage contributions
            const percentageContributions = {};
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    const contribution = Math.log(gapProducts[gap].product) / Math.log(targetZeta2);
                    percentageContributions[gap] = contribution * 100;
                }
            });
            
            return {
                primes: primes,
                totalPrimes: totalPrimesInAnalysis,  // Only count primes with gaps in filtered range
                allPrimesFound: primes.length,        // Total primes found in range
                maxPrime: maxPrime,
                maxGapFound: evenGaps.length > 0 ? Math.max(...evenGaps) : 0,  // Largest gap in filtered range
                targetZeta2: targetZeta2,
                gapFamilies: gapFamilies,
                gapProducts: gapProducts,
                evenGaps: evenGaps,
                progressiveProducts: progressiveProducts,
                percentageContributions: percentageContributions,
                finalProduct: cumulative,
                finalError: Math.abs(cumulative - targetZeta2),
                finalRelativeError: Math.abs(cumulative - targetZeta2) / targetZeta2,
                s: 2  // This function always uses s=2
            };
        }
        
        // Global variable to store uploaded/fetched primes
        let customPrimeList = null;
        
        // Handle file upload
        function handlePrimeFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.style.display = 'block';
            statusDiv.querySelector('span').textContent = 'Loading file...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    
                    // Parse primes from file (handle CSV or one-per-line)
                    let primes = [];
                    if (content.includes(',')) {
                        // CSV format
                        primes = content.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n) && n > 0);
                    } else {
                        // One per line
                        primes = content.split(/\r?\n/).map(s => parseInt(s.trim())).filter(n => !isNaN(n) && n > 0);
                    }
                    
                    // Sort and deduplicate
                    primes = Array.from(new Set(primes)).sort((a, b) => a - b);
                    
                    if (primes.length === 0) {
                        statusDiv.querySelector('span').textContent = 'Error: No valid primes found in file';
                        statusDiv.style.background = 'rgba(255, 100, 100, 0.1)';
                        return;
                    }
                    
                    customPrimeList = primes;
                    statusDiv.querySelector('span').textContent = `✓ Loaded ${primes.length.toLocaleString()} primes (max: ${primes[primes.length-1].toLocaleString()})`;
                    statusDiv.style.background = 'rgba(100, 255, 100, 0.1)';
                    
                    // Update max prime display
                    document.getElementById('maxPrime').value = primes[primes.length-1];
                    document.getElementById('maxPrimeDisplay').textContent = primes[primes.length-1].toLocaleString();
                    
                } catch (error) {
                    statusDiv.querySelector('span').textContent = `Error: ${error.message}`;
                    statusDiv.style.background = 'rgba(255, 100, 100, 0.1)';
                }
            };
            reader.readAsText(file);
        }
        
        // Fetch primes from OEIS
        async function fetchFromOEIS() {
            const count = parseInt(document.getElementById('oeisCount').value);
            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.style.display = 'block';
            statusDiv.querySelector('span').textContent = `Fetching ${count.toLocaleString()} primes from OEIS...`;
            
            try {
                // OEIS API endpoint for A000040 (prime numbers)
                // Note: Network access is disabled in this environment
                const url = `https://oeis.org/A000040/b000040.txt`;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error('Network access is disabled. Please download the file manually from OEIS and upload it instead.');
                
                const text = await response.text();
                
                // Parse OEIS b-file format: "n prime_n"
                const lines = text.split('\n');
                const primes = [];
                
                for (const line of lines) {
                    if (line.startsWith('#') || line.trim() === '') continue;
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        const prime = parseInt(parts[1]);
                        if (!isNaN(prime)) {
                            primes.push(prime);
                            if (primes.length >= count) break;
                        }
                    }
                }
                
                if (primes.length === 0) {
                    throw new Error('No primes found in OEIS response');
                }
                
                customPrimeList = primes;
                statusDiv.querySelector('span').textContent = `✓ Fetched ${primes.length.toLocaleString()} primes from OEIS (max: ${primes[primes.length-1].toLocaleString()})`;
                statusDiv.style.background = 'rgba(100, 255, 100, 0.1)';
                
                // Update max prime display
                document.getElementById('maxPrime').value = primes[primes.length-1];
                document.getElementById('maxPrimeDisplay').textContent = primes[primes.length-1].toLocaleString();
                
            } catch (error) {
                statusDiv.querySelector('span').textContent = `Network access disabled. Please: (1) Visit https://oeis.org/A000040/b000040.txt, (2) Download the file, (3) Upload it using the file input above.`;
                statusDiv.style.background = 'rgba(255, 215, 0, 0.2)';
                statusDiv.style.borderLeft = '4px solid #ffd700';
                console.error('OEIS fetch error:', error);
            }
        }
        
        // Clear custom prime list
        function clearCustomPrimes() {
            customPrimeList = null;
            document.getElementById('uploadStatus').style.display = 'none';
            document.getElementById('primeFileUpload').value = '';
            document.getElementById('maxPrime').value = 10000000;
            document.getElementById('maxPrimeDisplay').textContent = '10,000,000';
        }
        
        // Update displays
        function updateDisplays() {
            document.getElementById('maxPrimeDisplay').textContent = 
                parseInt(document.getElementById('maxPrime').value).toLocaleString();
            document.getElementById('animStartDisplay').textContent = 
                parseInt(document.getElementById('animStart').value).toLocaleString();
            document.getElementById('animEndDisplay').textContent = 
                parseInt(document.getElementById('animEnd').value).toLocaleString();
        }
        
        // Run analysis
        function runAnalysis() {
            const maxPrime = parseInt(document.getElementById('maxPrime').value);
            const s = parseFloat(document.getElementById('zetaS').value);
            const comparisonMode = document.getElementById('enableComparison').checked;
            const gapRangeFilter = getGapRangeFilter();
            
            // Validate gap range if in manual mode
            if (gapRangeFilter.mode === 'manual' && !validateGapRange()) {
                alert('Please fix the gap range errors before running analysis.');
                return;
            }
            
            const statusBar = document.getElementById('statusBar');
            statusBar.style.display = 'block';
            statusBar.className = 'status-bar computing';
            
            if (comparisonMode) {
                statusBar.textContent = `Computing comparison across s = [1.5, 2, 3, 4, 5, 10]...`;
            } else {
                const gapInfo = gapRangeFilter.mode === 'auto' ? 'all gaps' : `gaps ${gapRangeFilter.min}-${gapRangeFilter.max}`;
                statusBar.textContent = `Computing ζ(${s.toFixed(2)}) for primes up to ${maxPrime.toLocaleString()} (${gapInfo})...`;
            }
            
            // Use setTimeout to allow UI update
            setTimeout(() => {
                try {
                    // Progress callback for sieve computation
                    const progressCallback = (current, max, primesFound) => {
                        const percent = Math.min(100, (current / max) * 100).toFixed(1);
                        const statusBar = document.getElementById('statusBar');
                        statusBar.textContent = `Computing primes: ${percent}% (${current.toLocaleString()} / ${max.toLocaleString()}, ${primesFound.toLocaleString()} primes found)`;
                    };
                    
                    if (comparisonMode) {
                        // Compute for multiple s values
                        const compData = computeComparisonData(gapRangeFilter);
                        // Use s=2 as primary result for compatibility
                        analysisResults = compData[2];
                        analysisResults.comparisonData = compData;
                        
                        statusBar.className = 'status-bar complete';
                        statusBar.textContent = `Comparison complete: Computed for s = [1.5, 2, 3, 4, 5, 10]`;
                    } else {
                        // Single s analysis
                        analysisResults = computeGapDecompositionWithS(maxPrime, s, gapRangeFilter, progressCallback);
                        
                        const known = getKnownZetaValue(s);
                        const zetaLabel = known ? `ζ(${s}) = ${known.formula}` : `ζ(${s.toFixed(2)})`;
                        const maxGapFound = Math.max(...analysisResults.evenGaps);
                        
                        statusBar.className = 'status-bar complete';
                        const gapInfo = gapRangeFilter.mode === 'auto' ? 'all gaps' : `gaps ${gapRangeFilter.min}-${gapRangeFilter.max}`;
                        statusBar.textContent = `${zetaLabel}: ${((analysisResults.allPrimesFound || analysisResults.totalPrimes) || analysisResults.totalPrimes).toLocaleString()} primes, ${analysisResults.evenGaps.length} gap families (${gapInfo}, max: ${maxGapFound}), error = ${(analysisResults.finalRelativeError * 100).toFixed(8)}%`;
                    }
                    
                    updateStatistics();
                    renderAllCharts();
                    
                    if (comparisonMode) {
                        showComparisonSummary();
                    }
                } catch (error) {
                    statusBar.className = 'status-bar';
                    statusBar.style.color = '#ff6464';
                    statusBar.textContent = `Error: ${error.message}`;
                    console.error(error);
                }
            }, 50);
        }
        
        function showComparisonSummary() {
            if (!analysisResults.comparisonData) return;
            
            console.log("=== Gap Contribution Comparison ===");
            const sValues = [1.5, 2, 3, 4, 5, 10];
            sValues.forEach(s => {
                const data = analysisResults.comparisonData[s];
                const gap1 = data.percentageContributions[1] || 0;
                const gap2 = data.percentageContributions[2] || 0;
                console.log(`s=${s}: Gap 1 = ${gap1.toFixed(1)}%, Gap 2 = ${gap2.toFixed(1)}%`);
            });
        }
        
        // Update statistics panel
        function updateStatistics() {
            if (!analysisResults) return;
            
            const statsPanel = document.getElementById('statsPanel');
            const statsGrid = document.getElementById('statsGrid');
            statsPanel.style.display = 'block';
            
            // Calculate π using the formula: π = √6 × √(∏P_g)
            const productRoot = Math.sqrt(analysisResults.finalProduct);
            const calculatedPi = Math.sqrt(6) * productRoot;
            const actualPi = Math.PI;
            const piError = Math.abs(calculatedPi - actualPi);
            const piRelError = (piError / actualPi) * 100;
            
            // Calculate additional stats
            // Use gapProducts for exact forward-gap counts (avoids overcounting cousins/sexy primes)
            const primes = analysisResults.primes;
            const twinCount   = analysisResults.gapProducts[2]?.count || 0;
            const cousinCount = analysisResults.gapProducts[4]?.count || 0;
            const sexyCount   = analysisResults.gapProducts[6]?.count || 0;
            
            // Find most common gap
            const gapCounts = {};
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i+1] - primes[i];
                gapCounts[gap] = (gapCounts[gap] || 0) + 1;
            }
            const mostCommonGap = Object.entries(gapCounts)
                .sort((a, b) => b[1] - a[1])[0];
            
            const s = analysisResults.s || 2;
            const stats = [
                { label: 'Total Primes', value: ((analysisResults.allPrimesFound || analysisResults.totalPrimes) || analysisResults.totalPrimes || primes.length).toLocaleString() },
                { label: 'Maximum Prime', value: analysisResults.maxPrime.toLocaleString() },
                { label: 'Gap Families', value: analysisResults.evenGaps.length },
                { label: 'Twin Primes', value: twinCount, info: 'Pairs (p, p+2)' },
                { label: 'Cousin Primes', value: cousinCount, info: 'Pairs (p, p+4)' },
                { label: 'Sexy Primes', value: sexyCount, info: 'Pairs (p, p+6)' },
                { label: 'Most Common Gap', value: `${mostCommonGap[0]} (${mostCommonGap[1]}×)` },
                { label: 'Largest Gap', value: Math.max(...analysisResults.evenGaps) },
                { label: `Target ζ(${s})`, value: analysisResults.targetZeta2.toFixed(12) },
                { label: 'Computed Product', value: analysisResults.finalProduct.toFixed(12) },
                { label: 'Absolute Error', value: analysisResults.finalError.toExponential(6) },
                { label: 'Relative Error', value: (analysisResults.finalRelativeError * 100).toFixed(10) + '%' },
                { label: 'Calculated π', value: calculatedPi.toFixed(12), formula: 'π = √6 × √(∏P_g)' },
                { label: 'Actual π', value: actualPi.toFixed(12) },
                { label: 'π Error', value: piError.toExponential(6) },
                { label: 'π Rel. Error', value: piRelError.toFixed(10) + '%' }
            ];
            
            statsGrid.innerHTML = stats.map(stat => `
                <div class="stat-card">
                    <div class="stat-label">${stat.label}${stat.info ? '<br><span style="font-size: 0.65rem; color: #666;">' + stat.info + '</span>' : ''}${stat.formula ? '<br><span style="font-size: 0.65rem; color: #666;">' + stat.formula + '</span>' : ''}</div>
                    <div class="stat-value">${stat.value}</div>
                </div>
            `).join('');
        }
        
        // Render classical sequential view
        function renderClassicalView() {
            if (!analysisResults) return;
            
            const tbody = document.getElementById('classicalTableBody');
            const primes = analysisResults.primes;
            const s = analysisResults.s || 2;
            
            // Gap color mapping - matching the legend
            const gapColors = {
                2: '#e74c3c',  // Twin - red
                4: '#f39c12',  // Cousin - orange
                6: '#9b59b6',  // Sexy - purple
            };
            
            let html = '';
            let cumulative = 1;
            
            // Limit display to first 10,000 primes for performance
            const displayLimit = Math.min(primes.length - 1, 10000);
            
            for (let i = 0; i < displayLimit; i++) {
                const p = primes[i];
                const gap = i < primes.length - 1 ? primes[i + 1] - p : 0;
                const ps = Math.pow(p, s);
                const factor = ps / (ps - 1);
                cumulative *= factor;
                
                const gapColor = gapColors[gap] || '#95a5a6'; // Default gray for other gaps
                const gapLabel = gap === 2 ? 'Twin' : gap === 4 ? 'Cousin' : gap === 6 ? 'Sexy' : gap;
                
                // Alternating row colors for better readability
                const rowBg = i % 2 === 0 ? 'rgba(255, 255, 255, 0.02)' : 'transparent';
                
                html += `
                    <tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.03); cursor: pointer; transition: all 0.2s; background: ${rowBg};" 
                        onmouseover="this.style.background='rgba(102, 126, 234, 0.15)'; this.style.transform='translateX(4px)'" 
                        onmouseout="this.style.background='${rowBg}'; this.style.transform='translateX(0)'"
                        onclick="showGapDetails(${gap})">
                        <td style="padding: 12px 10px; color: #888; font-size: 0.9rem;">${(i + 1).toLocaleString()}</td>
                        <td style="padding: 12px 10px; text-align: right; font-weight: bold; color: #fff; font-size: 1rem;">${p.toLocaleString()}</td>
                        <td style="padding: 12px 10px; text-align: center;">
                            <span style="display: inline-block; padding: 6px 14px; background: ${gapColor}; color: #000; border-radius: 6px; font-weight: bold; font-size: 0.85rem; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                                ${gapLabel}
                            </span>
                        </td>
                        <td style="padding: 12px 10px; text-align: right; color: #4ecdc4; font-family: 'Courier New', monospace;">${factor.toFixed(10)}</td>
                        <td style="padding: 12px 10px; text-align: right; color: #ffd700; font-family: 'Courier New', monospace; font-weight: bold;">${cumulative.toFixed(10)}</td>
                    </tr>
                `;
            }
            
            if (displayLimit < primes.length - 1) {
                html += `
                    <tr style="background: rgba(255, 215, 0, 0.05);">
                        <td colspan="5" style="padding: 20px; text-align: center; color: #ffd700; font-style: italic; font-size: 0.95rem;">
                            📊 Showing first ${displayLimit.toLocaleString()} primes for performance. 
                            ${(primes.length - 1 - displayLimit).toLocaleString()} additional primes not displayed.
                        </td>
                    </tr>
                `;
            }
            
            tbody.innerHTML = html;
        }
        
        // Find k-tuple constellation pairs
        // Each prime can appear in multiple pairs
        function classifyKtuples(primes, s) {
            const ktuples = {
                twins: [],      // (p, p+2) pairs
                cousins: [],    // (p, p+4) pairs
                sexy: [],       // (p, p+6) pairs
                triplets: [],   // not used
                quadruplets: [], // not used
                isolated: []    // only prime 2
            };
            
            const primeSet = new Set(primes);
            
            // Find all twin pairs (p, p+2)
            for (let i = 0; i < primes.length; i++) {
                const p = primes[i];
                if (primeSet.has(p + 2)) {
                    ktuples.twins.push([p, p + 2]);
                }
            }
            
            // Find all cousin pairs (p, p+4)
            for (let i = 0; i < primes.length; i++) {
                const p = primes[i];
                if (primeSet.has(p + 4)) {
                    ktuples.cousins.push([p, p + 4]);
                }
            }
            
            // Find all sexy pairs (p, p+6)
            for (let i = 0; i < primes.length; i++) {
                const p = primes[i];
                if (primeSet.has(p + 6)) {
                    ktuples.sexy.push([p, p + 6]);
                }
            }
            
            // Isolated: only prime 2 (and last prime in range)
            ktuples.isolated.push(2);
            if (primes.length > 0 && primes[primes.length - 1] > 2) {
                ktuples.isolated.push(primes[primes.length - 1]);
            }
            
            const totalClassified = primes.length; // All primes accounted for
            const totalPrimes = primes.length;
            
            // Calculate products for each category
            // For pairs: flatten and get unique primes to avoid double-counting
            const calculateProduct = (pairsList) => {
                let product = 1;
                const uniquePrimes = new Set();
                
                // Flatten pairs/tuples and collect unique primes
                pairsList.forEach(item => {
                    if (Array.isArray(item)) {
                        item.forEach(p => uniquePrimes.add(p));
                    } else {
                        uniquePrimes.add(item);
                    }
                });
                
                // Calculate Euler product over unique primes
                uniquePrimes.forEach(p => {
                    const ps = Math.pow(p, s);
                    product *= ps / (ps - 1);
                });
                return product;
            };
            
            return {
                twins: { primes: ktuples.twins, product: calculateProduct(ktuples.twins) },
                cousins: { primes: ktuples.cousins, product: calculateProduct(ktuples.cousins) },
                sexy: { primes: ktuples.sexy, product: calculateProduct(ktuples.sexy) },
                triplets: { primes: ktuples.triplets, product: calculateProduct(ktuples.triplets) },
                quadruplets: { primes: ktuples.quadruplets, product: calculateProduct(ktuples.quadruplets) },
                isolated: { primes: ktuples.isolated, product: calculateProduct(ktuples.isolated) },
                stats: { totalPrimes: totalPrimes, totalClassified: totalClassified, verified: totalClassified === totalPrimes }
            };
        }
        
        // Render k-tuple classification view
        function renderKtupleView() {
            if (!analysisResults) return;
            
            const { primes, s } = analysisResults;
            const ktuples = classifyKtuples(primes, s);
            const tbody = document.getElementById('ktupleTableBody');
            
            const categories = [
                { 
                    id: 'twins',
                    name: 'Twin Primes (p, p+2)', 
                    data: ktuples.twins,
                    color: '#e74c3c',
                    description: 'Consecutive primes differing by 2'
                },
                { 
                    id: 'cousins',
                    name: 'Cousin Primes (p, p+4)', 
                    data: ktuples.cousins,
                    color: '#f39c12',
                    description: 'Primes differing by 4'
                },
                { 
                    id: 'sexy',
                    name: 'Sexy Primes (p, p+6)', 
                    data: ktuples.sexy,
                    color: '#9b59b6',
                    description: 'Primes differing by 6'
                },
                { 
                    id: 'triplets',
                    name: 'Prime Triplets', 
                    data: ktuples.triplets,
                    color: '#3498db',
                    description: 'Three consecutive primes in constellation'
                },
                { 
                    id: 'quadruplets',
                    name: 'Prime Quadruplets (p, p+2, p+6, p+8)', 
                    data: ktuples.quadruplets,
                    color: '#1abc9c',
                    description: 'Four primes in arithmetic pattern'
                },
                { 
                    id: 'isolated',
                    name: 'Isolated Primes', 
                    data: ktuples.isolated,
                    color: '#95a5a6',
                    description: 'Not part of any close constellation'
                }
            ];
            
            // Store globally for click handlers
            window.ktupleCategories = {};
            categories.forEach(cat => {
                window.ktupleCategories[cat.id] = {
                    name: cat.name,
                    primes: cat.data.primes,
                    product: cat.data.product,
                    color: cat.color
                };
            });
            
            let html = '';
            // Total product should be the Euler product over ALL primes (already calculated)
            const totalProduct = analysisResults.finalProduct;
            
            categories.forEach(cat => {
                const count = cat.data.primes.length;
                const product = cat.data.product;
                
                let example = '';
                if (count > 0) {
                    const first = cat.data.primes[0];
                    example = Array.isArray(first) ? first.join(', ') : first;
                }
                
                const contribution = product > 1 ? ((product - 1) / product * 100).toFixed(4) + '%' : '0%';
                
                html += `
                    <tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.05); cursor: pointer;" 
                        onmouseover="this.style.background='rgba(255, 107, 129, 0.1)'" 
                        onmouseout="this.style.background=''"
                        data-category="${cat.id}">
                        <td style="padding: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 12px; height: 12px; background: ${cat.color}; border-radius: 2px;"></div>
                                <strong>${cat.name}</strong>
                            </div>
                            <div style="font-size: 0.8rem; color: #888; margin-top: 4px; margin-left: 20px;">
                                ${cat.description}
                            </div>
                        </td>
                        <td style="padding: 12px; text-align: center; font-size: 1.2rem; font-weight: bold; color: ${cat.color};">
                            ${count.toLocaleString()}
                        </td>
                        <td style="padding: 12px; color: #aaa; font-family: 'Courier New', monospace;">
                            ${example}${count > 1 ? ', ...' : ''}
                        </td>
                        <td style="padding: 12px; text-align: right; color: #4ecdc4; font-family: 'Courier New', monospace;">
                            ${product.toFixed(12)}
                        </td>
                        <td style="padding: 12px; text-align: right; color: #ffd700;">
                            ${contribution}
                        </td>
                    </tr>
                `;
            });
            
            // Add total row
            html += `
                <tr style="border-top: 2px solid #ff6b81; background: rgba(255, 107, 129, 0.1); font-weight: bold;">
                    <td style="padding: 12px; color: #ff6b81;">TOTAL PRODUCT</td>
                    <td style="padding: 12px; text-align: center; color: #ff6b81;">-</td>
                    <td style="padding: 12px;">All constellations combined</td>
                    <td style="padding: 12px; text-align: right; color: #4ecdc4; font-family: 'Courier New', monospace;">
                        ${totalProduct.toFixed(12)}
                    </td>
                    <td style="padding: 12px; text-align: right; color: #ffd700;">
                        ζ(2) ≈ ${(Math.PI * Math.PI / 6).toFixed(12)}
                    </td>
                </tr>
            `;
            
            tbody.innerHTML = html;
            
            // Add event delegation for row clicks
            tbody.onclick = function(e) {
                const row = e.target.closest('tr[data-category]');
                if (row) {
                    const catId = row.getAttribute('data-category');
                    showKtupleDetails(catId);
                }
            };
            
            // Display verification stats
            const verificationDiv = document.getElementById('ktupleVerification');
            if (verificationDiv && ktuples.stats) {
                const verified = ktuples.stats.verified;
                const verifyIcon = verified ? '✓' : '✗';
                const verifyColor = verified ? '#4ecdc4' : '#ff6b81';
                verificationDiv.innerHTML = `
                    <strong style="color: ${verifyColor};">${verifyIcon} Classification Verification:</strong> 
                    ${ktuples.stats.totalClassified.toLocaleString()} of ${ktuples.stats.totalPrimes.toLocaleString()} primes classified
                    ${verified ? '(All primes accounted for)' : '(WARNING: Missing primes!)'}
                `;
            }
        }
        
        // Show detailed stats for a k-tuple category
        function showKtupleDetails(catId) {
            const cat = window.ktupleCategories[catId];
            if (!cat) return;
            
            const primes = cat.primes;
            const product = cat.product;
            const catName = cat.name;
            const color = cat.color;
            const count = primes.length; // number of pairs
            
            // Build grid of pairs/tuples
            let pairsList = '';
            const displayLimit = Math.min(count, 50);
            
            pairsList += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 8px;">';
            
            for (let i = 0; i < displayLimit; i++) {
                const item = primes[i];
                const display = Array.isArray(item) ? '(' + item.join(', ') + ')' : item;
                pairsList += '<div style="padding: 8px; background: rgba(255, 255, 255, 0.05); border-radius: 4px; color: #e0e0e0; font-family: \'Courier New\', monospace; text-align: center; border: 1px solid ' + color + '40;">' + display + '</div>';
            }
            
            pairsList += '</div>';
            
            if (count > displayLimit) {
                pairsList += '<div style="padding: 8px; color: #888; font-style: italic; text-align: center; margin-top: 8px;">... and ' + (count - displayLimit) + ' more</div>';
            }
            
            const contributionPct = product > 1 ? ((product - 1) / product * 100).toFixed(4) : '0';
            
            const modalHTML = 
                '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 10000; display: flex; align-items: center; justify-content: center;" onclick="this.remove()">' +
                    '<div style="background: #1a1a2a; border-radius: 12px; padding: 32px; max-width: 700px; max-height: 80vh; overflow-y: auto; border: 2px solid ' + color + ';" onclick="event.stopPropagation()">' +
                        '<div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">' +
                            '<div style="width: 20px; height: 20px; background: ' + color + '; border-radius: 4px;"></div>' +
                            '<h2 style="color: ' + color + '; margin: 0;">' + catName + '</h2>' +
                        '</div>' +
                        '<div style="background: rgba(255, 255, 255, 0.05); padding: 16px; border-radius: 8px; margin-bottom: 20px;">' +
                            '<div style="color: #ffd700; font-size: 1.2rem; margin-bottom: 8px;">' +
                                '<strong>' + count.toLocaleString() + '</strong> ' + (catId === 'isolated' ? 'primes' : 'pairs') +
                            '</div>' +
                            '<div style="color: #4ecdc4; font-size: 1.1rem; font-family: \'Courier New\', monospace;">Product: <strong>' + product.toFixed(12) + '</strong></div>' +
                            '<div style="color: #ccc; font-size: 0.9rem; margin-top: 8px;">Contribution: ' + contributionPct + '%</div>' +
                        '</div>' +
                        '<div style="margin-bottom: 16px;"><strong style="color: #ff6b81; font-size: 1.1rem;">' + (catId === 'isolated' ? 'Isolated primes:' : 'Prime pairs:') + '</strong></div>' +
                        '<div style="max-height: 300px; overflow-y: auto; background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 6px;">' +
                            pairsList +
                        '</div>' +
                        '<div style="text-align: center; margin-top: 24px;">' +
                            '<button onclick="this.closest(\'div[onclick*=remove]\').remove()" style="padding: 10px 24px; background: ' + color + '; color: #000; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 1rem;">Close</button>' +
                        '</div>' +
                    '</div>' +
                '</div>';
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }
        
        // Screenshot k-tuple view
        function screenshotKtupleView() {
            const tableElement = document.getElementById('ktupleTableWrapper');
            const verificationElement = document.getElementById('ktupleVerification');
            
            if (!tableElement) {
                alert('k-Tuple view not found. Please run analysis first.');
                return;
            }
            
            // Create a temporary container with just the table and verification
            const tempContainer = document.createElement('div');
            tempContainer.style.cssText = 'background: #0a0a0f; padding: 20px; position: absolute; left: -9999px;';
            
            const titleDiv = document.createElement('div');
            titleDiv.style.cssText = 'color: #ffd700; font-size: 1.8rem; font-weight: bold; margin-bottom: 20px; text-align: center;';
            titleDiv.textContent = 'Prime k-Tuple (Constellation) Classification';
            
            tempContainer.appendChild(titleDiv);
            tempContainer.appendChild(tableElement.cloneNode(true));
            if (verificationElement) {
                tempContainer.appendChild(verificationElement.cloneNode(true));
            }
            
            document.body.appendChild(tempContainer);
            
            html2canvas(tempContainer, {
                scale: 2,
                backgroundColor: '#0a0a0f',
                logging: false
            }).then(function(canvas) {
                document.body.removeChild(tempContainer);
                const link = document.createElement('a');
                link.download = 'ktuple_classification.png';
                link.href = canvas.toDataURL();
                link.click();
            });
        }
        
        // Toggle between gap and classical views
        function toggleViewMode() {
            // Only gap view mode exists now
            const chartsContainer = document.querySelectorAll('.charts-container')[2]; // Third charts-container (gap charts)
            chartsContainer.style.display = 'grid';
        }
        
        // Render all charts
        function renderAllCharts() {
            if (!analysisResults) return;
            
            if (document.getElementById('showConvergence').checked) {
                renderConvergenceChart();
            }
            if (document.getElementById('showGapContributions').checked) {
                renderGapContributionsChart();
            }
            if (document.getElementById('showGapDistribution').checked) {
                renderGapDistributionChart();
            }
            if (document.getElementById('showPercentageContrib').checked) {
                renderPercentageChart();
            }
            if (document.getElementById('showErrorAnalysis').checked) {
                renderErrorChart();
            }
            if (document.getElementById('showLogScale').checked) {
                renderLogScaleChart();
            }
            if (document.getElementById('showGapRatio').checked) {
                renderGapRatioChart();
            }
            
            // Render decimal convergence analysis
            if (document.getElementById('showDecimalConvergence')?.checked) {
                updateDecimalAnalysis();
            }
            
            // Render comparison chart if in comparison mode
            if (analysisResults.comparisonData) {
                renderComparisonChartActual();
            }
            
            // Update statistical tables
            updateStatsTables();
        }
        
        // Chart rendering functions

        // CLICK-TO-HIGHLIGHT FUNCTIONALITY
        let highlightedGap = null;
        
        function addTableClickHandlers() {
            // Add click handlers to all stat tables after they're rendered
            const tables = [
                'convergenceTableContent',
                'gapContribTableContent', 
                'gapDistTableContent',
                'percentageTableContent',
                'errorTableContent',
                'logScaleTableContent',
                'stepByStepTableContent'
            ];
            
            tables.forEach(tableId => {
                const table = document.getElementById(tableId);
                if (!table) return;
                
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach((row, index) => {
                    row.style.cursor = 'pointer';
                    row.addEventListener('click', function() {
                        // Remove previous highlights
                        document.querySelectorAll('.stats-table tr.highlighted').forEach(r => {
                            r.classList.remove('highlighted');
                        });
                        
                        // Add highlight to clicked row
                        this.classList.add('highlighted');
                        
                        // Get gap value from the row
                        // For step-by-step table: cells[1] is the gap column
                        // For other tables: cells[0] might be the gap
                        let gapValue;
                        
                        // Try to find gap value - check if second cell looks like a gap (small number)
                        if (this.cells[1] && this.cells[1].textContent) {
                            const secondColValue = parseInt(this.cells[1].textContent);
                            if (!isNaN(secondColValue) && secondColValue < 1000) {
                                // Likely a gap value (gaps are typically < 1000)
                                gapValue = secondColValue;
                            }
                        }
                        
                        // If not found in second column, try first
                        if (gapValue === undefined && this.cells[0]) {
                            const firstColValue = parseInt(this.cells[0].textContent);
                            if (!isNaN(firstColValue) && firstColValue < 1000) {
                                gapValue = firstColValue;
                            }
                        }
                        
                        if (gapValue !== undefined && !isNaN(gapValue)) {
                            highlightedGap = gapValue;
                            highlightGapOnCharts(gapValue);
                            
                            // Show detailed popup
                            showGapDetails(gapValue);
                        }
                    });
                });
            });
        }
        
        function highlightGapOnCharts(gap) {
            // Re-render charts with highlight
            if (document.getElementById('showGapContributions').checked) {
                renderGapContributionsChart(gap);
            }
            if (document.getElementById('showGapDistribution').checked) {
                renderGapDistributionChart(gap);
            }
            if (document.getElementById('showPercentageContrib').checked) {
                renderPercentageChart(gap);
            }
        }
        function renderConvergenceChart() {
            const canvas = document.getElementById('convergenceChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            // Clear
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const data = getFilteredProgressiveProducts();
            if (data.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data in selected gap range', w/2, h/2);
                return;
            }
            
            const target = analysisResults.targetZeta2;
            
            // Margins
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Scales
            const maxY = Math.max(target * 1.1, ...data.map(d => d.value));
            const minY = Math.min(0.8, ...data.map(d => d.value));
            const xScale = chartW / (data.length - 1);
            const yScale = chartH / (maxY - minY);
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxY - (maxY - minY) * (i / 10);
                ctx.fillStyle = '#888';
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(4), margin.left - 20, y + 12);
            }
            
            // Target line
            const targetY = margin.top + chartH - (target - minY) * yScale;
            ctx.strokeStyle = '#ff6464';
            ctx.lineWidth = 4;
            ctx.setLineDash([20, 20]);
            ctx.beginPath();
            ctx.moveTo(margin.left, targetY);
            ctx.lineTo(w - margin.right, targetY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#ff6464';
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`ζ(2) = π²/6 = ${target.toFixed(8)}`, margin.left + 40, targetY - 30);
            
            // Convergence line
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 6;
            ctx.beginPath();
            data.forEach((point, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - (point.value - minY) * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Points
            ctx.fillStyle = '#ffd700';
            data.forEach((point, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - (point.value - minY) * yScale;
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // X-axis labels
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 28px monospace';
            ctx.textAlign = 'center';
            data.forEach((point, i) => {
                if (i % Math.max(1, Math.floor(data.length / 15)) === 0) {
                    const x = margin.left + i * xScale;
                    ctx.fillText(`Gap ${point.gap}`, x, h - margin.bottom + 60);
                }
            });
            
            // Axis labels
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Progressive Product Convergence to ζ(2)', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Product Value', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Family', w / 2, h - 40);
        }
        
        function renderGapContributionsChart(highlightGap) {
            const canvas = document.getElementById('gapContribChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data in selected gap range', w/2, h/2);
                return;
            }
            
            const products = gaps.map(g => analysisResults.gapProducts[g]);
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const barWidth = chartW / gaps.length;
            const maxProduct = Math.max(...products.map(p => p.product));
            const yScale = chartH / maxProduct;
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxProduct - (maxProduct * (i / 10));
                ctx.fillStyle = '#888';
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(6), margin.left - 20, y + 12);
            }
            
            // Bars
            products.forEach((prod, i) => {
                const gap = gaps[i];
                const x = margin.left + i * barWidth;
                const barH = prod.product * yScale;
                const y = margin.top + chartH - barH;
                
                const isHighlighted = highlightGap && gap === highlightGap;
                
                const gradient = ctx.createLinearGradient(x, y, x, y + barH);
                if (isHighlighted) {
                    gradient.addColorStop(0, '#ff0000');
                    gradient.addColorStop(1, '#cc0000');
                } else {
                    gradient.addColorStop(0, '#ffd700');
                    gradient.addColorStop(1, '#ffaa00');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                ctx.strokeStyle = isHighlighted ? '#ff0000' : '#ffaa00';
                ctx.lineWidth = isHighlighted ? 8 : 3;
                ctx.strokeRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
            });
            
            // Labels
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            gaps.forEach((gap, i) => {
                const x = margin.left + i * barWidth + barWidth / 2;
                const isHighlighted = highlightGap && gap === highlightGap;
                ctx.fillStyle = isHighlighted ? '#ff0000' : '#aaa';
                ctx.font = isHighlighted ? 'bold 32px monospace' : 'bold 24px monospace';
                ctx.fillText(`${gap}`, x, h - margin.bottom + 50);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Individual Gap Family Products P_g', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Product P_g', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Size', w / 2, h - 40);
        }
        
        function renderGapDistributionChart(highlightGap) {
            const canvas = document.getElementById('gapDistChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = '#888';
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data in selected gap range', w/2, h/2);
                return;
            }
            
            const counts = gaps.map(g => analysisResults.gapProducts[g].count);
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const barWidth = chartW / gaps.length;
            const maxCount = Math.max(...counts);
            const yScale = chartH / maxCount;
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxCount - (maxCount * (i / 10));
                ctx.fillStyle = '#888';
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(Math.round(value).toLocaleString(), margin.left - 20, y + 12);
            }
            
            // Bars
            counts.forEach((count, i) => {
                const gap = gaps[i];
                const x = margin.left + i * barWidth;
                const barH = count * yScale;
                const y = margin.top + chartH - barH;
                
                const isHighlighted = highlightGap && gap === highlightGap;
                
                const gradient = ctx.createLinearGradient(x, y, x, y + barH);
                if (isHighlighted) {
                    gradient.addColorStop(0, '#ff0000');
                    gradient.addColorStop(1, '#cc0000');
                } else {
                    gradient.addColorStop(0, '#64ff64');
                    gradient.addColorStop(1, '#32aa32');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                ctx.strokeStyle = isHighlighted ? '#ff0000' : '#32aa32';
                ctx.lineWidth = isHighlighted ? 8 : 3;
                ctx.strokeRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
            });
            
            // Labels
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            gaps.forEach((gap, i) => {
                const x = margin.left + i * barWidth + barWidth / 2;
                const isHighlighted = highlightGap && gap === highlightGap;
                ctx.fillStyle = isHighlighted ? '#ff0000' : '#aaa';
                ctx.font = isHighlighted ? 'bold 32px monospace' : 'bold 24px monospace';
                ctx.fillText(`${gap}`, x, h - margin.bottom + 50);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Number of Primes per Gap Family', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Prime Count', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Size', w / 2, h - 40);
        }
        
        function renderPercentageChart(highlightGap) {
            const canvas = document.getElementById('percentageChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const percentages = gaps.map(g => analysisResults.percentageContributions[g]);
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const barWidth = chartW / gaps.length;
            const maxPct = Math.max(...percentages);
            const yScale = chartH / maxPct;
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxPct - (maxPct * (i / 10));
                ctx.fillStyle = '#888';
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(2) + '%', margin.left - 20, y + 12);
            }
            
            // Bars
            percentages.forEach((pct, i) => {
                const gap = gaps[i];
                const x = margin.left + i * barWidth;
                const barH = pct * yScale;
                const y = margin.top + chartH - barH;
                
                const isHighlighted = highlightGap && gap === highlightGap;
                
                const gradient = ctx.createLinearGradient(x, y, x, y + barH);
                if (isHighlighted) {
                    gradient.addColorStop(0, '#ff0000');
                    gradient.addColorStop(1, '#cc0000');
                } else {
                    gradient.addColorStop(0, '#ff6464');
                    gradient.addColorStop(1, '#aa3232');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                ctx.strokeStyle = isHighlighted ? '#ff0000' : '#aa3232';
                ctx.lineWidth = isHighlighted ? 8 : 3;
                ctx.strokeRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
            });
            
            // Labels
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            gaps.forEach((gap, i) => {
                const x = margin.left + i * barWidth + barWidth / 2;
                const isHighlighted = highlightGap && gap === highlightGap;
                ctx.fillStyle = isHighlighted ? '#ff0000' : '#aaa';
                ctx.font = isHighlighted ? 'bold 32px monospace' : 'bold 24px monospace';
                ctx.fillText(`${gap}`, x, h - margin.bottom + 50);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Percentage Contribution to log(ζ(2))', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Contribution %', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Size', w / 2, h - 40);
        }
        
        function renderErrorChart() {
            const canvas = document.getElementById('errorChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const data = analysisResults.progressiveProducts;
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const xScale = chartW / (data.length - 1);
            const errors = data.map(d => d.relativeError);
            const maxError = Math.max(...errors);
            const minError = Math.min(...errors);
            const yScale = chartH / (maxError - minError);
            
            // Grid (log scale for y-axis)
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const logValue = Math.log10(maxError) - (Math.log10(maxError) - Math.log10(minError)) * (i / 10);
                const value = Math.pow(10, logValue);
                ctx.fillStyle = '#888';
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText((value * 100).toExponential(2) + '%', margin.left - 20, y + 12);
            }
            
            // Error line
            ctx.strokeStyle = '#64ffff';
            ctx.lineWidth = 6;
            ctx.beginPath();
            data.forEach((point, i) => {
                const x = margin.left + i * xScale;
                const logError = Math.log10(point.relativeError);
                const normalizedLog = (logError - Math.log10(minError)) / (Math.log10(maxError) - Math.log10(minError));
                const y = margin.top + chartH * (1 - normalizedLog);
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Points
            ctx.fillStyle = '#64ffff';
            data.forEach((point, i) => {
                const x = margin.left + i * xScale;
                const logError = Math.log10(point.relativeError);
                const normalizedLog = (logError - Math.log10(minError)) / (Math.log10(maxError) - Math.log10(minError));
                const y = margin.top + chartH * (1 - normalizedLog);
                
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Labels
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 28px monospace';
            ctx.textAlign = 'center';
            data.forEach((point, i) => {
                if (i % Math.max(1, Math.floor(data.length / 15)) === 0) {
                    const x = margin.left + i * xScale;
                    ctx.fillText(`Gap ${point.gap}`, x, h - margin.bottom + 60);
                }
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Relative Error vs Target (Log Scale)', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Relative Error', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Family', w / 2, h - 40);
        }
        
        function renderLogScaleChart() {
            const canvas = document.getElementById('logScaleChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const logProducts = gaps.map(g => analysisResults.gapProducts[g].logProduct);
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const barWidth = chartW / gaps.length;
            const maxLog = Math.max(...logProducts);
            const minLog = Math.min(0, ...logProducts);
            const yScale = chartH / (maxLog - minLog);
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxLog - (maxLog - minLog) * (i / 10);
                ctx.fillStyle = '#888';
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(4), margin.left - 20, y + 12);
            }
            
            // Bars
            logProducts.forEach((logProd, i) => {
                const x = margin.left + i * barWidth;
                const barH = (logProd - minLog) * yScale;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(x, y, x, y + barH);
                gradient.addColorStop(0, '#aa64ff');
                gradient.addColorStop(1, '#6432aa');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                ctx.strokeStyle = '#6432aa';
                ctx.lineWidth = 3;
                ctx.strokeRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
            });
            
            // Labels
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            gaps.forEach((gap, i) => {
                const x = margin.left + i * barWidth + barWidth / 2;
                ctx.fillText(`${gap}`, x, h - margin.bottom + 50);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Log-Scale Product Growth: log(P_g)', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('log(P_g)', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Size', w / 2, h - 40);
        }
        
        function renderGapRatioChart() {
            const canvas = document.getElementById('gapRatioChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            if (!analysisResults || !analysisResults.gapProducts) {
                ctx.fillStyle = '#888';
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Run analysis first', w/2, h/2);
                return;
            }
            
            const margin = { left: 250, right: 250, top: 120, bottom: 180 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Get key gap counts
            const gap2Count = analysisResults.gapProducts[2]?.count || 0;
            const gap4Count = analysisResults.gapProducts[4]?.count || 0;
            const gap6Count = analysisResults.gapProducts[6]?.count || 0;
            const gap10Count = analysisResults.gapProducts[10]?.count || 0;
            const gap12Count = analysisResults.gapProducts[12]?.count || 0;
            const totalPrimes = analysisResults.allPrimesFound - 1; // Exclude last prime
            
            // Hardy-Littlewood singular series constants per gap
            // S(h) = 2 * C2 * Prod_{odd prime p dividing h} (p-1)/(p-2)
            // Gap 2, 4, 8: S = 2*C2  (no odd prime factors, or p=2 only)
            // Gap 6, 12, 18, 24: S = 4*C2  (factor of 2 from p=3 dividing gap)
            // Gap 10, 20: S = 8/3 * C2  (factor 4/3 from p=5 dividing gap)
            const C2_FULL = 0.6601618158468695; // Full precision twin prime constant
            
            // li2 approximation: better estimate of ∫₂ˣ dt/ln²(t)
            // li2(x) ≈ x/ln²(x) * (1 + 2/ln(x) + 6/ln²(x) + 24/ln³(x))
            function li2(x) {
                const L = Math.log(x);
                return (x / (L * L)) * (1 + 2/L + 6/(L*L) + 24/(L*L*L));
            }
            
            function singularSeries(h) {
                // Compute Prod_{odd prime p | h} (p-1)/(p-2)
                let mult = 1.0;
                for (let p = 3; p <= h; p++) {
                    if (h % p === 0) {
                        let isPrime = true;
                        for (let d = 2; d * d <= p; d++) { if (p % d === 0) { isPrime = false; break; } }
                        if (isPrime) mult *= (p - 1) / (p - 2);
                    }
                }
                return 2 * C2_FULL * mult;
            }
            
            // Hardy-Littlewood predictions using li2 approximation
            const maxPrime = analysisResults.maxPrime;
            const predictedTwins = singularSeries(2) * li2(maxPrime);   // gap 2: S=2*C2
            const predictedCousins = singularSeries(4) * li2(maxPrime); // gap 4: S=2*C2 (same)
            const hlError = Math.abs(gap2Count - predictedTwins);
            const hlErrorPercent = (hlError / gap2Count) * 100;
            
            // Calculate ratios
            const ratio_2_4 = gap4Count > 0 ? gap2Count / gap4Count : 0;
            const ratio_2_6 = gap6Count > 0 ? gap2Count / gap6Count : 0;
            const ratio_4_6 = gap6Count > 0 ? gap4Count / gap6Count : 0;
            
            // Calculate percentages
            const pct2 = (gap2Count / totalPrimes) * 100;
            const pct4 = (gap4Count / totalPrimes) * 100;
            const pct6 = (gap6Count / totalPrimes) * 100;
            const pct10 = (gap10Count / totalPrimes) * 100;
            const pct12 = (gap12Count / totalPrimes) * 100;
            
            // Draw three subcharts: Ratios, Percentages, and HL Error
            const subChartW = chartW / 3 - 40;
            const subChartH = chartH;
            
            // SUBCHART 1: Gap Ratios
            const x1 = margin.left;
            renderRatioSubchart(ctx, x1, margin.top, subChartW, subChartH, ratio_2_4, ratio_2_6, ratio_4_6);
            
            // SUBCHART 2: Gap Percentages
            const x2 = margin.left + subChartW + 60;
            renderPercentageSubchart(ctx, x2, margin.top, subChartW, subChartH, pct2, pct4, pct6, pct10, pct12);
            
            // SUBCHART 3: Hardy-Littlewood Error
            const x3 = margin.left + 2 * (subChartW + 60);
            renderHLErrorSubchart(ctx, x3, margin.top, subChartW, subChartH, gap2Count, predictedTwins, hlErrorPercent);
            
            // Main title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 56px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Ratio Convergence: Twin Prime Conjecture Evidence', w / 2, 70);
            
            // Footer info
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 32px sans-serif';
            ctx.fillText(`Analysis: ${analysisResults.allPrimesFound.toLocaleString()} primes up to ${maxPrime.toLocaleString()}`, w / 2, h - 80);
            
            ctx.font = '28px sans-serif';
            ctx.fillText(`Twin Prime Constant C₂ = 0.6601618158...  |  H-L Predicted (li₂ formula): ${Math.round(predictedTwins).toLocaleString()} twins`, w / 2, h - 40);
        }
        
        function renderRatioSubchart(ctx, x, y, w, h, ratio_2_4, ratio_2_6, ratio_4_6) {
            // Title
            ctx.fillStyle = '#ff4081';
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Count Ratios', x + w/2, y - 40);
            
            // Draw bars for ratios
            const barW = w / 4;
            const maxRatio = Math.max(ratio_2_4, ratio_2_6, ratio_4_6, 1.5);
            const scale = h / maxRatio;
            
            // Horizontal line at ratio = 1.0
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 4;
            ctx.setLineDash([15, 10]);
            const oneY = y + h - scale * 1.0;
            ctx.beginPath();
            ctx.moveTo(x, oneY);
            ctx.lineTo(x + w, oneY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText('Ratio = 1.0', x - 10, oneY + 8);
            
            // Bar 1: Gap 2/Gap 4
            const h1 = ratio_2_4 * scale;
            const y1 = y + h - h1;
            ctx.fillStyle = ratio_2_4 > 0.98 && ratio_2_4 < 1.02 ? '#4caf50' : '#ff6b6b';
            ctx.fillRect(x + barW * 0.5, y1, barW * 0.8, h1);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(x + barW * 0.5, y1, barW * 0.8, h1);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 32px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(ratio_2_4.toFixed(4), x + barW * 0.9, y1 - 15);
            
            ctx.font = 'bold 28px sans-serif';
            ctx.fillText('Gap 2/', x + barW * 0.9, y + h + 40);
            ctx.fillText('Gap 4', x + barW * 0.9, y + h + 75);
            
            // Bar 2: Gap 2/Gap 6
            const h2 = ratio_2_6 * scale;
            const y2 = y + h - h2;
            ctx.fillStyle = '#64b5f6';
            ctx.fillRect(x + barW * 1.7, y2, barW * 0.8, h2);
            ctx.strokeRect(x + barW * 1.7, y2, barW * 0.8, h2);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 32px monospace';
            ctx.fillText(ratio_2_6.toFixed(4), x + barW * 2.1, y2 - 15);
            
            ctx.font = 'bold 28px sans-serif';
            ctx.fillText('Gap 2/', x + barW * 2.1, y + h + 40);
            ctx.fillText('Gap 6', x + barW * 2.1, y + h + 75);
            
            // Bar 3: Gap 4/Gap 6
            const h3 = ratio_4_6 * scale;
            const y3 = y + h - h3;
            ctx.fillStyle = '#ba68c8';
            ctx.fillRect(x + barW * 2.9, y3, barW * 0.8, h3);
            ctx.strokeRect(x + barW * 2.9, y3, barW * 0.8, h3);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 32px monospace';
            ctx.fillText(ratio_4_6.toFixed(4), x + barW * 3.3, y3 - 15);
            
            ctx.font = 'bold 28px sans-serif';
            ctx.fillText('Gap 4/', x + barW * 3.3, y + h + 40);
            ctx.fillText('Gap 6', x + barW * 3.3, y + h + 75);
        }
        
        function renderPercentageSubchart(ctx, x, y, w, h, pct2, pct4, pct6, pct10, pct12) {
            // Title
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('% of Total Primes', x + w/2, y - 40);
            
            const barW = w / 6;
            const maxPct = Math.max(pct2, pct4, pct6, pct10, pct12, 15);
            const scale = h / maxPct;
            
            const gaps = [2, 4, 6, 10, 12];
            const pcts = [pct2, pct4, pct6, pct10, pct12];
            const colors = ['#ff4081', '#64b5f6', '#4caf50', '#ffb74d', '#ba68c8'];
            
            gaps.forEach((gap, i) => {
                const barH = pcts[i] * scale;
                const barY = y + h - barH;
                const barX = x + barW * (i + 0.5);
                
                ctx.fillStyle = colors[i];
                ctx.fillRect(barX, barY, barW * 0.8, barH);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.strokeRect(barX, barY, barW * 0.8, barH);
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 30px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(pcts[i].toFixed(2) + '%', barX + barW * 0.4, barY - 15);
                
                ctx.font = 'bold 32px sans-serif';
                ctx.fillText('Gap ' + gap, barX + barW * 0.4, y + h + 50);
            });
        }
        
        function renderHLErrorSubchart(ctx, x, y, w, h, observed, predicted, errorPct) {
            // Title
            ctx.fillStyle = '#ffb74d';
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Hardy-Littlewood Accuracy', x + w/2, y - 40);
            
            // Draw two bars: Predicted vs Observed
            const barW = w / 3;
            const maxVal = Math.max(observed, predicted);
            const scale = (h * 0.8) / maxVal;
            
            // Predicted bar
            const h1 = predicted * scale;
            const y1 = y + h * 0.9 - h1;
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(x + barW * 0.3, y1, barW * 0.8, h1);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(x + barW * 0.3, y1, barW * 0.8, h1);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(Math.round(predicted).toLocaleString(), x + barW * 0.7, y1 - 15);
            
            ctx.font = 'bold 28px sans-serif';
            ctx.fillText('Predicted', x + barW * 0.7, y + h * 0.9 + 40);
            ctx.fillText('(H-L)', x + barW * 0.7, y + h * 0.9 + 75);
            
            // Observed bar
            const h2 = observed * scale;
            const y2 = y + h * 0.9 - h2;
            ctx.fillStyle = '#4caf50';
            ctx.fillRect(x + barW * 1.6, y2, barW * 0.8, h2);
            ctx.strokeRect(x + barW * 1.6, y2, barW * 0.8, h2);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px monospace';
            ctx.fillText(observed.toLocaleString(), x + barW * 2.0, y2 - 15);
            
            ctx.font = 'bold 28px sans-serif';
            ctx.fillText('Observed', x + barW * 2.0, y + h * 0.9 + 40);
            ctx.fillText('(Actual)', x + barW * 2.0, y + h * 0.9 + 75);
            
            // Error percentage display
            ctx.fillStyle = errorPct < 1.0 ? '#4caf50' : errorPct < 5.0 ? '#ffb74d' : '#ff6b6b';
            ctx.font = 'bold 48px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Error: ' + errorPct.toFixed(3) + '%', x + w/2, y + h * 0.3);
            
            ctx.fillStyle = '#aaa';
            ctx.font = '24px sans-serif';
            const diff = observed - predicted;
            const sign = diff > 0 ? '+' : '';
            ctx.fillText(`Difference: ${sign}${Math.round(diff).toLocaleString()}`, x + w/2, y + h * 0.4);
        }
        
        // Custom Gap Comparison Functions
        function loadGapPreset(presetName) {
            const input = document.getElementById('compareGapsInput');
            
            switch(presetName) {
                case 'twins_cousins':
                    input.value = '2, 4';
                    break;
                case 'small_gaps':
                    input.value = '2, 4, 6, 8, 10';
                    break;
                case 'mod6':
                    input.value = '6, 12, 18, 24, 30, 36, 42, 48';
                    break;
                case 'mod6_nearby':
                    input.value = '10, 12, 14, 16, 18, 20, 22, 24';
                    break;
                case 'powers_of_2':
                    input.value = '2, 4, 8, 16, 32';
                    break;
                case 'clear':
                    input.value = '';
                    break;
            }
        }
        
        function renderCustomGapComparison() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            // Parse comma-separated gaps
            const input = document.getElementById('compareGapsInput').value;
            const selectedGaps = input.split(',')
                .map(s => s.trim())
                .filter(s => s !== '')
                .map(s => parseInt(s))
                .filter(n => !isNaN(n) && n >= 0);
            
            if (selectedGaps.length === 0) {
                alert('Please enter at least one gap (comma-separated)');
                return;
            }
            
            // Check if gaps exist in data
            const validGaps = selectedGaps.filter(g => analysisResults.gapProducts[g]);
            const missingGaps = selectedGaps.filter(g => !analysisResults.gapProducts[g]);
            
            if (validGaps.length === 0) {
                alert(`None of the selected gaps exist in the current range. Missing: ${missingGaps.join(', ')}`);
                return;
            }
            
            if (missingGaps.length > 0) {
                console.warn('Some gaps not found in data:', missingGaps);
            }
            
            // Render the comparison chart
            const canvas = document.getElementById('customGapCompareChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const margin = { left: 250, right: 100, top: 120, bottom: 180 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Get data for valid gaps
            const gapData = validGaps.map(g => ({
                gap: g,
                count: analysisResults.gapProducts[g].count,
                product: analysisResults.gapProducts[g].product,
                logProduct: analysisResults.gapProducts[g].logProduct,
                primes: analysisResults.gapProducts[g].primes
            }));
            
            // Three subcharts: Count, Product, Percentage
            const subChartW = chartW / 3 - 40;
            const subChartH = chartH;
            
            // SUBCHART 1: Prime Counts
            const x1 = margin.left;
            renderCompareSubchart(ctx, x1, margin.top, subChartW, subChartH, gapData, 'count', 'Prime Count', '#4caf50');
            
            // SUBCHART 2: Products P_g
            const x2 = margin.left + subChartW + 60;
            renderCompareSubchart(ctx, x2, margin.top, subChartW, subChartH, gapData, 'product', 'Product P_g', '#ff4081');
            
            // SUBCHART 3: Percentage of Total
            const x3 = margin.left + 2 * (subChartW + 60);
            const totalPrimes = analysisResults.allPrimesFound - 1;
            const percentages = gapData.map(d => ({
                ...d,
                percentage: (d.count / totalPrimes) * 100
            }));
            renderCompareSubchart(ctx, x3, margin.top, subChartW, subChartH, percentages, 'percentage', '% of Total', '#64b5f6');
            
            // Main title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 56px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Custom Gap Family Comparison', w / 2, 70);
            
            // Footer
            ctx.fillStyle = '#aaa';
            ctx.font = 'bold 32px sans-serif';
            ctx.fillText(`Comparing gaps: ${validGaps.join(', ')}  |  ${analysisResults.allPrimesFound.toLocaleString()} primes up to ${analysisResults.maxPrime.toLocaleString()}`, w / 2, h - 80);
            
            if (missingGaps.length > 0) {
                ctx.font = '28px sans-serif';
                ctx.fillStyle = '#ff6b6b';
                ctx.fillText(`Note: Gaps not found in range: ${missingGaps.join(', ')}`, w / 2, h - 40);
            }
            
            // Update table
            updateCustomGapCompareTable(validGaps);
        }
        
        function renderCompareSubchart(ctx, x, y, w, h, gapData, metric, title, color) {
            // Title
            ctx.fillStyle = color;
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(title, x + w/2, y - 40);
            
            const barW = w / (gapData.length + 1);
            const values = gapData.map(d => d[metric]);
            const maxVal = Math.max(...values);
            const scale = (h * 0.85) / maxVal;
            
            gapData.forEach((data, i) => {
                const barH = data[metric] * scale;
                const barY = y + h - barH;
                const barX = x + (i + 0.5) * barW;
                
                // Gradient bar
                const gradient = ctx.createLinearGradient(barX, barY, barX, barY + barH);
                gradient.addColorStop(0, color);
                const darkColor = color.replace('4caf50', '388e3c').replace('ff4081', 'c2185b').replace('64b5f6', '1976d2');
                gradient.addColorStop(1, darkColor);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(barX, barY, barW * 0.7, barH);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.strokeRect(barX, barY, barW * 0.7, barH);
                
                // Value on top
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 28px monospace';
                ctx.textAlign = 'center';
                const displayVal = metric === 'percentage' ? data[metric].toFixed(2) + '%' : 
                                   metric === 'product' ? data[metric].toFixed(4) :
                                   data[metric].toLocaleString();
                ctx.fillText(displayVal, barX + barW * 0.35, barY - 15);
                
                // Gap label
                ctx.font = 'bold 32px sans-serif';
                ctx.fillText('Gap ' + data.gap, barX + barW * 0.35, y + h + 50);
            });
        }
        
        function updateCustomGapCompareTable(gaps) {
            const precision = parseInt(document.getElementById('customGapComparePrecision').value);
            const table = document.getElementById('customGapCompareTableContent');
            const totalPrimes = analysisResults.allPrimesFound - 1;
            
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Prime Count</th>
                        <th>% of Total</th>
                        <th>Product P<sub>g</sub></th>
                        <th>Log(P<sub>g</sub>)</th>
                        <th>Avg Prime</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            gaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const pct = (data.count / totalPrimes) * 100;
                const avgPrime = data.primes.reduce((a, b) => a + b, 0) / data.primes.length;
                
                html += `
                    <tr class="gap-row" data-gap="${gap}" style="cursor: pointer;"
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td><strong>Gap ${gap}</strong></td>
                        <td>${data.count.toLocaleString()}</td>
                        <td>${pct.toFixed(precision)}%</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td>${data.logProduct.toFixed(precision)}</td>
                        <td>${avgPrime.toFixed(0)}</td>
                    </tr>
                `;
            });
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function exportCustomGapCompareCSV() {
            const input = document.getElementById('compareGapsInput').value;
            const selectedGaps = input.split(',')
                .map(s => s.trim())
                .filter(s => s !== '')
                .map(s => parseInt(s))
                .filter(n => !isNaN(n) && n >= 0 && analysisResults.gapProducts[n]);
            
            if (selectedGaps.length === 0) {
                alert('No valid gaps to export');
                return;
            }
            
            const precision = parseInt(document.getElementById('customGapComparePrecision').value);
            const totalPrimes = analysisResults.allPrimesFound - 1;
            
            let csv = '=================================================\n';
            csv += 'CUSTOM GAP FAMILY COMPARISON\n';
            csv += '=================================================\n\n';
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime.toLocaleString()}\n`;
            csv += `Total Primes:,${totalPrimes.toLocaleString()}\n`;
            csv += `Gaps Compared:,${selectedGaps.join(' vs ')}\n\n`;
            
            csv += 'COMPARISON DATA:\n';
            csv += 'Gap,Prime Count,% of Total,Product P_g,Log(P_g),Average Prime,First 5 Primes\n';
            
            selectedGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const pct = (data.count / totalPrimes) * 100;
                const avgPrime = data.primes.reduce((a, b) => a + b, 0) / data.primes.length;
                const firstPrimes = data.primes.slice(0, 5).join(' ');
                
                csv += `${gap},${data.count},${pct.toFixed(precision)}%,`;
                csv += `${data.product.toFixed(precision)},${data.logProduct.toFixed(precision)},`;
                csv += `${avgPrime.toFixed(0)},"${firstPrimes}"\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF COMPARISON\n';
            csv += '=================================================\n';
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.href = URL.createObjectURL(blob);
            link.download = `gap_comparison_${selectedGaps.join('_')}_${timestamp}.csv`;
            link.click();
        }
        
        // ========== DECIMAL CONVERGENCE ANALYSIS ==========
        
        function updateDecimalAnalysis() {
            if (!analysisResults) return;
            
            const gap = parseInt(document.getElementById('decimalGapSelect').value);
            const detailLevel = document.getElementById('decimalDetailLevel').value;
            
            renderDecimalConvergenceChart(gap);
            renderDecimalAnalysisTable(gap, detailLevel);
        }
        
        function renderDecimalConvergenceChart(focusGap = 2) {
            if (!analysisResults) return;
            
            const canvas = document.getElementById('decimalConvergenceChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const margin = { left: 300, right: 250, top: 150, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Get primes for the selected gap
            const gapData = analysisResults.gapProducts[focusGap];
            if (!gapData || !gapData.primes) {
                ctx.fillStyle = '#888';
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data for selected gap', w/2, h/2);
                return;
            }
            
            const primes = gapData.primes.slice(0, Math.min(100, gapData.primes.length));
            
            // Calculate cumulative product and contribution for each prime
            const data = [];
            let cumProduct = 1;
            
            primes.forEach((p, idx) => {
                const factor = (p * p) / (p * p - 1);
                const prevProduct = cumProduct;
                cumProduct *= factor;
                
                const contribution = Math.log10(factor);  // log base 10 for decimal places
                const cumulativeLog = Math.log10(cumProduct);
                
                data.push({
                    index: idx + 1,
                    prime: p,
                    factor: factor,
                    cumProduct: cumProduct,
                    contribution: contribution,  // How much this prime contributes
                    cumulativeLog: cumulativeLog,
                    decimalPlacesStable: Math.floor(-Math.log10(Math.abs(cumProduct - prevProduct * factor)))
                });
            });
            
            // Draw TWO subcharts: contribution magnitude and cumulative product
            
            // SUBCHART 1: Log10 contribution (shows which decimal places affected)
            const x1 = margin.left;
            const subW = chartW / 2 - 40;
            
            ctx.fillStyle = '#4ade80';
            ctx.font = 'bold 42px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Marginal Contribution (log₁₀)', x1 + subW/2, margin.top - 20);
            
            const maxContrib = Math.max(...data.map(d => d.contribution));
            const yScale1 = chartH / maxContrib;
            
            data.forEach((d, i) => {
                const x = x1 + (i / data.length) * subW;
                const barH = d.contribution * yScale1;
                const y = margin.top + chartH - barH;
                
                ctx.fillStyle = i < 5 ? '#22c55e' : i < 20 ? '#4ade80' : '#86efac';
                ctx.fillRect(x, y, Math.max(3, subW / data.length * 0.8), barH);
            });
            
            // Y-axis for contribution
            ctx.fillStyle = '#888';
            ctx.font = '28px monospace';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const val = (maxContrib / 5) * i;
                const y = margin.top + chartH - (chartH / 5) * i;
                ctx.fillText(val.toExponential(1), x1 - 20, y + 10);
            }
            
            // SUBCHART 2: Cumulative product convergence
            const x2 = margin.left + subW + 80;
            
            ctx.fillStyle = '#60a5fa';
            ctx.font = 'bold 42px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Cumulative Product P_g', x2 + subW/2, margin.top - 20);
            
            const minProd = Math.min(...data.map(d => d.cumProduct));
            const maxProd = Math.max(...data.map(d => d.cumProduct));
            const yScale2 = chartH / (maxProd - minProd);
            
            // Line chart
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 6;
            ctx.beginPath();
            
            data.forEach((d, i) => {
                const x = x2 + (i / data.length) * subW;
                const y = margin.top + chartH - (d.cumProduct - minProd) * yScale2;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Points
            data.forEach((d, i) => {
                const x = x2 + (i / data.length) * subW;
                const y = margin.top + chartH - (d.cumProduct - minProd) * yScale2;
                ctx.fillStyle = i < 5 ? '#ef4444' : '#3b82f6';
                ctx.beginPath();
                ctx.arc(x, y, i < 5 ? 12 : 8, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Y-axis for cumulative
            ctx.fillStyle = '#888';
            ctx.font = '28px monospace';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const val = minProd + ((maxProd - minProd) / 5) * i;
                const y = margin.top + chartH - (chartH / 5) * i;
                ctx.fillText(val.toFixed(6), x2 - 20, y + 10);
            }
            
            // Legend
            ctx.fillStyle = '#aaa';
            ctx.font = '32px sans-serif';
            ctx.textAlign = 'left';
            let legendY = margin.top + 50;
            
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(w - 230, legendY, 40, 40);
            ctx.fillStyle = '#ccc';
            ctx.fillText('First 5 primes', w - 180, legendY + 30);
            legendY += 60;
            
            ctx.fillStyle = '#4ade80';
            ctx.fillRect(w - 230, legendY, 40, 40);
            ctx.fillStyle = '#ccc';
            ctx.fillText('Primes 6-20', w - 180, legendY + 30);
            legendY += 60;
            
            ctx.fillStyle = '#86efac';
            ctx.fillRect(w - 230, legendY, 40, 40);
            ctx.fillStyle = '#ccc';
            ctx.fillText('Primes 20+', w - 180, legendY + 30);
            
            // Footer annotations
            ctx.fillStyle = '#888';
            ctx.font = '32px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Gap ${focusGap}: ${primes.length} primes analyzed | Final P_${focusGap} = ${data[data.length-1].cumProduct.toFixed(12)}`, w / 2, h - 60);
            
            ctx.font = '28px sans-serif';
            ctx.fillText(`First prime contributes log₁₀ ≈ ${data[0].contribution.toExponential(3)}, Last prime contributes log₁₀ ≈ ${data[data.length-1].contribution.toExponential(3)}`, w / 2, h - 20);
        }
        
        function renderDecimalAnalysisTable(gap, detailLevel) {
            if (!analysisResults) return;
            
            const gapData = analysisResults.gapProducts[gap];
            if (!gapData || !gapData.primes) return;
            
            const maxPrimes = detailLevel === 'summary' ? 20 : detailLevel === 'detailed' ? 100 : gapData.primes.length;
            const primes = gapData.primes.slice(0, maxPrimes);
            const precision = parseInt(document.getElementById('decimalConvergencePrecision')?.value || 12);
            
            const table = document.getElementById('decimalAnalysisTableContent');
            
            // Calculate data
            let cumProduct = 1;
            const rows = [];
            
            primes.forEach((p, idx) => {
                const factor = (p * p) / (p * p - 1);
                const prevProduct = cumProduct;
                cumProduct *= factor;
                
                const contribution = factor - 1;  // How much > 1
                const logContribution = Math.log10(factor);
                const percentChange = ((cumProduct - prevProduct) / prevProduct) * 100;
                
                // Calculate which decimal places are affected
                const decimalChange = Math.abs(cumProduct - prevProduct);
                const decimalPlace = decimalChange > 0 ? Math.ceil(-Math.log10(decimalChange)) : 15;
                
                rows.push({
                    index: idx + 1,
                    prime: p,
                    factor: factor.toFixed(precision),
                    contribution: contribution.toExponential(6),
                    logContrib: logContribution.toExponential(6),
                    cumProduct: cumProduct.toFixed(precision),
                    percentChange: percentChange.toExponential(4),
                    decimalPlace: Math.min(decimalPlace, 15)
                });
            });
            
            let html = `
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Prime p</th>
                        <th>p²/(p²-1)</th>
                        <th>Contribution<br>(factor - 1)</th>
                        <th>log₁₀(factor)</th>
                        <th>Cumulative P<sub>${gap}</sub></th>
                        <th>% Change</th>
                        <th>Decimal Places<br>Affected</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            rows.forEach(row => {
                const highlight = row.index <= 5 ? 'style="background: rgba(34, 197, 94, 0.1);"' : '';
                html += `
                    <tr ${highlight}>
                        <td style="font-weight: bold;">${row.index}</td>
                        <td style="font-family: monospace;">${row.prime.toLocaleString()}</td>
                        <td style="font-family: monospace; font-size: 0.9rem;">${row.factor}</td>
                        <td style="font-family: monospace; color: #4ade80;">${row.contribution}</td>
                        <td style="font-family: monospace;">${row.logContrib}</td>
                        <td style="font-family: monospace; color: #ffd700;">${row.cumProduct}</td>
                        <td style="font-family: monospace;">${row.percentChange}%</td>
                        <td style="text-align: center; color: ${row.decimalPlace > 10 ? '#22c55e' : '#ffd700'};">
                            ${row.decimalPlace}+
                        </td>
                    </tr>
                `;
            });
            
            // Add summary row
            html += `
                <tr style="border-top: 3px solid #ffd700; background: rgba(255, 215, 0, 0.05);">
                    <td colspan="3"><strong>Summary</strong></td>
                    <td colspan="5" style="text-align: left; padding-left: 20px;">
                        <strong>First prime (p=${primes[0]}):</strong> Contributes ${((primes[0]**2/(primes[0]**2-1) - 1)*100).toFixed(4)}% increase<br>
                        <strong>Last prime (p=${primes[primes.length-1]}):</strong> Contributes ${((primes[primes.length-1]**2/(primes[primes.length-1]**2-1) - 1)*100).toExponential(4)}% increase<br>
                        <strong>Weight ratio:</strong> First/Last = ${((primes[0]**2/(primes[0]**2-1) - 1) / (primes[primes.length-1]**2/(primes[primes.length-1]**2-1) - 1)).toExponential(2)}×
                    </td>
                </tr>
            `;
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function exportDecimalAnalysisCSV() {
            if (!analysisResults) return;
            
            const gap = parseInt(document.getElementById('decimalGapSelect').value);
            const detailLevel = document.getElementById('decimalDetailLevel').value;
            const precision = parseInt(document.getElementById('decimalConvergencePrecision')?.value || 12);
            const gapData = analysisResults.gapProducts[gap];
            
            if (!gapData || !gapData.primes) return;
            
            const maxPrimes = detailLevel === 'summary' ? 20 : detailLevel === 'detailed' ? 100 : gapData.primes.length;
            const primes = gapData.primes.slice(0, maxPrimes);
            
            let csv = 'DECIMAL CONVERGENCE ANALYSIS\\n';
            csv += `Gap ${gap} - Per-Prime Contribution Analysis\\n`;
            csv += `Date: ${new Date().toISOString()}\\n`;
            csv += `Precision: ${precision} decimal places\\n\\n`;
            
            csv += 'Index,Prime,Factor (p²/(p²-1)),Contribution (factor-1),Log₁₀(factor),Cumulative Product,Percent Change,Decimal Places Affected\\n';
            
            let cumProduct = 1;
            primes.forEach((p, idx) => {
                const factor = (p * p) / (p * p - 1);
                const prevProduct = cumProduct;
                cumProduct *= factor;
                const contribution = factor - 1;
                const logContribution = Math.log10(factor);
                const percentChange = ((cumProduct - prevProduct) / prevProduct) * 100;
                const decimalChange = Math.abs(cumProduct - prevProduct);
                const decimalPlace = decimalChange > 0 ? Math.ceil(-Math.log10(decimalChange)) : 15;
                
                csv += `${idx+1},${p},${factor.toFixed(precision)},${contribution.toExponential(6)},${logContribution.toExponential(6)},${cumProduct.toFixed(precision)},${percentChange.toExponential(4)}%,${Math.min(decimalPlace, 15)}+\\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `gap${gap}_decimal_convergence_${Date.now()}.csv`;
            link.click();
        }
        
        // Animation functions
        function startAnimation() {
            if (isAnimating) return;
            
            const useMaxPrime = document.getElementById('useMaxPrimeForAnim').checked;
            let startRange, endRange;
            
            if (useMaxPrime) {
                startRange = 100;
                endRange = parseInt(document.getElementById('maxPrime').value);
            } else {
                startRange = parseInt(document.getElementById('animStart').value);
                endRange = parseInt(document.getElementById('animEnd').value);
            }
            
            if (startRange >= endRange) {
                alert('Animation start must be less than end');
                return;
            }
            
            const animSpeed = parseInt(document.getElementById('animSpeed').value);
            
            isAnimating = true;
            let currentRange = startRange;
            const step = Math.max(100, Math.floor((endRange - startRange) / 100));
            
            const statusBar = document.getElementById('statusBar');
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            
            statusBar.style.display = 'block';
            progressContainer.style.display = 'block';
            
            function animateFrame() {
                if (!isAnimating || currentRange > endRange) {
                    stopAnimation();
                    return;
                }
                
                analysisResults = computeGapDecomposition(currentRange);
                
                const progress = ((currentRange - startRange) / (endRange - startRange)) * 100;
                progressFill.style.width = progress + '%';
                
                statusBar.className = 'status-bar computing';
                statusBar.textContent = `Animating: ${currentRange.toLocaleString()} / ${endRange.toLocaleString()} primes (${progress.toFixed(1)}%)`;
                
                updateStatistics();
                renderAllCharts();
                
                currentRange += step;
                
                // Use setTimeout with speed control instead of requestAnimationFrame
                setTimeout(() => {
                    animationId = requestAnimationFrame(animateFrame);
                }, animSpeed);
            }
            
            animateFrame();
        }
        
        function stopAnimation() {
            isAnimating = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            const statusBar = document.getElementById('statusBar');
            const progressContainer = document.getElementById('progressContainer');
            
            statusBar.className = 'status-bar complete';
            statusBar.textContent = 'Animation complete';
            progressContainer.style.display = 'none';
        }
        
        // Export functions
        function exportAllData() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            let csv = 'Gap-Class Decomposition of zeta(2) = pi^2/6\n';
            csv += `Analysis Date,${new Date().toISOString()}\n`;
            csv += `Maximum Prime,${analysisResults.maxPrime}\n`;
            csv += `Total Primes,${(analysisResults.allPrimesFound || analysisResults.totalPrimes)}\n`;
            csv += `Target zeta(2),${analysisResults.targetZeta2}\n`;
            csv += `Computed Product,${analysisResults.finalProduct}\n`;
            csv += `Absolute Error,${analysisResults.finalError}\n`;
            csv += `Relative Error,${analysisResults.finalRelativeError}\n\n`;
            
            csv += 'Gap Family Analysis\n';
            csv += 'Gap,Prime Count,Product P_g,Log Product,Percentage Contribution,First 20 Primes\n';
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const pct = analysisResults.percentageContributions[gap];
                const primes = data.primes.slice(0, 20).join(' ');
                csv += `${gap},${data.count},${data.product},${data.logProduct},${pct},"${primes}"\n`;
            });
            
            csv += '\nProgressive Convergence\n';
            csv += 'Gap,Cumulative Product,Log Product,Absolute Error,Relative Error\n';
            analysisResults.progressiveProducts.forEach(p => {
                csv += `${p.gap},${p.value},${p.logValue},${p.error},${p.relativeError}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.download = `gap_decomposition_${analysisResults.maxPrime}.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        function exportAllCharts() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const canvases = [
                { id: 'convergenceChart', name: 'convergence' },
                { id: 'gapContribChart', name: 'gap_contributions' },
                { id: 'gapDistChart', name: 'gap_distribution' },
                { id: 'percentageChart', name: 'percentage' },
                { id: 'errorChart', name: 'error_analysis' },
                { id: 'logScaleChart', name: 'log_scale' },
                { id: 'gapRatioChart', name: 'gap_ratio_analysis' }
            ];
            
            canvases.forEach(({ id, name }) => {
                const canvas = document.getElementById(id);
                const link = document.createElement('a');
                link.download = `${name}_${analysisResults.maxPrime}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            });
        }
        
        // Event listeners
        document.getElementById('maxPrime').addEventListener('input', updateDisplays);
        document.getElementById('animStart').addEventListener('input', updateDisplays);
        document.getElementById('animEnd').addEventListener('input', updateDisplays);
        
        // Table toggle function
        const tableStates = {
            convergenceTable: false,
            gapContribTable: false,
            gapDistTable: false,
            percentageTable: false,
            errorTable: false,
            logScaleTable: false,
            gapRatioTable: false,
            stepByStepTable: true
        };
        
        function toggleTable(tableId) {
            const container = document.getElementById(tableId);
            const button = event.target;
            
            tableStates[tableId] = !tableStates[tableId];
            
            if (tableStates[tableId]) {
                container.classList.add('expanded');
                button.textContent = 'Show Less';
            } else {
                container.classList.remove('expanded');
                button.textContent = 'Show All';
            }
            
            updateStatsTables();
        }
        
        // Update all stats tables
        function updateStatsTables() {
            if (!analysisResults) return;
            
            updateConvergenceTable();
            updateGapContribTable();
            updateGapDistTable();
            updatePercentageTable();
            updateErrorTable();
            updateLogScaleTable();
            updateStepByStepTable();
            updateGapRatioTable();
            
            // Add click handlers after tables are populated
            setTimeout(() => addTableClickHandlers(), 100);
        }
        
        function updateConvergenceTable() {
            const precision = parseInt(document.getElementById('convergencePrecision').value);
            const showAll = tableStates.convergenceTable;
            const data = analysisResults.progressiveProducts;
            const displayData = showAll ? data : data.slice(0, 5);
            
            const table = document.getElementById('convergenceTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Cumulative Product</th>
                        <th>Log Product</th>
                        <th>Target ζ(2)</th>
                        <th>Absolute Error</th>
                        <th>Relative Error (%)</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayData.forEach(row => {
                html += `
                    <tr class="gap-row" data-gap="${row.gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${row.gap}</td>
                        <td>${row.value.toFixed(precision)}</td>
                        <td>${row.logValue.toFixed(precision)}</td>
                        <td>${analysisResults.targetZeta2.toFixed(precision)}</td>
                        <td>${row.error.toExponential(precision)}</td>
                        <td>${(row.relativeError * 100).toFixed(precision)}</td>
                    </tr>
                `;
            });
            
            if (!showAll && data.length > 5) {
                html += `
                    <tr>
                        <td colspan="6" style="text-align: center; color: #888; font-style: italic;">
                            ... ${data.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateGapContribTable() {
            const precision = parseInt(document.getElementById('gapContribPrecision').value);
            const showAll = tableStates.gapContribTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            
            const table = document.getElementById('gapContribTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Product P<sub>g</sub></th>
                        <th>Log(P<sub>g</sub>)</th>
                        <th>Prime Count</th>
                        <th>First 10 Primes</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const primeList = data.primes.slice(0, 10).join(', ');
                html += `
                    <tr class="gap-row" data-gap="${gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${gap}</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td>${data.logProduct.toFixed(precision)}</td>
                        <td>${data.count}</td>
                        <td class="prime-list">${primeList}${data.count > 10 ? '...' : ''}</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateGapDistTable() {
            const precision = parseInt(document.getElementById('gapDistPrecision').value);
            const showAll = tableStates.gapDistTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            
            const totalPrimes = analysisResults.totalPrimes;
            
            const table = document.getElementById('gapDistTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Prime Count</th>
                        <th>Percentage of Total</th>
                        <th>Cumulative Count</th>
                        <th>Cumulative %</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            let cumulative = 0;
            displayGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                cumulative += data.count;
                const percentage = (data.count / totalPrimes) * 100;
                const cumulativePercentage = (cumulative / totalPrimes) * 100;
                
                html += `
                    <tr class="gap-row" data-gap="${gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${gap}</td>
                        <td>${data.count}</td>
                        <td>${percentage.toFixed(precision)}%</td>
                        <td>${cumulative}</td>
                        <td>${cumulativePercentage.toFixed(precision)}%</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updatePercentageTable() {
            const precision = parseInt(document.getElementById('percentagePrecision').value);
            const showAll = tableStates.percentageTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            
            const table = document.getElementById('percentageTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Contribution to log(ζ(2))</th>
                        <th>Product P<sub>g</sub></th>
                        <th>Ratio to ζ(2)</th>
                        <th>Log Contribution</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const percentage = analysisResults.percentageContributions[gap];
                const ratio = data.product / analysisResults.targetZeta2;
                
                html += `
                    <tr class="gap-row" data-gap="${gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${gap}</td>
                        <td>${percentage.toFixed(precision)}%</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td>${ratio.toFixed(precision)}</td>
                        <td>${data.logProduct.toFixed(precision)}</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateErrorTable() {
            const precision = parseInt(document.getElementById('errorPrecision').value);
            const showAll = tableStates.errorTable;
            const data = analysisResults.progressiveProducts;
            const displayData = showAll ? data : data.slice(0, 5);
            
            const table = document.getElementById('errorTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Product Value</th>
                        <th>Absolute Error</th>
                        <th>Relative Error</th>
                        <th>Log10(Error)</th>
                        <th>Error Reduction</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayData.forEach((row, idx) => {
                const logError = Math.log10(row.relativeError);
                const prevError = idx > 0 ? data[idx - 1].relativeError : row.relativeError;
                const errorReduction = idx > 0 ? ((prevError - row.relativeError) / prevError * 100) : 0;
                
                html += `
                    <tr class="gap-row" data-gap="${row.gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${row.gap}</td>
                        <td>${row.value.toFixed(precision)}</td>
                        <td>${row.error.toExponential(precision)}</td>
                        <td>${(row.relativeError * 100).toFixed(precision)}%</td>
                        <td>${logError.toFixed(precision)}</td>
                        <td>${errorReduction.toFixed(precision)}%</td>
                    </tr>
                `;
            });
            
            if (!showAll && data.length > 5) {
                html += `
                    <tr>
                        <td colspan="6" style="text-align: center; color: #888; font-style: italic;">
                            ... ${data.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateLogScaleTable() {
            const precision = parseInt(document.getElementById('logScalePrecision').value);
            const showAll = tableStates.logScaleTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            
            const table = document.getElementById('logScaleTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Log(P<sub>g</sub>)</th>
                        <th>P<sub>g</sub></th>
                        <th>Prime Count</th>
                        <th>Avg Log per Prime</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const avgLogPerPrime = data.logProduct / data.count;
                
                html += `
                    <tr class="gap-row" data-gap="${gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${gap}</td>
                        <td>${data.logProduct.toFixed(precision)}</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td>${data.count}</td>
                        <td>${avgLogPerPrime.toFixed(precision)}</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateStepByStepTable() {
            const precision = parseInt(document.getElementById('stepByStepPrecision').value);
            const showAll = tableStates.stepByStepTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            const target = analysisResults.targetZeta2;
            
            const table = document.getElementById('stepByStepTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Gap Added</th>
                        <th>P<sub>g</sub></th>
                        <th>Formula</th>
                        <th>Cumulative Product</th>
                        <th>Distance to π²/6</th>
                        <th>% Complete</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayGaps.forEach((gap, idx) => {
                const data = analysisResults.gapProducts[gap];
                const cumulative = analysisResults.progressiveProducts[idx].value;
                const distance = target - cumulative;
                const percentComplete = (cumulative / target) * 100;
                
                // Build formula string showing multiplication
                let formula = 'P₁';
                for (let i = 1; i <= idx; i++) {
                    formula += ` × P${gaps[i]}`;
                }
                
                html += `
                    <tr class="gap-row" data-gap="${gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${idx + 1}</td>
                        <td>${gap}</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td style="font-size: 0.85rem; color: #aaa;">${formula}</td>
                        <td>${cumulative.toFixed(precision)}</td>
                        <td>${distance.toFixed(precision)}</td>
                        <td>${percentComplete.toFixed(precision)}%</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="7" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            // Add final target row
            html += `
                <tr style="border-top: 3px solid #ffd700; background: rgba(255, 215, 0, 0.1); font-weight: 600;">
                    <td>Target</td>
                    <td colspan="3" style="text-align: center;">ζ(2) = π²/6</td>
                    <td>${target.toFixed(precision)}</td>
                    <td>0.${'0'.repeat(precision)}</td>
                    <td>100.${'0'.repeat(precision)}%</td>
                </tr>
            `;
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateGapRatioTable() {
            if (!analysisResults) return;
            
            const table = document.getElementById('gapRatioTableContent');
            const gap2Count = analysisResults.gapProducts[2]?.count || 0;
            const gap4Count = analysisResults.gapProducts[4]?.count || 0;
            const gap6Count = analysisResults.gapProducts[6]?.count || 0;
            const gap10Count = analysisResults.gapProducts[10]?.count || 0;
            const gap12Count = analysisResults.gapProducts[12]?.count || 0;
            const totalPrimes = analysisResults.allPrimesFound - 1;
            
            // Full precision constant, li2 approximation, and per-gap singular series
            const C2_FULL = 0.6601618158468695;
            function li2(x) { const L = Math.log(x); return (x/(L*L))*(1 + 2/L + 6/(L*L) + 24/(L*L*L)); }
            function singularSeries(h) {
                let mult = 1.0;
                for (let p = 3; p <= h; p++) {
                    if (h % p === 0) {
                        let ip = true; for (let d=2;d*d<=p;d++) if(p%d===0){ip=false;break;}
                        if (ip) mult *= (p-1)/(p-2);
                    }
                }
                return 2 * C2_FULL * mult;
            }
            const maxPrime = analysisResults.maxPrime;
            const predictedTwins = singularSeries(2) * li2(maxPrime);
            const hlError = Math.abs(gap2Count - predictedTwins);
            const hlErrorPercent = (hlError / gap2Count) * 100;
            
            // Calculate ratios
            const ratio_2_4 = gap4Count > 0 ? gap2Count / gap4Count : 0;
            const ratio_2_6 = gap6Count > 0 ? gap2Count / gap6Count : 0;
            const ratio_4_6 = gap6Count > 0 ? gap4Count / gap6Count : 0;
            
            // Calculate percentages
            const pct2 = (gap2Count / totalPrimes) * 100;
            const pct4 = (gap4Count / totalPrimes) * 100;
            const pct6 = (gap6Count / totalPrimes) * 100;
            const pct10 = (gap10Count / totalPrimes) * 100;
            const pct12 = (gap12Count / totalPrimes) * 100;
            
            let html = `
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Value</th>
                        <th>Interpretation</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Gap 2/Gap 4 Ratio</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem; color: ${ratio_2_4 > 0.98 && ratio_2_4 < 1.02 ? '#4caf50' : '#ff6b6b'};">
                            ${ratio_2_4.toFixed(6)}
                        </td>
                        <td>${ratio_2_4 > 0.98 && ratio_2_4 < 1.02 ? 
                            '✓ Near 1.0 - supports equal density' : 
                            'Deviates from 1.0 - check at higher N'}</td>
                    </tr>
                    <tr>
                        <td><strong>Gap 2/Gap 6 Ratio</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${ratio_2_6.toFixed(6)}</td>
                        <td>Gap 6 is asymptotically ~2× <em>more</em> frequent than gap 2 (S(6) = 2×S(2))</td>
                    </tr>
                    <tr>
                        <td><strong>Gap 4/Gap 6 Ratio</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${ratio_4_6.toFixed(6)}</td>
                        <td>Cousin vs Sexy prime density</td>
                    </tr>
                    <tr style="border-top: 2px solid #2a2a4a;">
                        <td><strong>Gap 2 % of Total</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${pct2.toFixed(4)}%</td>
                        <td>${gap2Count.toLocaleString()} twin primes found</td>
                    </tr>
                    <tr>
                        <td><strong>Gap 4 % of Total</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${pct4.toFixed(4)}%</td>
                        <td>${gap4Count.toLocaleString()} cousin primes found</td>
                    </tr>
                    <tr>
                        <td><strong>Gap 6 % of Total</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${pct6.toFixed(4)}%</td>
                        <td>${gap6Count.toLocaleString()} sexy primes found</td>
                    </tr>
                    <tr>
                        <td><strong>Gap 12 % of Total</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${pct12.toFixed(4)}%</td>
                        <td>${gap12Count.toLocaleString()} primes (largest small gap)</td>
                    </tr>
                    <tr style="border-top: 2px solid #2a2a4a;">
                        <td><strong>H-L Predicted Twins (li₂)</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${Math.round(predictedTwins).toLocaleString()}</td>
                        <td>Uses S(2)·li₂(x); S(2)=2C₂≈${(2*0.6601618158468695).toFixed(8)}</td>
                    </tr>
                    <tr>
                        <td><strong>H-L Predicted Cousins (li₂)</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${Math.round(predictedTwins).toLocaleString()}</td>
                        <td>S(4)=S(2) — identical constant, so prediction equals twin prime prediction</td>
                    </tr>
                    <tr>
                        <td><strong>Hardy-Littlewood Error</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem; color: ${hlErrorPercent < 1.0 ? '#4caf50' : hlErrorPercent < 5.0 ? '#ffb74d' : '#ff6b6b'};">
                            ${hlErrorPercent.toFixed(4)}%
                        </td>
                        <td>${hlErrorPercent < 1.0 ? '✓ Excellent match!' : hlErrorPercent < 5.0 ? 'Good agreement' : 'Check computation'}</td>
                    </tr>
                    <tr>
                        <td><strong>Twin Difference</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">
                            ${gap2Count > predictedTwins ? '+' : ''}${Math.round(gap2Count - predictedTwins).toLocaleString()}
                        </td>
                        <td>${gap2Count > predictedTwins ? 'More twins than predicted' : 'Fewer twins than predicted'}</td>
                    </tr>
                </tbody>
            `;
            
            table.innerHTML = html;
        }
        
        // Export functions for individual tables and charts
        function exportTableCSV(tableType) {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const maxPrime = analysisResults.maxPrime;
            let csv = '';
            let filename = '';
            
            switch(tableType) {
                case 'convergence':
                    csv = generateConvergenceCSV();
                    filename = `convergence_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'gapContrib':
                    csv = generateGapContribCSV();
                    filename = `gap_contributions_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'gapDist':
                    csv = generateGapDistCSV();
                    filename = `gap_distribution_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'percentage':
                    csv = generatePercentageCSV();
                    filename = `percentage_contributions_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'error':
                    csv = generateErrorCSV();
                    filename = `error_analysis_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'logScale':
                    csv = generateLogScaleCSV();
                    filename = `log_scale_products_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'gapRatio':
                    csv = generateGapRatioCSV();
                    filename = `gap_ratio_analysis_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'stepByStep':
                    csv = generateStepByStepCSV();
                    filename = `step_by_step_${maxPrime}_${timestamp}.csv`;
                    break;
            }
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }
        
        function exportChartPNG_DOM(canvasId, chartName) {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            
            // Find the chart wrapper that contains both canvas and table
            const chartWrapper = document.getElementById(canvasId).closest('.chart-wrapper');
            if (!chartWrapper) {
                alert('Chart wrapper not found');
                return;
            }
            
            // Use html2canvas to capture the entire chart wrapper (canvas + table)
            html2canvas(chartWrapper, {
                scale: 2, // High quality
                backgroundColor: '#0a0a0f',
                logging: false,
                useCORS: true,
                allowTaint: true
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = `${chartName}_DOM_${analysisResults.maxPrime}_${timestamp}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            }).catch(err => {
                console.error('Export failed:', err);
                alert('Export failed. See console for details.');
            });
        }
        
        function exportChartPNG_Canvas(canvasId, chartName) {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            
            // Create composite canvas
            const compositeCanvas = document.createElement('canvas');
            const ctx = compositeCanvas.getContext('2d');
            
            // Get source chart
            const sourceCanvas = document.getElementById(canvasId);
            const chartW = sourceCanvas.width;
            const chartH = sourceCanvas.height;
            
            // Get row count from global export setting
            const rowCountSetting = document.getElementById('globalExportRows')?.value || '15';
            const maxRows = rowCountSetting === 'all' ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            
            // Calculate dynamic dimensions
            const headerH = 250;
            const statsBarH = 120;
            const tableHeaderH = 60;
            const rowHeight = 50;
            const tableH = tableHeaderH + (maxRows * rowHeight) + 100;
            const padding = 40;
            const footerSpace = 80;
            
            compositeCanvas.width = chartW;
            compositeCanvas.height = headerH + statsBarH + chartH + tableH + footerSpace;
            
            // Background
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);
            
            // Title section
            const s = analysisResults.s || 2;
            const zetaFormula = s === 2 ? `ζ(${s}) = π²/6` : `ζ(${s})`;
            const titleMap = {
                'convergenceChart': `Progressive Product Convergence to ${zetaFormula}`,
                'gapContribChart': 'Individual Gap Family Products P_g',
                'gapDistChart': 'Prime Distribution by Gap Class',
                'percentageChart': `Percentage Contribution to log(ζ(${s}))`,
                'errorChart': 'Convergence Error Analysis',
                'logScaleChart': 'Log-Scale Product Growth: log(P_g)',
                'gapRatioChart': 'Gap Ratio Analysis: Twin Prime Conjecture Evidence',
                'customGapCompareChart': 'Custom Gap Family Comparison',
                'decimalConvergenceChart': `Decimal Convergence Analysis: Weight Decay & Precision`
            };
            
            // Draw title at TOP of image
            if (canvasId !== 'customGapCompareChart') {
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 72px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(titleMap[canvasId] || 'Chart', compositeCanvas.width / 2, 90);
                
                // Author credit instead of date
                ctx.fillStyle = '#888';
                ctx.font = '36px sans-serif';
                ctx.fillText('by Wessen Getachew', compositeCanvas.width / 2, 160);
            }
            
            // Stats summary bar
            const statsY = headerH + padding;
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(padding, statsY, compositeCanvas.width - 2 * padding, statsBarH - 2 * padding);
            
            ctx.strokeStyle = '#3a3a5a';
            ctx.lineWidth = 3;
            ctx.strokeRect(padding, statsY, compositeCanvas.width - 2 * padding, statsBarH - 2 * padding);
            
            // Stats content - 6 boxes
            const boxW = (compositeCanvas.width - 2 * padding - 5 * 20) / 6;
            const statsData = [
                { label: 'N Range', value: analysisResults.maxPrime.toLocaleString() },
                { label: 'Total Primes', value: ((analysisResults.allPrimesFound || analysisResults.totalPrimes) || analysisResults.totalPrimes).toLocaleString() },
                { label: 'Gap Families', value: analysisResults.evenGaps.length.toString() },
                { label: 'Target ζ(2)', value: analysisResults.targetZeta2.toFixed(8) },
                { label: 'Final Product', value: analysisResults.finalProduct.toFixed(8) },
                { label: 'Rel. Error', value: (analysisResults.finalRelativeError * 100).toFixed(6) + '%' }
            ];
            
            statsData.forEach((stat, idx) => {
                const x = padding + idx * (boxW + 20);
                
                ctx.fillStyle = '#888';
                ctx.font = '28px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(stat.label, x + boxW / 2, statsY + 30);
                
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 40px monospace';
                ctx.fillText(stat.value, x + boxW / 2, statsY + 70);
            });
            
            // Draw chart
            const chartY = headerH + statsBarH;
            ctx.drawImage(sourceCanvas, 0, chartY, chartW, chartH);
            
            // Draw stats table
            const tableY = chartY + chartH + padding;
            const actualTableHeight = renderStatsTableToCanvas(ctx, canvasId, tableY, compositeCanvas.width, maxRows);
            
            // Add footer info
            const footerY = tableY + actualTableHeight + 30;
            ctx.fillStyle = '#666';
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            
            if (canvasId === 'customGapCompareChart') {
                const input = document.getElementById('compareGapsInput')?.value || '';
                const gapCount = input.split(',').filter(s => s.trim() !== '').length;
                ctx.fillText(`Comparing ${gapCount} gaps | Analysis: ${analysisResults.allPrimesFound.toLocaleString()} primes up to ${analysisResults.maxPrime.toLocaleString()}`, compositeCanvas.width / 2, footerY);
            } else if (canvasId === 'decimalConvergenceChart') {
                const gap = parseInt(document.getElementById('decimalGapSelect')?.value || 2);
                const detailLevel = document.getElementById('decimalDetailLevel')?.value || 'summary';
                const detailText = detailLevel === 'summary' ? 'First 20 primes' : detailLevel === 'detailed' ? 'First 100 primes' : 'All primes';
                ctx.fillText(`Gap ${gap} - ${detailText} | Showing ${maxRows} table rows | Analysis: ${analysisResults.totalPrimes.toLocaleString()} primes up to ${analysisResults.maxPrime.toLocaleString()}`, compositeCanvas.width / 2, footerY);
            } else {
                ctx.fillText(`Showing ${maxRows} rows | Analysis: ${analysisResults.totalPrimes.toLocaleString()} primes up to ${analysisResults.maxPrime.toLocaleString()}`, compositeCanvas.width / 2, footerY);
            }
            
            // Export
            const link = document.createElement('a');
            link.download = `${chartName}_Canvas_${analysisResults.maxPrime}_${timestamp}.png`;
            link.href = compositeCanvas.toDataURL('image/png');
            link.click();
        }
        
        function renderStatsTableToCanvas(ctx, canvasId, startY, canvasWidth, maxRows) {
            // Determine which table data to render based on canvasId
            const tableMap = {
                'convergenceChart': renderConvergenceTableData,
                'gapContribChart': renderGapContribTableData,
                'gapDistChart': renderGapDistTableData,
                'percentageChart': renderPercentageTableData,
                'errorChart': renderErrorTableData,
                'logScaleChart': renderLogScaleTableData,
                'gapRatioChart': renderGapRatioTableData,
                'customGapCompareChart': renderCustomGapCompareTableData,
                'decimalConvergenceChart': renderDecimalConvergenceTableData
            };
            
            const renderFunc = tableMap[canvasId];
            if (renderFunc) {
                return renderFunc(ctx, startY, canvasWidth, maxRows);
            }
            return 0;
        }
        
        function renderConvergenceTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                // Fallback if called without maxRows
                const rowCountSetting = document.getElementById('globalExportRows')?.value || '15';
                maxRows = rowCountSetting === 'all' ? analysisResults.progressiveProducts.length : parseInt(rowCountSetting);
            }
            
            const precision = parseInt(document.getElementById('convergencePrecision').value);
            const data = analysisResults.progressiveProducts.slice(0, maxRows);
            
            const headers = ['Gap', 'Cumulative Product', 'Log Product', 'Target ζ(2)', 'Abs Error', 'Rel Error (%)'];
            const colW = (canvasWidth - 80) / headers.length;
            
            // Header background
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            // Headers
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            // Rows
            ctx.font = '28px monospace';
            data.forEach((row, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                
                // Alternating row background
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const rowData = [
                    row.gap.toString(),
                    row.value.toFixed(precision),
                    row.logValue.toFixed(precision),
                    analysisResults.targetZeta2.toFixed(precision),
                    row.error.toExponential(precision),
                    (row.relativeError * 100).toFixed(precision)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add DISPLAYED row (last gap's actual state)
            const displayedY = startY + 60 + data.length * 50;
            ctx.fillStyle = 'rgba(78, 205, 196, 0.1)';
            ctx.fillRect(40, displayedY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, displayedY, canvasWidth - 80, 50);
            
            const lastRow = data[data.length - 1];
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 32px monospace';
            const displayedData = [
                'Displayed',
                lastRow.value.toFixed(precision),
                lastRow.logValue.toFixed(precision),
                analysisResults.targetZeta2.toFixed(precision),
                lastRow.error.toExponential(precision),
                (lastRow.relativeError * 100).toFixed(precision) + '%'
            ];
            
            displayedData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + colIdx * colW + colW / 2, displayedY + 35);
            });
            
            // Add LIMIT row (theoretical target at ∞)
            const limitY = displayedY + 50;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, limitY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, limitY, canvasWidth - 80, 50);
            
            const s = analysisResults.s || 2;
            const known = getKnownZetaValue(s);
            const zetaLabel = known ? known.formula : `ζ(${s.toFixed(1)})`;
            const targetLogValue = Math.log(analysisResults.targetZeta2);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const limitData = [
                'Limit',
                analysisResults.targetZeta2.toFixed(precision),
                targetLogValue.toFixed(precision),
                analysisResults.targetZeta2.toFixed(precision),
                '0.0',
                '0.0%'
            ];
            
            limitData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + colIdx * colW + colW / 2, limitY + 35);
            });
            
            // Return actual height used (including both rows)
            const tableHeaderH = 60;
            const rowHeight = 50;
            return tableHeaderH + (data.length * rowHeight) + (2 * rowHeight); // +2 for displayed and limit rows
        }
        
        function renderGapContribTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            }
            
            const precision = parseInt(document.getElementById('gapContribPrecision').value);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const headers = ['Gap', 'Product P_g', 'Log(P_g)', 'Prime Count', 'First Primes'];
            const colWidths = [0.1, 0.2, 0.2, 0.15, 0.35];
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            let xPos = 40;
            headers.forEach((header, idx) => {
                const w = (canvasWidth - 80) * colWidths[idx];
                ctx.fillText(header, xPos + w / 2, startY + 40);
                xPos += w;
            });
            
            ctx.font = '28px monospace';
            gaps.forEach((gap, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const primes = data.primes.slice(0, 5).join(', ');
                const rowData = [
                    gap.toString(),
                    data.product.toFixed(precision),
                    data.logProduct.toFixed(precision),
                    data.count.toString(),
                    primes
                ];
                
                xPos = 40;
                rowData.forEach((cell, colIdx) => {
                    const w = (canvasWidth - 80) * colWidths[colIdx];
                    ctx.textAlign = colIdx === 4 ? 'left' : 'center';
                    const textX = colIdx === 4 ? xPos + 10 : xPos + w / 2;
                    ctx.fillText(cell, textX, y + 35);
                    xPos += w;
                });
            });
            
            // Add DISPLAYED row (cumulative totals for shown gaps only)
            const displayedY = startY + 60 + gaps.length * 50;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, displayedY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, displayedY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const totalLogProduct = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.logProduct || 0), 0);
            const totalProduct = Math.exp(totalLogProduct);
            const totalPrimesDisplayed = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.count || 0), 0);
            
            ctx.textAlign = 'left';
            ctx.fillText('Displayed', 50, displayedY + 35);
            
            const displayedData = [totalProduct.toFixed(precision), totalLogProduct.toFixed(precision), totalPrimesDisplayed.toLocaleString(), 'Shown'];
            
            xPos = colWidths[0] * (canvasWidth - 80);
            displayedData.forEach((cell, colIdx) => {
                const w = (canvasWidth - 80) * colWidths[colIdx + 1];
                ctx.textAlign = colIdx === 3 ? 'left' : 'center';
                const textX = colIdx === 3 ? 40 + xPos + 10 : 40 + xPos + w / 2;
                ctx.fillText(cell, textX, displayedY + 35);
                xPos += w;
            });
            
            // Add LIMIT row (theoretical limits as gap→∞)
            const limitY = displayedY + 50;
            ctx.fillStyle = 'rgba(139, 92, 246, 0.1)';
            ctx.fillRect(40, limitY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, limitY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#8b5cf6';
            ctx.font = 'bold 32px monospace';
            
            ctx.textAlign = 'left';
            ctx.fillText('Limit', 50, limitY + 35);
            
            const s = analysisResults.s || 2;
            const known = getKnownZetaValue(s);
            const zetaLabel = known ? known.formula : `ζ(${s.toFixed(1)})`;
            const limitData = ['1.0', '0.0', analysisResults.totalPrimes.toLocaleString(), '—'];
            
            xPos = colWidths[0] * (canvasWidth - 80);
            limitData.forEach((cell, colIdx) => {
                const w = (canvasWidth - 80) * colWidths[colIdx + 1];
                ctx.textAlign = colIdx === 3 ? 'left' : 'center';
                const textX = colIdx === 3 ? 40 + xPos + 10 : 40 + xPos + w / 2;
                ctx.fillText(cell, textX, limitY + 35);
                xPos += w;
            });
            
            return 60 + (gaps.length * 50) + 100; // Header + rows + 2 summary rows
        }
        
        function renderGapDistTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            }
            const precision = parseInt(document.getElementById('gapDistPrecision').value);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const headers = ['Gap', 'Count', '% of Total', 'Cumulative', 'Cumulative %'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            ctx.font = '28px monospace';
            let cumulative = 0;
            gaps.forEach((gap, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                cumulative += data.count;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const percentage = (data.count / analysisResults.totalPrimes) * 100;
                const cumulativePercentage = (cumulative / analysisResults.totalPrimes) * 100;
                
                const rowData = [
                    gap.toString(),
                    data.count.toString(),
                    percentage.toFixed(precision) + '%',
                    cumulative.toString(),
                    cumulativePercentage.toFixed(precision) + '%'
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add DISPLAYED row (totals for shown gaps only)
            const displayedY = startY + 60 + gaps.length * 50;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, displayedY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, displayedY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('Displayed', 50, displayedY + 35);
            
            ctx.textAlign = 'center';
            const displayedTotal = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.count || 0), 0);
            const displayedPercentage = (displayedTotal / analysisResults.totalPrimes * 100).toFixed(precision);
            const displayedData = [displayedTotal.toLocaleString(), displayedPercentage + '%', displayedTotal.toLocaleString(), displayedPercentage + '%'];
            
            displayedData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, displayedY + 35);
            });
            
            // Add LIMIT row (all primes analyzed)
            const limitY = displayedY + 50;
            ctx.fillStyle = 'rgba(139, 92, 246, 0.1)';
            ctx.fillRect(40, limitY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, limitY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#8b5cf6';
            ctx.font = 'bold 32px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('Limit', 50, limitY + 35);
            
            ctx.textAlign = 'center';
            const limitData = [analysisResults.totalPrimes.toLocaleString(), '100.0%', analysisResults.totalPrimes.toLocaleString(), '100.0%'];
            
            limitData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, limitY + 35);
            });
            
            return 60 + (gaps.length * 50) + 100; // Header + rows + 2 summary rows
        }
        
        function renderPercentageTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            }
            const precision = parseInt(document.getElementById('percentagePrecision').value);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const headers = ['Gap', 'Contribution %', 'Product P_g', 'Ratio', 'Log Contrib'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            ctx.font = '28px monospace';
            gaps.forEach((gap, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const percentage = analysisResults.percentageContributions[gap];
                const ratio = data.product / analysisResults.targetZeta2;
                
                const rowData = [
                    gap.toString(),
                    percentage.toFixed(precision) + '%',
                    data.product.toFixed(precision),
                    ratio.toFixed(precision),
                    data.logProduct.toFixed(precision)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add DISPLAYED row (totals for shown gaps only)
            const displayedY = startY + 60 + gaps.length * 50;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, displayedY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, displayedY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const totalLogProduct = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.logProduct || 0), 0);
            const totalPercentage = gaps.reduce((sum, gap) => sum + (analysisResults.percentageContributions[gap] || 0), 0);
            const totalProduct = Math.exp(totalLogProduct);
            const totalRatio = totalProduct / analysisResults.targetZeta2;
            
            ctx.textAlign = 'left';
            ctx.fillText('Displayed', 50, displayedY + 35);
            
            ctx.textAlign = 'center';
            const displayedData = [totalPercentage.toFixed(precision) + '%', totalProduct.toFixed(precision), totalRatio.toFixed(precision), totalLogProduct.toFixed(precision)];
            
            displayedData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, displayedY + 35);
            });
            
            // Add LIMIT row (theoretical limits)
            const limitY = displayedY + 50;
            ctx.fillStyle = 'rgba(139, 92, 246, 0.1)';
            ctx.fillRect(40, limitY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, limitY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#8b5cf6';
            ctx.font = 'bold 32px monospace';
            
            ctx.textAlign = 'left';
            ctx.fillText('Limit', 50, limitY + 35);
            
            ctx.textAlign = 'center';
            const limitData = ['100.0%', analysisResults.targetZeta2.toFixed(precision), '1.0', '—'];
            
            limitData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, limitY + 35);
            });
            
            return 60 + (gaps.length * 50) + 100;
        }
        
        function renderErrorTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.progressiveProducts.length : parseInt(rowCountSetting);
            }
            const precision = parseInt(document.getElementById('errorPrecision').value);
            const data = analysisResults.progressiveProducts.slice(0, maxRows);
            
            const headers = ['Gap', 'Product', 'Abs Error', 'Rel Error', 'Log10(Error)'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            ctx.font = '28px monospace';
            data.forEach((row, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const logError = Math.log10(row.relativeError);
                
                const rowData = [
                    row.gap.toString(),
                    row.value.toFixed(precision),
                    row.error.toExponential(precision),
                    (row.relativeError * 100).toFixed(precision) + '%',
                    logError.toFixed(precision)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add DISPLAYED row (last gap's actual state)
            const displayedY = startY + 60 + data.length * 50;
            ctx.fillStyle = 'rgba(78, 205, 196, 0.1)';
            ctx.fillRect(40, displayedY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, displayedY, canvasWidth - 80, 50);
            
            const lastRow = data[data.length - 1];
            const lastLogError = Math.log10(lastRow.relativeError);
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 32px monospace';
            
            ctx.textAlign = 'left';
            ctx.fillText('Displayed', 50, displayedY + 35);
            
            ctx.textAlign = 'center';
            const displayedData = [
                lastRow.value.toFixed(precision),
                lastRow.error.toExponential(precision),
                (lastRow.relativeError * 100).toFixed(precision) + '%',
                lastLogError.toFixed(precision)
            ];
            
            displayedData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, displayedY + 35);
            });
            
            // Add LIMIT row (theoretical target)
            const limitY = displayedY + 50;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, limitY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, limitY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            
            ctx.textAlign = 'left';
            ctx.fillText('Limit', 50, limitY + 35);
            
            ctx.textAlign = 'center';
            const limitData = [analysisResults.targetZeta2.toFixed(precision), '0.0', '0.0%', '—'];
            
            limitData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, limitY + 35);
            });
            
            return 60 + (data.length * 50) + 100;
        }
        
        function renderLogScaleTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            }
            const precision = parseInt(document.getElementById('logScalePrecision').value);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const headers = ['Gap', 'Log(P_g)', 'P_g', 'Count', 'Avg/Prime'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            ctx.font = '28px monospace';
            gaps.forEach((gap, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const avgLogPerPrime = data.logProduct / data.count;
                
                const rowData = [
                    gap.toString(),
                    data.logProduct.toFixed(precision),
                    data.product.toFixed(precision),
                    data.count.toString(),
                    avgLogPerPrime.toFixed(precision)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add DISPLAYED row (totals for shown gaps only)
            const displayedY = startY + 60 + gaps.length * 50;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, displayedY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, displayedY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const totalLog = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.logProduct || 0), 0);
            const totalCount = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.count || 0), 0);
            const totalProduct = Math.exp(totalLog);
            const avgLogPerPrime = totalCount > 0 ? (totalLog / totalCount).toFixed(precision) : '—';
            
            ctx.textAlign = 'left';
            ctx.fillText('Displayed', 50, displayedY + 35);
            
            ctx.textAlign = 'center';
            const displayedData = [totalLog.toFixed(precision), totalProduct.toFixed(precision), totalCount.toLocaleString(), avgLogPerPrime];
            
            displayedData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, displayedY + 35);
            });
            
            // Add LIMIT row (theoretical limits)
            const limitY = displayedY + 50;
            ctx.fillStyle = 'rgba(139, 92, 246, 0.1)';
            ctx.fillRect(40, limitY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, limitY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#8b5cf6';
            ctx.font = 'bold 32px monospace';
            
            ctx.textAlign = 'left';
            ctx.fillText('Limit', 50, limitY + 35);
            
            ctx.textAlign = 'center';
            const limitData = ['0.0', '1.0', analysisResults.totalPrimes.toLocaleString(), '—'];
            
            limitData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, limitY + 35);
            });
            
            return 60 + (gaps.length * 50) + 100;
        }
        
        function renderGapRatioTableData(ctx, startY, canvasWidth, maxRows) {
            const precision = parseInt(document.getElementById('gapRatioPrecision')?.value || 6);
            
            // Calculate all the statistics
            const gap2Count = analysisResults.gapProducts[2]?.count || 0;
            const gap4Count = analysisResults.gapProducts[4]?.count || 0;
            const gap6Count = analysisResults.gapProducts[6]?.count || 0;
            const gap10Count = analysisResults.gapProducts[10]?.count || 0;
            const gap12Count = analysisResults.gapProducts[12]?.count || 0;
            const totalPrimes = analysisResults.allPrimesFound - 1;
            
            const C2_FULL = 0.6601618158468695;
            const maxPrime = analysisResults.maxPrime;
            function li2scr(x) { const L = Math.log(x); return (x/(L*L))*(1 + 2/L + 6/(L*L) + 24/(L*L*L)); }
            function singSerScr(h) {
                let mult = 1.0;
                for (let p = 3; p <= h; p++) {
                    if (h % p === 0) {
                        let ip = true; for (let d=2;d*d<=p;d++) if(p%d===0){ip=false;break;}
                        if (ip) mult *= (p-1)/(p-2);
                    }
                }
                return 2 * C2_FULL * mult;
            }
            const predictedTwins = singSerScr(2) * li2scr(maxPrime);
            
            const ratio_2_4 = gap4Count > 0 ? gap2Count / gap4Count : 0;
            const ratio_2_6 = gap6Count > 0 ? gap2Count / gap6Count : 0;
            const ratio_4_6 = gap6Count > 0 ? gap4Count / gap6Count : 0;
            
            const pct2 = (gap2Count / totalPrimes) * 100;
            const pct4 = (gap4Count / totalPrimes) * 100;
            const pct6 = (gap6Count / totalPrimes) * 100;
            const pct10 = (gap10Count / totalPrimes) * 100;
            const pct12 = (gap12Count / totalPrimes) * 100;
            
            const hlError = Math.abs(gap2Count - predictedTwins);
            const hlErrorPercent = (hlError / gap2Count) * 100;
            
            // Table 1: Gap Ratios
            const headers1 = ['Ratio', 'Value', 'Convergence'];
            const colW1 = (canvasWidth - 80) / 3;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ff4081';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Count Ratios', canvasWidth / 2, startY + 40);
            
            startY += 60;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 50);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 30px sans-serif';
            headers1.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW1 + colW1 / 2, startY + 35);
            });
            
            startY += 50;
            
            const ratioData = [
                ['Gap 2 / Gap 4', ratio_2_4, ratio_2_4 > 0.98 && ratio_2_4 < 1.02 ? '✓ Near 1.0' : 'Diverging'],
                ['Gap 2 / Gap 6', ratio_2_6, '—'],
                ['Gap 4 / Gap 6', ratio_4_6, '—']
            ];
            
            ctx.font = '28px monospace';
            ratioData.forEach((row, rowIdx) => {
                const y = startY + rowIdx * 50;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                ctx.textAlign = 'left';
                ctx.fillText(row[0], 60, y + 35);
                
                ctx.textAlign = 'center';
                ctx.fillText(row[1].toFixed(precision), 40 + colW1 + colW1 / 2, y + 35);
                ctx.fillText(row[2], 40 + 2 * colW1 + colW1 / 2, y + 35);
            });
            
            startY += ratioData.length * 50 + 60;
            
            // Table 2: Gap Percentages
            const headers2 = ['Gap', 'Count', '% of Total'];
            const colW2 = (canvasWidth - 80) / 3;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Family Percentages', canvasWidth / 2, startY + 40);
            
            startY += 60;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 50);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 30px sans-serif';
            headers2.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW2 + colW2 / 2, startY + 35);
            });
            
            startY += 50;
            
            const pctData = [
                [2, gap2Count, pct2],
                [4, gap4Count, pct4],
                [6, gap6Count, pct6],
                [10, gap10Count, pct10],
                [12, gap12Count, pct12]
            ];
            
            ctx.font = '28px monospace';
            pctData.forEach((row, rowIdx) => {
                const y = startY + rowIdx * 50;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                ctx.textAlign = 'center';
                ctx.fillText(row[0].toString(), 40 + colW2 / 2, y + 35);
                ctx.fillText(row[1].toLocaleString(), 40 + colW2 + colW2 / 2, y + 35);
                ctx.fillText(row[2].toFixed(2) + '%', 40 + 2 * colW2 + colW2 / 2, y + 35);
            });
            
            startY += pctData.length * 50 + 60;
            
            // Table 3: Hardy-Littlewood Analysis
            const headers3 = ['Metric', 'Value'];
            const colW3 = (canvasWidth - 80) / 2;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffb74d';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Hardy-Littlewood Prediction Analysis', canvasWidth / 2, startY + 40);
            
            startY += 60;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 50);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 30px sans-serif';
            headers3.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW3 + colW3 / 2, startY + 35);
            });
            
            startY += 50;
            
            const hlData = [
                ['Twin Prime Count (Observed)', gap2Count.toLocaleString()],
                ['Twin Prime Count (Predicted, li₂)', Math.round(predictedTwins).toLocaleString()],
                ['Absolute Error', Math.round(hlError).toLocaleString()],
                ['Relative Error', hlErrorPercent.toFixed(3) + '%'],
                ['Twin Prime Constant C₂', C2_FULL.toFixed(10)]
            ];
            
            ctx.font = '28px monospace';
            hlData.forEach((row, rowIdx) => {
                const y = startY + rowIdx * 50;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                ctx.textAlign = 'left';
                ctx.fillText(row[0], 60, y + 35);
                
                ctx.textAlign = 'center';
                ctx.fillText(row[1], 40 + colW3 + colW3 / 2, y + 35);
            });
            
            startY += hlData.length * 50;
            
            return startY - arguments[1] + 60; // Return total height used
        }
        
        function renderDecimalConvergenceTableData(ctx, startY, canvasWidth, maxRows) {
            // Get selected gap from dropdown, default to 2
            const gap = parseInt(document.getElementById('decimalGapSelect')?.value || 2);
            const precision = parseInt(document.getElementById('decimalConvergencePrecision')?.value || 12);
            const gapData = analysisResults.gapProducts[gap];
            
            if (!gapData || !gapData.primes) {
                return 0;
            }
            
            const originalStartY = startY;
            const numPrimes = Math.min(maxRows || 20, gapData.primes.length);
            const primes = gapData.primes.slice(0, numPrimes);
            
            // Title
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#22c55e';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Gap ${gap} - Per-Prime Marginal Contribution (First ${numPrimes})`, canvasWidth / 2, startY + 40);
            
            startY += 60;
            
            // Headers
            const headers = ['#', 'Prime', 'Factor', 'Contrib.', 'Cumulative', 'Decimal'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 50);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 28px sans-serif';
            ctx.textAlign = 'center';
            
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 35);
            });
            
            startY += 50;
            
            // Data rows
            let cumProduct = 1;
            ctx.font = '24px monospace';
            
            primes.forEach((p, idx) => {
                const factor = (p * p) / (p * p - 1);
                const prevProduct = cumProduct;
                cumProduct *= factor;
                
                const contribution = factor - 1;
                const decimalChange = Math.abs(cumProduct - prevProduct);
                const decimalPlace = decimalChange > 0 ? Math.ceil(-Math.log10(decimalChange)) : 15;
                
                const y = startY + idx * 45;
                
                // Alternate row background + highlight first 5
                if (idx < 5) {
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.1)';
                    ctx.fillRect(40, y, canvasWidth - 80, 45);
                } else if (idx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 45);
                }
                
                ctx.fillStyle = idx < 5 ? '#4ade80' : '#e0e0e0';
                ctx.textAlign = 'center';
                
                // Index
                ctx.fillText((idx + 1).toString(), 40 + 0 * colW + colW / 2, y + 32);
                // Prime
                ctx.fillText(p.toLocaleString(), 40 + 1 * colW + colW / 2, y + 32);
                // Factor
                const displayPrecision = Math.min(precision, 9); // Canvas display limited to 9 for space
                ctx.fillText(factor.toFixed(displayPrecision), 40 + 2 * colW + colW / 2, y + 32);
                // Contribution
                ctx.fillText(contribution.toExponential(2), 40 + 3 * colW + colW / 2, y + 32);
                // Cumulative Product
                ctx.fillText(cumProduct.toFixed(displayPrecision), 40 + 4 * colW + colW / 2, y + 32);
                // Decimal Places
                ctx.fillStyle = decimalPlace > 10 ? '#22c55e' : '#ffd700';
                ctx.fillText(`${Math.min(decimalPlace, 15)}+`, 40 + 5 * colW + colW / 2, y + 32);
            });
            
            startY += primes.length * 45 + 20;
            
            // Add summary row
            const firstPrime = primes[0];
            const lastPrime = primes[primes.length - 1];
            const firstFactor = (firstPrime * firstPrime) / (firstPrime * firstPrime - 1);
            const lastFactor = (lastPrime * lastPrime) / (lastPrime * lastPrime - 1);
            const firstContrib = ((firstFactor - 1) * 100);
            const lastContrib = ((lastFactor - 1) * 100);
            const weightRatio = firstContrib / lastContrib;
            
            // Summary box background
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(40, startY, canvasWidth - 80, 120);
            
            // Border
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, startY, canvasWidth - 80, 120);
            
            // Summary title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Summary:', 60, startY + 35);
            
            // Summary content
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '26px sans-serif';
            ctx.fillText(`First prime (p=${firstPrime}): Contributes ${firstContrib.toFixed(4)}% increase`, 60, startY + 70);
            ctx.fillText(`Last prime (p=${lastPrime}): Contributes ${lastContrib.toExponential(4)}% increase`, 60, startY + 100);
            
            ctx.fillStyle = '#4ade80';
            ctx.font = 'bold 26px sans-serif';
            ctx.fillText(`Weight ratio: First/Last = ${weightRatio.toExponential(2)}×`, canvasWidth - 500, startY + 85);
            
            startY += 120 + 40;
            
            return startY - originalStartY;
        }
        
        function renderCustomGapCompareTableData(ctx, startY, canvasWidth, maxRows) {
            // Get selected gaps from input
            const input = document.getElementById('compareGapsInput')?.value || '';
            const selectedGaps = input.split(',')
                .map(s => s.trim())
                .filter(s => s !== '')
                .map(s => parseInt(s))
                .filter(n => !isNaN(n) && n >= 0 && analysisResults.gapProducts[n]);
            
            if (selectedGaps.length === 0) {
                // No gaps selected, return minimal height
                return 100;
            }
            
            // Limit to maxRows if provided
            const rowCountSetting = document.getElementById('globalExportRows')?.value || 'all';
            const displayGaps = (rowCountSetting === 'all') ? selectedGaps : selectedGaps.slice(0, parseInt(rowCountSetting));
            
            const precision = parseInt(document.getElementById('customGapComparePrecision')?.value || 6);
            const totalPrimes = analysisResults.allPrimesFound - 1;
            
            const headers = ['Gap', 'Prime Count', '% of Total', 'Product P_g', 'Log(P_g)', 'Avg Prime'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 28px sans-serif'; // Reduced from 32px to match smaller data
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            startY += 60;
            
            ctx.font = '24px monospace'; // Reduced from 28px
            displayGaps.forEach((gap, rowIdx) => {
                const y = startY + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                const pct = (data.count / totalPrimes) * 100;
                const avgPrime = data.primes.reduce((a, b) => a + b, 0) / data.primes.length;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                
                // Format product - use scientific notation if very close to 1
                let productStr;
                if (Math.abs(data.product - 1.0) < 0.0001) {
                    // Very close to 1, show deviation
                    const deviation = data.product - 1.0;
                    productStr = `1+${deviation.toExponential(2)}`;
                } else {
                    productStr = data.product.toFixed(Math.min(4, precision));
                }
                
                const rowData = [
                    gap.toString(),
                    data.count.toLocaleString(),
                    pct.toFixed(Math.min(4, precision)) + '%',
                    productStr,
                    data.logProduct.toFixed(Math.min(4, precision)),
                    avgPrime.toFixed(0)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.textAlign = 'center';
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            startY += displayGaps.length * 50;
            
            // Add summary row if not showing all
            if (selectedGaps.length > displayGaps.length) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
                ctx.fillRect(40, startY, canvasWidth - 80, 50);
                
                ctx.fillStyle = '#ffd700';
                ctx.font = 'italic 28px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`... ${selectedGaps.length - displayGaps.length} more gaps (adjust "Data Rows" setting to see all)`, canvasWidth / 2, startY + 35);
                startY += 50;
            }
            
            return startY - arguments[1] + 60;
        }
        
        function generateConvergenceCSV() {
            const precision = parseInt(document.getElementById('convergencePrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Progressive Convergence Analysis\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset presents the progressive convergence of the gap-class decomposition\n';
            csv += 'of the Riemann zeta function at s=2. By partitioning the Euler product according\n';
            csv += 'to prime gap classes, we observe how each gap family P_g contributes to the final\n';
            csv += 'value of pi^2/6. The cumulative product demonstrates geometric convergence as\n';
            csv += 'additional gap families are incorporated into the decomposition.\n\n';
            
            csv += 'METHODOLOGY:\n';
            csv += 'For each even gap g, we compute P_g = product over all primes p with gap(p)=g of p^2/(p^2-1)\n';
            csv += 'The progressive product tracks: zeta(2) = P_1 × P_2 × P_4 × P_6 × ...\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime Analyzed:,${analysisResults.maxPrime}\n`;
            csv += `Total Primes Found:,${(analysisResults.allPrimesFound || analysisResults.totalPrimes)}\n`;
            csv += `Number of Gap Families:,${analysisResults.evenGaps.length}\n`;
            csv += `Target Value (pi^2/6):,${analysisResults.targetZeta2}\n`;
            csv += `Final Computed Product:,${analysisResults.finalProduct}\n`;
            csv += `Final Absolute Error:,${analysisResults.finalError}\n`;
            csv += `Final Relative Error:,${analysisResults.finalRelativeError}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Cumulative Product,Log Product,Target zeta(2),Absolute Error,Relative Error (%)\n';
            
            analysisResults.progressiveProducts.forEach(row => {
                csv += `${row.gap},${row.value.toFixed(precision)},${row.logValue.toFixed(precision)},`;
                csv += `${analysisResults.targetZeta2.toFixed(precision)},${row.error.toExponential(precision)},`;
                csv += `${(row.relativeError * 100).toFixed(precision)}\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateGapContribCSV() {
            const precision = parseInt(document.getElementById('gapContribPrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Individual Gap Family Products\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset contains the individual product values P_g for each gap family.\n';
            csv += 'Each P_g represents the contribution of all primes with forward gap g to the\n';
            csv += 'overall Euler product. The data includes prime counts, product values, logarithmic\n';
            csv += 'contributions, and the first primes in each family for verification and further analysis.\n\n';
            
            csv += 'FORMULA:\n';
            csv += 'P_g = product over all primes p where gap(p)=g of [p^2 / (p^2 - 1)]\n';
            csv += 'where gap(p) = next_prime(p) - p\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Total Primes:,${(analysisResults.allPrimesFound || analysisResults.totalPrimes)}\n`;
            csv += `Total Gap Families:,${analysisResults.evenGaps.length}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Product P_g,Log(P_g),Prime Count,Percentage of Total,First 20 Primes in Family\n';
            
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const pct = (data.count / analysisResults.totalPrimes * 100).toFixed(4);
                const primes = data.primes.slice(0, 20).join(' ');
                csv += `${gap},${data.product.toFixed(precision)},${data.logProduct.toFixed(precision)},`;
                csv += `${data.count},${pct}%,"${primes}"\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateGapDistCSV() {
            const precision = parseInt(document.getElementById('gapDistPrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Prime Distribution by Gap Class\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset analyzes how primes distribute across different gap classes.\n';
            csv += 'For each even gap g, we count how many primes have forward gap g, compute\n';
            csv += 'the percentage of total primes this represents, and track cumulative statistics.\n';
            csv += 'This data is essential for understanding prime constellation frequencies and\n';
            csv += 'testing conjectures about gap distribution (e.g., Twin Prime Conjecture).\n\n';
            
            csv += 'DEFINITIONS:\n';
            csv += '- Gap g: The difference between consecutive primes (p_n+1 - p_n)\n';
            csv += '- Count: Number of primes p where gap(p) = g\n';
            csv += '- Percentage: (Count / Total Primes) × 100\n';
            csv += '- Cumulative: Running total of primes accounted for\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Total Primes Analyzed:,${(analysisResults.allPrimesFound || analysisResults.totalPrimes)}\n`;
            csv += `Distinct Gap Families:,${analysisResults.evenGaps.length}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Prime Count,Percentage of Total,Cumulative Count,Cumulative Percentage\n';
            
            let cumulative = 0;
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                cumulative += data.count;
                const percentage = (data.count / analysisResults.totalPrimes) * 100;
                const cumulativePercentage = (cumulative / analysisResults.totalPrimes) * 100;
                
                csv += `${gap},${data.count},${percentage.toFixed(precision)}%,`;
                csv += `${cumulative},${cumulativePercentage.toFixed(precision)}%\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generatePercentageCSV() {
            const precision = parseInt(document.getElementById('percentagePrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Percentage Contribution Analysis\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset quantifies the relative contribution of each gap family to the\n';
            csv += 'final value of zeta(2) = pi^2/6. Contributions are measured logarithmically\n';
            csv += 'since the Euler product is multiplicative. The data reveals which gap classes\n';
            csv += 'dominate the convergence and how contribution scales with gap size.\n\n';
            
            csv += 'METHODOLOGY:\n';
            csv += 'Contribution percentage = [log(P_g) / log(zeta(2))] × 100\n';
            csv += 'This measures what fraction of the logarithmic sum comes from each gap class.\n';
            csv += 'Ratio = P_g / zeta(2) shows the multiplicative contribution.\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Target zeta(2):,${analysisResults.targetZeta2}\n`;
            csv += `Final Product:,${analysisResults.finalProduct}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Contribution to log(zeta(2)) (%),Product P_g,Ratio to zeta(2),Log Contribution\n';
            
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const percentage = analysisResults.percentageContributions[gap];
                const ratio = data.product / analysisResults.targetZeta2;
                
                csv += `${gap},${percentage.toFixed(precision)}%,${data.product.toFixed(precision)},`;
                csv += `${ratio.toFixed(precision)},${data.logProduct.toFixed(precision)}\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateErrorCSV() {
            const precision = parseInt(document.getElementById('errorPrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Convergence Error Analysis\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset tracks the convergence error as additional gap families are\n';
            csv += 'incorporated into the decomposition. Multiple error metrics are provided:\n';
            csv += 'absolute error, relative error, logarithmic error, and error reduction rate.\n';
            csv += 'The data demonstrates geometric convergence to pi^2/6 and can be used to\n';
            csv += 'estimate asymptotic convergence rates.\n\n';
            
            csv += 'ERROR DEFINITIONS:\n';
            csv += '- Absolute Error: |Product - pi^2/6|\n';
            csv += '- Relative Error: Absolute Error / pi^2/6\n';
            csv += '- Log10(Error): Logarithmic scale for visualization\n';
            csv += '- Error Reduction: Percentage decrease from previous step\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Target zeta(2):,${analysisResults.targetZeta2}\n`;
            csv += `Final Relative Error:,${(analysisResults.finalRelativeError * 100).toFixed(precision)}%\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Product Value,Absolute Error,Relative Error (%),Log10(Error),Error Reduction (%)\n';
            
            const data = analysisResults.progressiveProducts;
            data.forEach((row, idx) => {
                const logError = Math.log10(row.relativeError);
                const prevError = idx > 0 ? data[idx - 1].relativeError : row.relativeError;
                const errorReduction = idx > 0 ? ((prevError - row.relativeError) / prevError * 100) : 0;
                
                csv += `${row.gap},${row.value.toFixed(precision)},${row.error.toExponential(precision)},`;
                csv += `${(row.relativeError * 100).toFixed(precision)}%,${logError.toFixed(precision)},`;
                csv += `${errorReduction.toFixed(precision)}%\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateLogScaleCSV() {
            const precision = parseInt(document.getElementById('logScalePrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Logarithmic Product Analysis\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset presents logarithmic analysis of gap family products.\n';
            csv += 'Working in log space reveals linear patterns that may be obscured in\n';
            csv += 'multiplicative form. The average log contribution per prime in each\n';
            csv += 'gap family can reveal scaling relationships and potential closed-form\n';
            csv += 'expressions for P_g involving pi or other fundamental constants.\n\n';
            
            csv += 'ANALYTICAL VALUE:\n';
            csv += 'Log-scale analysis is crucial for:\n';
            csv += '- Detecting power-law relationships in P_g vs g\n';
            csv += '- Identifying potential pi-based formulas for individual gap products\n';
            csv += '- Computing asymptotic behavior as g → infinity\n';
            csv += '- Stable numerical analysis of very small/large products\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Total Gap Families:,${analysisResults.evenGaps.length}\n`;
            csv += `log(zeta(2)):,${Math.log(analysisResults.targetZeta2).toFixed(precision)}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Log(P_g),P_g,Prime Count,Average Log per Prime,Log Density\n';
            
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const avgLogPerPrime = data.logProduct / data.count;
                const logDensity = data.logProduct / gap;
                
                csv += `${gap},${data.logProduct.toFixed(precision)},${data.product.toFixed(precision)},`;
                csv += `${data.count},${avgLogPerPrime.toFixed(precision)},${logDensity.toFixed(precision)}\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateGapRatioCSV() {
            const precision = parseInt(document.getElementById('gapRatioPrecision')?.value || 6);
            let csv = '=================================================\n';
            csv += 'GAP RATIO ANALYSIS: TWIN PRIME CONJECTURE EVIDENCE\n';
            csv += 'Hardy-Littlewood Equal Density Hypothesis Test\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset tests the Hardy-Littlewood conjecture that twin primes (gap 2)\n';
            csv += 'and cousin primes (gap 4) have equal asymptotic density. If true, the ratio\n';
            csv += 'Count(gap=2)/Count(gap=4) should approach 1.0 as N → ∞, providing strong\n';
            csv += 'computational evidence for infinite twin primes.\n\n';
            
            csv += 'THEORETICAL FOUNDATION:\n';
            csv += 'Hardy-Littlewood Conjecture B: the number of prime pairs (p, p+h) up to x is:\n';
            csv += '  π_h(x) ~ S(h) · li₂(x)  where  li₂(x) ≈ x/ln²(x)·(1 + 2/ln(x) + ...)\n';
            csv += 'The singular series S(h) = 2·C₂ · ∏_{odd prime p|h} (p-1)/(p-2)\n';
            csv += 'Key values: S(2)=S(4)=S(8)=2·C₂≈1.3203  S(6)=S(12)=4·C₂≈2.6406\n';
            csv += 'IMPORTANT: Gap 6 is asymptotically TWICE as frequent as gap 2 or 4 (not equal).\n';
            csv += 'Only gaps 2 and 4 are predicted to have equal asymptotic density.\n\n';
            
            const gap2Count = analysisResults.gapProducts[2]?.count || 0;
            const gap4Count = analysisResults.gapProducts[4]?.count || 0;
            const gap6Count = analysisResults.gapProducts[6]?.count || 0;
            const gap10Count = analysisResults.gapProducts[10]?.count || 0;
            const gap12Count = analysisResults.gapProducts[12]?.count || 0;
            const totalPrimes = analysisResults.allPrimesFound - 1;
            
            const C2_FULL = 0.6601618158468695;
            const maxPrime = analysisResults.maxPrime;
            function li2csv(x) { const L = Math.log(x); return (x/(L*L))*(1 + 2/L + 6/(L*L) + 24/(L*L*L)); }
            function singularSeriesCSV(h) {
                let mult = 1.0;
                for (let p = 3; p <= h; p++) {
                    if (h % p === 0) {
                        let ip = true; for (let d=2;d*d<=p;d++) if(p%d===0){ip=false;break;}
                        if (ip) mult *= (p-1)/(p-2);
                    }
                }
                return 2 * C2_FULL * mult;
            }
            const predictedTwins = singularSeriesCSV(2) * li2csv(maxPrime);
            
            const ratio_2_4 = gap4Count > 0 ? gap2Count / gap4Count : 0;
            const ratio_2_6 = gap6Count > 0 ? gap2Count / gap6Count : 0;
            const ratio_4_6 = gap6Count > 0 ? gap4Count / gap6Count : 0;
            
            const pct2 = (gap2Count / totalPrimes) * 100;
            const pct4 = (gap4Count / totalPrimes) * 100;
            const pct6 = (gap6Count / totalPrimes) * 100;
            const pct10 = (gap10Count / totalPrimes) * 100;
            const pct12 = (gap12Count / totalPrimes) * 100;
            
            const hlError = Math.abs(gap2Count - predictedTwins);
            const hlErrorPercent = (hlError / gap2Count) * 100;
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${maxPrime.toLocaleString()}\n`;
            csv += `Total Primes Analyzed:,${totalPrimes.toLocaleString()}\n`;
            csv += `Twin Prime Constant C₂ (full):,${C2_FULL.toFixed(16)}\n`;
            csv += `S(2) = S(4) = 2·C₂:,${(2*C2_FULL).toFixed(10)}\n`;
            csv += `S(6) = S(12) = 4·C₂:,${(4*C2_FULL).toFixed(10)}\n\n`;
            
            csv += 'GAP COUNT RATIOS:\n';
            csv += 'Ratio,Value,Expected limit,Interpretation\n';
            csv += `Gap 2 / Gap 4,${ratio_2_4.toFixed(precision)},1.0000,${ratio_2_4 > 0.98 && ratio_2_4 < 1.02 ? '✓ Near 1.0 - S(2)=S(4) confirmed' : 'Check at higher N'}\n`;
            csv += `Gap 2 / Gap 6,${ratio_2_6.toFixed(precision)},0.5000,Gap 6 is 2x more frequent (S(6)=2·S(2)) - ratio converges to 0.5\n`;
            csv += `Gap 4 / Gap 6,${ratio_4_6.toFixed(precision)},0.5000,Same: S(4)=S(2) so gap4/gap6 also converges to 0.5\n\n`;
            
            csv += 'GAP FAMILY STATISTICS:\n';
            csv += 'Gap,Count,Percentage of Total,S(h),Asymptotic frequency relative to gap 2,Note\n';
            csv += `2,${gap2Count.toLocaleString()},${pct2.toFixed(4)}%,${(2*C2_FULL).toFixed(6)},1.0x baseline,Twin Primes\n`;
            csv += `4,${gap4Count.toLocaleString()},${pct4.toFixed(4)}%,${(2*C2_FULL).toFixed(6)},1.0x (equal to gap 2),Cousin Primes\n`;
            csv += `6,${gap6Count.toLocaleString()},${pct6.toFixed(4)}%,${(4*C2_FULL).toFixed(6)},2.0x more frequent,Sexy Primes\n`;
            csv += `10,${gap10Count.toLocaleString()},${pct10.toFixed(4)}%,${(8/3*2*C2_FULL).toFixed(6)},4/3x more frequent,\n`;
            csv += `12,${gap12Count.toLocaleString()},${pct12.toFixed(4)}%,${(4*C2_FULL).toFixed(6)},2.0x more frequent,\n\n`;
            
            csv += 'HARDY-LITTLEWOOD PREDICTION ANALYSIS (using li₂ approximation):\n';
            csv += 'Formula: π₂(x) ~ S(2)·li₂(x)  where li₂(x)=x/ln²(x)·(1+2/ln(x)+6/ln²(x)+24/ln³(x))\n';
            csv += 'Metric,Value\n';
            csv += `Twin Primes Observed,${gap2Count.toLocaleString()}\n`;
            csv += `Twin Primes Predicted (H-L li₂),${Math.round(predictedTwins).toLocaleString()}\n`;
            csv += `Absolute Error,${Math.round(hlError).toLocaleString()}\n`;
            csv += `Relative Error,${hlErrorPercent.toFixed(precision)}%\n`;
            csv += `Difference (Observed - Predicted),${gap2Count > predictedTwins ? '+' : ''}${Math.round(gap2Count - predictedTwins).toLocaleString()}\n\n`;
            
            csv += 'INTERPRETATION:\n';
            if (ratio_2_4 > 0.98 && ratio_2_4 < 1.02) {
                csv += '✓ Gap 2/Gap 4 ratio near 1.0 — confirms S(2)=S(4), supporting HL equal-density prediction\n';
            } else {
                csv += '! Gap 2/Gap 4 ratio deviates from 1.0 — try larger N for convergence\n';
            }
            csv += `✓ Gap 2/Gap 6 ratio converging toward 0.5 (currently ${ratio_2_6.toFixed(4)}) — confirms S(6)=2·S(2)\n`;
            if (hlErrorPercent < 1.0) {
                csv += '✓ H-L li₂ formula predicts twin prime count with <1% error — excellent\n';
            } else if (hlErrorPercent < 5.0) {
                csv += '✓ H-L li₂ formula shows good agreement (<5% error)\n';
            } else {
                csv += `Note: ${hlErrorPercent.toFixed(2)}% error — at small N the simple formula underestimates; use larger N\n`;
            }
            csv += '\nCONCLUSION:\n';
            csv += 'Gap 2/Gap 4 ratio converges to 1.0 (equal density, same S constant).\n';
            csv += 'Gap 2/Gap 6 ratio converges to 0.5 (gap 6 twice as frequent, S(6)=2·S(2)).\n';
            csv += 'The H-L li₂ prediction matches observed twin prime counts within ~1% at large N.\n\n';
            
            csv += '=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateStepByStepCSV() {
            const precision = parseInt(document.getElementById('stepByStepPrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Step-by-Step Accumulation Process\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset provides a sequential view of how the gap-class decomposition\n';
            csv += 'builds toward pi^2/6. Each row shows the addition of one gap family to the\n';
            csv += 'cumulative product, demonstrating the geometric convergence process step by step.\n';
            csv += 'The formula column explicitly shows which gap families have been multiplied together.\n\n';
            
            csv += 'INTERPRETATION GUIDE:\n';
            csv += '- Step: Sequential order of gap family addition\n';
            csv += '- Gap Added: The gap g being incorporated in this step\n';
            csv += '- P_g: The product value for this specific gap family\n';
            csv += '- Formula: Explicit product notation (P_1 × P_2 × P_4 × ...)\n';
            csv += '- Cumulative Product: Running product after this step\n';
            csv += '- Distance to pi^2/6: How far from target value\n';
            csv += '- Percent Complete: (Cumulative / pi^2/6) × 100\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Target zeta(2):,${analysisResults.targetZeta2}\n`;
            csv += `Total Gap Families:,${analysisResults.evenGaps.length}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Step,Gap Added,P_g,Formula,Cumulative Product,Distance to pi^2/6,Percent Complete\n';
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = "#888";
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            gaps.forEach((gap, idx) => {
                const data = analysisResults.gapProducts[gap];
                const cumulative = analysisResults.progressiveProducts[idx].value;
                const distance = analysisResults.targetZeta2 - cumulative;
                const percentComplete = (cumulative / analysisResults.targetZeta2) * 100;
                
                let formula = 'P_1';
                for (let i = 1; i <= idx; i++) {
                    formula += ` × P_${gaps[i]}`;
                }
                
                csv += `${idx + 1},${gap},${data.product.toFixed(precision)},"${formula}",`;
                csv += `${cumulative.toFixed(precision)},${distance.toFixed(precision)},`;
                csv += `${percentComplete.toFixed(precision)}%\n`;
            });
            
            csv += `\nFINAL TARGET,∞,1.0,"zeta(2) = pi^2/6",${analysisResults.targetZeta2.toFixed(precision)},0.0,100.0%\n`;
            
            csv += '\n=================================================\n';
            csv += 'RESEARCH NOTES:\n';
            csv += 'This decomposition provides a novel perspective on the Basel problem.\n';
            csv += 'By organizing the Euler product by prime gaps rather than sequential primes,\n';
            csv += 'we reveal connections between prime constellation distributions and the\n';
            csv += 'fundamental constant pi. The rapid convergence suggests each gap family P_g\n';
            csv += 'may admit closed-form expressions in terms of pi and gap parameters.\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function exportStepByStepTablePNG() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const precision = parseInt(document.getElementById('stepByStepPrecision').value);
            
            // Get row count from global export setting
            const rowCountSetting = document.getElementById('globalExportRows')?.value || '15';
            
            const maxRows = rowCountSetting === 'all' ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Calculate dimensions
            const headerH = 200;
            const tableHeaderH = 80;
            const rowH = 60;
            const footerH = 100;
            const padding = 40;
            
            const canvasW = 3840;
            const canvasH = headerH + tableHeaderH + (gaps.length + 2) * rowH + footerH; // +2 for displayed and limit rows
            
            canvas.width = canvasW;
            canvas.height = canvasH;
            
            // Background
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvasW, canvasH);
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 64px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Step-by-Step Gap Accumulation: ζ(2) = P₁ × P₂ × P₄ × ...', canvasW / 2, 80);
            
            ctx.fillStyle = '#888';
            ctx.font = '32px monospace';
            ctx.fillText(`Analysis: ${analysisResults.totalPrimes.toLocaleString()} primes up to ${analysisResults.maxPrime.toLocaleString()}`, canvasW / 2, 140);
            
            // Table headers
            const tableY = headerH + padding;
            const headers = ['Step', 'Gap', 'P_g', 'Cumulative Product', 'Distance to π²/6', '% Complete'];
            const colWidths = [0.08, 0.08, 0.18, 0.24, 0.22, 0.20];
            
            ctx.fillStyle = '#1a1a2a';
            ctx.fillRect(padding, tableY, canvasW - 2 * padding, tableHeaderH);
            
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 4;
            ctx.strokeRect(padding, tableY, canvasW - 2 * padding, tableHeaderH);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            
            let xPos = padding;
            headers.forEach((header, idx) => {
                const w = (canvasW - 2 * padding) * colWidths[idx];
                ctx.fillText(header, xPos + w / 2, tableY + 50);
                xPos += w;
            });
            
            // Table rows
            ctx.font = '32px monospace';
            gaps.forEach((gap, rowIdx) => {
                const y = tableY + tableHeaderH + rowIdx * rowH;
                const data = analysisResults.gapProducts[gap];
                const cumulative = analysisResults.progressiveProducts[rowIdx].value;
                const distance = analysisResults.targetZeta2 - cumulative;
                const percentComplete = (cumulative / analysisResults.targetZeta2) * 100;
                
                // Alternating row background
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.02)';
                    ctx.fillRect(padding, y, canvasW - 2 * padding, rowH);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const rowData = [
                    (rowIdx + 1).toString(),
                    gap.toString(),
                    data.product.toFixed(precision),
                    cumulative.toFixed(precision),
                    distance.toFixed(precision),
                    percentComplete.toFixed(precision) + '%'
                ];
                
                xPos = padding;
                rowData.forEach((cell, colIdx) => {
                    const w = (canvasW - 2 * padding) * colWidths[colIdx];
                    ctx.fillText(cell, xPos + w / 2, y + 42);
                    xPos += w;
                });
            });
            
            // DISPLAYED row (actual state at last gap)
            const displayedY = tableY + tableHeaderH + gaps.length * rowH;
            ctx.fillStyle = 'rgba(78, 205, 196, 0.1)';
            ctx.fillRect(padding, displayedY, canvasW - 2 * padding, rowH);
            
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 4;
            ctx.strokeRect(padding, displayedY, canvasW - 2 * padding, rowH);
            
            const lastGap = gaps[gaps.length - 1];
            const lastData = analysisResults.gapProducts[lastGap];
            const lastCumulative = analysisResults.progressiveProducts[gaps.length - 1].value;
            const lastDistance = analysisResults.targetZeta2 - lastCumulative;
            const lastPercentComplete = (lastCumulative / analysisResults.targetZeta2) * 100;
            
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 36px monospace';
            const displayedData = [
                'Displayed',
                lastGap.toString(),
                lastData.product.toFixed(precision),
                lastCumulative.toFixed(precision),
                lastDistance.toFixed(precision),
                lastPercentComplete.toFixed(precision) + '%'
            ];
            
            xPos = padding;
            displayedData.forEach((cell, colIdx) => {
                const w = (canvasW - 2 * padding) * colWidths[colIdx];
                ctx.fillText(cell, xPos + w / 2, displayedY + 42);
                xPos += w;
            });
            
            // LIMIT row (theoretical target at infinity)
            const limitY = displayedY + rowH;
            ctx.fillStyle = 'rgba(255, 215, 0, 0.1)';
            ctx.fillRect(padding, limitY, canvasW - 2 * padding, rowH);
            
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 4;
            ctx.strokeRect(padding, limitY, canvasW - 2 * padding, rowH);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 36px monospace';
            const limitData = [
                'Limit',
                '∞',
                '1.0',
                analysisResults.targetZeta2.toFixed(precision),
                '0.' + '0'.repeat(precision),
                '100.' + '0'.repeat(precision) + '%'
            ];
            
            xPos = padding;
            limitData.forEach((cell, colIdx) => {
                const w = (canvasW - 2 * padding) * colWidths[colIdx];
                ctx.fillText(cell, xPos + w / 2, limitY + 42);
                xPos += w;
            });
            
            // Footer
            ctx.fillStyle = '#666';
            ctx.font = '28px monospace';
            ctx.textAlign = 'right';
            const dateStr = new Date().toLocaleDateString('en-GB', { 
                day: '2-digit', 
                month: 'long', 
                year: 'numeric' 
            });
            ctx.fillText(dateStr, canvasW - padding, canvasH - 40);
            
            // Export
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const link = document.createElement('a');
            link.download = `step_by_step_table_${analysisResults.maxPrime}_${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
        
        // Composite screenshot generation
        function generateCompositeScreenshot() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const statusBar = document.getElementById('screenshotStatus');
            statusBar.style.display = 'block';
            statusBar.className = 'status-bar computing';
            statusBar.textContent = 'Generating composite screenshot...';
            
            setTimeout(() => {
                try {
                    // Collect selected charts
                    const chartSelections = {
                        convergence: document.getElementById('screenshotConvergence').checked,
                        gapContrib: document.getElementById('screenshotGapContrib').checked,
                        gapDist: document.getElementById('screenshotGapDist').checked,
                        percentage: document.getElementById('screenshotPercentage').checked,
                        error: document.getElementById('screenshotError').checked,
                        logScale: document.getElementById('screenshotLogScale').checked,
                        gapRatio: document.getElementById('screenshotGapRatio').checked,
                        decimalConv: document.getElementById('screenshotDecimalConv').checked
                    };
                    
                    const selectedCharts = [];
                    const chartCanvasIds = {
                        convergence: 'convergenceChart',
                        gapContrib: 'gapContribChart',
                        gapDist: 'gapDistChart',
                        percentage: 'percentageChart',
                        error: 'errorChart',
                        logScale: 'logScaleChart',
                        gapRatio: 'gapRatioChart',
                        decimalConv: 'decimalConvergenceChart'
                    };
                    
                    Object.keys(chartSelections).forEach(key => {
                        if (chartSelections[key]) {
                            selectedCharts.push({
                                name: key,
                                canvasId: chartCanvasIds[key]
                            });
                        }
                    });
                    
                    if (selectedCharts.length === 0) {
                        statusBar.className = 'status-bar';
                        statusBar.style.color = '#ff6464';
                        statusBar.textContent = 'Please select at least one chart';
                        return;
                    }
                    
                    const baseRes = parseInt(document.getElementById('screenshotResolution').value);
                    const scale = baseRes / 1920;
                    
                    const layout = document.getElementById('screenshotLayout').value;
                    const title = document.getElementById('screenshotTitle').value;
                    const subtitle = document.getElementById('screenshotSubtitle').value;
                    
                    // Calculate dimensions
                    let cols, rows;
                    if (layout === 'grid') {
                        cols = 2;
                        rows = Math.ceil(selectedCharts.length / 2);
                    } else if (layout === 'vertical') {
                        cols = 1;
                        rows = selectedCharts.length;
                    } else { // horizontal
                        cols = Math.min(3, selectedCharts.length);
                        rows = Math.ceil(selectedCharts.length / cols);
                    }
                    
                    const chartW = 1920 * scale;
                    const chartH = 1080 * scale;
                    const headerH = 250 * scale;
                    // Adjust footer based on number of charts - less space for single chart
                    const footerH = selectedCharts.length === 1 ? 400 * scale : 600 * scale;
                    const padding = 40 * scale;
                    const statsH = 100 * scale;
                    
                    const canvasW = cols * chartW + (cols + 1) * padding;
                    const canvasH = headerH + statsH + rows * chartH + (rows + 1) * padding + footerH;
                    
                    const canvas = document.getElementById('compositeCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = canvasW;
                    canvas.height = canvasH;
                    
                    // Background
                    ctx.fillStyle = '#0a0a0f';
                    ctx.fillRect(0, 0, canvasW, canvasH);
                    
                    // Header section
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `bold ${72 * scale}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText(title, canvasW / 2, 80 * scale);
                    
                    ctx.fillStyle = '#aaa';
                    ctx.font = `${36 * scale}px sans-serif`;
                    ctx.fillText(subtitle, canvasW / 2, 140 * scale);
                    
                    // Stats summary bar
                    const statsY = headerH + 20 * scale;
                    ctx.fillStyle = '#1a1a2a';
                    ctx.fillRect(padding, statsY, canvasW - 2 * padding, statsH - 40 * scale);
                    
                    ctx.strokeStyle = '#3a3a5a';
                    ctx.lineWidth = 2 * scale;
                    ctx.strokeRect(padding, statsY, canvasW - 2 * padding, statsH - 40 * scale);
                    
                    const statsText = `${analysisResults.totalPrimes.toLocaleString()} primes analyzed | Maximum: ${analysisResults.maxPrime.toLocaleString()} | ${analysisResults.evenGaps.length} gap families | Final error: ${(analysisResults.finalRelativeError * 100).toFixed(8)}%`;
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `${28 * scale}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.fillText(statsText, canvasW / 2, statsY + (statsH - 40 * scale) / 2 + 10 * scale);
                    
                    // Draw charts
                    selectedCharts.forEach((chart, idx) => {
                        const row = Math.floor(idx / cols);
                        const col = idx % cols;
                        
                        const x = col * chartW + (col + 1) * padding;
                        const y = headerH + statsH + row * chartH + (row + 1) * padding;
                        
                        const sourceCanvas = document.getElementById(chart.canvasId);
                        
                        // Draw border
                        ctx.strokeStyle = '#2a2a4a';
                        ctx.lineWidth = 3 * scale;
                        ctx.strokeRect(x - 2 * scale, y - 2 * scale, chartW + 4 * scale, chartH + 4 * scale);
                        
                        // Draw chart
                        ctx.drawImage(sourceCanvas, x, y, chartW, chartH);
                    });
                    
                    // Footer narrative section
                    const footerY = headerH + statsH + rows * chartH + (rows + 1) * padding + 40 * scale;
                    
                    ctx.fillStyle = '#12121a';
                    ctx.fillRect(padding, footerY, canvasW - 2 * padding, footerH - 80 * scale);
                    
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 4 * scale;
                    ctx.strokeRect(padding, footerY, canvasW - 2 * padding, footerH - 80 * scale);
                    
                    // Narrative title
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `bold ${38 * scale}px serif`;
                    ctx.textAlign = 'left';
                    ctx.fillText('Mathematical Observations', padding + 30 * scale, footerY + 50 * scale);
                    
                    // Generate and render narrative
                    const narrative = generateRamanujanNarrative();
                    ctx.fillStyle = '#e0e0e0';
                    // Smaller font for single chart to fit better
                    const fontSize = selectedCharts.length === 1 ? 22 : 26;
                    ctx.font = `${fontSize * scale}px Georgia, serif`;
                    
                    const maxLineWidth = canvasW - 2 * padding - 60 * scale;
                    const lineHeight = (fontSize + 12) * scale;
                    let currentY = footerY + 100 * scale;
                    
                    const paragraphs = narrative.split('\n\n');
                    paragraphs.forEach(para => {
                        const words = para.split(' ');
                        let line = '';
                        
                        for (let i = 0; i < words.length; i++) {
                            const testLine = line + words[i] + ' ';
                            const metrics = ctx.measureText(testLine);
                            
                            if (metrics.width > maxLineWidth && line !== '') {
                                ctx.fillText(line.trim(), padding + 30 * scale, currentY);
                                currentY += lineHeight;
                                line = words[i] + ' ';
                            } else {
                                line = testLine;
                            }
                        }
                        
                        if (line.trim() !== '') {
                            ctx.fillText(line.trim(), padding + 30 * scale, currentY);
                            currentY += lineHeight;
                        }
                        currentY += lineHeight * 0.3;
                    });
                    
                    // Date stamp
                    ctx.fillStyle = '#666';
                    ctx.font = `${22 * scale}px monospace`;
                    ctx.textAlign = 'right';
                    const dateStr = new Date().toLocaleDateString('en-GB', { 
                        day: '2-digit', 
                        month: 'long', 
                        year: 'numeric' 
                    });
                    ctx.fillText(dateStr, canvasW - padding - 30 * scale, canvasH - 30 * scale);
                    
                    // Export
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const resLabel = baseRes >= 3840 ? (baseRes >= 7680 ? '8K' : '4K') : (baseRes >= 2560 ? 'QHD' : 'HD');
                    const link = document.createElement('a');
                    link.download = `gap_decomposition_composite_${analysisResults.maxPrime}_${resLabel}_${timestamp}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    
                    statusBar.className = 'status-bar complete';
                    statusBar.textContent = `Composite screenshot generated: ${selectedCharts.length} charts, ${resLabel} resolution`;
                    
                } catch (error) {
                    statusBar.className = 'status-bar';
                    statusBar.style.color = '#ff6464';
                    statusBar.textContent = `Error: ${error.message}`;
                    console.error(error);
                }
            }, 100);
        }
        
        function generateRamanujanNarrative() {
            const r = analysisResults;
            
            // Extract key numerical insights
            const twinCount = r.gapProducts[2] ? r.gapProducts[2].count : 0;
            const twinPct = r.percentageContributions[2] ? r.percentageContributions[2].toFixed(3) : 0;
            
            const gap4Count = r.gapProducts[4] ? r.gapProducts[4].count : 0;
            const gap4Pct = r.percentageContributions[4] ? r.percentageContributions[4].toFixed(3) : 0;
            
            const gap6Count = r.gapProducts[6] ? r.gapProducts[6].count : 0;
            const gap6Pct = r.percentageContributions[6] ? r.percentageContributions[6].toFixed(3) : 0;
            
            const errorExp = Math.floor(Math.log10(r.finalRelativeError));
            const errorMantissa = (r.finalRelativeError / Math.pow(10, errorExp)).toFixed(2);
            
            // Random variation selector - always Euler style
            const variation = Math.floor(Math.random() * 5);
            
            const eulerVariations = [
                `Concerning the partition of ζ(2) by prime gaps: among ${(r.allPrimesFound || r.totalPrimes).toLocaleString()} primes, the ${twinCount} twin pairs contribute ${twinPct}% logarithmically. With ${r.evenGaps.length} gap families, we achieve ${errorMantissa} × 10^${errorExp} precision relative to π²/6. The geometric rapidity of convergence suggests π emerges from prime gap arithmetic itself.`,
                
                `The decomposition ∏P_g reveals that ${twinCount} twin primes provide ${twinPct}% of log(ζ(2)). Partitioning ${(r.allPrimesFound || r.totalPrimes).toLocaleString()} primes across ${r.evenGaps.length} gap classes yields error ${errorMantissa} × 10^${errorExp}. This elegant structure connects circular geometry to prime distribution.`,
                
                `By gap-class partition, ζ(2) = ∏P_g exhibits rapid convergence. The ${twinCount} twins contribute ${twinPct}%, while ${r.evenGaps.length} families suffice for ${errorMantissa} × 10^${errorExp} precision. A remarkable bridge between discrete gaps and π²/6.`,
                
                `The ${r.evenGaps.length} gap families demonstrate hierarchical contribution: twins (${twinCount} pairs) at ${twinPct}%, cousins (${gap4Count} pairs) at ${gap4Pct}%, sexy primes (${gap6Count} pairs) at ${gap6Pct}%. Convergence to π²/6 proceeds with error ${errorMantissa} × 10^${errorExp}, revealing π's arithmetic foundation.`,
                
                `Among ${(r.allPrimesFound || r.totalPrimes).toLocaleString()} primes examined, the gap decomposition yields ${r.evenGaps.length} distinct families. Twin primes alone account for ${twinPct}% of the logarithmic sum. The finite product approximates π²/6 with merely ${errorMantissa} × 10^${errorExp} relative deviation, a testament to the profound regularity underlying prime distribution.`
            ];
            
            return eulerVariations[variation];
        }
        
        // Initialize
        updateDisplays();

        // ========== ZETA(S) GENERALIZATION ==========
        
        function getKnownZetaValue(s) {
            const knownValues = {
                2: { value: Math.PI**2 / 6, formula: "π²/6" },
                4: { value: Math.PI**4 / 90, formula: "π⁴/90" },
                6: { value: Math.PI**6 / 945, formula: "π⁶/945" },
                8: { value: Math.PI**8 / 9450, formula: "π⁸/9450" },
                10: { value: Math.PI**10 / 93555, formula: "π¹⁰/93555" }
            };
            return knownValues[s] || null;
        }
        
        function setZetaS(value) {
            document.getElementById('zetaS').value = value;
            updateZetaSDisplay();
        }
        
        function updateZetaSDisplay() {
            const s = parseFloat(document.getElementById('zetaS').value);
            document.getElementById('zetaSDisplay').textContent = s.toFixed(2);
            
            const known = getKnownZetaValue(s);
            const infoDiv = document.getElementById('zetaSInfo');
            const behaviorDiv = document.getElementById('zetaSBehavior');
            
            if (known) {
                infoDiv.innerHTML = `<strong>ζ(${s}) = ${known.formula} ≈ ${known.value.toFixed(6)}</strong>`;
            } else {
                const approx = computeApproximateZeta(s);
                infoDiv.innerHTML = `ζ(${s.toFixed(2)}) ≈ ${approx.toFixed(6)}`;
            }
            
            // Update behavioral description
            if (s < 1.3) {
                behaviorDiv.textContent = 'Approaches divergence - all gaps contribute equally';
            } else if (s < 1.8) {
                behaviorDiv.textContent = 'Gap 1 and Gap 2 nearly balanced (~45% vs 39%)';
            } else if (s < 2.5) {
                behaviorDiv.textContent = 'Twin primes (Gap 2) dominate - optimal for twin prime research';
            } else if (s < 3.5) {
                behaviorDiv.textContent = 'Gap 1 begins to dominate - twin prime influence fading';
            } else if (s < 5) {
                behaviorDiv.textContent = 'Gap 1 strongly dominant (~80%) - small primes control ζ(s)';
            } else {
                behaviorDiv.textContent = 'Gap 1 nearly total dominance (>90%) - prime 2 dominates everything';
            }
        }
        
        function computeApproximateZeta(s) {
            // Quick approximation using first 1000 terms
            let sum = 0;
            for (let n = 1; n <= 1000; n++) {
                sum += 1 / Math.pow(n, s);
            }
            return sum;
        }
        
        function computeGapDecompositionWithS(maxPrime, s, gapRangeFilter = null, progressCallback = null) {
            const primes = sievePrimes(maxPrime, progressCallback);
            
            // Get target value
            const known = getKnownZetaValue(s);
            const targetZeta = known ? known.value : computeApproximateZeta(s);
            
            // Calculate gaps and classify primes
            const gapFamilies = {}; // Will be populated by loop - gap 1 gets prime 2 from 3-2=1
            const gaps = [];
            
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i + 1] - primes[i];
                gaps.push(gap);
                
                if (!gapFamilies[gap]) {
                    gapFamilies[gap] = [];
                }
                gapFamilies[gap].push(primes[i]);
            }
            
            // Calculate products for each gap family using p^s/(p^s-1)
            const gapProducts = {};
            
            // Find all unique gaps that actually exist in the data
            const uniqueGaps = new Set(gaps);
            let evenGaps = Array.from(uniqueGaps).sort((a, b) => a - b);
            
            // Apply gap range filter if specified
            if (gapRangeFilter && gapRangeFilter.mode === 'manual') {
                const minGap = gapRangeFilter.min;
                const maxGap = gapRangeFilter.max;
                evenGaps = evenGaps.filter(gap => gap >= minGap && gap <= maxGap);
            }
            
            evenGaps.forEach(gap => {
                if (gapFamilies[gap] && gapFamilies[gap].length > 0) {
                    let product = 1;
                    let logProduct = 0;
                    
                    gapFamilies[gap].forEach(p => {
                        const ps = Math.pow(p, s);
                        const factor = ps / (ps - 1);
                        product *= factor;
                        logProduct += Math.log(factor);
                    });
                    
                    gapProducts[gap] = {
                        product: product,
                        logProduct: logProduct,
                        count: gapFamilies[gap].length,
                        primes: gapFamilies[gap] // Store ALL primes
                    };
                }
            });
            
            // Add last prime contribution
            const lastPrime = primes[primes.length - 1];
            const lastPs = Math.pow(lastPrime, s);
            const lastFactor = lastPs / (lastPs - 1);
            
            // Calculate progressive convergence
            const progressiveProducts = [];
            let cumulative = 1;
            let cumulativeLog = 0;
            
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    cumulative *= gapProducts[gap].product;
                    cumulativeLog += gapProducts[gap].logProduct;
                    
                    progressiveProducts.push({
                        gap: gap,
                        value: cumulative,
                        logValue: cumulativeLog,
                        error: Math.abs(cumulative - targetZeta),
                        relativeError: Math.abs(cumulative - targetZeta) / targetZeta
                    });
                }
            });
            
            // Multiply by last prime
            cumulative *= lastFactor;
            const finalProduct = cumulative;
            const finalError = Math.abs(finalProduct - targetZeta);
            
            // Calculate percentage contributions
            const totalLogProduct = cumulativeLog + Math.log(lastFactor);
            const percentageContributions = {};
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    const contribution = gapProducts[gap].logProduct / totalLogProduct;
                    percentageContributions[gap] = contribution * 100;
                }
            });
            
            return {
                s: s,
                primes: primes,
                totalPrimes: primes.length,
                allPrimesFound: primes.length,  // Total primes found - same as totalPrimes in this function
                maxPrime: maxPrime,
                targetZeta: targetZeta,
                targetZeta2: targetZeta, // Keep for compatibility
                gapFamilies: gapFamilies,
                evenGaps: evenGaps,
                gapProducts: gapProducts,
                progressiveProducts: progressiveProducts,
                percentageContributions: percentageContributions,
                finalProduct: finalProduct,
                finalError: finalError,
                finalRelativeError: finalError / targetZeta
            };
        }
        
        function computeComparisonData(gapRangeFilter = null) {
            const maxPrime = parseInt(document.getElementById('maxPrime').value);
            const sValues = [1.5, 2, 3, 4, 5, 10];
            
            const comparisonResults = {};
            
            sValues.forEach(s => {
                comparisonResults[s] = computeGapDecompositionWithS(maxPrime, s, gapRangeFilter);
            });
            
            return comparisonResults;
        }
        
        function renderComparisonChart() {
            const canvas = document.createElement('canvas');
            canvas.width = 3840;
            canvas.height = 2400;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, 3840, 2400);
            
            const compData = computeComparisonData();
            const sValues = [1.5, 2, 3, 4, 5, 10];
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 72px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Contribution Evolution Across ζ(s)', 1920, 100);
            
            // Draw comparison bars
            const margin = {left: 250, right: 100, top: 200, bottom: 150};
            const chartW = 3840 - margin.left - margin.right;
            const chartH = 2400 - margin.top - margin.bottom;
            
            const barWidth = chartW / (sValues.length * 5); // 5 gaps shown
            
            sValues.forEach((s, sIdx) => {
                const data = compData[s];
                const topGaps = [1, 2, 4, 6, 8].filter(g => data.percentageContributions[g]);
                
                topGaps.forEach((gap, gapIdx) => {
                    const pct = data.percentageContributions[gap] || 0;
                    const x = margin.left + (sIdx * 5 + gapIdx) * barWidth;
                    const barH = (pct / 100) * chartH;
                    const y = margin.top + chartH - barH;
                    
                    const colors = ['#ff4444', '#ffd700', '#4ecdc4', '#8b5cf6', '#06b6d4'];
                    ctx.fillStyle = colors[gapIdx];
                    ctx.fillRect(x, y, barWidth * 0.8, barH);
                });
                
                // Label s value
                ctx.fillStyle = '#aaa';
                ctx.font = 'bold 32px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`s=${s}`, margin.left + (sIdx * 5 + 2) * barWidth, 2400 - 50);
            });
            
            // Legend
            const legendX = margin.left;
            const legendY = 150;
            const gapLabels = ['Gap 1', 'Gap 2', 'Gap 4', 'Gap 6', 'Gap 8'];
            const colors = ['#ff4444', '#ffd700', '#4ecdc4', '#8b5cf6', '#06b6d4'];
            
            gapLabels.forEach((label, i) => {
                ctx.fillStyle = colors[i];
                ctx.fillRect(legendX + i * 180, legendY, 40, 40);
                ctx.fillStyle = '#ccc';
                ctx.font = 'bold 28px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(label, legendX + i * 180 + 50, legendY + 30);
            });
            
            return canvas;
        }
        function applyResearchPreset(preset) {
            const presets = {
                'complete': { maxPrime: 10000000, gapRangeMode: 'auto', minGapRange: 0, maxGapRange: 500, gapFilter: false, minGap: 0, maxGapFilter: 500, desc: 'Complete Analysis - 10 Million Primes (All Gaps)' },
                'twins': { maxPrime: 100000, gapRangeMode: 'manual', minGapRange: 0, maxGapRange: 10, gapFilter: true, minGap: 2, maxGapFilter: 10, desc: 'Twin Prime Focus (Gaps 0-10)' },
                'goldbach': { maxPrime: 500000, gapRangeMode: 'manual', minGapRange: 0, maxGapRange: 30, gapFilter: false, minGap: 0, maxGapFilter: 30, desc: 'Goldbach Range (Gaps 0-30)' },
                'topology': { maxPrime: 1000000, gapRangeMode: 'manual', minGapRange: 30, maxGapRange: 90, gapFilter: true, minGap: 30, maxGapFilter: 90, desc: 'Large Gap Topology (Gaps 30-90)' },
                'extreme': { maxPrime: 5000000, gapRangeMode: 'manual', minGapRange: 100, maxGapRange: 500, gapFilter: true, minGap: 100, maxGapFilter: 500, desc: 'Extreme Range (Gaps 100-500)' },
                'full': { maxPrime: 1000000, gapRangeMode: 'auto', minGapRange: 0, maxGapRange: 200, gapFilter: false, minGap: 0, maxGapFilter: 200, desc: 'Full Spectrum (All Gaps)' },
                'rh': { maxPrime: 2000000, gapRangeMode: 'manual', minGapRange: 0, maxGapRange: 50, gapFilter: false, minGap: 0, maxGapFilter: 50, desc: 'RH Investigation (Gaps 0-50)' }
            };
            const config = presets[preset];
            if (!config) return;
            
            document.getElementById('maxPrime').value = config.maxPrime;
            document.getElementById('maxPrimeDisplay').textContent = config.maxPrime.toLocaleString();
            
            // Set gap range mode
            document.querySelector(`input[name="gapRangeMode"][value="${config.gapRangeMode}"]`).checked = true;
            document.getElementById('minGapRange').value = config.minGapRange;
            document.getElementById('maxGapRange').value = config.maxGapRange;
            updateGapRangeMode();
            
            // Only set gap filter if the checkbox exists
            const gapFilterCheckbox = document.getElementById('enableGapFilter');
            if (gapFilterCheckbox) {
                gapFilterCheckbox.checked = config.gapFilter;
            }
            
            // Only set gap filter values if the inputs exist
            const minGapFilter = document.getElementById('minGapFilter');
            const maxGapFilter = document.getElementById('maxGapFilter');
            if (minGapFilter) minGapFilter.value = config.minGap;
            if (maxGapFilter) maxGapFilter.value = config.maxGapFilter;
            
            if (typeof toggleGapFilter === 'function') {
                toggleGapFilter();
            }
            
            const statusBar = document.getElementById('statusBar');
            if (statusBar) {
                statusBar.style.display = 'block';
                statusBar.style.background = 'rgba(34, 197, 94, 0.2)';
                statusBar.style.borderLeft = '4px solid #22c55e';
                statusBar.textContent = 'Applied preset: ' + config.desc + '. Click "Run Analysis" to compute.';
                setTimeout(() => statusBar.style.display = 'none', 4000);
            }
        }
        
        function updateMaxPrimeDisplay() {
            const value = parseInt(document.getElementById('maxPrime').value);
            document.getElementById('maxPrimeDisplay').textContent = value.toLocaleString();
        }
        
        function updateGapRangeMode() {
            const manualMode = document.querySelector('input[name="gapRangeMode"]:checked').value === 'manual';
            const controls = document.getElementById('manualGapRangeControls');
            controls.style.display = manualMode ? 'block' : 'none';
            
            if (manualMode) {
                validateGapRange();
            }
        }
        
        function validateGapRange() {
            const minGap = parseInt(document.getElementById('minGapRange').value) || 0;
            const maxGap = parseInt(document.getElementById('maxGapRange').value) || 0;
            const errorDiv = document.getElementById('gapRangeError');
            
            // Check if both are even (or min is 0 for gap-1)
            const minValid = minGap === 0 || minGap % 2 === 0;
            const maxValid = maxGap % 2 === 0;
            
            // Check if min < max
            const rangeValid = minGap < maxGap;
            
            if (!minValid || !maxValid || !rangeValid) {
                errorDiv.style.display = 'block';
                return false;
            } else {
                errorDiv.style.display = 'none';
                return true;
            }
        }
        
        function getGapRangeFilter() {
            const mode = document.querySelector('input[name="gapRangeMode"]:checked').value;
            
            if (mode === 'auto') {
                return { mode: 'auto', min: null, max: null };
            } else {
                const min = parseInt(document.getElementById('minGapRange').value) || 0;
                const max = parseInt(document.getElementById('maxGapRange').value) || 50;
                return { mode: 'manual', min: min, max: max };
            }
        }


        // TAB SWITCHING
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById('tab-' + tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // PRIME DENSITY ANALYSIS
        let densityData = null;
        
        function computeDensity() {
            if (!analysisResults || !analysisResults.primes) {
                alert('Please run main analysis first!');
                return;
            }
            
            const primes = analysisResults.primes;
            const maxPrime = primes[primes.length - 1];
            const intervalSize = Math.max(1000, Math.floor(maxPrime / 20));
            
            densityData = [];
            let intervalStart = 2;
            
            while (intervalStart < maxPrime) {
                const intervalEnd = Math.min(intervalStart + intervalSize, maxPrime);
                const primesInInterval = primes.filter(p => p >= intervalStart && p < intervalEnd).length;
                const density = primesInInterval / intervalSize;
                const midpoint = (intervalStart + intervalEnd) / 2;
                const predicted = 1 / Math.log(midpoint);
                
                densityData.push({
                    start: intervalStart,
                    end: intervalEnd,
                    count: primesInInterval,
                    density: density.toFixed(6),
                    predicted: predicted.toFixed(6)
                });
                
                intervalStart = intervalEnd;
            }
            
            document.getElementById('densityStatus').style.display = 'block';
            document.getElementById('densityStatus').innerHTML = `
                <strong>Prime Density Analysis Complete</strong><br>
                Analyzed ${densityData.length} intervals of size ~${intervalSize.toLocaleString()}<br>
                Max prime: ${maxPrime.toLocaleString()}
            `;
            
            renderDensityTable();
            renderDensityChart();
        }

        function renderDensityTable() {
            const tbody = document.getElementById('densityTableBody');
            tbody.innerHTML = '';
            
            densityData.forEach(item => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = item.start.toLocaleString();
                row.insertCell(1).textContent = item.end.toLocaleString();
                row.insertCell(2).textContent = item.count;
                row.insertCell(3).textContent = item.density;
                row.insertCell(4).textContent = item.predicted;
            });
        }

        function renderDensityChart() {
            const canvas = document.getElementById('densityChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const margin = {left: 250, right: 150, top: 200, bottom: 200};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const densities = densityData.map(d => parseFloat(d.density));
            const maxDensity = Math.max(...densities);
            
            const xScale = chartW / densityData.length;
            const yScale = chartH / maxDensity;
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 3;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
            }
            
            // Bars
            densityData.forEach((item, i) => {
                const barH = parseFloat(item.density) * yScale;
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(0, y, 0, y + barH);
                gradient.addColorStop(0, '#ffd700');
                gradient.addColorStop(1, '#ff8800');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + xScale * 0.1, y, xScale * 0.8, barH);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Prime Density by Interval', w / 2, 120);
            
            // Y-axis label
            ctx.save();
            ctx.translate(100, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 60px sans-serif';
            ctx.fillText('Density (primes per unit)', 0, 0);
            ctx.restore();
            
            // X-axis label
            ctx.font = 'bold 60px sans-serif';
            ctx.fillText('Interval Number', w / 2, h - 80);
        }

        function copyDensityList() {
            const text = densityData.map(d => `[${d.start}-${d.end}]: ${d.count} primes, density ${d.density}`).join('\n');
            navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
        }

        function exportDensityCSV() {
            let csv = 'Range Start,Range End,Prime Count,Actual Density,Predicted Density\n';
            densityData.forEach(item => {
                csv += `${item.start},${item.end},${item.count},${item.density},${item.predicted}\n`;
            });
            const blob = new Blob([csv], {type: 'text/csv'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'prime_density.csv';
            a.click();
        }

        // TWIN PRIMES
        let twinsData = null;
        
        function computeTwinPrimes() {
            if (!analysisResults || !analysisResults.primes) {
                alert('Please run main analysis first!');
                return;
            }
            
            const primes = analysisResults.primes;
            twinsData = [];
            
            for (let i = 0; i < primes.length - 1; i++) {
                if (primes[i+1] - primes[i] === 2) {
                    const gapBefore = i > 0 ? primes[i] - primes[i-1] : 0;
                    const gapAfter = i < primes.length - 2 ? primes[i+2] - primes[i+1] : 0;
                    twinsData.push({
                        p: primes[i],
                        q: primes[i+1],
                        gapBefore,
                        gapAfter
                    });
                }
            }
            
            document.getElementById('twinsStatus').style.display = 'block';
            document.getElementById('twinsStatus').innerHTML = `
                <strong>Twin Prime Search Complete</strong><br>
                Found ${twinsData.length} twin prime pairs<br>
                Largest pair: (${twinsData[twinsData.length-1].p}, ${twinsData[twinsData.length-1].q})
            `;
            
            renderTwinsTable();
            renderTwinsChart();
        }

        function renderTwinsTable() {
            const tbody = document.getElementById('twinsTableBody');
            tbody.innerHTML = '';
            
            twinsData.forEach((item, idx) => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = idx + 1;
                row.insertCell(1).textContent = `(${item.p}, ${item.q})`;
                row.insertCell(2).textContent = item.gapBefore || 'N/A';
                row.insertCell(3).textContent = item.gapAfter || 'N/A';
            });
        }

        function renderTwinsChart() {
            const canvas = document.getElementById('twinsChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const margin = {left: 250, right: 150, top: 200, bottom: 200};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Sample every Nth twin to avoid overcrowding
            const sampleRate = Math.max(1, Math.floor(twinsData.length / 100));
            const sampledTwins = twinsData.filter((_, i) => i % sampleRate === 0);
            
            const xScale = chartW / sampledTwins.length;
            const maxP = twinsData[twinsData.length - 1].p;
            const yScale = chartH / maxP;
            
            // Plot twin primes
            ctx.fillStyle = '#ffd700';
            sampledTwins.forEach((twin, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - (twin.p * yScale);
                ctx.fillRect(x, y, xScale * 0.6, 10);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Twin Primes Distribution (${twinsData.length} pairs)`, w/2, 120);
            
            ctx.font = 'bold 50px sans-serif';
            ctx.fillText(`Sampled every ${sampleRate} pairs for visualization`, w/2, h - 80);
        }

        function copyTwinsList() {
            const text = twinsData.map(d => `(${d.p}, ${d.q})`).join('\n');
            navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
        }

        function exportTwinsCSV() {
            let csv = 'Index,Prime 1,Prime 2,Gap Before,Gap After\n';
            twinsData.forEach((item, idx) => {
                csv += `${idx+1},${item.p},${item.q},${item.gapBefore},${item.gapAfter}\n`;
            });
            const blob = new Blob([csv], {type: 'text/csv'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'twin_primes.csv';
            a.click();
        }

        // PRIME GAPS
        let gapsStatsData = null;
        
        function computeGapStats() {
            if (!analysisResults || !analysisResults.primes) {
                alert('Please run main analysis first!');
                return;
            }
            
            const primes = analysisResults.primes;
            const gapCounts = {};
            const firstOccurrence = {};
            
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i+1] - primes[i];
                gapCounts[gap] = (gapCounts[gap] || 0) + 1;
                if (!firstOccurrence[gap]) {
                    firstOccurrence[gap] = `${primes[i]} → ${primes[i+1]}`;
                }
            }
            
            const totalGaps = primes.length - 1;
            gapsStatsData = Object.entries(gapCounts).map(([gap, count]) => ({
                gap: parseInt(gap),
                count,
                percentage: (count / totalGaps * 100).toFixed(2),
                first: firstOccurrence[gap]
            })).sort((a, b) => a.gap - b.gap);
            
            const mostCommon = gapsStatsData.reduce((a,b) => a.count > b.count ? a : b);
            
            document.getElementById('gapsStatus').style.display = 'block';
            document.getElementById('gapsStatus').innerHTML = `
                <strong>Gap Analysis Complete</strong><br>
                Found ${gapsStatsData.length} different gap sizes<br>
                Most common: gap ${mostCommon.gap} (${mostCommon.count} occurrences, ${mostCommon.percentage}%)
            `;
            
            renderGapsTable();
            renderGapsChart();
        }

        function renderGapsTable() {
            const tbody = document.getElementById('gapsTableBody');
            tbody.innerHTML = '';
            
            gapsStatsData.forEach(item => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = item.gap;
                row.insertCell(1).textContent = item.count;
                row.insertCell(2).textContent = item.percentage + '%';
                row.insertCell(3).textContent = item.first;
            });
        }

        function renderGapsChart() {
            const canvas = document.getElementById('gapsChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const margin = {left: 250, right: 150, top: 200, bottom: 200};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Show top 50 most frequent gaps
            const topGaps = [...gapsStatsData].sort((a,b) => b.count - a.count).slice(0, 50);
            
            const xScale = chartW / topGaps.length;
            const maxCount = Math.max(...topGaps.map(g => g.count));
            const yScale = chartH / maxCount;
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 3;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
            }
            
            // Bars
            topGaps.forEach((item, i) => {
                const barH = item.count * yScale;
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(0, y, 0, y + barH);
                gradient.addColorStop(0, '#4ecdc4');
                gradient.addColorStop(1, '#2a7a73');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + xScale * 0.1, y, xScale * 0.8, barH);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Prime Gap Frequency Distribution (Top 50)', w / 2, 120);
            
            ctx.save();
            ctx.translate(100, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 60px sans-serif';
            ctx.fillText('Frequency', 0, 0);
            ctx.restore();
        }

        function copyGapsList() {
            const text = gapsStatsData.map(d => `Gap ${d.gap}: ${d.count} (${d.percentage}%)`).join('\n');
            navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
        }

        function exportGapsCSV() {
            let csv = 'Gap Size,Frequency,Percentage,First Occurrence\n';
            gapsStatsData.forEach(item => {
                csv += `${item.gap},${item.count},${item.percentage},${item.first}\n`;
            });
            const blob = new Blob([csv], {type: 'text/csv'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'gap_statistics.csv';
            a.click();
        }

        // PRIME CONSTELLATIONS
        let constellationsData = null;
        
        function computeConstellations() {
            if (!analysisResults || !analysisResults.primes) {
                alert('Please run main analysis first!');
                return;
            }
            
            const primes = analysisResults.primes;
            const primeSet = new Set(primes);
            
            constellationsData = {
                twins: [],
                cousins: [],
                sexy: [],
                triplets: [],
                quadruplets: []
            };
            
            primes.forEach(p => {
                if (primeSet.has(p+2)) constellationsData.twins.push([p, p+2]);
                if (primeSet.has(p+4)) constellationsData.cousins.push([p, p+4]);
                if (primeSet.has(p+6)) constellationsData.sexy.push([p, p+6]);
                if (primeSet.has(p+2) && primeSet.has(p+6)) constellationsData.triplets.push([p, p+2, p+6]);
                if (primeSet.has(p+2) && primeSet.has(p+6) && primeSet.has(p+8)) constellationsData.quadruplets.push([p, p+2, p+6, p+8]);
            });
            
            document.getElementById('constellationsStatus').style.display = 'block';
            document.getElementById('constellationsStatus').innerHTML = `
                <strong>Constellation Search Complete</strong><br>
                Twins: ${constellationsData.twins.length} | Cousins: ${constellationsData.cousins.length} | Sexy: ${constellationsData.sexy.length}<br>
                Triplets: ${constellationsData.triplets.length} | Quadruplets: ${constellationsData.quadruplets.length}
            `;
            
            renderConstellationsTable();
            renderConstellationsChart();
        }

        function renderConstellationsTable() {
            const tbody = document.getElementById('constellationsTableBody');
            tbody.innerHTML = '';
            
            Object.entries(constellationsData).forEach(([type, items]) => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = type.charAt(0).toUpperCase() + type.slice(1);
                row.insertCell(1).textContent = items.length;
                const examples = items.slice(0, 5).map(p => '(' + p.join(',') + ')').join(' ');
                row.insertCell(2).textContent = examples;
            });
        }

        function renderConstellationsChart() {
            const canvas = document.getElementById('constellationsChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const margin = {left: 300, right: 150, top: 200, bottom: 250};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const types = Object.entries(constellationsData);
            const counts = types.map(([_, items]) => items.length);
            const maxCount = Math.max(...counts);
            
            const barWidth = chartW / types.length;
            const yScale = chartH / maxCount;
            
            // Grid
            ctx.strokeStyle = '#2a2a4a';
            ctx.lineWidth = 3;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxCount - (maxCount * (i / 10));
                ctx.fillStyle = '#888';
                ctx.font = 'bold 40px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(Math.floor(value).toLocaleString(), margin.left - 30, y + 15);
            }
            
            // Bars
            const colors = ['#ffd700', '#ff8800', '#ff4444', '#8b5cf6', '#06b6d4'];
            types.forEach(([name, items], i) => {
                const barH = items.length * yScale;
                const x = margin.left + i * barWidth;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(0, y, 0, y + barH);
                gradient.addColorStop(0, colors[i]);
                gradient.addColorStop(1, colors[i] + '88');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                // Labels
                ctx.fillStyle = '#ccc';
                ctx.font = 'bold 50px sans-serif';
                ctx.textAlign = 'center';
                ctx.save();
                ctx.translate(x + barWidth / 2, h - margin.bottom + 80);
                ctx.rotate(-Math.PI / 4);
                ctx.fillText(name.charAt(0).toUpperCase() + name.slice(1), 0, 0);
                ctx.restore();
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Prime Constellation Counts', w / 2, 120);
            
            ctx.save();
            ctx.translate(100, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 60px sans-serif';
            ctx.fillText('Count', 0, 0);
            ctx.restore();
        }

        function copyConstellationsList() {
            let text = '';
            Object.entries(constellationsData).forEach(([type, items]) => {
                text += `${type}: ${items.length}\n`;
            });
            navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
        }

        function exportConstellationsCSV() {
            let csv = 'Type,Count,Examples (first 10)\n';
            Object.entries(constellationsData).forEach(([type, items]) => {
                const examples = items.slice(0, 10).map(p => '(' + p.join(',') + ')').join('; ');
                csv += `${type},${items.length},"${examples}"\n`;
            });
            const blob = new Blob([csv], {type: 'text/csv'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'prime_constellations.csv';
            a.click();
        }
        
        // Auto-run analysis on page load with 10M default
        window.addEventListener('DOMContentLoaded', function() {
            console.log('Auto-running analysis with 10M primes...');
            
            // Load default preset for custom gap comparison
            loadGapPreset('small_gaps');
            
            setTimeout(() => {
                runAnalysis();
            }, 500); // Small delay to ensure everything is loaded
            
            // Add event listeners for chart toggle checkboxes
            const chartToggles = [
                'showGapContributions',
                'showConvergence',
                'showGapDistribution',
                'showPercentageContrib',
                'showErrorAnalysis',
                'showLogScale',
                'showGapRatio',
                'showDecimalConvergence',
                'showCustomGapCompare'
            ];
            
            chartToggles.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', function() {
                        if (analysisResults) {
                            renderAllCharts();
                        }
                    });
                }
            });
        });

        function renderComparisonChartActual() {
            if (!analysisResults?.comparisonData) {
                document.getElementById('comparisonWrapper').style.display = 'none';
                return;
            }
            
            document.getElementById('comparisonWrapper').style.display = 'block';
            
            const canvas = document.getElementById('comparisonChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = '#0a0a10';
            ctx.fillRect(0, 0, w, h);
            
            const sValues = [1.5, 2, 3, 4, 5, 10];
            const gapColors = {1: '#ff4444', 2: '#ffd700', 4: '#4ecdc4', 6: '#8b5cf6', 8: '#06b6d4'};
            
            const margin = {left: 250, right: 200, top: 200, bottom: 200};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Contribution Evolution: How ζ(s) Changes Gap Dominance', w/2, 120);
            
            // Draw stacked bars for each s
            const barW = chartW / sValues.length * 0.8;
            const spacing = chartW / sValues.length;
            
            sValues.forEach((s, idx) => {
                const data = analysisResults.comparisonData[s];
                const x = margin.left + idx * spacing + spacing * 0.1;
                let yOffset = 0;
                
                [1, 2, 4, 6, 8].forEach(gap => {
                    const pct = data.percentageContributions[gap] || 0;
                    const barH = (pct / 100) * chartH;
                    
                    ctx.fillStyle = gapColors[gap];
                    ctx.fillRect(x, margin.top + chartH - yOffset - barH, barW, barH);
                    
                    yOffset += barH;
                });
                
                // Label
                ctx.fillStyle = '#aaa';
                ctx.font = 'bold 40px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`s=${s}`, x + barW/2, h - 100);
            });
            
            // Legend
            let legendY = margin.top + 50;
            Object.entries(gapColors).forEach(([gap, color]) => {
                ctx.fillStyle = color;
                ctx.fillRect(w - margin.right + 20, legendY, 50, 50);
                ctx.fillStyle = '#ccc';
                ctx.font = 'bold 36px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`Gap ${gap}`, w - margin.right + 80, legendY + 38);
                legendY += 80;
            });
        }
        
        function exportComparisonPNG() {
            const canvas = document.getElementById('comparisonChart');
            const link = document.createElement('a');
            link.download = `zeta_s_comparison_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // ========== CONVERGENCE ANALYSIS FUNCTIONS ==========
        
        function getConvergenceAnalysis(gap, product, s) {
            const TWIN_PRIME_CONSTANT = 0.6601618158468695739278121100145557784326233602847334;
            console.log('getConvergenceAnalysis called with gap:', gap, 'product:', product);
            
            if (gap === 1) {
                const exact = Math.pow(2, s) / (Math.pow(2, s) - 1);
                const error = Math.abs(product - exact);
                
                return `
                    <strong>Observed Value:</strong> P<sub>1</sub>(${s}) = ${product.toFixed(15)}<br><br>
                    
                    <strong>Theoretical:</strong> 2<sup>${s}</sup>/(2<sup>${s}</sup>-1) = ${exact.toFixed(15)}<br><br>
                    
                    <strong>Discrepancy:</strong> ${error.toExponential(3)}<br><br>
                    
                    <strong>Note:</strong> Gap 1 contains only prime 2. The product reduces to a single term: 2<sup>${s}</sup>/(2<sup>${s}</sup>-1).
                `;
            }
            
            if (gap === 2) {
                const C2_FULL = 0.6601618158468695739278121100145557784326233602847334;
                const x = analysisResults.maxPrime;
                const L = Math.log(x);
                const li2_approx = (x/(L*L)) * (1 + 2/L + 6/(L*L) + 24/(L*L*L));
                const twinPrimeCount_predicted = 2 * C2_FULL * li2_approx;
                const twinPrimeCount_actual = analysisResults.gapProducts[gap].count;
                const remaining = (Math.PI**2 / 6) / ((4/3) * product);
                
                return `
                    <strong>Observed:</strong> P<sub>2</sub>(2) = ${product.toFixed(15)}<br><br>
                    
                    <strong>Contribution to log(ζ(2)):</strong><br>
                    log(P<sub>2</sub>) = ${Math.log(product).toFixed(12)}<br>
                    ${((Math.log(product) / Math.log(Math.PI**2/6)) * 100).toFixed(2)}% of total log(π²/6)<br><br>
                    
                    <strong>Combined with P<sub>1</sub>:</strong><br>
                    P<sub>1</sub> × P<sub>2</sub> = ${(4/3 * product).toFixed(15)}<br>
                    Remaining product (P<sub>4</sub> × P<sub>6</sub> × ...): ${remaining.toFixed(15)}<br><br>
                    
                    <strong>Twin Prime Count (up to ${analysisResults.maxPrime.toLocaleString()}):</strong><br>
                    H-L Formula: π₂(x) ~ 2C₂·li₂(x)<br>
                    Predicted: ${Math.round(twinPrimeCount_predicted).toLocaleString()}<br>
                    Observed: ${twinPrimeCount_actual.toLocaleString()}<br>
                    Ratio obs/pred: ${(twinPrimeCount_actual / twinPrimeCount_predicted).toFixed(4)}<br><br>
                    
                    <strong>Note on gap 6 vs gap 2:</strong><br>
                    S(6) = 2·S(2), so gap 6 (sexy primes) is asymptotically <em>twice</em> as frequent as twins or cousins.
                `;
            }
            
            if (gap === 4) {
                return `
                    <strong>Observed:</strong> P<sub>4</sub>(2) = ${product.toFixed(15)}<br><br>
                    
                    <strong>Log contribution:</strong> ${Math.log(product).toFixed(15)}<br><br>
                    
                    <strong>Pattern:</strong> Cousin primes (p, p+4) less frequent than twin primes.<br>
                    Deviation from 1: ${((product - 1) * 100).toFixed(3)}%
                `;
            }
            
            if (gap === 6) {
                return `
                    <strong>Observed:</strong> P<sub>6</sub>(2) = ${product.toFixed(15)}<br><br>
                    
                    <strong>Log contribution:</strong> ${Math.log(product).toFixed(15)}<br><br>
                    
                    <strong>Pattern:</strong> Sexy primes (p, p+6) show notable contribution.<br>
                    Gap divisible by 6 creates modular patterns.<br>
                    Deviation from 1: ${((product - 1) * 100).toFixed(3)}%
                `;
            }
            
            const logContrib = Math.log(product);
            const percentAbove = ((product - 1) * 100);
            
            return `
                <strong>Observed:</strong> P<sub>${gap}</sub>(${s}) = ${product.toFixed(15)}<br><br>
                
                <strong>Log contribution:</strong> ${logContrib.toFixed(15)}<br><br>
                
                <strong>Pattern:</strong> As gap size increases, prime density decreases.<br>
                P<sub>${gap}</sub> approaches 1.<br>
                Deviation from 1: ${percentAbove.toFixed(6)}%
            `;
        }

        // ========== MODAL POPUP FUNCTIONS ==========
        
        // Expand inline detail section for a specific gap in all chart tables
        function expandInlineGapDetail(gap) {
            // This function is now disabled - no dropdowns, no row highlighting
            // Highlighting is done in the chart bars instead
        }
        
        // Close inline detail section
        function closeInlineDetail(gap) {
            const details = document.querySelectorAll(`#gapDetail${gap}`);
            details.forEach(detail => {
                detail.style.animation = 'slideUp 0.3s';
                setTimeout(() => detail.remove(), 300);
            });
            unhighlightAllRows();
        }
        
        // Highlight gap row in all tables
        function highlightGapRow(gap) {
            const tables = document.querySelectorAll('.stats-table');
            tables.forEach(table => {
                const rows = table.querySelectorAll('tr');
                rows.forEach(row => {
                    const firstCell = row.querySelector('td');
                    if (firstCell && firstCell.textContent.trim() === gap.toString()) {
                        row.style.background = 'rgba(78, 205, 196, 0.2)';
                        row.style.outline = '2px solid #4ecdc4';
                    }
                });
            });
        }
        
        // Remove all row highlights
        function unhighlightAllRows() {
            const tables = document.querySelectorAll('.stats-table');
            tables.forEach(table => {
                const rows = table.querySelectorAll('tr');
                rows.forEach(row => {
                    row.style.background = '';
                    row.style.outline = '';
                });
            });
        }
        
        function showGapDetails(gap) {
            console.log('=== showGapDetails DEBUG ===');
            console.log('Input gap:', gap, 'type:', typeof gap);
            
            if (!analysisResults) {
                console.error('No analysisResults!');
                return;
            }
            
            // Ensure gap is a number (might come as string from onclick attribute)
            gap = parseInt(gap);
            console.log('After parseInt, gap:', gap, 'type:', typeof gap);
            
            // First, expand inline detail sections
            expandInlineGapDetail(gap);
            
            // Then show modal popup
            const modal = document.getElementById('gapModal');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');
            
            console.log('Available keys in gapProducts:', Object.keys(analysisResults.gapProducts));
            console.log('Attempting to retrieve gapProducts[' + gap + ']...');
            
            const gapData = analysisResults.gapProducts[gap];
            console.log('Retrieved gapData:', gapData);
            
            if (gapData) {
                console.log('gapData.product:', gapData.product);
                console.log('gapData.count:', gapData.count);
                console.log('gapData.primes (first 5):', gapData.primes?.slice(0, 5));
            }
            
            if (!gapData) {
                console.error('No gapData found for gap:', gap);
                alert(`No data available for gap ${gap}`);
                return;
            }
            
            const s = analysisResults.s || 2;
            const known = getKnownZetaValue(s);
            const zetaLabel = known ? `ζ(${s}) = ${known.formula}` : `ζ(${s.toFixed(2)})`;
            
            // Calculate additional statistics
            const pctContribution = analysisResults.percentageContributions[gap] || 0;
            const avgPrimeInGap = gapData.primes.reduce((a, b) => a + b, 0) / gapData.primes.length;
            
            // Find constellation type
            let gapType = '';
            if (gap === 1) gapType = 'Only Odd Gap (3-2=1)';
            else if (gap === 2) gapType = 'Twin Primes (p, p+2)';
            else if (gap === 4) gapType = 'Cousin Primes (p, p+4)';
            else if (gap === 6) gapType = 'Sexy Primes (p, p+6)';
            else if (gap % 6 === 0) gapType = 'Divisible by 6';
            else gapType = 'General Gap';
            
            title.textContent = `Gap ${gap} - Detailed Analysis`;
            
            body.innerHTML = `
                <div id="modalPart1">
                <div class="modal-section">
                    <div class="modal-section-title">Basic Information</div>
                    <div class="modal-stat-grid">
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Gap Size</div>
                            <div class="modal-stat-value">${gap}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Constellation Type</div>
                            <div class="modal-stat-value" style="font-size: 1rem;">${gapType}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Prime Count in Gap Family (up to ${analysisResults.maxPrime.toLocaleString()})</div>
                            <div class="modal-stat-value">${gapData.count.toLocaleString()}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Current s Value</div>
                            <div class="modal-stat-value">s = ${s.toFixed(2)}</div>
                        </div>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Gap Product: P<sub>${gap}</sub>(s)</div>
                    <div class="modal-stat-grid">
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Product Value P<sub>${gap}</sub></div>
                            <div class="modal-stat-value">${gapData.product.toFixed(12)}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Log Product (log P<sub>${gap}</sub>)</div>
                            <div class="modal-stat-value">${gapData.logProduct.toFixed(12)}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Contribution to log(${zetaLabel})</div>
                            <div class="modal-stat-value">${pctContribution.toFixed(6)}%</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Formula</div>
                            <div class="modal-stat-value" style="font-size: 0.9rem;">∏<sub>p∈Gap${gap}</sub> p<sup>${s.toFixed(1)}</sup>/(p<sup>${s.toFixed(1)}</sup>-1)</div>
                        </div>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Statistical Properties</div>
                    <div class="modal-stat-grid">
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Average Prime in Gap</div>
                            <div class="modal-stat-value">${avgPrimeInGap.toFixed(2)}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Smallest Prime</div>
                            <div class="modal-stat-value">${Math.min(...gapData.primes).toLocaleString()}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Largest Prime in Range</div>
                            <div class="modal-stat-value">${Math.max(...gapData.primes).toLocaleString()}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">
                                Density (primes per 
                                <input type="number" id="densityRange_${gap}" value="1000" min="1" max="1000000" 
                                       style="width: 80px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; padding: 4px 8px; color: #ffd700; font-family: 'Courier New', monospace; margin: 0 4px;"
                                       onchange="updateDensity(${gap}, this.value)">)
                            </div>
                            <div class="modal-stat-value" id="densityValue_${gap}">${((gapData.count / analysisResults.maxPrime) * 1000).toFixed(3)}</div>
                        </div>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div class="modal-section-title" style="margin-bottom: 0;">All ${gapData.count.toLocaleString()} Primes in Gap ${gap} Family (up to ${analysisResults.maxPrime.toLocaleString()})</div>
                        <button class="btn btn-secondary" onclick="copyPrimesToClipboard(${gap})" style="padding: 6px 12px; font-size: 0.85rem;">
                            Copy All Primes
                        </button>
                    </div>
                    <div class="modal-prime-list" id="primeList${gap}">
                        <code>${gapData.primes.map(p => p.toLocaleString()).join(', ')}</code>
                    </div>
                    <div style="margin-top: 8px; font-size: 0.8rem; color: #888;">
                        Showing all ${gapData.count.toLocaleString()} primes. Scroll to see more.
                    </div>
                </div>
                </div>
                
                <div id="modalPart2">
                <div class="modal-section">
                    <div class="modal-section-title">Convergence Analysis: What does P<sub>${gap}</sub> converge to?</div>
                    <div style="background: rgba(255, 215, 0, 0.05); padding: 16px; border-radius: 6px; border-left: 3px solid #ffd700; color: #ccc; line-height: 1.8;">
                        ${getConvergenceAnalysis(gap, gapData.product, s)}
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Mathematical Context</div>
                    <div style="background: rgba(139, 92, 246, 0.05); padding: 16px; border-radius: 6px; border-left: 3px solid #8b5cf6; color: #ccc; line-height: 1.8;">
                        <strong>Gap Decomposition Theorem:</strong><br>
                        ζ(s) = ∏<sub>g∈{1,2,4,6,...}</sub> P<sub>g</sub>(s)<br><br>
                        
                        For this gap:<br>
                        P<sub>${gap}</sub>(${s.toFixed(2)}) = ${gapData.product.toFixed(6)}<br>
                        Contributing ${pctContribution.toFixed(2)}% to the logarithmic product.<br><br>
                        
                        ${gap === 1 ? '<strong style="color: #ffd700;">Special Note:</strong> Gap 1 contains only prime 2, the only even prime and the only odd gap (3-2=1).' : ''}
                        ${gap === 2 ? '<strong style="color: #ffd700;">Twin Prime Note:</strong> These are primes p where p+2 is also prime. They dominate ζ(2) decomposition!' : ''}
                        ${gap === 6 ? '<strong style="color: #4ecdc4;">Sexy Prime Note:</strong> These are primes p where p+6 is also prime, named "sexy" from Latin "sex" (six).' : ''}
                    </div>
                </div>
                </div>
            `;
            
            modal.classList.add('active');
        }
        
        function closeGapModal(event) {
            if (event && event.target.className !== 'modal-overlay') return;
            document.getElementById('gapModal').classList.remove('active');
        }
        
        function screenshotModalPart1() {
            const modalHeader = document.querySelector('.modal-header');
            const modalPart1 = document.getElementById('modalPart1');
            
            if (!modalPart1) {
                alert('Modal content not found');
                return;
            }
            
            // Clone header and part 1
            const headerClone = modalHeader.cloneNode(true);
            const part1Clone = modalPart1.cloneNode(true);
            
            // Find the prime list container and preserve its current scroll state/visible content
            const originalPrimeList = modalPart1.querySelector('.modal-prime-list');
            const clonedPrimeList = part1Clone.querySelector('.modal-prime-list');
            
            if (originalPrimeList && clonedPrimeList) {
                // Set max-height to match what's visible (not expanded)
                const visibleHeight = originalPrimeList.clientHeight;
                clonedPrimeList.style.maxHeight = visibleHeight + 'px';
                clonedPrimeList.style.overflow = 'hidden';
                
                // Preserve scroll position
                clonedPrimeList.scrollTop = originalPrimeList.scrollTop;
            }
            
            // Create a temporary container with header and part 1
            const tempContainer = document.createElement('div');
            tempContainer.style.cssText = 'position: absolute; left: -9999px; background: #1a1a2e; padding: 24px; max-width: 1200px;';
            
            tempContainer.appendChild(headerClone);
            tempContainer.appendChild(part1Clone);
            document.body.appendChild(tempContainer);
            
            // Use html2canvas to capture
            html2canvas(tempContainer, {
                scale: 3, // 4K quality (3x scale)
                backgroundColor: '#1a1a2e',
                logging: false,
                useCORS: true,
                width: tempContainer.scrollWidth,
                height: tempContainer.scrollHeight
            }).then(canvas => {
                // Remove temp container
                document.body.removeChild(tempContainer);
                
                // Convert to blob and download
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const modalTitle = document.getElementById('modalTitle').textContent.replace(/[^a-zA-Z0-9]/g, '_');
                    link.download = `${modalTitle}_Part1_${timestamp}_4K.png`;
                    link.href = url;
                    link.click();
                });
            });
        }
        
        function screenshotModalPart2() {
            const modalHeader = document.querySelector('.modal-header');
            const modalPart2 = document.getElementById('modalPart2');
            
            if (!modalPart2) {
                alert('Modal content not found');
                return;
            }
            
            // Create a temporary container with header and part 2
            const tempContainer = document.createElement('div');
            tempContainer.style.cssText = 'position: absolute; left: -9999px; background: #1a1a2e; padding: 24px;';
            
            // Clone header and part 2
            const headerClone = modalHeader.cloneNode(true);
            const part2Clone = modalPart2.cloneNode(true);
            
            tempContainer.appendChild(headerClone);
            tempContainer.appendChild(part2Clone);
            document.body.appendChild(tempContainer);
            
            // Use html2canvas to capture
            html2canvas(tempContainer, {
                scale: 3, // 4K quality (3x scale)
                backgroundColor: '#1a1a2e',
                logging: false,
                useCORS: true,
                width: tempContainer.scrollWidth,
                height: tempContainer.scrollHeight
            }).then(canvas => {
                // Remove temp container
                document.body.removeChild(tempContainer);
                
                // Convert to blob and download
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const modalTitle = document.getElementById('modalTitle').textContent.replace(/[^a-zA-Z0-9]/g, '_');
                    link.download = `${modalTitle}_Part2_${timestamp}_4K.png`;
                    link.href = url;
                    link.click();
                });
            });
        }
        
        // Update density calculation when user changes the range
        function updateDensity(gap, range) {
            const gapData = analysisResults.gapProducts[gap];
            if (!gapData) return;
            
            const density = (gapData.count / analysisResults.maxPrime) * parseFloat(range);
            document.getElementById(`densityValue_${gap}`).textContent = density.toFixed(3);
        }
        
        // Screenshot the classical or gap view at the bottom
        function screenshotClassicalView() {
            // Check which view is currently shown
            const classicalView = document.getElementById('classicalView');
            const isClassicalViewVisible = classicalView.style.display !== 'none';
            
            if (!isClassicalViewVisible) {
                alert('Please switch to Classical Sequential View mode to take a screenshot of it.');
                return;
            }
            
            const tableWrapper = document.getElementById('classicalTableWrapper');
            const table = document.getElementById('classicalTable');
            
            if (!table || !tableWrapper) {
                alert('Classical view table not found.');
                return;
            }
            
            // Create a temporary container with visible rows + summary
            const tempContainer = document.createElement('div');
            tempContainer.style.cssText = 'background: #0a0a0f; padding: 20px; position: absolute; left: -9999px; top: 0;';
            
            // Add title
            const titleDiv = document.createElement('div');
            titleDiv.style.cssText = 'color: #4ecdc4; font-size: 1.8rem; font-weight: bold; margin-bottom: 20px; text-align: center;';
            titleDiv.textContent = 'Classical Sequential Prime View';
            tempContainer.appendChild(titleDiv);
            
            // Clone the table structure
            const tableClone = document.createElement('table');
            tableClone.style.cssText = table.style.cssText;
            tableClone.innerHTML = table.querySelector('thead').outerHTML;
            
            const tbody = document.createElement('tbody');
            
            // Get visible rows from the scrollable container
            const rows = Array.from(table.querySelectorAll('tbody tr'));
            const scrollTop = tableWrapper.scrollTop;
            const containerHeight = tableWrapper.clientHeight;
            
            // Find visible rows
            let visibleRows = [];
            rows.forEach(row => {
                const rowTop = row.offsetTop;
                const rowBottom = rowTop + row.offsetHeight;
                if (rowBottom > scrollTop && rowTop < scrollTop + containerHeight) {
                    visibleRows.push(row);
                }
            });
            
            // Add visible rows
            visibleRows.forEach(row => {
                tbody.appendChild(row.cloneNode(true));
            });
            
            tableClone.appendChild(tbody);
            
            const tableDiv = document.createElement('div');
            tableDiv.style.cssText = 'background: rgba(0, 0, 0, 0.2); border-radius: 6px; padding: 16px; margin-bottom: 20px;';
            tableDiv.appendChild(tableClone);
            tempContainer.appendChild(tableDiv);
            
            // Add convergence summary
            if (analysisResults) {
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = 'background: rgba(78, 205, 196, 0.1); padding: 16px; border-radius: 6px; border: 1px solid #4ecdc4; text-align: center;';
                const target = Math.PI * Math.PI / 6;
                const finalProduct = analysisResults.finalProduct;
                const error = Math.abs(finalProduct - target);
                summaryDiv.innerHTML = `
                    <div style="color: #4ecdc4; font-size: 1.2rem; font-weight: bold; margin-bottom: 8px;">
                        Convergence to ζ(2) = π²/6
                    </div>
                    <div style="color: #ffd700; font-family: 'Courier New', monospace; font-size: 1rem;">
                        Product: ${finalProduct.toFixed(12)}
                    </div>
                    <div style="color: #ffd700; font-family: 'Courier New', monospace; font-size: 1rem;">
                        Target:  ${target.toFixed(12)}
                    </div>
                    <div style="color: #ccc; font-size: 0.9rem; margin-top: 8px;">
                        Error: ${error.toExponential(4)}
                    </div>
                `;
                tempContainer.appendChild(summaryDiv);
            }
            
            document.body.appendChild(tempContainer);
            
            // Use html2canvas to capture the temp container
            html2canvas(tempContainer, {
                scale: 2,
                backgroundColor: '#0a0a0f',
                logging: false
            }).then(canvas => {
                document.body.removeChild(tempContainer);
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    link.download = `Classical_Prime_Sequence_${timestamp}.png`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                });
            });
        }
        
        // Copy all primes in gap family to clipboard
        function copyPrimesToClipboard(gap) {
            if (!analysisResults || !analysisResults.gapProducts[gap]) return;
            
            const primes = analysisResults.gapProducts[gap].primes;
            
            // Format options: comma-separated or one-per-line
            const commaFormat = primes.join(', ');
            const lineFormat = primes.join('\n');
            
            // Copy comma-separated by default
            navigator.clipboard.writeText(commaFormat).then(() => {
                // Show feedback
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '✓ Copied!';
                button.style.background = '#22c55e';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
            }).catch(err => {
                alert('Failed to copy. Error: ' + err);
            });
        }
        
        // Make charts clickable
        function addChartClickHandlers() {
            const chartIds = ['gapContribChart', 'gapDistChart', 'percentageChart', 'errorChart', 'logScaleChart'];
            
            chartIds.forEach(chartId => {
                const canvas = document.getElementById(chartId);
                if (!canvas) return;
                
                canvas.style.cursor = 'pointer';
                canvas.onclick = (e) => handleChartClick(e, chartId);
            });
        }
        
        function handleChartClick(event, canvasId) {
            if (!analysisResults) return;
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Scale to canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = x * scaleX;
            const canvasY = y * scaleY;
            
            // Determine which gap was clicked based on chart type
            const gaps = getFilteredGaps();
            if (!gaps || gaps.length === 0) return;
            
            // Use the CORRECT margins that match the render functions
            const margin = {left: 200, right: 100, top: 100, bottom: 150};
            const chartW = canvas.width - margin.left - margin.right;
            const chartH = canvas.height - margin.top - margin.bottom;
            
            // Check if click is in chart area
            if (canvasX < margin.left || canvasX > canvas.width - margin.right ||
                canvasY < margin.top || canvasY > canvas.height - margin.bottom) {
                return;
            }
            
            // Bars are rendered with full barWidth spacing between centers
            // Each bar uses barWidth * 0.8 centered within barWidth space
            const barWidth = chartW / gaps.length;
            
            // Determine which bar slot was clicked
            const relativeX = canvasX - margin.left;
            const clickedIndex = Math.floor(relativeX / barWidth);
            
            // Check if click is within the actual bar (not the 10% margin on sides)
            const barStartX = clickedIndex * barWidth;
            const clickXInBar = relativeX - barStartX;
            const barActualStart = barWidth * 0.1;
            const barActualEnd = barWidth * 0.9;
            
            // Ensure index is valid and click is on the actual bar
            if (clickedIndex >= 0 && clickedIndex < gaps.length && 
                clickXInBar >= barActualStart && clickXInBar <= barActualEnd) {
                const clickedGap = parseInt(gaps[clickedIndex]);
                console.log('Chart bar clicked, gap:', clickedGap, 'from chart:', canvasId, 'index:', clickedIndex, 'of', gaps.length);
                showGapDetails(clickedGap);
            }
        }
        
        // Chart Animation System
        const chartAnimations = {
            convergenceChart: { isPlaying: false, currentRange: 100, intervalId: null, speed: 1.0 },
            gapContribChart: { isPlaying: false, currentRange: 100, intervalId: null, speed: 1.0 },
            gapDistChart: { isPlaying: false, currentRange: 100, intervalId: null, speed: 1.0 },
            percentageChart: { isPlaying: false, currentRange: 100, intervalId: null, speed: 1.0 },
            errorChart: { isPlaying: false, currentRange: 100, intervalId: null, speed: 1.0 },
            logScaleChart: { isPlaying: false, currentRange: 100, intervalId: null, speed: 1.0 }
        };
        
        function toggleChartAnimation(chartId) {
            const anim = chartAnimations[chartId];
            if (!anim) return;
            
            const btn = event.target.closest('.chart-play-pause-btn');
            
            if (anim.isPlaying) {
                // Pause
                anim.isPlaying = false;
                btn.classList.remove('playing');
                btn.innerHTML = 'Play';
                if (anim.intervalId) {
                    clearInterval(anim.intervalId);
                    anim.intervalId = null;
                }
            } else {
                // Play
                if (!analysisResults) {
                    alert('Please run the analysis first!');
                    return;
                }
                
                // Reset to starting range
                anim.currentRange = 100;
                
                anim.isPlaying = true;
                btn.classList.add('playing');
                btn.innerHTML = 'Pause';
                startChartAnimation(chartId);
            }
        }
        
        function startChartAnimation(chartId) {
            const anim = chartAnimations[chartId];
            if (!anim) return;
            
            const maxRange = parseInt(document.getElementById('maxPrime').value);
            const baseInterval = 100; // Base update interval in ms
            const interval = baseInterval / anim.speed;
            
            anim.intervalId = setInterval(() => {
                if (anim.currentRange >= maxRange) {
                    // Animation complete - reset to start and stop
                    anim.currentRange = 100;
                    const btn = document.querySelector(`[onclick="toggleChartAnimation('${chartId}')"]`);
                    if (btn) {
                        anim.isPlaying = false;
                        btn.classList.remove('playing');
                        btn.innerHTML = 'Play';
                    }
                    clearInterval(anim.intervalId);
                    anim.intervalId = null;
                    
                    // Re-render with full range
                    renderIndividualChart(chartId, maxRange);
                    return;
                }
                
                // Increment range
                const increment = Math.max(1, Math.floor(maxRange / 100));
                anim.currentRange = Math.min(anim.currentRange + increment, maxRange);
                
                // Re-render chart with current range
                renderIndividualChart(chartId, anim.currentRange);
            }, interval);
        }
        
        function updateChartSpeed(chartId) {
            const anim = chartAnimations[chartId];
            if (!anim) return;
            
            const slider = document.getElementById(chartId + 'SpeedSlider');
            const speedDisplay = document.getElementById(chartId + 'Speed');
            
            anim.speed = parseFloat(slider.value);
            speedDisplay.textContent = anim.speed.toFixed(1) + 'x';
            
            // If playing, restart with new speed
            if (anim.isPlaying) {
                clearInterval(anim.intervalId);
                anim.intervalId = null;
                startChartAnimation(chartId);
            }
        }
        
        function renderIndividualChart(chartId, maxPrime) {
            // Get current s value
            const s = analysisResults.s || 2;
            
            // Calculate gap decomposition for the specified range
            const tempResults = computeGapDecompositionWithS(maxPrime, s);
            
            // Store original results
            const originalResults = analysisResults;
            
            // Temporarily use the new results for rendering
            analysisResults = tempResults;
            
            // Render the specific chart - these functions use the global analysisResults
            switch(chartId) {
                case 'convergenceChart':
                    renderConvergenceChart();
                    break;
                case 'gapContribChart':
                    renderGapContribChart();
                    break;
                case 'gapDistChart':
                    renderGapDistChart();
                    break;
                case 'percentageChart':
                    renderPercentageChart();
                    break;
                case 'errorChart':
                    renderErrorChart();
                    break;
                case 'logScaleChart':
                    renderLogScaleChart();
                    break;
            }
            
            // Restore original results
            analysisResults = originalResults;
        }
        
        // Event delegation for gap row clicks - highlights bar in associated chart AND opens modal
        document.addEventListener('click', function(e) {
            const row = e.target.closest('.gap-row');
            if (row && row.dataset.gap) {
                const gap = parseInt(row.dataset.gap);
                console.log('Row clicked, gap:', gap);
                
                // Find which table this row belongs to
                const tableContainer = row.closest('.stats-table-container');
                if (tableContainer && tableContainer.dataset.chart) {
                    const chartId = tableContainer.dataset.chart;
                    console.log('Chart to highlight:', chartId);
                    
                    // Re-render the specific chart with this gap highlighted
                    highlightGapInChart(chartId, gap);
                }
                
                // Always open the modal popup when clicking a row
                showGapDetails(gap);
            }
        });
        
        // Highlight a specific gap in a specific chart
        function highlightGapInChart(chartId, gap) {
            switch(chartId) {
                case 'gapContribChart':
                    renderGapContributionsChart(gap);
                    break;
                case 'gapDistChart':
                    renderGapDistributionChart(gap);
                    break;
                case 'percentageChart':
                    renderPercentageChart(gap);
                    break;
            }
        }
        // ============================================================
        // MERTENS FUNCTION MODULE — all vars/functions prefixed m_
        // ============================================================
        (function() {
            // Data stores
            const m_mobius  = [];
            const m_mertens = [];
            const m_sqFree  = [];
            const m_nFactors = [];
            let   m_maxComputed = 0;

            // State
            let m_currentRange = 2000;
            let m_animId = null;
            let m_isAnimating = false;
            let m_animSpeed = 50;
            let m_selectedRow = null;
            let m_sortCol = 'n';
            let m_sortAsc = true;

            // Expose to global scope so onclick="" handlers work
            window.m_onRangeSlider  = v => { m_currentRange = parseInt(v); document.getElementById('m_rangeValue').textContent = v; document.getElementById('m_manualInput').value = v; m_drawGraph(); m_updateStats(); m_populateTable(); };
            window.m_onManualInput  = v => { const n = parseInt(v); if (n >= 100 && n <= 100000) { m_currentRange = n; document.getElementById('m_rangeValue').textContent = n; if (n <= 10000) document.getElementById('m_rangeSlider').value = n; m_drawGraph(); m_updateStats(); m_populateTable(); } };
            window.m_onSpeedSlider  = v => { m_animSpeed = parseInt(v); document.getElementById('m_speedValue').textContent = v; };
            window.m_startAnimation = m_startAnimation;
            window.m_stopAnimation  = m_stopAnimation;
            window.m_startBackwardAnimation = m_startBackwardAnimation;
            window.m_drawGraph      = m_drawGraph;
            window.m_populateTable  = m_populateTable;
            window.m_sortTable      = col => { if (m_sortCol === col) m_sortAsc = !m_sortAsc; else { m_sortCol = col; m_sortAsc = true; } m_populateTable(); };
            window.m_exportCSV      = m_exportCSV;

            // ----- Computation -----
            function m_primeFactors(n) {
                const f = []; let d = 2;
                while (d * d <= n) { while (n % d === 0) { f.push(d); n /= d; } d++; }
                if (n > 1) f.push(n);
                return f;
            }

            function m_computeMobius(n) {
                if (n === 1) return 1;
                const f = m_primeFactors(n);
                const u = [...new Set(f)];
                if (f.length !== u.length) return 0;
                return u.length % 2 === 0 ? 1 : -1;
            }

            function m_extendTo(target) {
                if (target <= m_maxComputed) return;
                for (let n = m_maxComputed + 1; n <= target; n++) {
                    const mu  = m_computeMobius(n);
                    const M   = (n === 1 ? 0 : m_mertens[n - 2]) + mu;
                    const f   = m_primeFactors(n);
                    const u   = [...new Set(f)];
                    m_mobius.push(mu);
                    m_mertens.push(M);
                    m_sqFree.push(mu !== 0 ? 1 : 0);
                    m_nFactors.push(u.length);
                }
                m_maxComputed = target;
            }

            // ----- Stats -----
            function m_updateStats() {
                m_extendTo(m_currentRange);
                const d = m_mertens.slice(0, m_currentRange);
                const s = m_sqFree.slice(0, m_currentRange);
                let maxV = d[0], minV = d[0], maxI = 0, minI = 0;
                let zeros = 0, within = 0;
                for (let i = 0; i < d.length; i++) {
                    if (d[i] > maxV) { maxV = d[i]; maxI = i; }
                    if (d[i] < minV) { minV = d[i]; minI = i; }
                    if (d[i] === 0) zeros++;
                    if (Math.abs(d[i]) <= Math.sqrt(i + 1)) within++;
                }
                const sqF = s.reduce((a, b) => a + b, 0);
                document.getElementById('m_statRange').textContent   = `n = 1 to ${m_currentRange.toLocaleString()}`;
                document.getElementById('m_statMax').textContent     = `M(${maxI+1}) = ${maxV}`;
                document.getElementById('m_statMin').textContent     = `M(${minI+1}) = ${minV}`;
                document.getElementById('m_statZeros').textContent   = `${zeros} points`;
                document.getElementById('m_statSquareFree').textContent = `${sqF.toLocaleString()} / ${m_currentRange.toLocaleString()}`;
                document.getElementById('m_statBoundary').textContent = `${((within / m_currentRange) * 100).toFixed(1)}%`;
            }

            // ----- Graph -----
            function m_drawGraph() {
                m_extendTo(m_currentRange);
                const canvas = document.getElementById('m_graphCanvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const W = canvas.width, H = canvas.height, pad = 65;
                const gW = W - 2*pad, gH = H - 2*pad;
                ctx.clearRect(0, 0, W, H);

                const d = m_mertens.slice(0, m_currentRange);
                const maxV = Math.max(...d,  Math.sqrt(m_currentRange));
                const minV = Math.min(...d, -Math.sqrt(m_currentRange));
                const range = maxV - minV || 1;

                const toY = v => pad + ((maxV - v) / range) * gH;
                const toX = i => pad + ((i + 1) / m_currentRange) * gW;

                // Grid lines
                ctx.strokeStyle = '#1a1a2a'; ctx.lineWidth = 1;
                const yStep = range > 40 ? 5 : range > 15 ? 2 : 1;
                for (let v = Math.ceil(minV); v <= Math.floor(maxV); v += yStep) {
                    const y = toY(v);
                    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(W - pad, y); ctx.stroke();
                }

                // Axes
                ctx.strokeStyle = '#3a3a5a'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(pad, H - pad); ctx.lineTo(W - pad, H - pad); ctx.stroke();

                // Zero line
                const zeroY = toY(0);
                ctx.strokeStyle = '#4a4a6a'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(pad, zeroY); ctx.lineTo(W - pad, zeroY); ctx.stroke();
                ctx.setLineDash([]);

                // Y labels
                ctx.fillStyle = '#888'; ctx.font = '11px monospace'; ctx.textAlign = 'right';
                for (let v = Math.ceil(minV); v <= Math.floor(maxV); v += yStep) {
                    ctx.fillText(v, pad - 8, toY(v) + 4);
                }

                // X labels
                ctx.textAlign = 'center';
                const xStep = m_currentRange > 10000 ? 2000 : m_currentRange > 1000 ? 500 : 200;
                for (let i = 0; i <= m_currentRange; i += xStep) {
                    ctx.fillText(i.toLocaleString(), pad + (i / m_currentRange) * gW, H - pad + 18);
                }

                // Axis titles
                ctx.fillStyle = '#666'; ctx.font = '11px sans-serif';
                ctx.textAlign = 'right'; ctx.fillText('M(n)', pad - 8, pad - 10);
                ctx.textAlign = 'center'; ctx.fillText('n', W - pad + 30, H - pad + 18);

                // √n boundaries
                if (document.getElementById('m_showBounds').checked) {
                    ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.5;
                    const step = Math.max(3, Math.floor(m_currentRange / 500));
                    [1, -1].forEach(sign => {
                        ctx.beginPath();
                        for (let i = 1; i <= m_currentRange; i += step) {
                            const x = pad + (i / m_currentRange) * gW;
                            const y = toY(sign * Math.sqrt(i));
                            i === 1 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    });
                    ctx.globalAlpha = 1;
                    // Label
                    ctx.fillStyle = '#ef4444'; ctx.font = '11px sans-serif'; ctx.textAlign = 'left'; ctx.globalAlpha = 0.7;
                    ctx.fillText('±√n (RH boundary)', pad + 6, toY(Math.sqrt(m_currentRange)) - 6);
                    ctx.globalAlpha = 1;
                }

                // Zero crossing highlights
                if (document.getElementById('m_showZeros').checked) {
                    ctx.fillStyle = '#22c55e'; ctx.globalAlpha = 0.25;
                    for (let i = 0; i < m_currentRange; i++) {
                        if (d[i] === 0) {
                            const x = toX(i);
                            ctx.fillRect(x - 1, pad, 2, gH);
                        }
                    }
                    ctx.globalAlpha = 1;
                }

                // Mertens line
                ctx.strokeStyle = '#4ecdc4'; ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < m_currentRange; i++) {
                    const x = toX(i), y = toY(d[i]);
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Selected point
                if (m_selectedRow !== null && m_selectedRow <= m_currentRange) {
                    const x = pad + (m_selectedRow / m_currentRange) * gW;
                    const y = toY(d[m_selectedRow - 1]);
                    ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(x, y, 7, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#b8860b'; ctx.lineWidth = 2; ctx.stroke();
                }
            }

            // ----- Animation -----
            function m_startAnimation() {
                if (m_isAnimating) return;
                m_isAnimating = true;
                document.getElementById('m_playBtn').style.display = 'none';
                document.getElementById('m_pauseBtn').style.display = 'inline-block';
                const max = parseInt(document.getElementById('m_rangeSlider').max);
                function step() {
                    if (!m_isAnimating) return;
                    if (m_currentRange < max) {
                        m_currentRange = Math.min(m_currentRange + Math.max(10, Math.floor(max / 300)), max);
                        document.getElementById('m_rangeSlider').value = Math.min(m_currentRange, 10000);
                        document.getElementById('m_rangeValue').textContent = m_currentRange;
                        document.getElementById('m_manualInput').value = m_currentRange;
                        m_drawGraph(); m_updateStats();
                        m_animId = setTimeout(step, m_animSpeed);
                    } else {
                        if (document.getElementById('m_loopAnim').checked) {
                            m_currentRange = 100;
                            m_animId = setTimeout(step, m_animSpeed * 3);
                        } else { m_stopAnimation(); }
                    }
                }
                step();
            }

            function m_startBackwardAnimation() {
                if (m_isAnimating) return;
                m_isAnimating = true;
                document.getElementById('m_playBtn').style.display = 'none';
                document.getElementById('m_pauseBtn').style.display = 'inline-block';
                function step() {
                    if (!m_isAnimating) return;
                    if (m_currentRange > 100) {
                        m_currentRange = Math.max(m_currentRange - Math.max(10, Math.floor(m_currentRange / 100)), 100);
                        document.getElementById('m_rangeSlider').value = Math.min(m_currentRange, 10000);
                        document.getElementById('m_rangeValue').textContent = m_currentRange;
                        document.getElementById('m_manualInput').value = m_currentRange;
                        m_drawGraph(); m_updateStats();
                        m_animId = setTimeout(step, m_animSpeed);
                    } else {
                        if (document.getElementById('m_loopAnim').checked) {
                            m_currentRange = parseInt(document.getElementById('m_rangeSlider').max);
                            m_animId = setTimeout(step, m_animSpeed * 3);
                        } else { m_stopAnimation(); }
                    }
                }
                step();
            }

            function m_stopAnimation() {
                m_isAnimating = false;
                document.getElementById('m_playBtn').style.display = 'inline-block';
                document.getElementById('m_pauseBtn').style.display = 'none';
                clearTimeout(m_animId); m_animId = null;
                m_populateTable();
            }

            // ----- Table -----
            function m_populateTable() {
                m_extendTo(m_currentRange);
                const body = document.getElementById('m_tableBody');
                if (!body) return;

                const search = document.getElementById('m_searchInput').value.trim();
                const filter = document.getElementById('m_filterType').value;

                let rows = [];
                for (let i = 0; i < m_currentRange; i++) {
                    const n = i + 1;
                    const mu = m_mobius[i], M = m_mertens[i];
                    const delta = i === 0 ? mu : M - m_mertens[i - 1];
                    const sqF = m_sqFree[i] === 1;
                    const factors = m_nFactors[i];
                    const distance = Math.abs(M);
                    const within = distance <= Math.sqrt(n);
                    const isZero = M === 0;
                    if (filter === 'zeros'       && !isZero)   continue;
                    if (filter === 'positive'    && M <= 0)    continue;
                    if (filter === 'negative'    && M >= 0)    continue;
                    if (filter === 'square-free' && !sqF)      continue;
                    if (search && !n.toString().includes(search)) continue;
                    rows.push({n, mu, M, delta, sqF, factors, distance, within, isZero});
                }

                rows.sort((a, b) => {
                    const av = a[m_sortCol === 'sqFree' ? 'sqF' : m_sortCol === 'within' ? 'within' : m_sortCol];
                    const bv = b[m_sortCol === 'sqFree' ? 'sqF' : m_sortCol === 'within' ? 'within' : m_sortCol];
                    const r = (av > bv ? 1 : av < bv ? -1 : 0);
                    return m_sortAsc ? r : -r;
                });

                // Limit display for performance
                const display = rows.slice(0, 500);

                body.innerHTML = display.map(r => {
                    const muCls = r.mu > 0 ? 'color:#22c55e' : r.mu < 0 ? 'color:#ef4444' : 'color:#a855f7';
                    const MCls  = r.M  > 0 ? 'color:#22c55e' : r.M  < 0 ? 'color:#ef4444' : 'color:#4ecdc4';
                    const dCls  = r.delta > 0 ? 'color:#22c55e' : r.delta < 0 ? 'color:#ef4444' : 'color:#888';
                    const rowBg = r.isZero ? 'background:rgba(34,197,94,0.08)' : (r.n === m_selectedRow ? 'background:rgba(255,215,0,0.08)' : '');
                    return `<tr data-n="${r.n}" style="${rowBg}; border-bottom:1px solid #1a1a2a; cursor:pointer;">
                        <td style="padding:8px 12px; color:#e0e0e0;">${r.n}</td>
                        <td style="padding:8px 12px; ${muCls}; font-weight:600;">${r.mu}</td>
                        <td style="padding:8px 12px; ${MCls}; font-weight:700;">${r.M}</td>
                        <td style="padding:8px 12px; ${dCls};">${r.delta > 0 ? '+' : ''}${r.delta}</td>
                        <td style="padding:8px 12px;">${r.sqF ? '<span style="background:rgba(34,197,94,0.2);color:#22c55e;padding:2px 8px;border-radius:10px;font-size:0.78rem;">Yes</span>' : '<span style="background:rgba(239,68,68,0.2);color:#ef4444;padding:2px 8px;border-radius:10px;font-size:0.78rem;">No</span>'}</td>
                        <td style="padding:8px 12px; color:#ccc;">${r.factors}</td>
                        <td style="padding:8px 12px; color:#ccc;">${r.distance}</td>
                        <td style="padding:8px 12px;">${r.within ? '<span style="background:rgba(34,197,94,0.2);color:#22c55e;padding:2px 8px;border-radius:10px;font-size:0.78rem;">Yes</span>' : '<span style="background:rgba(239,68,68,0.2);color:#ef4444;padding:2px 8px;border-radius:10px;font-size:0.78rem;">No</span>'}</td>
                        <td style="padding:8px 12px;">${r.isZero ? '<span style="background:rgba(78,205,196,0.2);color:#4ecdc4;padding:2px 8px;border-radius:10px;font-size:0.78rem;">Equilibrium</span>' : r.M > 0 ? '<span style="color:#22c55e;">Positive</span>' : '<span style="color:#ef4444;">Negative</span>'}</td>
                    </tr>`;
                }).join('');

                // Row click handler
                body.querySelectorAll('tr[data-n]').forEach(tr => {
                    tr.addEventListener('click', () => {
                        m_selectedRow = parseInt(tr.dataset.n);
                        m_drawGraph();
                        m_populateTable();
                    });
                });

                // Footer
                const full = m_mertens.slice(0, m_currentRange);
                const muFull = m_mobius.slice(0, m_currentRange);
                const sfFull = m_sqFree.slice(0, m_currentRange);
                document.getElementById('m_sumMu').textContent      = muFull.reduce((a,b) => a+b, 0);
                document.getElementById('m_finalM').textContent     = full[full.length - 1];
                document.getElementById('m_sqFreeCount').textContent = sfFull.reduce((a,b) => a+b, 0).toLocaleString();
                document.getElementById('m_avgDist').textContent    = (full.reduce((a,b) => a + Math.abs(b), 0) / m_currentRange).toFixed(2);
                document.getElementById('m_withinCount').textContent = full.filter((m,i) => Math.abs(m) <= Math.sqrt(i+1)).length.toLocaleString();
                document.getElementById('m_zeroCount').textContent  = full.filter(m => m === 0).length;

                if (rows.length > 500) {
                    const info = document.createElement('tr');
                    info.innerHTML = `<td colspan="9" style="padding:10px; text-align:center; color:#888; font-size:0.8rem;">Showing first 500 of ${rows.length} matching rows. Use filters to narrow results.</td>`;
                    body.appendChild(info);
                }
            }

            // ----- CSV Export -----
            function m_exportCSV() {
                m_extendTo(m_currentRange);
                let csv = 'n,mu(n),M(n),delta,square_free,prime_factors,distance,within_boundary,status\n';
                for (let i = 0; i < m_currentRange; i++) {
                    const n = i+1, mu = m_mobius[i], M = m_mertens[i];
                    const delta = i === 0 ? mu : M - m_mertens[i-1];
                    csv += `${n},${mu},${M},${delta},${m_sqFree[i]},${m_nFactors[i]},${Math.abs(M)},${Math.abs(M)<=Math.sqrt(n)?1:0},${M===0?'equilibrium':M>0?'positive':'negative'}\n`;
                }
                const a = document.createElement('a');
                a.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);
                a.download = `mertens_n${m_currentRange}.csv`;
                a.click();
            }

            // ----- Tooltip -----
            const m_canvas = document.getElementById('m_graphCanvas');
            if (m_canvas) {
                m_canvas.addEventListener('mousemove', e => {
                    const rect = m_canvas.getBoundingClientRect();
                    const scaleX = m_canvas.width / rect.width;
                    const cx = (e.clientX - rect.left) * scaleX;
                    const pad = 65, gW = m_canvas.width - 2*pad;
                    const i = Math.round((cx - pad) / gW * m_currentRange) - 1;
                    if (i < 0 || i >= m_currentRange) return;
                    m_extendTo(m_currentRange);
                    const n = i+1, mu = m_mobius[i], M = m_mertens[i];
                    const tip = document.getElementById('m_tooltip');
                    tip.innerHTML = `<strong style="color:#4ecdc4">n = ${n}</strong><br>μ(n) = <span style="color:${mu>0?'#22c55e':mu<0?'#ef4444':'#a855f7'}">${mu}</span><br>M(n) = <span style="color:${M>0?'#22c55e':M<0?'#ef4444':'#4ecdc4'}">${M}</span><br>|M(n)| / √n = ${(Math.abs(M)/Math.sqrt(n)).toFixed(4)}`;
                    tip.style.opacity = '1';
                    tip.style.left = (e.clientX - rect.left + 12) + 'px';
                    tip.style.top  = (e.clientY - rect.top  - 40) + 'px';
                });
                m_canvas.addEventListener('mouseleave', () => {
                    document.getElementById('m_tooltip').style.opacity = '0';
                });
                m_canvas.addEventListener('click', e => {
                    const rect = m_canvas.getBoundingClientRect();
                    const scaleX = m_canvas.width / rect.width;
                    const cx = (e.clientX - rect.left) * scaleX;
                    const pad = 65, gW = m_canvas.width - 2*pad;
                    const i = Math.round((cx - pad) / gW * m_currentRange) - 1;
                    if (i >= 0 && i < m_currentRange) { m_selectedRow = i+1; m_drawGraph(); m_populateTable(); }
                });
            }

            // ----- Init -----
            window.addEventListener('load', () => {
                m_extendTo(2000);
                m_drawGraph();
                m_updateStats();
                m_populateTable();
            });

        })(); // end Mertens module
        // ============================================================
        // HARDY-LITTLEWOOD DEEP DIVE MODULE
        // ============================================================
        (function() {
            const C2 = 0.6601618158468695;

            // ── helpers ──────────────────────────────────────────────
            function isPrime(n) {
                if (n < 2) return false;
                if (n === 2) return true;
                if (n % 2 === 0) return false;
                for (let d = 3; d * d <= n; d += 2) if (n % d === 0) return false;
                return true;
            }

            function oddPrimeFactors(h) {
                // unique odd prime factors of h
                const factors = [];
                let n = h;
                while (n % 2 === 0) n /= 2;
                for (let p = 3; p * p <= n; p += 2) {
                    if (n % p === 0) { factors.push(p); while (n % p === 0) n /= p; }
                }
                if (n > 1) factors.push(n);
                return factors;
            }

            function singularSeries(h) {
                const opf = oddPrimeFactors(h);
                let mult = 1;
                opf.forEach(p => mult *= (p - 1) / (p - 2));
                return 2 * C2 * mult;
            }

            function li2(x, terms = 4) {
                // li_2(x) = integral_2^x dt/ln^2(t)
                // Asymptotic expansion: x/ln^2(x) * sum_{k=0}^{terms-1} (k+1)!/1 / ln^k(x)
                // Coefficients: k=0:1, k=1:2, k=2:6, k=3:24, k=4:120 = (k+1)!
                const L = Math.log(x);
                let sum = 1;
                let coeff = 1;
                for (let k = 1; k < terms; k++) {
                    coeff *= (k + 1); // (k+1)! — NOT k!, which was the bug
                    sum += coeff / Math.pow(L, k);
                }
                return (x / (L * L)) * sum;
            }

            function gapName(h) {
                const names = { 2:'Twin', 4:'Cousin', 6:'Sexy', 8:'', 10:'', 12:'', 14:'',
                    18:'', 20:'', 24:'', 30:'', 42:'', 60:'', 70:'', 78:'', 102:'', 210:'' };
                return names[h] || '';
            }

            function factorString(h) {
                // return "2^a × p × q…" nicely
                let n = h, pow2 = 0;
                while (n % 2 === 0) { pow2++; n /= 2; }
                let s = pow2 > 1 ? `2^${pow2}` : pow2 === 1 ? '2' : '';
                const opf = oddPrimeFactors(h);
                if (opf.length) s += (s ? '×' : '') + opf.join('×');
                return s || String(h);
            }

            // ── Part 2: C2 partial products table ────────────────────
            function buildC2Table() {
                const tbody = document.getElementById('hl_c2_table_body');
                if (!tbody) return;
                const primes = [3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73];
                let running = 1;
                const C2_TARGET = 0.6601618158468695;
                let rows = '';
                primes.forEach(p => {
                    const factor = p * (p - 2) / ((p - 1) * (p - 1));
                    running *= factor;
                    const pctOfFinal = (running / C2_TARGET * 100).toFixed(3);
                    const factorColor = factor < 0.97 ? '#ef4444' : '#f59e0b';
                    rows += `<tr style="border-bottom:1px solid #1a1a2a;">
                        <td style="padding:6px 12px;color:#e0e0e0;">${p}</td>
                        <td style="padding:6px 12px;color:#ccc;">${p}×${p-2}/${(p-1)}² = ${p*(p-2)}/${(p-1)*(p-1)}</td>
                        <td style="padding:6px 12px;color:${factorColor};">${factor.toFixed(8)}</td>
                        <td style="padding:6px 12px;color:#ffd700;">${running.toFixed(10)}</td>
                        <td style="padding:6px 12px;">
                            <div style="display:flex;align-items:center;gap:8px;">
                                <div style="background:#1a1a2a;border-radius:3px;width:80px;height:8px;overflow:hidden;">
                                    <div style="background:${parseFloat(pctOfFinal)>100?'#ef4444':'#ffd700'};height:100%;width:${Math.min(parseFloat(pctOfFinal),100)}%;"></div>
                                </div>
                                <span style="color:${parseFloat(pctOfFinal)>100?'#ef4444':'#888'};">${pctOfFinal}%${parseFloat(pctOfFinal)>100?' ↑':''}</span>
                            </div>
                        </td>
                    </tr>`;
                });
                rows += `<tr style="background:#1a1a2a;font-weight:700;">
                    <td colspan="3" style="padding:8px 12px;color:#4ecdc4;">Limit (infinite product)</td>
                    <td style="padding:8px 12px;color:#ffd700;">0.6601618158468695…</td>
                    <td style="padding:8px 12px;color:#22c55e;">100.000%</td>
                </tr>
                <tr>
                    <td colspan="5" style="padding:8px 12px;color:#888;font-size:.8rem;font-style:italic;">
                        Note: the partial product starts <em>above</em> C₂ (red ↑ bars) because the first few factors pull it down from 1.0 quickly but overshoot. It converges monotonically downward toward C₂ once the large early corrections (p=3,5,7) have been applied. The product never passes below C₂.
                    </td>
                </tr>`;
                tbody.innerHTML = rows;
            }

            // ── Part 3: Singular series table ─────────────────────────
            function buildSingularTable() {
                const tbody = document.getElementById('hl_singular_table_body');
                if (!tbody) return;
                const gaps = [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,36,42,48,60,66,70,78,90,102,110,120,150,180,210,330];
                const S2 = 2 * C2;
                let rows = '';
                gaps.forEach((h, idx) => {
                    const opf = oddPrimeFactors(h);
                    const factors = opf.map(p => `(${p-1})/(${p-2})=${((p-1)/(p-2)).toFixed(4)}`);
                    const product = opf.reduce((a, p) => a * (p-1)/(p-2), 1);
                    const Sh = 2 * C2 * product;
                    const ratio = Sh / S2;
                    const rowBg = idx % 2 === 0 ? '' : 'background:rgba(255,255,255,.02)';
                    const ratioColor = ratio > 1.5 ? '#22c55e' : ratio > 1.1 ? '#f59e0b' : '#4ecdc4';
                    rows += `<tr style="border-bottom:1px solid #1a1a2a;${rowBg}">
                        <td style="padding:6px 10px;color:#ffd700;font-weight:700;">${h}</td>
                        <td style="padding:6px 10px;color:#ccc;font-family:monospace;font-size:.8rem;">${factorString(h)}</td>
                        <td style="padding:6px 10px;color:#a855f7;">${opf.length ? opf.join(', ') : '(none)'}</td>
                        <td style="padding:6px 10px;color:#ccc;font-size:.8rem;">${factors.length ? factors.join(' × ') : '—'}</td>
                        <td style="padding:6px 10px;color:#f59e0b;font-family:monospace;">${product.toFixed(6)}</td>
                        <td style="padding:6px 10px;color:#22c55e;font-family:monospace;font-weight:700;">${Sh.toFixed(8)}</td>
                        <td style="padding:6px 10px;color:${ratioColor};font-weight:700;">${ratio.toFixed(4)}×</td>
                        <td style="padding:6px 10px;color:#888;font-size:.8rem;">${gapName(h)}</td>
                    </tr>`;
                });
                tbody.innerHTML = rows;
            }

            // ── Part 4: li2 expansion table ────────────────────────────
            window.hl_updateLi2Table = function() {
                const tbody = document.getElementById('hl_li2_table_body');
                if (!tbody) return;
                const xEl = document.getElementById('hl_li2_x_input');
                const x = xEl ? parseFloat(xEl.value) || 400000000 : 400000000;
                const L = Math.log(x);
                const lnDisp = document.getElementById('hl_li2_lnx_display');
                if (lnDisp) lnDisp.textContent = `ln(x) = ${L.toFixed(6)}   x/ln²(x) = ${(x/(L*L)).toLocaleString('en', {maximumFractionDigits:0})}`;

                // observed twins: use analysis results if available
                const obsTwins = (typeof analysisResults !== 'undefined' && analysisResults && analysisResults.gapProducts && analysisResults.gapProducts[2])
                    ? analysisResults.gapProducts[2].count : 1507733;

                const termLabels = [
                    '1 term (crude)',
                    '2 terms (+ 2/lnx)',
                    '3 terms (+ 6/ln²x)',
                    '4 terms (+ 24/ln³x)',
                    '5 terms (+ 120/ln⁴x)',
                    '6 terms (+ 720/ln⁵x)'
                ];
                const termFormulas = [
                    'x/ln²(x)',
                    'x/ln²(x)·(1+2/L)',
                    'x/ln²(x)·(1+2/L+6/L²)',
                    'x/ln²(x)·(1+2/L+6/L²+24/L³)',
                    'x/ln²(x)·(1+…+120/L⁴)',
                    'x/ln²(x)·(1+…+720/L⁵)'
                ];
                const coeffs = [1, 2, 6, 24, 120, 720];
                let prevErr = null;
                let rows = '';

                for (let t = 1; t <= 6; t++) {
                    let sum = 1;
                    for (let k = 1; k < t; k++) sum += coeffs[k] / Math.pow(L, k);
                    const li2val = (x / (L * L)) * sum;
                    const pred = 2 * C2 * li2val;
                    const err = Math.abs(obsTwins - pred) / obsTwins * 100;
                    const improvement = prevErr !== null ? (prevErr - err).toFixed(3) + '%' : '—';
                    const errColor = err < 1 ? '#22c55e' : err < 5 ? '#f59e0b' : '#ef4444';
                    const isActive = t === 4 ? 'background:#1e1e30;' : '';
                    rows += `<tr style="border-bottom:1px solid #1a1a2a;${isActive}">
                        <td style="padding:7px 12px;color:${t===4?'#4ecdc4':'#ccc'};">${termLabels[t-1]}${t===4?' ✓':''}</td>
                        <td style="padding:7px 12px;color:#888;font-size:.78rem;">${termFormulas[t-1]}</td>
                        <td style="padding:7px 12px;color:#e0e0e0;font-family:monospace;">${Math.round(li2val).toLocaleString()}</td>
                        <td style="padding:7px 12px;color:#ffd700;font-family:monospace;">${Math.round(pred).toLocaleString()}</td>
                        <td style="padding:7px 12px;color:#22c55e;font-size:.82rem;">${improvement}</td>
                        <td style="padding:7px 12px;color:${errColor};font-weight:600;">${err.toFixed(4)}%</td>
                    </tr>`;
                    prevErr = err;
                }
                tbody.innerHTML = rows;
            };

            // ── Part 5: Full gap-by-gap table (live from analysis) ─────
            window.hl_populateFullTable = function() {
                const tbody = document.getElementById('hl_full_table_body');
                const rangeDisp = document.getElementById('hl_range_display');
                if (!tbody) return;
                if (typeof analysisResults === 'undefined' || !analysisResults || !analysisResults.gapProducts) {
                    return; // leave placeholder
                }
                const x = analysisResults.maxPrime;
                if (rangeDisp) rangeDisp.textContent = `N = ${x.toLocaleString()}  |  ${analysisResults.allPrimesFound.toLocaleString()} primes`;

                const li2x = li2(x, 4);
                const S2 = singularSeries(2);
                const gaps = analysisResults.evenGaps || [];
                let rows = '';
                gaps.forEach((h, idx) => {
                    const obs = analysisResults.gapProducts[h]?.count || 0;
                    const opf = oddPrimeFactors(h);
                    const Sh = singularSeries(h);
                    const pred = Sh * li2x;
                    const ratio = obs / pred;
                    const err = Math.abs(obs - pred) / Math.max(obs, 1) * 100;
                    const ratioColor = ratio > 0.99 && ratio < 1.01 ? '#22c55e' : ratio > 0.95 && ratio < 1.05 ? '#f59e0b' : '#ef4444';
                    const errColor = err < 2 ? '#22c55e' : err < 10 ? '#f59e0b' : '#ef4444';
                    const pctConv = Math.min(100, 100 - Math.abs(100 * (ratio - 1)));
                    const rowBg = idx % 2 === 0 ? '' : 'background:rgba(255,255,255,.015)';
                    rows += `<tr style="border-bottom:1px solid #1a1a2a;${rowBg}">
                        <td style="padding:6px 10px;color:#ffd700;font-weight:700;">${h}</td>
                        <td style="padding:6px 10px;color:#888;font-size:.78rem;">${gapName(h)}</td>
                        <td style="padding:6px 10px;color:#a855f7;font-size:.78rem;">${opf.length ? opf.join(', ') : 'none'}</td>
                        <td style="padding:6px 10px;color:#22c55e;font-family:monospace;">${Sh.toFixed(6)}</td>
                        <td style="padding:6px 10px;color:#4ecdc4;font-family:monospace;">${(Sh/S2).toFixed(4)}×</td>
                        <td style="padding:6px 10px;color:#ffd700;font-family:monospace;">${Math.round(pred).toLocaleString()}</td>
                        <td style="padding:6px 10px;color:#e0e0e0;font-family:monospace;">${obs.toLocaleString()}</td>
                        <td style="padding:6px 10px;color:${ratioColor};font-weight:700;">${ratio.toFixed(4)}</td>
                        <td style="padding:6px 10px;color:${errColor};">${err.toFixed(2)}%</td>
                        <td style="padding:6px 10px;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <div style="background:#1a1a2a;border-radius:3px;width:70px;height:6px;overflow:hidden;">
                                    <div style="background:${ratioColor};height:100%;width:${Math.max(0,Math.min(100,pctConv))}%;transition:width .3s;"></div>
                                </div>
                                <span style="color:#888;font-size:.75rem;">${pctConv.toFixed(0)}%</span>
                            </div>
                        </td>
                    </tr>`;
                });
                tbody.innerHTML = rows || '<tr><td colspan="10" style="padding:14px;color:#888;text-align:center;">No gap data found</td></tr>';

                // Also update Part 7 ratios table
                hl_populateRatioTable(x);
                // Also refresh li2 table with current observed twins
                hl_updateLi2Table();
                // Sync x input
                const xEl = document.getElementById('hl_x_input');
                const li2El = document.getElementById('hl_li2_x_input');
                if (xEl) xEl.value = x;
                if (li2El) li2El.value = x;
            };

            // ── Part 7: ratio convergence table ────────────────────────
            function hl_populateRatioTable(x) {
                const tbody = document.getElementById('hl_ratio_table_body');
                if (!tbody || typeof analysisResults === 'undefined' || !analysisResults) return;
                const gp = analysisResults.gapProducts;

                const ratioSpecs = [
                    { label:'Count(2)/Count(4)', a:2, b:4,
                      why:'S(2)=S(4)=2C₂ (neither 2 nor 4 has odd prime factors) — both gaps equally likely' },
                    { label:'Count(6)/Count(2)', a:6, b:2,
                      why:'S(6)=4C₂, S(2)=2C₂ → ratio=2. Factor of 2 from p=3 dividing 6.' },
                    { label:'Count(6)/Count(4)', a:6, b:4,
                      why:'Same as above: S(6)/S(4) = 4C₂/2C₂ = 2' },
                    { label:'Count(12)/Count(6)', a:12, b:6,
                      why:'S(12)=S(6)=4C₂ (12=4×3, same odd factor 3). Ratio → 1.' },
                    { label:'Count(10)/Count(2)', a:10, b:2,
                      why:'S(10)=8C₂/3 (factor 4/3 from p=5). Ratio → 4/3 ≈ 1.333.' },
                    { label:'Count(30)/Count(6)', a:30, b:6,
                      why:'S(30)=8C₂ (factors from p=3 and p=5). Ratio → S(30)/S(6) = 2.' },
                ];

                let rows = '';
                ratioSpecs.forEach(spec => {
                    const ca = gp[spec.a]?.count || 0;
                    const cb = gp[spec.b]?.count || 0;
                    if (!cb) return;
                    const theoryLimit = singularSeries(spec.a) / singularSeries(spec.b);
                    const current = ca / cb;
                    const pctReached = Math.min(100, Math.max(0, 100 - Math.abs((current/theoryLimit - 1)*100)));
                    const barColor = pctReached > 95 ? '#22c55e' : pctReached > 80 ? '#f59e0b' : '#ef4444';
                    rows += `<tr style="border-bottom:1px solid #1a1a2a;">
                        <td style="padding:8px 12px;color:#ffd700;font-family:monospace;">${spec.label}</td>
                        <td style="padding:8px 12px;color:#888;font-size:.8rem;">${spec.why}</td>
                        <td style="padding:8px 12px;color:#4ecdc4;font-family:monospace;font-weight:700;">${theoryLimit.toFixed(6)}</td>
                        <td style="padding:8px 12px;color:#e0e0e0;font-family:monospace;">${current.toFixed(6)}</td>
                        <td style="padding:8px 12px;color:${barColor};">${pctReached.toFixed(1)}%</td>
                        <td style="padding:8px 12px;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <div style="background:#1a1a2a;border-radius:3px;width:90px;height:8px;overflow:hidden;">
                                    <div style="background:${barColor};height:100%;width:${pctReached}%;"></div>
                                </div>
                            </div>
                        </td>
                    </tr>`;
                });
                tbody.innerHTML = rows || '<tr><td colspan="6" style="padding:14px;text-align:center;color:#888;">No data</td></tr>';
            }

            // ── Part 6: interactive walkthrough ───────────────────────
            window.hl_setGap = function(h) {
                const el = document.getElementById('hl_gap_input');
                if (el) { el.value = h; hl_computeWalkthrough(); }
            };

            window.hl_computeWalkthrough = function() {
                const h = parseInt(document.getElementById('hl_gap_input')?.value || 6);
                const x = parseFloat(document.getElementById('hl_x_input')?.value || 400000000);
                const out = document.getElementById('hl_walkthrough_output');
                if (!out) return;

                const L = Math.log(x);
                const opf = oddPrimeFactors(h);
                const S2 = 2 * C2;
                const Sh = singularSeries(h);
                const li2val = li2(x, 4);
                const prediction = Sh * li2val;
                const obs = (typeof analysisResults !== 'undefined' && analysisResults?.gapProducts?.[h])
                    ? analysisResults.gapProducts[h].count : null;

                let html = '';

                // Step 1: factorise h
                html += `<div class="hl-step-block">
                    <div class="hl-step-num">Step 1 — Factorise h</div>
                    <div class="hl-step-math">h = ${h} = ${factorString(h)}</div>
                    <div class="hl-step-explain">We need the <strong>odd prime factors</strong> of h. Even prime factor p=2 is already absorbed into the baseline C₂ and contributes no extra correction. Odd prime factors: <strong>${opf.length ? opf.join(', ') : '(none — h is a power of 2)'}</strong></div>
                </div>`;

                // Step 2: correction factors
                if (opf.length === 0) {
                    html += `<div class="hl-step-block" style="border-left-color:#4ecdc4">
                        <div class="hl-step-num">Step 2 — Correction Factors</div>
                        <div class="hl-step-math">No odd prime factors → correction product = 1</div>
                        <div class="hl-step-explain">Since h = ${factorString(h)} has no odd prime factors, there is no "extra opening" of residue classes. S(h) = S(2) — gap ${h} has identical asymptotic density to gap 2.</div>
                    </div>`;
                } else {
                    let corrHtml = '';
                    let product = 1;
                    opf.forEach(p => {
                        const factor = (p-1)/(p-2);
                        product *= factor;
                        corrHtml += `<div style="background:#0a0a10;border-radius:4px;padding:8px 12px;margin-bottom:6px;">
                            <span style="color:#a855f7;font-weight:600;">p = ${p}:</span>
                            <span style="color:#ffd700;font-family:'Times New Roman',serif;font-size:1rem;margin-left:8px;">(${p}−1)/(${p}−2) = ${p-1}/${p-2} = ${factor.toFixed(6)}</span>
                            <span style="color:#888;font-size:.82rem;margin-left:12px;">
                                Because ${p} | ${h}, the pair {p, p+${h}} has p ≡ p+${h} (mod ${p}), so neither is forced to be divisible by ${p}. This ${factor > 1.5 ? 'more than doubles' : factor > 1.1 ? 'significantly boosts' : 'boosts'} the density by factor ${factor.toFixed(4)}.
                            </span>
                        </div>`;
                    });
                    html += `<div class="hl-step-block">
                        <div class="hl-step-num">Step 2 — Correction Factors for Each Odd Prime p | h</div>
                        ${corrHtml}
                        <div class="hl-step-math" style="margin-top:10px;">Product of all corrections = ${product.toFixed(8)}</div>
                    </div>`;
                }

                // Step 3: compute S(h)
                const product_opf = opf.reduce((a,p) => a*(p-1)/(p-2), 1);
                html += `<div class="hl-step-block" style="border-left-color:#22c55e">
                    <div class="hl-step-num">Step 3 — Compute S(h)</div>
                    <div class="hl-step-math">S(${h}) = 2 × C₂ × ${product_opf.toFixed(6)}</div>
                    <div class="hl-step-math">= 2 × 0.6601618… × ${product_opf.toFixed(6)}</div>
                    <div class="hl-step-math">= <strong style="color:#22c55e">${Sh.toFixed(10)}</strong></div>
                    <div class="hl-step-explain">Compared to S(2) = ${S2.toFixed(8)}: S(${h})/S(2) = <strong style="color:#ffd700">${(Sh/S2).toFixed(6)}×</strong>
                    — gap ${h} is ${(Sh/S2).toFixed(4)} times as frequent as twin primes asymptotically.</div>
                </div>`;

                // Step 4: compute li2
                const base = x / (L*L);
                const coeffs = [1, 2, 6, 24, 120];
                let termBreakdown = '';
                let cumsum = 0;
                coeffs.slice(0,4).forEach((c, k) => {
                    const term = c / Math.pow(L, k);
                    cumsum += term;
                    termBreakdown += `<div style="color:#ccc;font-family:monospace;font-size:.82rem;margin-bottom:3px;">
                        ${k===0?'':'  + '}${c}/ln${k===0?'':'^'+k}(x) = ${c}/${Math.pow(L,k).toFixed(4)} = <span style="color:#4ecdc4">${term.toFixed(6)}</span>  ${k>0?`(${(term*100).toFixed(2)}% correction)`:'(base term)'}
                    </div>`;
                });
                html += `<div class="hl-step-block" style="border-left-color:#4ecdc4">
                    <div class="hl-step-num">Step 4 — Compute li₂(x) with 4 Terms</div>
                    <div class="hl-step-math">x = ${x.toLocaleString()},  ln(x) = ${L.toFixed(6)},  x/ln²(x) = ${Math.round(base).toLocaleString()}</div>
                    <div style="margin:10px 0;">${termBreakdown}</div>
                    <div class="hl-step-math">Sum of terms = ${cumsum.toFixed(8)}</div>
                    <div class="hl-step-math">li₂(x) = ${Math.round(base).toLocaleString()} × ${cumsum.toFixed(8)} = <strong style="color:#4ecdc4">${Math.round(li2val).toLocaleString()}</strong></div>
                </div>`;

                // Step 5: final prediction
                html += `<div class="hl-step-block" style="border-left-color:#f59e0b">
                    <div class="hl-step-num">Step 5 — Final Prediction</div>
                    <div class="hl-step-math">π<sub>${h}</sub>(${x.toLocaleString()}) ~ S(${h}) × li₂(x)</div>
                    <div class="hl-step-math">= ${Sh.toFixed(8)} × ${Math.round(li2val).toLocaleString()}</div>
                    <div class="hl-step-math">= <strong style="color:#f59e0b">${Math.round(prediction).toLocaleString()}</strong></div>
                    <div class="hl-step-explain">Predicted prime pairs (p, p+${h}) up to ${x.toLocaleString()}: approximately <strong style="color:#ffd700">${Math.round(prediction).toLocaleString()}</strong></div>
                </div>`;

                // Step 6: vs observed (if available)
                if (obs !== null) {
                    const err = Math.abs(obs - prediction) / obs * 100;
                    const errColor = err < 1 ? '#22c55e' : err < 5 ? '#f59e0b' : '#ef4444';
                    html += `<div class="hl-result-box">
                        <div style="color:#e879f9;font-weight:700;font-size:1rem;margin-bottom:12px;">Step 6 — Comparison with Your Data</div>
                        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;">
                            <div><div style="color:#888;font-size:.78rem;">H-L Predicted</div><div style="color:#ffd700;font-size:1.3rem;font-weight:700;font-family:monospace;">${Math.round(prediction).toLocaleString()}</div></div>
                            <div><div style="color:#888;font-size:.78rem;">Observed (your data)</div><div style="color:#e0e0e0;font-size:1.3rem;font-weight:700;font-family:monospace;">${obs.toLocaleString()}</div></div>
                            <div><div style="color:#888;font-size:.78rem;">Relative Error</div><div style="color:${errColor};font-size:1.3rem;font-weight:700;font-family:monospace;">${err.toFixed(3)}%</div></div>
                        </div>
                        <div style="margin-top:12px;color:#888;font-size:.82rem;">
                            Obs/Pred ratio = ${(obs/prediction).toFixed(6)} (converges to 1.0 as x→∞)
                        </div>
                    </div>`;
                } else {
                    html += `<div class="hl-result-box">
                        <div style="color:#e879f9;font-weight:700;margin-bottom:8px;">Final Result for Gap ${h}</div>
                        <div style="color:#ffd700;font-size:1.2rem;font-family:monospace;">${Math.round(prediction).toLocaleString()} predicted prime pairs (p, p+${h}) up to ${x.toLocaleString()}</div>
                        <div style="color:#888;font-size:.82rem;margin-top:8px;">Run analysis above to compare against observed count</div>
                    </div>`;
                }

                out.innerHTML = html;
            };

            // ── Init on load ───────────────────────────────────────────
            window.addEventListener('load', () => {
                buildC2Table();
                buildSingularTable();
                hl_updateLi2Table();
                // Try to auto-populate if analysis already ran
                if (typeof analysisResults !== 'undefined' && analysisResults) {
                    hl_populateFullTable();
                }
            });

            // Hook into the existing runAnalysis so tables auto-update after analysis
            const _origRun = window.runAnalysis;
            if (typeof _origRun === 'function') {
                window.runAnalysis = function() {
                    const result = _origRun.apply(this, arguments);
                    // Delay to let analysis complete
                    setTimeout(() => {
                        if (typeof analysisResults !== 'undefined' && analysisResults) {
                            hl_populateFullTable();
                        }
                    }, 2000);
                    return result;
                };
            }

        })(); // end HL module
    </script>
</body>
</html>
