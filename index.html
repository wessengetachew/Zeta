<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gap-Class Decomposition of ζ(2) = π²/6 | Mathematical Research Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500&family=Cinzel:wght@400;600;700&family=Cinzel+Decorative:wght@400;700&family=Inter:wght@300;400;500;600&family=Source+Serif+4:ital,wght@0,300;0,400;0,600;1,300;1,400&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --parchment:      #f5edd6;
            --parchment-dark: #ede0bc;
            --parchment-deep: #e4d3a0;
            --ink:            #1e1008;
            --ink-mid:        #3b220f;
            --ink-light:      #6b4c2a;
            --gold:           #8b6310;
            --gold-light:     #c49b38;
            --sepia:          #704214;
            --red-ink:        #8b1a1a;
            --border:         #a07830;
            --panel-bg:       #faf5e4;
            --panel-border:   rgba(160,120,48,0.35);
            --accent:         #8b6310;
            --accent2:        #5a3a1a;
            --green-ink:      #2d5a27;
            --teal-ink:       #1a4a4a;
            --purple-ink:     #4a2a6a;
            --orange-ink:     #7a3a0a;
            --canvas-bg:      #ffffff;
            --canvas-ring:    #c8c0b0;
        }
        /* ═══ DARK MODE VARIABLES ═══ */
        body.dark-mode {
            --parchment:      #1c1608;
            --parchment-dark: #141008;
            --parchment-deep: #0e0b05;
            --ink:            #e8d9b0;
            --ink-mid:        #c8b080;
            --ink-light:      #9a8060;
            --gold:           #c49b38;
            --gold-light:     #e0bc60;
            --sepia:          #c08040;
            --red-ink:        #e06060;
            --border:         #c49b38;
            --panel-bg:       #1c1608;
            --panel-border:   rgba(196,155,56,0.3);
            --accent:         #c49b38;
            --accent2:        #e0c080;
            --green-ink:      #5a9a5a;
            --teal-ink:       #3a9090;
            --purple-ink:     #9060b8;
            --orange-ink:     #b87030;
            background: #0e0b05;
            background-image: none;
            color: var(--ink);
            --canvas-bg:      #06040e;
            --canvas-ring:    #2a1a4a;
        }

        /* Header */
        canvas {
            background: var(--canvas-bg) !important;
        }
        canvas#fc-coprime, canvas#fc-noncoprime, canvas#rz-circle-canvas {
            border-radius: 50%;
        }
        canvas#fc-combined, canvas#rz-spectrum-canvas, canvas#compositeCanvas {
            border-radius: 0;
        }
        /* Light mode: dark-hardcoded divs around canvases */
        body:not(.dark-mode) [style*="background: #0a0a10"],
        body:not(.dark-mode) [style*="background:#0a0a10"],
        body:not(.dark-mode) [style*="background: #0a0a0f"],
        body:not(.dark-mode) [style*="background:#0a0a0f"] {
            background: #ffffff !important;
            color: var(--ink) !important;
        }

        body.dark-mode .header {
            background: #0a0804 !important;
            background-image: linear-gradient(135deg, #0a0804 0%, #1a1008 100%) !important;
        }

        /* All white/parchment panels → dark */
        body.dark-mode .intro-section,
        body.dark-mode .chart-wrapper,
        body.dark-mode .control-panel,
        body.dark-mode .dropdown,
        body.dark-mode .collapsible-section,
        body.dark-mode .animation-controls,
        body.dark-mode .chart-animation-controls,
        body.dark-mode .modal-content,
        body.dark-mode .modal-stat-item,
        body.dark-mode .modal-prime-list,
        body.dark-mode .stats-table-wrapper,
        body.dark-mode .data-table,
        body.dark-mode .stats-table,
        body.dark-mode .dropdown-section,
        body.dark-mode .dropdown-content {
            background: var(--parchment) !important;
            background-image: none !important;
        }

        /* Inputs and selects */
        body.dark-mode input[type="number"],
        body.dark-mode select,
        body.dark-mode .precision-control select {
            background: var(--parchment-dark) !important;
            color: var(--ink) !important;
            border-color: var(--border) !important;
        }
        body.dark-mode input[type="number"]:focus,
        body.dark-mode select:focus {
            background: var(--parchment-deep) !important;
        }

        /* Table headers */
        body.dark-mode .stats-table thead,
        body.dark-mode .data-table th,
        body.dark-mode table thead tr {
            background: var(--parchment-dark) !important;
        }

        /* Scrollbars */
        body.dark-mode .stats-table-container::-webkit-scrollbar-track,
        body.dark-mode .modal-prime-list::-webkit-scrollbar-track {
            background: var(--parchment-dark) !important;
        }

        /* formula-box hardcoded rgba(255,255,240) */
        body.dark-mode .formula-box {
            background: rgba(196,155,56,0.1) !important;
            color: var(--ink) !important;
            border-color: var(--border) !important;
        }

        /* chart-description */
        body.dark-mode .chart-description {
            background: rgba(196,155,56,0.07) !important;
            color: var(--ink-mid) !important;
        }

        /* export buttons */
        body.dark-mode .export-btn {
            background: var(--parchment-dark) !important;
            color: var(--ink-mid) !important;
        }
        body.dark-mode .export-btn.csv {
            background: var(--ink) !important;
            color: var(--parchment) !important;
        }

        /* inline dark panels that appear light mode out of place — keep dark is fine */
        /* but inline rgba(255,255,255,...) panels need flip */
        body.dark-mode [style*="rgba(255,255,255,0.02)"],
        body.dark-mode [style*="rgba(255, 255, 255, 0.05)"] {
            background: rgba(196,155,56,0.04) !important;
        }
        /* inline rgba(255,215,0,...) gold tint panels stay fine */
        /* inline rgba(255,100,100,...) red tint panels stay fine */

        /* HL step blocks */
        body.dark-mode .hl-step-block {
            background: var(--parchment-dark) !important;
        }
        body.dark-mode .hl-step-math { color: var(--ink) !important; }
        body.dark-mode .hl-step-explain { color: var(--ink-light) !important; }

        /* Inline #2a2a4a export button */
        body.dark-mode [style*="background: #2a2a4a"] {
            background: var(--parchment-dark) !important;
            color: var(--ink-mid) !important;
        }

        /* Section dividers */
        body.dark-mode .section-divider { background: var(--border); }

        /* Modal overlay darkens further */
        body.dark-mode .modal-overlay { background: rgba(0,0,0,0.92); }

        /* Mertens / Euler canvas wrapper divs */
        body.dark-mode [style*="background: #0a0a10"],
        body.dark-mode [style*="background:#0a0a10"] {
            background: #050402 !important;
            border-color: var(--panel-border) !important;
        }

        /* ═══ FONT THEMES ═══ */
        /* Default: Cinzel (current — mathematical/epigraphic) */
        body.font-inter {
            font-family: 'Inter', 'Helvetica Neue', sans-serif !important;
        }
        body.font-inter .chart-title, body.font-inter h1, body.font-inter h2,
        body.font-inter h3, body.font-inter h4, body.font-inter label,
        body.font-inter button, body.font-inter .btn,
        body.font-inter [style*="Cinzel"] {
            font-family: 'Inter', sans-serif !important;
            letter-spacing: 0.01em !important;
            text-transform: none !important;
        }
        body.font-sourceserif {
            font-family: 'Source Serif 4', Georgia, serif !important;
        }
        body.font-sourceserif .chart-title, body.font-sourceserif h1, body.font-sourceserif h2,
        body.font-sourceserif h3, body.font-sourceserif h4, body.font-sourceserif label,
        body.font-sourceserif button, body.font-sourceserif .btn,
        body.font-sourceserif [style*="Cinzel"] {
            font-family: 'Source Serif 4', Georgia, serif !important;
            letter-spacing: 0.02em !important;
            text-transform: none !important;
        }
        body.font-mono {
            font-family: 'JetBrains Mono', 'Courier New', monospace !important;
        }
        body.font-mono .chart-title, body.font-mono h1, body.font-mono h2,
        body.font-mono h3, body.font-mono h4, body.font-mono label,
        body.font-mono button, body.font-mono .btn,
        body.font-mono [style*="Cinzel"] {
            font-family: 'JetBrains Mono', monospace !important;
            letter-spacing: 0.02em !important;
            text-transform: none !important;
        }
        /* Font toggle button */
        #font-toggle {
            position: fixed;
            top: 18px;
            right: 110px;
            z-index: 9999;
            background: var(--ink);
            color: var(--parchment);
            border: 1px solid var(--border);
            font-family: 'Cinzel', serif;
            font-size: 0.65rem;
            letter-spacing: 0.08em;
            padding: 6px 12px;
            cursor: pointer;
            text-transform: uppercase;
            transition: background 0.3s, color 0.3s;
        }
        #font-toggle:hover { background: var(--gold); color: var(--parchment); }
        body.dark-mode #font-toggle { background: #1e1810; color: var(--gold-light); border-color: var(--gold); }

        /* ═══ DARK MODE TOGGLE ═══ */
        #dark-mode-toggle {
            position: fixed;
            top: 18px;
            right: 22px;
            z-index: 9999;
            background: var(--ink);
            color: var(--parchment);
            border: 1px solid var(--border);
            font-family: 'Cinzel', serif;
            font-size: 0.65rem;
            letter-spacing: 0.08em;
            padding: 6px 12px;
            cursor: pointer;
            text-transform: uppercase;
            transition: background 0.3s, color 0.3s;
        }
        #dark-mode-toggle:hover {
            background: var(--gold);
            color: var(--parchment);
        }
        body.dark-mode #dark-mode-toggle {
            background: #1e1810;
            color: var(--gold-light);
            border-color: var(--gold);
        }

        /* ── JS-generated table cell text ── */
        body.dark-mode #m_tableBody td,
        body.dark-mode #m_tableBody [style*="color:#aaa"],
        body.dark-mode [style*="color:#aaa"] { color: var(--ink-light) !important; }
        body.dark-mode [style*="color:#ccc"],
        body.dark-mode [style*="color: #ccc"] { color: var(--ink-mid) !important; }
        body.dark-mode [style*="color:#888"],
        body.dark-mode [style*="color: #888"] { color: var(--ink-light) !important; }
        body.dark-mode [style*="color:#e0e0e0"],
        body.dark-mode [style*="color: #e0e0e0"] { color: var(--ink) !important; }
        body.dark-mode [style*="color:#ffd700"],
        body.dark-mode [style*="color: #ffd700"] { color: var(--gold) !important; }
        body.dark-mode [style*="color:#4ecdc4"],
        body.dark-mode [style*="color: #4ecdc4"] { color: var(--teal-ink) !important; }
        body.dark-mode [style*="color:#a855f7"] { color: var(--purple-ink) !important; }
        body.dark-mode [style*="color:#ff6b81"] { color: var(--red-ink) !important; }

        /* canvas wrappers and Mertens table — keep intentionally dark */
        body.dark-mode canvas { background: #050402 !important; }
        body.dark-mode [style*="background: #0a0a10"],
        body.dark-mode [style*="background:#0a0a10"] {
            background: #050402 !important;
            border-color: var(--panel-border) !important;
        }
        body.dark-mode [style*="background: #1a1a2e"],
        body.dark-mode [style*="background:#1a1a2e"] { background: #0e0b05 !important; }
        .geo-decor-wrapper {
            display: flex;
            justify-content: center;
            margin: 24px auto 8px;
        }
        .geo-decor-diagram {
            cursor: pointer;
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            display: block;
            opacity: 0.88;
            transform-origin: center center;
            user-select: none;
        }
        .geo-decor-diagram:hover { opacity: 1; }
        .geo-decor-caption {
            text-align: center;
            font-family: 'Cinzel', serif;
            font-size: 0.6rem;
            letter-spacing: 0.12em;
            color: var(--ink-light);
            text-transform: uppercase;
            margin-bottom: 20px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body { 
            font-family: 'EB Garamond', Georgia, serif;
            background: #ffffff;
            color: var(--ink);
            line-height: 1.65;
            min-height: 100vh;
            transition: background 0.3s, color 0.3s;
        }
        
        .tool-nav {
            margin-top: 18px;
            font-size: 0.75rem;
            color: rgba(245,237,214,0.55);
            font-family: 'Cinzel', serif;
            letter-spacing: 0.07em;
        }
        .tool-nav-link {
            color: var(--gold-light);
            text-decoration: none;
            border-bottom: 1px dotted var(--gold-light);
            transition: color 0.2s, border-color 0.2s;
        }
        .tool-nav-link:hover {
            color: var(--parchment);
            border-bottom-color: var(--parchment);
        }
        .tool-nav-link.nav-highlight {
            color: var(--parchment);
            border-bottom-color: var(--parchment);
            text-shadow: 0 0 12px var(--gold-light);
            transition: color 0.4s, text-shadow 0.4s;
        }

        .header {
            background: var(--ink);
            background-image: linear-gradient(135deg, #1e1008 0%, #3b220f 100%);
            padding: 60px 80px 50px;
            border-bottom: 4px double var(--border);
            text-align: center;
            position: relative;
        }
        .header::after {
            content: '';
            position: absolute;
            bottom: -8px; left: 0; right: 0;
            height: 4px;
            background: var(--gold-light);
            opacity: 0.3;
        }
        .header h1 { 
            font-family: 'Cinzel Decorative', 'Cinzel', serif;
            font-size: 1.8rem; 
            color: var(--gold-light);
            margin-bottom: 16px;
            letter-spacing: 0.04em;
            line-height: 1.4;
            text-transform: uppercase;
        }
        .header .subtitle { 
            color: rgba(245,237,214,0.7);
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            letter-spacing: 0.08em;
            margin-bottom: 12px;
            text-transform: uppercase;
        }
        .header .author { 
            color: rgba(245,237,214,0.5);
            font-family: 'EB Garamond', serif;
            font-style: italic;
            font-size: 1rem;
        }
        .header .author a {
            color: var(--gold-light);
            text-decoration: none;
            border-bottom: 1px dotted var(--gold-light);
        }
        
        .introduction {
            max-width: 1000px;
            margin: 50px auto;
            padding: 0 40px;
        }
        
        .intro-section {
            background: var(--parchment);
            background-image: linear-gradient(180deg, #f7f0db 0%, #f5edd6 100%);
            border: 1px solid var(--border);
            box-shadow: 0 2px 20px rgba(0,0,0,0.2), inset 0 0 40px rgba(180,140,60,0.05);
            padding: 40px 48px;
            margin-bottom: 32px;
            position: relative;
            transition: background 0.3s, color 0.3s;
        }
        .intro-section::before {
            content: '';
            position: absolute;
            top: 4px; left: 4px; right: 4px; bottom: 4px;
            border: 1px solid rgba(160,120,48,0.2);
            pointer-events: none;
        }
        
        .intro-section h2 {
            font-family: 'Cinzel', serif;
            color: var(--ink);
            font-size: 1.3rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px double var(--border);
        }
        
        .intro-section h3 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 0.85rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            margin: 28px 0 12px 0;
        }
        
        .intro-section p {
            margin-bottom: 18px;
            color: var(--ink-mid);
            font-size: 1rem;
            line-height: 1.82;
            text-align: justify;
            hyphens: auto;
        }
        
        .intro-section ul, .intro-section ol {
            margin-left: 28px;
            margin-bottom: 18px;
            color: var(--ink-mid);
        }
        
        .intro-section li {
            margin-bottom: 12px;
            line-height: 1.75;
        }
        
        .formula-box {
            background: rgba(255,255,240,0.7);
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
            padding: 18px 24px;
            border-radius: 0;
            font-family: 'EB Garamond', Georgia, serif;
            font-size: 1.3rem;
            text-align: center;
            color: var(--ink);
            margin: 20px 0;
            line-height: 2;
        }
        
        .research-question {
            background: rgba(139,26,26,0.05);
            padding: 20px 24px;
            border-radius: 0;
            border-left: 4px solid var(--red-ink);
            margin: 20px 0;
        }
        
        .research-question h3 {
            color: var(--red-ink) !important;
            margin-bottom: 12px;
        }
        
        .controls-container {
            max-width: 1200px;
            margin: 0 auto 36px auto;
            padding: 0 40px;
        }
        
        .control-panel {
            background: var(--parchment);
            background-image: linear-gradient(180deg, #f7f0db 0%, #f5edd6 100%);
            border: 1px solid var(--border);
            box-shadow: 0 2px 16px rgba(0,0,0,0.15);
            padding: 28px 32px;
            margin-bottom: 20px;
            position: relative;
        }
        .control-panel::before {
            content: '';
            position: absolute;
            top: 3px; left: 3px; right: 3px; bottom: 3px;
            border: 1px solid rgba(160,120,48,0.18);
            pointer-events: none;
        }
        
        .control-panel h3 {
            font-family: 'Cinzel', serif;
            color: var(--ink);
            font-size: 0.85rem;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 2px double var(--border);
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            font-family: 'Cinzel', serif;
            font-size: 0.72rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--gold);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        
        .control-value {
            color: var(--sepia);
            font-family: 'EB Garamond', serif;
            font-size: 1rem;
            font-style: italic;
        }
        
        input[type="number"], select {
            width: 100%;
            padding: 9px 12px;
            background: var(--parchment);
            border: 1px solid var(--border);
            color: var(--ink);
            font-family: 'EB Garamond', serif;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.2s, background 0.2s;
            border-radius: 0;
        }
        
        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--ink);
            background: #fff9ee;
        }
        
        .btn {
            padding: 11px 28px;
            background: var(--ink);
            border: none;
            color: var(--parchment);
            font-family: 'Cinzel', serif;
            font-size: 0.78rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            cursor: pointer;
            transition: background 0.2s;
            border-radius: 0;
        }
        
        .btn:hover {
            background: var(--sepia);
        }
        
        .btn:active {
            background: var(--ink-mid);
        }
        
        .btn-secondary {
            background: var(--parchment-dark);
            color: var(--ink);
            border: 1px solid var(--border);
        }
        
        .btn-secondary:hover {
            background: var(--parchment-deep);
        }

        /* Collapsible Dropdown Styles */
        .dropdown-section {
            background: var(--parchment);
            border: 1px solid var(--border);
            margin-bottom: 16px;
            overflow: hidden;
            box-shadow: 0 1px 8px rgba(0,0,0,0.1);
        }
        
        .dropdown-header {
            padding: 16px 24px;
            background: linear-gradient(135deg, #1e1008 0%, #3b220f 100%);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
            user-select: none;
        }
        
        .dropdown-header:hover {
            background: linear-gradient(135deg, #2a160a 0%, #4a2a12 100%);
        }
        
        .dropdown-header h3 {
            color: #e0bc60 !important;
            font-family: 'Cinzel', serif;
            font-size: 0.82rem !important;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            margin: 0 !important;
            border: none !important;
            padding: 0 !important;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .dropdown-icon {
            color: #e0bc60;
            font-size: 1rem;
            transition: transform 0.3s;
        }
        
        .dropdown-section.active .dropdown-icon {
            transform: rotate(180deg);
        }
        
        .dropdown-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding: 0 24px;
            background: var(--parchment);
        }
        
        .dropdown-section.active .dropdown-content {
            max-height: 3000px;
            padding: 24px;
            transition: max-height 0.5s ease-in;
        }
        
        .dropdown-badge {
            background: rgba(139,99,16,0.15);
            color: var(--gold);
            padding: 3px 10px;
            font-family: 'Cinzel', serif;
            font-size: 0.65rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .preset-btn {
            padding: 6px 12px;
            background: var(--parchment-dark);
            border: 1px solid var(--border);
            color: var(--ink-mid);
            font-family: 'Cinzel', serif;
            font-size: 0.68rem;
            letter-spacing: 0.06em;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            text-transform: uppercase;
        }

        .preset-btn:hover {
            background: var(--ink);
            color: var(--parchment);
            border-color: var(--ink);
        }

        .preset-btn:active {
            background: var(--sepia);
        }
        
        /* Collapsible Section Styles */
        .collapsible-section {
            background: var(--parchment);
            border: 1px solid var(--border);
            margin-bottom: 16px;
            overflow: hidden;
            box-shadow: 0 1px 8px rgba(0,0,0,0.1);
        }
        
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 24px;
            cursor: pointer;
            background: linear-gradient(135deg, var(--ink) 0%, var(--ink-mid) 100%);
            transition: all 0.2s;
            user-select: none;
        }
        
        .collapsible-header:hover {
            background: linear-gradient(135deg, #2a160a 0%, #4a2a12 100%);
        }
        
        .collapsible-header h3 {
            margin: 0;
            color: var(--gold-light);
            font-family: 'Cinzel', serif;
            font-size: 0.82rem;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .collapsible-icon {
            font-size: 1.2rem;
            color: var(--gold-light);
            transition: transform 0.3s;
        }
        
        .collapsible-section.active .collapsible-icon {
            transform: rotate(180deg);
        }
        
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            padding: 0 24px;
            background: var(--parchment);
        }
        
        .collapsible-section.active .collapsible-content {
            max-height: 3000px;
            padding: 24px;
            transition: max-height 0.5s ease-in;
        }
        
        .section-description {
            color: var(--ink-light);
            font-size: 0.92rem;
            margin-bottom: 16px;
            line-height: 1.7;
            font-style: italic;
        }
        
        .button-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .charts-container {
            max-width: 3840px;
            margin: 0 auto;
            padding: 0 40px 40px 40px;
        }
        
        .chart-wrapper {
            background: var(--parchment);
            background-image: linear-gradient(180deg, #f7f0db 0%, #f5edd6 100%);
            border: 1px solid var(--border);
            box-shadow: 0 2px 16px rgba(0,0,0,0.15), inset 0 0 40px rgba(180,140,60,0.04);
            padding: 24px 28px;
            margin-bottom: 28px;
            position: relative;
        }
        .chart-wrapper::before {
            content: '';
            position: absolute;
            top: 3px; left: 3px; right: 3px; bottom: 3px;
            border: 1px solid rgba(160,120,48,0.2);
            pointer-events: none;
        }
        
        .chart-title {
            font-family: 'Cinzel', serif;
            color: var(--ink);
            font-size: 1rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            margin-bottom: 16px;
            padding-bottom: 10px;
            border-bottom: 2px double var(--border);
        }
        
        .chart-animation-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: rgba(245,237,214,0.95);
            padding: 12px;
            border: 1px solid var(--border);
            z-index: 10;
        }
        
        .chart-play-pause-btn {
            padding: 8px 16px;
            background: var(--ink);
            border: none;
            color: var(--parchment);
            font-family: 'Cinzel', serif;
            font-size: 0.7rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .chart-play-pause-btn:hover {
            background: var(--sepia);
        }
        
        .chart-play-pause-btn.playing {
            background: var(--red-ink);
        }
        
        .chart-play-pause-btn.playing:hover {
            background: #6a1010;
        }
        
        .chart-speed-control {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .chart-speed-label {
            font-family: 'Cinzel', serif;
            font-size: 0.65rem;
            letter-spacing: 0.08em;
            color: var(--ink-light);
            text-transform: uppercase;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chart-speed-value {
            color: var(--gold);
            font-family: 'EB Garamond', serif;
            font-size: 0.85rem;
        }
        
        .chart-speed-slider {
            width: 100%;
            height: 6px;
            background: var(--parchment-dark);
            border: 1px solid var(--border);
            border-radius: 0;
            outline: none;
            -webkit-appearance: none;
        }
        
        .chart-speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--gold);
            cursor: pointer;
        }
        
        .chart-speed-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--gold);
            cursor: pointer;
            border: none;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: auto;
            background: #0a0a10;
            border: 1px solid var(--border);
        }
        
        .status-bar {
            background: var(--parchment-dark);
            border: 1px solid var(--border);
            padding: 12px 20px;
            margin-bottom: 20px;
            font-family: 'EB Garamond', serif;
            font-size: 0.95rem;
            color: var(--ink-mid);
        }
        
        .status-bar.computing {
            color: var(--gold);
            border-left: 4px solid var(--gold);
        }
        
        .status-bar.complete {
            color: var(--green-ink);
            border-left: 4px solid var(--green-ink);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: var(--parchment-dark);
            padding: 14px 16px;
            border-left: 3px solid var(--gold);
            border: 1px solid var(--panel-border);
            border-left: 3px solid var(--gold);
        }
        
        .stat-label {
            font-family: 'Cinzel', serif;
            font-size: 0.65rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--gold);
            margin-bottom: 6px;
        }
        
        .stat-value {
            font-size: 1.2rem;
            color: var(--ink);
            font-family: 'EB Garamond', serif;
            font-weight: 600;
        }
        
        .toggle-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            color: var(--ink-mid);
            font-size: 0.92rem;
        }
        
        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
        }
        
        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            inset: 0;
            background: var(--parchment-deep);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: 0.3s;
        }
        
        .toggle-slider:before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            left: 3px;
            top: 2px;
            background: var(--ink-light);
            transition: 0.3s;
        }
        
        .toggle input:checked + .toggle-slider {
            background: var(--gold);
            border-color: var(--gold);
        }
        
        .toggle input:checked + .toggle-slider:before {
            transform: translateX(24px);
            background: var(--ink);
        }
        
        .animation-controls {
            background: var(--parchment-dark);
            border: 1px solid var(--border);
            padding: 16px;
            margin-top: 16px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--parchment-deep);
            border: 1px solid var(--border);
            overflow: hidden;
            margin-top: 12px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--gold), var(--gold-light));
            width: 0%;
            transition: width 0.3s;
        }
        
        .stats-table-wrapper {
            background: var(--parchment-dark);
            border: 1px solid var(--panel-border);
            padding: 20px;
            margin-top: 20px;
        }
        
        .stats-table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px double var(--border);
        }
        
        .stats-table-title {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 0.75rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        
        .precision-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .precision-control label {
            font-family: 'Cinzel', serif;
            font-size: 0.65rem;
            letter-spacing: 0.08em;
            color: var(--ink-light);
            text-transform: uppercase;
        }
        
        .precision-control select {
            width: 80px;
            padding: 5px 8px;
            background: var(--parchment);
            border: 1px solid var(--border);
            color: var(--ink);
            font-family: 'EB Garamond', serif;
            font-size: 0.9rem;
        }
        
        .show-all-toggle {
            background: var(--parchment);
            color: var(--ink-mid);
            border: 1px solid var(--border);
            padding: 5px 12px;
            font-family: 'Cinzel', serif;
            font-size: 0.65rem;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .show-all-toggle:hover {
            background: var(--parchment-deep);
        }
        
        .stats-table-container {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .stats-table-container.expanded {
            max-height: 800px;
        }
        
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'EB Garamond', serif;
            font-size: 0.92rem;
        }
        
        .stats-table thead {
            position: sticky;
            top: 0;
            background: var(--parchment-dark);
            z-index: 10;
        }
        
        .stats-table th {
            padding: 10px 12px;
            text-align: left;
            font-family: 'Cinzel', serif;
            font-size: 0.65rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--gold);
            border-bottom: 2px solid var(--border);
        }
        
        .stats-table th:first-child {
            text-align: center;
        }
        
        .stats-table td {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(160,120,48,0.15);
            color: var(--ink-mid);
        }
        
        .stats-table td:first-child {
            text-align: center;
            color: var(--gold);
            font-weight: 600;
        }
        
        .stats-table tr:hover {
            background: rgba(139,99,16,0.05);
        }
        
        .stats-table tr:nth-child(even) {
            background: rgba(139,99,16,0.03);
        }
        
        .prime-list {
            max-width: 400px;
            color: var(--ink-light);
            font-size: 0.85rem;
        }
        
        .stats-table-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .stats-table-container::-webkit-scrollbar-track {
            background: var(--parchment-dark);
        }
        
        .stats-table-container::-webkit-scrollbar-thumb {
            background: var(--border);
        }
        
        .stats-table-container::-webkit-scrollbar-thumb:hover {
            background: var(--gold);
        }

        /* TAB SYSTEM */
        .tab-navigation {
            display: flex;
            gap: 0;
            background: var(--parchment-dark);
            padding: 0;
            border-bottom: 2px solid var(--border);
        }

        .tab-btn {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-right: 1px solid var(--panel-border);
            color: var(--ink-light);
            font-family: 'Cinzel', serif;
            font-size: 0.72rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .tab-btn:hover {
            background: rgba(139,99,16,0.08);
            color: var(--ink);
        }

        .tab-btn.active {
            background: var(--gold);
            color: var(--parchment);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: var(--parchment);
        }

        .data-table th {
            background: var(--parchment-dark);
            font-family: 'Cinzel', serif;
            font-size: 0.65rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--gold);
            padding: 10px 12px;
            text-align: left;
            border-bottom: 2px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .data-table td {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(160,120,48,0.15);
            color: var(--ink-mid);
            font-family: 'EB Garamond', serif;
        }

        .data-table tr:hover {
            background: rgba(139,99,16,0.05);
            cursor: pointer;
        }

        .data-table tr.highlighted {
            background: rgba(139,99,16,0.15);
            border-left: 4px solid var(--gold);
        }

        .stats-table tr {
            cursor: pointer;
            transition: all 0.2s;
        }

        .stats-table tr.highlighted {
            background: rgba(139,99,16,0.15);
            border-left: 4px solid var(--gold);
        }

        .data-table tbody {
            max-height: 600px;
            overflow-y: auto;
        }

        .copy-btn {
            padding: 5px 12px;
            background: var(--sepia);
            border: none;
            color: var(--parchment);
            font-family: 'Cinzel', serif;
            font-size: 0.65rem;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: var(--ink);
        }

        .data-container {
            background: var(--parchment-dark);
            border: 1px solid var(--border);
            padding: 24px;
            margin: 20px 0;
        }

        .chart-description {
            background: rgba(139,99,16,0.07);
            border-left: 4px solid var(--gold);
            padding: 14px 18px;
            margin-bottom: 20px;
            color: var(--ink-mid);
            font-size: 0.93rem;
            line-height: 1.75;
            font-style: italic;
        }
        
        .export-row {
            display: flex;
            gap: 8px;
            margin-top: 14px;
            padding-top: 12px;
            border-top: 1px solid rgba(160,120,48,0.3);
        }
        
        .export-btn {
            flex: 1;
            padding: 8px 12px;
            background: var(--parchment-dark);
            color: var(--ink-mid);
            border: 1px solid var(--border);
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 0.68rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            transition: all 0.2s;
        }
        
        .export-btn:hover {
            background: var(--parchment-deep);
        }
        
        .export-btn.csv {
            background: var(--ink);
            color: var(--parchment);
            border-color: var(--ink);
        }
        
        .export-btn.csv:hover {
            background: var(--green-ink);
        }
        
        .export-btn.png {
            background: var(--sepia);
            color: var(--parchment);
            border-color: var(--sepia);
        }
        
        .export-btn.png:hover {
            background: var(--ink-mid);
        }
        
        .section-divider {
            height: 1px;
            background: var(--border);
            opacity: 0.4;
            margin: 24px 0;
        }
        /* Modal Popup Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(30,16,8,0.85);
            z-index: 10000;
            backdrop-filter: blur(4px);
        }
        
        .modal-overlay.active {
            display: flex;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.2s;
        }
        
        .modal-content {
            background: var(--parchment);
            background-image: linear-gradient(180deg, #f7f0db 0%, #f5edd6 100%);
            border: 2px solid var(--border);
            padding: 36px;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            animation: slideIn 0.3s;
            position: relative;
        }
        .modal-content::before {
            content: '';
            position: absolute;
            top: 4px; left: 4px; right: 4px; bottom: 4px;
            border: 1px solid rgba(160,120,48,0.2);
            pointer-events: none;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px double var(--border);
        }
        
        .modal-title {
            font-family: 'Cinzel', serif;
            color: var(--ink);
            font-size: 1.2rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }
        
        .modal-close {
            background: var(--red-ink);
            color: var(--parchment);
            border: none;
            padding: 8px 16px;
            font-family: 'Cinzel', serif;
            font-size: 0.72rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
        }
        
        .modal-close:hover {
            background: #6a1010;
        }
        
        .modal-screenshot {
            background: var(--sepia);
            color: var(--parchment);
            border: none;
            padding: 8px 16px;
            font-family: 'Cinzel', serif;
            font-size: 0.72rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
        }
        
        .modal-screenshot:hover {
            background: var(--ink-mid);
        }
        
        .modal-section {
            margin-bottom: 24px;
        }
        
        .modal-section-title {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 0.82rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            margin-bottom: 12px;
        }
        
        .modal-stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .modal-stat-item {
            background: var(--parchment-dark);
            border: 1px solid var(--panel-border);
            border-left: 3px solid var(--gold);
            padding: 12px;
        }
        
        .modal-stat-label {
            font-family: 'Cinzel', serif;
            font-size: 0.65rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--gold);
            margin-bottom: 4px;
        }
        
        .modal-stat-value {
            color: var(--ink);
            font-size: 1.2rem;
            font-family: 'EB Garamond', serif;
            font-weight: 600;
        }
        
        .modal-prime-list {
            background: var(--parchment-dark);
            border: 1px solid var(--panel-border);
            border-left: 3px solid var(--sepia);
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .modal-prime-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .modal-prime-list::-webkit-scrollbar-track {
            background: var(--parchment-dark);
        }
        
        .modal-prime-list::-webkit-scrollbar-thumb {
            background: var(--border);
        }
        
        .modal-prime-list::-webkit-scrollbar-thumb:hover {
            background: var(--gold);
        }
        
        .modal-prime-list code {
            color: var(--sepia);
            font-size: 0.92rem;
            line-height: 1.8;
            word-wrap: break-word;
            font-family: 'EB Garamond', serif;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes slideDown {
            from {
                max-height: 0;
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                max-height: 500px;
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes slideUp {
            from {
                max-height: 500px;
                opacity: 1;
            }
            to {
                max-height: 0;
                opacity: 0;
            }
        }
        /* Hardy-Littlewood Deep Dive styles */
        .hl-preset-btn { padding:6px 12px; background:var(--parchment-dark); border:1px solid var(--border); color:var(--ink-mid); cursor:pointer; font-family:'Cinzel',serif; font-size:.68rem; letter-spacing:.06em; text-transform:uppercase; transition:background .2s; }
        .hl-preset-btn:hover { background:var(--ink); color:var(--parchment); border-color:var(--ink); }
        .hl-step-block { background:var(--parchment-dark); border-left:3px solid var(--gold); padding:14px 18px; margin-bottom:10px; }
        .hl-step-num { color:var(--gold); font-family:'Cinzel',serif; font-size:.68rem; font-weight:700; text-transform:uppercase; letter-spacing:.1em; margin-bottom:6px; }
        .hl-step-math { font-family:'EB Garamond',Georgia,serif; font-size:1.1rem; color:var(--ink); margin-bottom:4px; line-height:1.65; }
        .hl-step-explain { color:var(--ink-light); font-size:.88rem; line-height:1.65; font-style:italic; }
        .hl-result-box { background:var(--parchment-dark); border:2px solid var(--border); padding:18px; margin-top:16px; text-align:center; }

        /* ── RESPONSIVE ── */
        @media screen and (max-width: 768px) {
            .charts-container { padding: 0 16px 20px 16px; }
            .chart-wrapper { padding: 12px; }
            .introduction { padding: 0 16px; }
            .controls-container { padding: 0 16px; }
            .header { padding: 24px 16px; }
            .header h1 { font-size: 1.2rem; }
            .header .subtitle { font-size: 0.8rem; }
            .control-grid { grid-template-columns: 1fr; }
            .intro-section { padding: 20px 16px; }
            .chart-animation-controls { position: static; width: 100%; margin-bottom: 12px; }
            .chart-title { font-size: 0.85rem; }
            .modal-content { width: 95%; max-height: 90vh; padding: 16px; }
            .modal-stat-grid { grid-template-columns: 1fr; gap: 12px; }
            .btn { padding: 10px 16px; font-size: 0.72rem; }
            .stats-table-container { overflow-x: auto; }
        }
        
        @media screen and (max-width: 480px) {
            .header h1 { font-size: 1rem; }
            .chart-wrapper { padding: 8px; }
            .charts-container { padding: 0 8px 16px 8px; }
            .modal-content { width: 98%; padding: 12px; }
        }
    </style>
</head>
<body class="dark-mode">
    <header class="header">
        <h1>Gap-Class Decomposition of ζ(2) = π²/6</h1>
        <div class="subtitle">A Partition of the Euler Product by Prime Gap Class: Numerical Evidence and Open Questions</div>
        <div class="author">Wessen Getachew &nbsp;·&nbsp; 2026</div>
        <div class="tool-nav">
            MSC 2020: 11M06 &nbsp;·&nbsp; 11N05 &nbsp;·&nbsp; 11A41 &nbsp;·&nbsp;
            <a class="tool-nav-link" href="https://wessengetachew.github.io/G/" target="_blank">Interactive Tool</a>
            &nbsp;·&nbsp;
            <a class="tool-nav-link" href="https://wessengetachew.github.io/Primes/" target="_blank">Modular Sieve</a>
            &nbsp;·&nbsp;
            <a class="tool-nav-link" href="https://wessengetachew.github.io/Composite/" target="_blank">Composite</a>
            &nbsp;·&nbsp;
            <a class="tool-nav-link" href="https://wessengetachew.github.io/Transform/" target="_blank">Transform</a>
            &nbsp;·&nbsp;
            <a class="tool-nav-link" href="#riemannZerosSection" style="color:#a855f7;">&#950; Riemann Zeros</a>
        </div>
    </header>
    
    <button id="font-toggle" onclick="cycleFontTheme()" title="Switch font">Aa Cinzel</button>
    <button id="dark-mode-toggle" onclick="document.body.classList.toggle('dark-mode'); this.textContent = document.body.classList.contains('dark-mode') ? '☾ Dark' : '☀ Light'; if(typeof fareyRedraw==='function') fareyRedraw(); if(typeof rzDraw==='function' && window._rzVisible) rzDraw(); if(typeof renderAllCharts==='function' && window.analysisResults) renderAllCharts(); if(typeof m_drawGraph==='function') m_drawGraph();">☀ Light</button>

    <div class="introduction">
        <div class="intro-section">

            <!-- 2πr/m Farey diagram -->
            <!-- ══ FAREY INTERACTIVE DIAGRAMS ══ -->
            <div id="farey-root" style="margin:24px auto 0;max-width:900px;">

              <!-- Advanced dropdown -->
              <div style="text-align:right;margin-bottom:8px;">
                <button onclick="toggleFareyPanel()" style="font-family:'Cinzel',serif;font-size:0.62rem;letter-spacing:0.1em;text-transform:uppercase;background:var(--parchment-dark);color:var(--gold);border:1px solid var(--border);padding:5px 14px;cursor:pointer;">&#9660; Advanced</button>
              </div>

              <div id="farey-panel" style="display:none;background:var(--parchment-dark);border:1px solid var(--panel-border);padding:16px 20px;margin-bottom:14px;font-family:'Cinzel',serif;font-size:0.68rem;letter-spacing:0.07em;color:var(--ink-mid);">
                <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:14px 24px;align-items:start;">

                  <!-- Label mode -->
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">LABEL MODE</div>
                    <select id="f-label" onchange="fareyRedraw()" style="background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:3px 6px;font-family:'Cinzel',serif;font-size:0.62rem;width:100%;">
                      <option value="none">None</option>
                      <option value="fraction">r/m</option>
                      <option value="r">r only</option>
                      <option value="m">m only</option>
                      <option value="angle">Angle (deg)</option>
                      <option value="radian">Radian (×π)</option>
                      <option value="decimal">Decimal</option>
                    </select>
                  </div>

                  <!-- Label replaces dot -->
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">LABEL STYLE</div>
                    <select id="f-label-style" onchange="fareyRedraw()" style="background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:3px 6px;font-family:'Cinzel',serif;font-size:0.62rem;width:100%;">
                      <option value="dot+label">Dot + Label</option>
                      <option value="label-only">Label Only</option>
                    </select>
                  </div>

                  <!-- Label size -->
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">LABEL SIZE</div>
                    <div style="display:flex;align-items:center;gap:8px;">
                      <input id="f-lsize" type="range" min="4" max="18" value="7" style="flex:1;accent-color:var(--gold);" oninput="document.getElementById('f-lsize-val').textContent=this.value;fareyRedraw()">
                      <span id="f-lsize-val" style="color:var(--ink);min-width:20px;text-align:right;">7</span>
                    </div>
                  </div>

                  <!-- Point color: gcd=1 -->
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">COLOR gcd=1</div>
                    <input id="f-col1" type="color" value="#4a90d9" oninput="fareyRedraw()" style="width:100%;height:28px;border:1px solid var(--border);cursor:pointer;background:none;">
                  </div>

                  <!-- Point color: gcd>1 -->
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">COLOR gcd&gt;1</div>
                    <input id="f-col2" type="color" value="#c94040" oninput="fareyRedraw()" style="width:100%;height:28px;border:1px solid var(--border);cursor:pointer;background:none;">
                  </div>

                  <!-- Canvas size -->
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">DIAGRAM SIZE</div>
                    <div style="display:flex;align-items:center;gap:8px;">
                      <input id="f-size" type="range" min="160" max="2000" value="260" style="flex:1;accent-color:var(--gold);" oninput="document.getElementById('f-size-num').value=this.value;fareyResize()">
                      <input id="f-size-num" type="number" min="160" max="2000" value="260" style="width:54px;background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:2px 4px;font-family:'Cinzel',serif;font-size:0.62rem;text-align:right;" oninput="var v=Math.min(2000,Math.max(160,parseInt(this.value)||260));document.getElementById('f-size').value=v;fareyResize()">
                      <span style="color:var(--ink-light);font-size:0.58rem;">px</span>
                    </div>
                  </div>

                  <!-- Ring spacing -->
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">RING SPACING</div>
                    <div style="display:flex;align-items:center;gap:8px;">
                      <input id="f-spacing" type="range" min="10" max="200" value="100" style="flex:1;accent-color:var(--gold);" oninput="document.getElementById('f-spacing-val').textContent=this.value+'%';fareyRedraw()">
                      <span id="f-spacing-val" style="color:var(--ink);min-width:36px;text-align:right;font-size:0.6rem;">100%</span>
                    </div>
                    <div style="margin-top:6px;color:#9a8060;font-size:0.58rem;">INNER RADIUS</div>
                    <div style="display:flex;align-items:center;gap:8px;margin-top:3px;">
                      <input id="f-rinner" type="range" min="0" max="50" value="4" style="flex:1;accent-color:var(--gold);" oninput="document.getElementById('f-rinner-val').textContent=(this.value/100).toFixed(2);fareyRedraw()">
                      <span id="f-rinner-val" style="color:var(--ink);min-width:36px;text-align:right;font-size:0.6rem;">0.04</span>
                    </div>
                    <div style="margin-top:6px;color:#9a8060;font-size:0.58rem;">ZOOM</div>
                    <div style="display:flex;align-items:center;gap:8px;margin-top:3px;">
                      <input id="f-zoom" type="range" min="50" max="500" value="100" style="flex:1;accent-color:var(--gold);" oninput="document.getElementById('f-zoom-val').textContent=this.value+'%';fareyRedraw()">
                      <span id="f-zoom-val" style="color:var(--ink);min-width:36px;text-align:right;font-size:0.6rem;">100%</span>
                    </div>
                    <div style="margin-top:8px;">
                      <label style="cursor:pointer;display:flex;align-items:center;gap:8px;">
                        <input id="f-invert-order" type="checkbox" onchange="fareyRedraw()" style="accent-color:var(--gold);">
                        <span style="color:#9a8060;font-size:0.6rem;text-transform:uppercase;letter-spacing:0.08em;">Invert Ring Order (outer→inner)</span>
                      </label>
                    </div>
                    <div style="margin-top:8px;color:#9a8060;font-size:0.58rem;">BRIGHTNESS</div>
                    <div style="display:flex;align-items:center;gap:8px;margin-top:3px;">
                      <input id="f-bright" type="range" min="0" max="100" value="0" style="flex:1;accent-color:var(--gold);" oninput="document.getElementById('f-bright-val').textContent='+'+this.value+'%';fareyRedraw()">
                      <span id="f-bright-val" style="color:var(--ink);min-width:36px;text-align:right;font-size:0.6rem;">+0%</span>
                    </div>
                    <div style="margin-top:8px;color:#9a8060;font-size:0.58rem;">POINT SIZE</div>
                    <div style="display:flex;align-items:center;gap:8px;margin-top:3px;">
                      <input id="f-ptsize" type="range" min="10" max="400" value="100" style="flex:1;accent-color:var(--gold);" oninput="document.getElementById('f-ptsize-val').textContent=this.value+'%';fareyRedraw()">
                      <span id="f-ptsize-val" style="color:var(--ink);min-width:36px;text-align:right;font-size:0.6rem;">100%</span>
                    </div>
                  </div>

                  <!-- Show chords -->
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">SHOW CHORDS</div>
                    <label style="cursor:pointer;display:flex;align-items:center;gap:6px;">
                      <input id="f-chords" type="checkbox" checked onchange="fareyRedraw()" style="accent-color:var(--gold);">
                      <span>Involution chords</span>
                    </label>
                    <label style="cursor:pointer;display:flex;align-items:center;gap:6px;margin-top:4px;">
                      <input id="f-spokes" type="checkbox" checked onchange="fareyRedraw()" style="accent-color:var(--gold);">
                      <span>Radial spokes</span>
                    </label>
                  </div>

                  <!-- Angle direction -->
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">ANGLE DIRECTION</div>
                    <select id="f-dir" onchange="fareyRedraw()" style="background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:3px 6px;font-family:'Cinzel',serif;font-size:0.62rem;width:100%;">
                      <option value="1">+2πr/m (counter-clockwise)</option>
                      <option value="-1" selected>−2πr/m (clockwise)</option>
                    </select>
                  </div>

                  <!-- Per-ring cumulative rotation -->
                  <div style="grid-column:1/-1;">
                    <div style="margin-bottom:6px;color:var(--gold);letter-spacing:0.1em;">PER-RING CUMULATIVE ROTATION</div>
                    <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px 16px;align-items:end;">
                      <div>
                        <div style="margin-bottom:4px;color:#9a8060;font-size:0.6rem;">STEP a/b</div>
                        <div style="display:flex;align-items:center;gap:4px;">
                          <input id="f-ringstep-a" type="number" min="0" max="360" value="0" style="width:44px;background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:2px 4px;font-family:'Cinzel',serif;font-size:0.62rem;text-align:center;" oninput="fareyRedraw()">
                          <span style="color:var(--gold);">/</span>
                          <input id="f-ringstep-b" type="number" min="1" max="360" value="2" style="width:44px;background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:2px 4px;font-family:'Cinzel',serif;font-size:0.62rem;text-align:center;" oninput="fareyRedraw()">
                          <span style="color:#9a8060;font-size:0.58rem;margin-left:2px;">× 360°</span>
                        </div>
                      </div>
                      <div>
                        <div style="margin-bottom:4px;color:#9a8060;font-size:0.6rem;">DIRECTION</div>
                        <select id="f-ringdir" onchange="fareyRedraw()" style="background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:3px 6px;font-family:'Cinzel',serif;font-size:0.62rem;width:100%;">
                          <option value="1">Inner → Outer</option>
                          <option value="-1">Outer → Inner</option>
                        </select>
                      </div>
                      <div>
                        <div style="margin-bottom:4px;color:#9a8060;font-size:0.6rem;">AUTO-ROTATE SPEED</div>
                        <div style="display:flex;align-items:center;gap:6px;">
                          <input id="f-ringspeed" type="range" min="1" max="100" value="20" style="flex:1;accent-color:var(--gold);" oninput="document.getElementById('f-ringspeed-val').textContent=this.value;">
                          <span id="f-ringspeed-val" style="color:var(--ink);min-width:24px;font-size:0.6rem;">20</span>
                        </div>
                      </div>
                      <div>
                        <div style="margin-bottom:4px;color:#9a8060;font-size:0.6rem;">CONTROLS</div>
                        <div style="display:flex;gap:6px;flex-wrap:wrap;">
                          <button id="f-ringanim-btn" onclick="fareyToggleRingAnim()" style="font-family:'Cinzel',serif;font-size:0.56rem;letter-spacing:0.06em;text-transform:uppercase;padding:3px 8px;border:1px solid var(--border);background:var(--parchment-dark);color:var(--ink-mid);cursor:pointer;">&#9654; Spin</button>
                          <button onclick="fareyResetRings()" style="font-family:'Cinzel',serif;font-size:0.56rem;letter-spacing:0.06em;text-transform:uppercase;padding:3px 8px;border:1px solid var(--border);background:var(--parchment-dark);color:var(--ink-mid);cursor:pointer;">&#8635; Reset</button>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">RING POLYGON</div>
                    <label style="cursor:pointer;display:flex;align-items:center;gap:6px;">
                      <input id="f-samemod" type="checkbox" onchange="fareyRedraw()" style="accent-color:var(--gold);">
                      <span>Draw polygon connecting residues around each ring</span>
                    </label>
                    <div style="margin-top:6px;color:var(--gold);font-size:0.58rem;letter-spacing:0.06em;">POINTS TO CONNECT</div>
                    <select id="f-samemod-filter" onchange="fareyRedraw()" style="margin-top:3px;background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:3px 6px;font-family:'Cinzel',serif;font-size:0.62rem;width:100%;">
                      <option value="gcd1">gcd=1 only  (mod 4 → square, mod 8 → square…)</option>
                      <option value="all">All points  (mod 4 → square, mod 8 → octagon…)</option>
                      <option value="gcd2">gcd&gt;1 only</option>
                    </select>
                    <div style="margin-top:8px;color:var(--gold);font-size:0.58rem;letter-spacing:0.06em;">WHICH RINGS</div>
                    <select id="f-samemod-rings" onchange="fareyRedraw()" style="margin-top:3px;background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:3px 6px;font-family:'Cinzel',serif;font-size:0.62rem;width:100%;">
                      <option value="outer">Outer ring only (mod N)</option>
                      <option value="all">All rings</option>
                      <option value="outer5">Outer 5 rings</option>
                    </select>
                    <label style="cursor:pointer;display:flex;align-items:center;gap:6px;margin-top:8px;">
                      <input id="f-crossmod" type="checkbox" checked onchange="fareyRedraw()" style="accent-color:var(--gold);">
                      <span style="color:var(--gold);font-size:0.58rem;letter-spacing:0.06em;">CROSS-MOD CONNECTIONS (r → same r, ring m→m+1)</span>
                    </label>
                  </div>

                  <!-- Gap quick-select -->
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">SHOW GAP OVERLAY</div>
                    <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
                      <input id="f-gap-input" type="text" placeholder="e.g. 2 or 2,4,6" value=""
                        style="flex:1;min-width:80px;background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:3px 6px;font-family:'Cinzel',serif;font-size:0.62rem;"
                        onkeydown="if(event.key==='Enter')fareyGapInputApply()">
                      <button onclick="fareyGapInputApply()" style="font-family:'Cinzel',serif;font-size:0.55rem;letter-spacing:0.06em;text-transform:uppercase;padding:3px 10px;border:1px solid var(--gold);background:var(--parchment-dark);color:var(--gold);cursor:pointer;">Show</button>
                      <button onclick="fareyGapOverlayClear()" style="font-family:'Cinzel',serif;font-size:0.55rem;letter-spacing:0.06em;text-transform:uppercase;padding:3px 10px;border:1px solid #c94040;background:var(--parchment-dark);color:#c94040;cursor:pointer;">Clear</button>
                    </div>
                    <div id="f-gap-input-status" style="font-family:'Cinzel',serif;font-size:0.55rem;color:#9a8060;margin-top:3px;min-height:14px;"></div>
                  </div>

                  <!-- Same-mod color -->
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">SAME-MOD LINE COLOR</div>
                    <select id="f-samemod-colmode" onchange="fareyRedraw()" style="background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:3px 6px;font-family:'Cinzel',serif;font-size:0.62rem;width:100%;margin-bottom:6px;">
                      <option value="permod">Per-mod (rainbow)</option>
                      <option value="fixed">Fixed color</option>
                      <option value="gradient">Gradient (inner→outer)</option>
                    </select>
                    <input id="f-samemod-col" type="color" value="#e0a030" oninput="fareyRedraw()" style="width:100%;height:24px;border:1px solid var(--border);cursor:pointer;background:none;">
                  </div>

                  <!-- Same-mod thickness -->
                  <div>
                    <div style="margin-bottom:5px;color:var(--gold);">SAME-MOD THICKNESS</div>
                    <div style="display:flex;align-items:center;gap:8px;">
                      <input id="f-samemod-thick" type="range" min="1" max="30" value="4" style="flex:1;accent-color:var(--gold);" oninput="document.getElementById('f-samemod-thick-val').textContent=(this.value/10).toFixed(1);fareyRedraw()">
                      <span id="f-samemod-thick-val" style="color:var(--ink);min-width:28px;text-align:right;">0.4</span>
                    </div>
                    <div style="margin-top:8px;color:var(--gold);">CROSS-MOD THICKNESS</div>
                    <div style="display:flex;align-items:center;gap:8px;margin-top:4px;">
                      <input id="f-crossmod-thick" type="range" min="1" max="30" value="30" style="flex:1;accent-color:var(--gold);" oninput="document.getElementById('f-crossmod-thick-val').textContent=(this.value/10).toFixed(1);fareyRedraw()">
                      <span id="f-crossmod-thick-val" style="color:var(--ink);min-width:28px;text-align:right;">3.0</span>
                    </div>
                  </div>

                </div>
              </div>

              <!-- ══ CANVAS AREA ══ -->

              <!-- Split view (two small canvases) -->
              <div id="farey-split-view" style="display:flex;justify-content:center;gap:32px;align-items:flex-start;flex-wrap:wrap;">
                <div style="text-align:center;">
                  <canvas id="fc-coprime" width="260" height="260" style="cursor:pointer;display:block;" onclick="fareyRotate('coprime')" title="Click to rotate 90°"></canvas>
                  <div id="fc-label1" style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.1em;text-transform:uppercase;color:#4a90d9;margin-top:6px;">gcd(r, m) = 1</div>
                </div>
                <div style="text-align:center;">
                  <canvas id="fc-noncoprime" width="260" height="260" style="cursor:pointer;display:block;" onclick="fareyRotate('noncoprime')" title="Click to rotate 90°"></canvas>
                  <div id="fc-label2" style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.1em;text-transform:uppercase;color:#c94040;margin-top:6px;">gcd(r, m) &gt; 1</div>
                </div>
              </div>

              <!-- Combined view -->
              <div id="farey-combined-view" style="display:none;text-align:center;">
                <div style="position:relative;display:inline-block;">
                  <canvas id="fc-combined" width="800" height="800" style="cursor:crosshair;display:block;" title="Click a point to inspect it"></canvas>
                  <div id="farey-tooltip" style="display:none;position:absolute;pointer-events:none;background:#0e0b05;border:1px solid #c49b38;padding:10px 14px;font-family:'Cinzel',serif;font-size:0.65rem;letter-spacing:0.06em;line-height:1.8;color:#e8d9b0;min-width:160px;z-index:10;box-shadow:0 4px 20px rgba(0,0,0,0.7);"></div>
                </div>

                <!-- Canvas mode buttons -->
                <div style="margin-top:10px;display:flex;justify-content:center;gap:8px;align-items:center;flex-wrap:wrap;">
                  <button onclick="fareyCombinedMode('both')"       id="fcm-both"       style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:4px 12px;border:1px solid var(--border);background:var(--gold);color:var(--parchment);cursor:pointer;">Combined</button>
                  <button onclick="fareyCombinedMode('coprime')"    id="fcm-coprime"    style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:4px 12px;border:1px solid #4a90d9;background:var(--parchment-dark);color:#4a90d9;cursor:pointer;">gcd=1</button>
                  <button onclick="fareyCombinedMode('noncoprime')" id="fcm-noncoprime" style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:4px 12px;border:1px solid #c94040;background:var(--parchment-dark);color:#c94040;cursor:pointer;">gcd&gt;1</button>
                  <span style="color:var(--border);">|</span>
                  <button id="fcm-ar-out"    onclick="fareyToggleAutoRotate('out')" style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:4px 10px;border:1px solid var(--border);background:var(--parchment-dark);color:var(--ink-mid);cursor:pointer;">&#8635; Out→In</button>
                  <button id="fcm-autorotate" onclick="fareyToggleAutoRotate()"     style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:4px 10px;border:1px solid var(--border);background:var(--parchment-dark);color:var(--ink-mid);cursor:pointer;">&#9654; Rotate</button>
                  <button id="fcm-ar-in"     onclick="fareyToggleAutoRotate('in')"  style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:4px 10px;border:1px solid var(--border);background:var(--parchment-dark);color:var(--ink-mid);cursor:pointer;">&#8634; In→Out</button>
                  <button onclick="fareyRotateReset()"                              style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:4px 10px;border:1px solid var(--border);background:var(--parchment-dark);color:var(--ink-mid);cursor:pointer;">&#11119; Reset</button>
                  <button id="fcm-inspect"   onclick="fareyToggleInspect()"         style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:4px 10px;border:1px solid var(--border);background:var(--parchment-dark);color:var(--ink-mid);cursor:pointer;">&#9679; Inspect</button>
                  <button id="fcm-chain-clear" onclick="fareyClearChain()"          style="display:none;font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:4px 10px;border:1px solid #e879f9;background:var(--parchment-dark);color:#e879f9;cursor:pointer;">&#10005; Clear Chain</button>
                  <span style="color:var(--border);">|</span>
                  <button id="fcm-zeros"     onclick="fareyToggleZeros()"           style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:4px 10px;border:1px solid var(--border);background:var(--parchment-dark);color:#a855f7;cursor:pointer;">&#950; Riemann t</button>
                  <a href="#riemannZerosSection"                                    style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:4px 10px;border:1px solid #a855f7;background:var(--parchment-dark);color:#a855f7;cursor:pointer;text-decoration:none;">&#8595; Zeros</a>
                </div>

                <!-- Canvas sub-label -->
                <div id="fc-combined-label" style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.1em;text-transform:uppercase;color:var(--gold);margin-top:5px;">Combined · click canvas to rotate 90°</div>

                <!-- Gap animation bar (shown when gap active) -->
                <div id="farey-gap-overlay-controls" style="display:none;margin-top:6px;align-items:center;gap:8px;font-family:'Cinzel',serif;font-size:0.58rem;color:#4a90d9;flex-wrap:wrap;justify-content:center;">
                  <span>OPACITY</span>
                  <input id="f-overlay-alpha" type="range" min="10" max="100" value="80" style="width:70px;accent-color:#4a90d9;" oninput="document.getElementById('f-overlay-alpha-val').textContent=this.value+'%';if(window._overlayGap!==null&&window._overlayGap!==undefined){fareyRedraw();}">
                  <span id="f-overlay-alpha-val" style="min-width:28px;">80%</span>
                  <span style="color:var(--border);">|</span>
                  <button id="fcm-gap-play" onclick="fareyGapAnimToggle()" style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:3px 12px;border:1px solid #e879f9;background:var(--parchment-dark);color:#e879f9;cursor:pointer;">&#9654; Play</button>
                  <span style="color:#9a8060;">SPEED</span>
                  <input id="f-anim-speed" type="range" min="1" max="10" value="5" style="width:60px;accent-color:#e879f9;">
                  <label style="color:#9a8060;cursor:pointer;display:flex;align-items:center;gap:4px;"><input type="checkbox" id="f-anim-loop" checked style="accent-color:#e879f9;"> Loop</label>
                </div>

                <!-- Gap stats bar -->
                <div id="farey-gap-overlay-bar" style="display:none;margin-top:8px;padding:8px 16px;background:rgba(10,30,60,0.85);border:1px solid #4a90d9;border-radius:6px;font-family:'Cinzel',serif;font-size:0.62rem;color:#e8d9b0;text-align:center;">
                  <span id="farey-gap-overlay-info"></span>
                  &nbsp;
                  <button onclick="fareyGapOverlayClear()" style="font-family:'Cinzel',serif;font-size:0.56rem;text-transform:uppercase;padding:2px 8px;border:1px solid #4a90d9;background:transparent;color:#4a90d9;cursor:pointer;">&#10005; Clear</button>
                </div>

                <!-- Chain panel -->
                <div id="farey-chain-panel" style="display:none;margin-top:8px;padding:12px 16px;background:var(--parchment-dark);border:1px solid #e879f9;border-radius:6px;font-family:'Cinzel',serif;font-size:0.62rem;color:var(--ink);">
                  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                    <span id="farey-chain-title" style="color:#e879f9;font-weight:bold;font-size:0.65rem;"></span>
                    <button onclick="fareyChainCopy()" style="font-family:'Cinzel',serif;font-size:0.55rem;text-transform:uppercase;padding:3px 10px;border:1px solid #e879f9;background:transparent;color:#e879f9;cursor:pointer;">&#x2398; Copy CSV</button>
                  </div>
                  <div id="farey-chain-info" style="line-height:1.9;"></div>
                </div>

                <!-- Export row -->
                <div style="margin-top:12px;display:flex;justify-content:center;gap:8px;flex-wrap:wrap;">
                  <button onclick="fareyComposite()"      style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;background:var(--ink);color:var(--gold);border:1px solid var(--border);padding:5px 14px;cursor:pointer;">&#8615; Export Composite PNG</button>
                  <button onclick="fareyTriangleExport()" style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;background:var(--ink);color:var(--gold);border:1px solid var(--border);padding:5px 14px;cursor:pointer;">&#9651; Export Triangle PNG</button>
                  <button onclick="fareyExportDOM()"      style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;background:linear-gradient(135deg,#3b82f6,#1e40af);color:#fff;border:1px solid #3b82f6;padding:5px 14px;cursor:pointer;">&#9633; Export DOM PNG</button>
                  <button onclick="fareyExportCSV()"      style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;background:linear-gradient(135deg,#22c55e,#15803d);color:#fff;border:1px solid #22c55e;padding:5px 14px;cursor:pointer;">&#8681; Export CSV</button>
                </div>
              </div>

              <!-- ══ MOD N + PARAMETERS (always visible below canvas) ══ -->
              <div style="margin-top:14px;padding:12px 16px;background:var(--parchment-dark);border:1px solid var(--panel-border);border-radius:4px;">
                <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:center;">
                  <span style="font-family:'Cinzel',serif;font-size:0.62rem;letter-spacing:0.08em;color:var(--gold);">MOD N</span>
                  <input id="f-mod" type="range" min="2" max="2000" value="49" style="width:200px;accent-color:var(--gold);" oninput="document.getElementById('f-mod-num').value=this.value;fareyRedraw()">
                  <input id="f-mod-num" type="number" min="2" max="9999" value="49" style="width:58px;background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:3px 6px;font-family:'Cinzel',serif;font-size:0.62rem;text-align:right;" oninput="var v=Math.min(9999,Math.max(2,parseInt(this.value)||2));document.getElementById('f-mod').value=Math.min(2000,v);fareyRedraw()">
                  <span style="color:var(--border);">|</span>
                  <span style="font-family:'Cinzel',serif;font-size:0.62rem;letter-spacing:0.08em;color:var(--gold);">GAP OVERLAY</span>
                  <input id="f-gap-input" type="text" placeholder="e.g. 2 or 2,4,6" style="width:120px;background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:3px 6px;font-family:'Cinzel',serif;font-size:0.62rem;" onkeydown="if(event.key==='Enter')fareyGapInputApply()">
                  <button onclick="fareyGapInputApply()" style="font-family:'Cinzel',serif;font-size:0.58rem;text-transform:uppercase;padding:3px 10px;border:1px solid var(--gold);background:var(--parchment-dark);color:var(--gold);cursor:pointer;">Show</button>
                  <button onclick="fareyGapOverlayClear()" style="font-family:'Cinzel',serif;font-size:0.58rem;text-transform:uppercase;padding:3px 10px;border:1px solid #c94040;background:var(--parchment-dark);color:#c94040;cursor:pointer;">Clear</button>
                  <div id="f-gap-input-status" style="font-family:'Cinzel',serif;font-size:0.55rem;color:#9a8060;min-width:10px;"></div>
                </div>
              </div>

              <!-- ══ STATS / DESCRIPTION DROPDOWN ══ -->
              <div id="farey-stats-section" style="margin-top:10px;">

                <!-- Farey Stats dropdown -->
                <div style="background:var(--parchment-dark);border:1px solid var(--panel-border);border-radius:4px;margin-bottom:6px;">
                  <div style="display:flex;justify-content:space-between;align-items:center;padding:9px 14px;cursor:pointer;" onclick="var b=this.nextElementSibling;var a=this.querySelector('.farey-arrow');b.style.display=b.style.display==='none'?'block':'none';a.textContent=b.style.display==='none'?'▶':'▼';">
                    <span style="font-family:'Cinzel',serif;font-size:0.62rem;letter-spacing:0.1em;text-transform:uppercase;color:var(--gold);">&#9632; Farey Structure Statistics</span>
                    <span class="farey-arrow" style="color:var(--gold);font-size:0.7rem;">▶</span>
                  </div>
                  <div style="display:none;padding:12px 16px;">
                    <div id="farey-live-stats" style="font-family:'Cinzel',serif;font-size:0.62rem;line-height:2;color:var(--ink-mid);"></div>
                  </div>
                </div>

                <!-- Gap Overlay Data dropdown -->
                <div id="farey-gap-stats-panel" style="display:none;background:var(--parchment-dark);border:1px solid rgba(74,144,217,0.4);border-radius:4px;margin-bottom:6px;">
                  <div style="display:flex;justify-content:space-between;align-items:center;padding:9px 14px;cursor:pointer;" onclick="var b=this.nextElementSibling;var a=this.querySelector('.farey-arrow');b.style.display=b.style.display==='none'?'block':'none';a.textContent=b.style.display==='none'?'▶':'▼';">
                    <span style="font-family:'Cinzel',serif;font-size:0.62rem;letter-spacing:0.1em;text-transform:uppercase;color:#4a90d9;">&#9632; Gap Overlay Data</span>
                    <span class="farey-arrow" style="color:#4a90d9;font-size:0.7rem;">▶</span>
                  </div>
                  <div style="display:none;padding:12px 16px;">
                    <div id="farey-gap-stats-content" style="font-family:'Cinzel',serif;font-size:0.62rem;line-height:2;color:var(--ink-mid);"></div>
                    <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;">
                      <button onclick="fareyGapStatsExportCSV()" style="font-family:'Cinzel',serif;font-size:0.58rem;text-transform:uppercase;padding:4px 12px;border:1px solid #4a90d9;background:transparent;color:#4a90d9;cursor:pointer;">&#8681; CSV</button>
                      <button onclick="fareyGapStatsExportDOM()" style="font-family:'Cinzel',serif;font-size:0.58rem;text-transform:uppercase;padding:4px 12px;background:linear-gradient(135deg,#3b82f6,#1e40af);color:#fff;border:1px solid #3b82f6;cursor:pointer;">&#9633; PNG</button>
                    </div>
                  </div>
                </div>

                <!-- Description dropdown -->
                <div style="background:var(--parchment-dark);border:1px solid var(--panel-border);border-radius:4px;margin-bottom:6px;">
                  <div style="display:flex;justify-content:space-between;align-items:center;padding:9px 14px;cursor:pointer;" onclick="var b=this.nextElementSibling;var a=this.querySelector('.farey-arrow');b.style.display=b.style.display==='none'?'block':'none';a.textContent=b.style.display==='none'?'▶':'▼';">
                    <span style="font-family:'Cinzel',serif;font-size:0.62rem;letter-spacing:0.1em;text-transform:uppercase;color:var(--gold);">&#9632; What This Shows</span>
                    <span class="farey-arrow" style="color:var(--gold);font-size:0.7rem;">▶</span>
                  </div>
                  <div style="display:none;padding:12px 16px;font-family:Georgia,serif;font-size:0.8rem;color:var(--ink-mid);line-height:1.7;">
                    <p>Each point r/m (0 ≤ r ≤ m, 1 ≤ m ≤ mod N) is plotted at angle 2πr/m on ring m. Points with gcd(r,m)=1 (blue) are the Farey fractions — their distribution is uniform on the critical line Re(s)=½ in the sense of Franel-Landau. Points with gcd(r,m)&gt;1 (red) reveal the multiplicative structure.</p>
                    <p>The <strong>cross-mod connections</strong> trace how each residue r threads through rings 1→modN — these are the channels along which prime gap residues cluster. The <strong>ring polygon</strong> connects consecutive residues around a single ring: at mod 4 (gcd=1) you get a square; at mod 8 an octagon (all) or square (gcd=1 only).</p>
                    <p>The <strong>gap overlay</strong> highlights the residue pairs (p mod N, (p+g) mod N) for primes in gap class g — the chords connecting r₁ to r₂ on the outer ring, with the inward spiral showing the full cross-mod path.</p>
                  </div>
                </div>

              </div>

            </div>
            <!-- ══ END FAREY ══ -->
            </div>            </div>
        </div><!-- end intro-section -->
        <div class="intro-section">
            <h2>Abstract</h2>

            <p>Euler's product formula expresses ζ(2) = π²/6 as an infinite product over all primes. Because the product converges absolutely, its factors may be collected in any order without changing the value. This tool implements a specific collection: prime factors are grouped by the <em>forward gap</em> of each prime — the distance to the next prime — yielding a factorization ζ(2) = ∏<sub>g</sub> P<sub>g</sub> indexed by gap class. This regrouping is a direct consequence of absolute convergence, not a new theorem. Its interest lies in what the resulting numerical magnitudes reveal about prime gap structure.</p>

            <p>At N = 400 million, gap class 1 (the prime 2 alone) contributes 57.8% of log ζ(2), and gap class 2 (twin primes) contributes a further 34.8% of log ζ(2) — together accounting for over 92% of the total logarithmic weight of the Euler product. That is, 92% of log(π²/6) is explained by just the prime 2 and the twin primes alone. Conditional on Hardy &amp; Littlewood's Conjecture B (1923) and the standard sieve heuristic that primes of a given gap class carry no systematic size-bias, the singular series S(g) predicts the asymptotic ratio of log-weights between any two gap classes: S(g)/S(h) → w<sub>g</sub>/w<sub>h</sub> as N → ∞. Here S(h) = 2C<sub>2</sub> · ∏<sub>p | h, p odd prime</sub> (p−1)/(p−2), where C<sub>2</sub> = ∏<sub>p ≥ 3</sub> p(p−2)/(p−1)² ≈ 0.6601618… is the twin prime constant. Because 2 divides every even gap but contributes no correction factor (it is already absorbed into C<sub>2</sub>), only the odd prime divisors of h enter S(h). In particular S(2) = S(4) = 2C<sub>2</sub>, so twin and cousin primes have equal asymptotic density; and S(6) = 4C<sub>2</sub> = 2·S(2), so gap-6 primes are asymptotically twice as frequent as gap-2 primes — the observed ratio at 400M is 1.73, converging toward 2. This ratio observation is directly testable against finite data and does not appear to have been stated in this form previously. The framework also raises a structural question: if twin primes were finite, P<sub>2</sub>(s) would be a finite product of factors p<sup>s</sup>/(p<sup>s</sup>−1) over a fixed finite set of primes — what analytic constraints would that place on the remaining sub-products via the product identity with ζ(s)?</p>

            <div class="formula-box">
                ζ(2) = ∏<sub>p prime</sub> p²/(p²−1) &nbsp;=&nbsp; ∏<sub>g ∈ G</sub> P<sub>g</sub> &nbsp;=&nbsp; π²/6 ≈ 1.644934066848…
            </div>

            <p style="color:var(--ink-light);font-size:0.88rem;margin-top:-8px;text-align:center;">G = {1, 2, 4, 6, 8, …} is the set of all realized prime gap sizes. &nbsp; P<sub>g</sub> = ∏<sub>{p : gap(p)=g}</sub> p²/(p²−1).</p>

            <h3>Gap-Class Partition</h3>

            <p>Define gap(p<sub>n</sub>) = p<sub>n+1</sub> − p<sub>n</sub>. By absolute convergence of the Euler product, its factors may be partitioned by gap class:</p>

            <div class="formula-box">
                P<sub>g</sub> &nbsp;=&nbsp; ∏<sub>{p : gap(p) = g}</sub> p²/(p²−1)
            </div>

            <p>Gap class g = 1 contains only the prime 2, since gap(2) = 3 − 2 = 1, contributing the fixed factor 4/3. Every other realized gap size is even, because all primes beyond 2 are odd.</p>

            <h3>Gap Classification</h3>

            <ul>
                <li><strong>Gap 1:</strong> {2} — the prime 2 alone; gap(2) = 3 − 2 = 1</li>
                <li><strong>Gap 2 (Twin Primes):</strong> {3, 5, 11, 17, 29, 41, 59, 71, 101, 107, …} — primes p with forward gap 2</li>
                <li><strong>Gap 4 (Cousin Primes):</strong> {7, 13, 19, 37, 43, 67, 79, 97, 103, 109, …}</li>
                <li><strong>Gap 6 (Sexy Primes):</strong> {23, 31, 47, 53, 61, 73, 83, 89, 113, …}</li>
                <li><strong>Larger even gaps:</strong> g = 8, 10, 12, … all contribute progressively smaller P<sub>g</sub></li>
            </ul>

            <h3>Key Questions This Tool Investigates</h3>

            <ol>
                <li><strong>Quantitative contributions:</strong> What fraction of log ζ(2) does each gap class account for? At N = 400M, gaps 1 and 2 together exceed 92%.</li>
                <li><strong>Hardy-Littlewood log-weight ratios:</strong> Conditional on Conjecture B, S(g)/S(h) predicts the limiting ratio w<sub>g</sub>/w<sub>h</sub>. S(2) = S(4), so twins and cousins have equal asymptotic density. S(6) = 2·S(2), so gap 6 is asymptotically twice as frequent as gap 2 — the observed ratio at 400M is 1.73, converging toward 2.</li>
                <li><strong>Closed form for P<sub>2</sub>(2):</strong> Numerically P<sub>2</sub>(2) ≈ 1.18689… No relation to π, C<sub>2</sub>, or known constants is apparent. Open question.</li>
                <li><strong>Finiteness obstruction:</strong> A finite twin prime set would make P<sub>2</sub>(s) a finite product of factors p<sup>s</sup>/(p<sup>s</sup>−1) over a fixed finite set of primes, with poles where p<sup>s</sup> = 1, i.e. on Re(s) = 0. Compatibility with ζ(s)'s analytic structure on Re(s) > 1 then requires precise cancellation by remaining sub-products — whether this is possible is open.</li>
                <li><strong>Generalization to ζ(s):</strong> The decomposition extends to all Re(s) > 1. As s grows, P<sub>1</sub>(s) = 2<sup>s</sup>/(2<sup>s</sup>−1) dominates increasingly; at s = 10 it accounts for ~96% of log ζ(10).</li>
                <li><strong>Asymptotic tail:</strong> The partial product ∏<sub>g ≤ G</sub> P<sub>g</sub> converges to ζ(2) as G → ∞, but the precise rate has not been established.</li>
            </ol>

            <h3>What This Framework Does Not Claim</h3>

            <p style="color:var(--red-ink);">The gap-class factorization is a rearrangement of Euler's product, valid by absolute convergence. It contains no new analytic content in itself. The Hardy-Littlewood ratio observation and the finiteness question are presented as research directions supported by computational evidence at finite N — not proofs of any conjecture.</p>

            <h3>Performance &amp; Browser Limits</h3>

            <ul>
                <li><strong>Sieving:</strong> Segmented sieve in 1M-number chunks — only ~50 MB during generation regardless of range</li>
                <li><strong>Storage (the real cap):</strong> After sieving, all primes must be held in memory. At 300M that is ~16M primes ≈ 340 MB total.</li>
                <li><strong>Safe range:</strong> Up to ~200M reliably; up to ~300M on most machines with few other tabs open</li>
                <li><strong>Above 300M:</strong> Expect freezing or out-of-memory errors. For N = 400M and above, use the companion Python script, which processes primes incrementally at constant ~50 MB RAM.</li>
            </ul>
        </div>
    </div>
        </div><!-- end abstract intro-section -->
    </div><!-- end introduction -->
    
    <div class="controls-container">
        <!-- Computation Parameters (NOT in dropdown - on main page) -->
        <div class="control-panel">
            <h3>Computation Parameters</h3>
            <div class="control-grid">
                <div class="control-group">
                    <label>
                        Maximum Prime
                        <span class="control-value" id="maxPrimeDisplay">10,000,000</span>
                    </label>
                    <input type="number" id="maxPrime" value="10000000" min="1000" max="300000000" step="1000000"
                           oninput="updateMaxPrimeDisplay()">
                    <div style="margin-top: 8px; font-size: 0.85rem; color: #888;">
                        Note: Values > 100M may take several minutes
                    </div>
                    <div style="margin-top: 4px; font-size: 0.75rem; color: var(--orange-ink);">
                        Browser limit: ~300M (use Python script for 400M-1B+)
                    </div>
                </div>
                
                <div class="control-group">
                    <label style="display: block; margin-bottom: 8px; color: var(--gold); font-size: 1rem;">
                        Gap Range Filter
                    </label>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="radio" name="gapRangeMode" value="auto" checked 
                                   onchange="updateGapRangeMode()" style="width: auto;">
                            <span style="color:var(--ink-mid);">Auto (all gaps found)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 10px;">
                            <input type="radio" name="gapRangeMode" value="manual" 
                                   onchange="updateGapRangeMode()" style="width: auto;">
                            <span style="color:var(--ink-mid);">Manual range</span>
                        </label>
                    </div>
                    <div id="manualGapRangeControls" style="display: none; margin-top: 12px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <label style="font-size: 0.85rem; color: #888; margin-bottom: 4px; display: block;">
                                    Min Gap (even)
                                </label>
                                <input type="number" id="minGapRange" value="0" min="0" step="2"
                                       oninput="validateGapRange()">
                            </div>
                            <div>
                                <label style="font-size: 0.85rem; color: #888; margin-bottom: 4px; display: block;">
                                    Max Gap (even)
                                </label>
                                <input type="number" id="maxGapRange" value="50" min="2" step="2"
                                       oninput="validateGapRange()">
                            </div>
                        </div>
                        <div id="gapRangeError" style="margin-top: 6px; font-size: 0.8rem; color: #ff6464; display: none;">
                            Min gap must be less than max gap. Both must be even numbers (or 0 for gap-1).
                        </div>
                    </div>
                </div>
                
            <div class="button-row" style="margin-top: 20px;">
                <button class="btn" onclick="runAnalysis()">Run Analysis</button>
                <button class="btn btn-secondary" onclick="exportAllData()">Export All Data (CSV)</button>
                <button class="btn btn-secondary" onclick="exportAllCharts()">Export All Charts (PNG)</button>
            </div>
        </div>

        <!-- Advanced Controls Dropdown (Collapsed by default) -->
        <div class="dropdown-section">
            <div class="dropdown-header" onclick="toggleSection(this)">
                <h3>Advanced Controls</h3>
                <span class="dropdown-icon">v</span>
            </div>
            <div class="dropdown-content">
                <!-- Research Presets -->
                <div style="margin-bottom: 24px; padding-bottom: 24px; border-bottom: 1px solid #2a2a4a;">
                    <h4 style="color: var(--gold); margin: 0 0 12px 0; font-size: 1.1rem;">Research Presets</h4>
                    <p class="section-description">
                        Quick configurations for common research scenarios
                    </p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        <button onclick="applyResearchPreset('complete')" class="preset-btn" style="background: var(--ink); color: var(--parchment); padding: 10px;">
                            <strong>Complete Analysis</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">Primes: 10M, All Gaps</span>
                        </button>
                        <button onclick="applyResearchPreset('twins')" class="preset-btn" style="background: var(--red-ink); padding: 10px;">
                            <strong>Twin Prime Focus</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">Primes: 100K, Gaps: 2-10</span>
                        </button>
                        <button onclick="applyResearchPreset('goldbach')" class="preset-btn" style="background: var(--sepia); padding: 10px;">
                            <strong>Goldbach Range</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">Primes: 500K, Gaps: 2-30</span>
                        </button>
                        <button onclick="applyResearchPreset('topology')" class="preset-btn" style="background: var(--purple-ink); padding: 10px;">
                            <strong>Large Gap Topology</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">Primes: 1M, Gaps: 30-90</span>
                        </button>
                        <button onclick="applyResearchPreset('extreme')" class="preset-btn" style="background: var(--purple-ink); padding: 10px;">
                            <strong>Extreme Range</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">Primes: 5M, Gaps: 100+</span>
                        </button>
                        <button onclick="applyResearchPreset('full')" class="preset-btn" style="background: var(--green-ink); padding: 10px;">
                            <strong>Full Spectrum</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">Primes: 1M, All Gaps</span>
                        </button>
                        <button onclick="applyResearchPreset('rh')" class="preset-btn" style="background: var(--teal-ink); padding: 10px;">
                            <strong>Riemann Hypothesis Analysis</strong><br>
                            <span style="font-size: 0.85em; opacity: 0.9;">High-precision: 2M primes</span>
                        </button>
                    </div>
                </div>

                <!-- Zeta Exponent -->
                <div style="border: 2px solid var(--purple-ink); padding: 16px; border-radius: 8px; background: rgba(74,42,106,0.04); margin-bottom: 20px;">
                    <label style="color: var(--purple-ink); font-weight: 600; display: block; margin-bottom: 12px;">
                        Zeta Exponent (s)
                        <span class="control-value" id="zetaSDisplay" style="color: var(--gold);">2.00</span>
                    </label>
                    <input type="range" id="zetaS" value="2" min="1.01" max="20" step="0.01"
                           style="width: 100%;" oninput="updateZetaSDisplay()" onchange="updateZetaSDisplay()">
                    
                    <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 6px; margin-top: 12px;">
                        <button onclick="setZetaS(1.5)" class="preset-btn" style="background: var(--purple-ink); padding: 6px; font-size: 0.8rem;">s=1.5</button>
                        <button onclick="setZetaS(2)" class="preset-btn" style="background: var(--purple-ink); padding: 6px; font-size: 0.8rem;">s=2</button>
                        <button onclick="setZetaS(3)" class="preset-btn" style="background: var(--purple-ink); padding: 6px; font-size: 0.8rem;">s=3</button>
                        <button onclick="setZetaS(4)" class="preset-btn" style="background: var(--purple-ink); padding: 6px; font-size: 0.8rem;">s=4</button>
                        <button onclick="setZetaS(5)" class="preset-btn" style="background: var(--purple-ink); padding: 6px; font-size: 0.8rem;">s=5</button>
                        <button onclick="setZetaS(10)" class="preset-btn" style="background: var(--purple-ink); padding: 6px; font-size: 0.8rem;">s=10</button>
                    </div>
                    
                    <div style="margin-top: 12px; padding: 12px; background: rgba(139,99,16,0.05); border-radius: 6px;">
                        <div id="zetaSInfo" style="font-weight: 600; color: var(--gold);">ζ(2) = π²/6 ≈ 1.6449</div>
                        <div id="zetaSBehavior" style="margin-top: 8px; color: #888; font-size: 0.8rem;">
                            Twin primes dominate at s=2
                        </div>
                        <div style="margin-top: 4px; color: #888; font-size: 0.75rem;">
                            Formula: ζ(s) = ∏ p^s/(p^s-1)
                        </div>
                    </div>
                </div>

                <!-- Gap Range Filter -->
                <div style="border: 2px solid var(--sepia); padding: 16px; border-radius: 8px; background: rgba(112,66,20,0.04); margin-bottom: 20px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <h4 style="margin: 0; color: var(--sepia); font-size: 1rem;">Gap Range Filter (Zoom)</h4>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 0.9rem;">
                            <input type="checkbox" id="enableGapFilter" style="width: auto;" onchange="toggleGapFilter()">
                            <span style="color: var(--sepia); font-weight: 600;">Enable Filter</span>
                        </label>
                    </div>
                    
                    <div id="gapFilterControls" style="display: none;">
                        <p style="font-size: 0.85rem; color: var(--ink-mid); margin: 0 0 12px 0;">
                            Filter which gaps appear in all charts. Perfect for examining larger gaps without small gaps dominating.
                        </p>

                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                            <div>
                                <label style="display: block; font-size: 0.85rem; margin-bottom: 4px; color: var(--ink-mid);">Min Gap</label>
                                <input type="number" id="minGapFilter" value="2" min="0" max="1000" step="2" 
                                       style="width: 100%; padding: 6px; background: var(--parchment-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--ink-mid);"
                                       onchange="updateGapFilterDisplay()">
                            </div>
                            <div>
                                <label style="display: block; font-size: 0.85rem; margin-bottom: 4px; color: var(--ink-mid);">Max Gap</label>
                                <input type="number" id="maxGapFilter" value="50" min="2" max="1000" step="2" 
                                       style="width: 100%; padding: 6px; background: var(--parchment-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--ink-mid);"
                                       onchange="updateGapFilterDisplay()">
                            </div>
                        </div>

                        <div style="margin-bottom: 12px;">
                            <label style="display: block; font-size: 0.85rem; margin-bottom: 6px; color: var(--ink-mid);">Quick Presets:</label>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;">
                                <button onclick="setGapRange(2, 10)" class="preset-btn">Tiny (2-10)</button>
                                <button onclick="setGapRange(2, 20)" class="preset-btn">Small (2-20)</button>
                                <button onclick="setGapRange(20, 50)" class="preset-btn">Medium (20-50)</button>
                                <button onclick="setGapRange(30, 90)" class="preset-btn">Large (30-90)</button>
                                <button onclick="setGapRange(50, 150)" class="preset-btn">Huge (50-150)</button>
                                <button onclick="setGapRangeToLast(20)" class="preset-btn" style="background: var(--sepia);">Last 20</button>
                                <button onclick="setGapRangeToLast(10)" class="preset-btn" style="background: var(--sepia);">Last 10</button>
                                <button onclick="resetGapFilter()" class="preset-btn" style="background: var(--ink-light);">Reset</button>
                            </div>
                        </div>

                        <div style="background: rgba(45,90,39,0.06); padding: 10px; border-radius: 6px; border-left: 3px solid var(--green-ink);">
                            <p style="margin: 0; font-size: 0.85rem; color: var(--green-ink);">
                                <strong>Active:</strong> <span id="gapFilterStatus">Showing all gaps</span>
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Animation Controls -->
                <div style="border: 2px solid var(--orange-ink); padding: 16px; border-radius: 8px; background: rgba(122,58,10,0.04); margin-bottom: 20px;">
                    <h4 style="margin: 0 0 12px 0; color: #f59e0b; font-size: 1rem;">Animation Speed (ms delay)</h4>
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; margin-bottom: 6px;">
                            <span style="color: var(--ink-mid);">Delay: </span>
                            <span class="control-value" id="animSpeedDisplay">100</span>
                            <span style="color:var(--ink-light); font-size: 0.75rem;"> (Lower = Faster, Higher = Slower)</span>
                        </label>
                        <input type="range" id="animSpeed" min="10" max="500" value="100" step="10"
                               style="width: 100%;" oninput="document.getElementById('animSpeedDisplay').textContent = this.value">
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="useMaxPrimeForAnim" style="width: auto;" checked>
                            <span>Animate from 0 to Max Prime</span>
                        </label>
                        <div style="margin-top: 4px; font-size: 0.75rem; color: #888;">
                            Uncheck to set custom range below
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
                        <div>
                            <label style="display: block; font-size: 0.85rem; margin-bottom: 4px; color: var(--ink-mid);">
                                Custom Start
                                <span class="control-value" id="animStartDisplay">1</span>
                            </label>
                            <input type="number" id="animStart" value="1" min="1" max="10000000" step="100"
                                   style="width: 100%; padding: 6px; background: var(--parchment-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--ink-mid);">
                        </div>
                        <div>
                            <label style="display: block; font-size: 0.85rem; margin-bottom: 4px; color: var(--ink-mid);">
                                Custom End
                                <span class="control-value" id="animEndDisplay">10000000</span>
                            </label>
                            <input type="number" id="animEnd" value="10000000" min="1000" max="10000000" step="1000"
                                   style="width: 100%; padding: 6px; background: var(--parchment-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--ink-mid);">
                        </div>
                    </div>

                    <div style="display: flex; gap: 12px;">
                        <button class="btn btn-secondary" onclick="startAnimation()" style="flex: 1;">Start Animation</button>
                        <button class="btn btn-secondary" onclick="stopAnimation()" style="flex: 1;">Stop Animation</button>
                    </div>
                </div>

                <!-- Alternative Data Sources -->
                <div style="margin-top: 20px; padding: 16px; background: rgba(26,74,74,0.04); border-radius: 8px; border-left: 4px solid var(--teal-ink);">
                    <h4 style="color: var(--teal-ink); margin: 0 0 12px 0; font-size: 1rem;">Alternative Data Sources</h4>
                    <p style="font-size: 0.85rem; color: var(--ink-mid); margin-bottom: 12px;">
                        To use pre-computed prime lists — note the same ~300M browser limit applies to uploaded files
                    </p>
                    
                    <div style="display: grid; gap: 12px;">
                        <div>
                            <label style="display: block; margin-bottom: 6px; font-size: 0.9rem; color: var(--ink-mid);">
                                Upload Prime List (CSV/TXT)
                            </label>
                            <input type="file" id="primeFileUpload" accept=".txt,.csv" 
                                   style="width: 100%; padding: 8px; background: var(--parchment-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--ink-mid);"
                                   onchange="handlePrimeFileUpload(event)">
                            <div style="font-size: 0.75rem; color: #666; margin-top: 4px;">
                                Format: One prime per line or comma-separated<br>
                                Sources: <a href="https://primes.utm.edu/lists/" target="_blank" style="color: var(--teal-ink);">Prime Pages</a> | 
                                <a href="https://oeis.org/A000040/b000040.txt" target="_blank" style="color: var(--teal-ink);">OEIS A000040</a>
                            </div>
                        </div>
                        
                        <div>
                            <label style="display: block; margin-bottom: 6px; font-size: 0.9rem; color: var(--ink-mid);">
                                OEIS A000040 (Prime Numbers Database)
                            </label>
                            <div style="display: flex; gap: 8px; align-items: flex-end;">
                                <div style="flex: 1;">
                                    <label style="display: block; font-size: 0.75rem; color: #888; margin-bottom: 4px;">
                                        Fetch first N primes
                                    </label>
                                    <input type="number" id="oeisCount" value="100000" min="1000" max="1000000" step="10000"
                                           style="width: 100%; padding: 6px; background: var(--parchment-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--ink-mid);">
                                </div>
                                <button class="btn btn-secondary" onclick="fetchFromOEIS()" style="flex-shrink: 0;">
                                    Fetch from OEIS
                                </button>
                            </div>
                            <div style="font-size: 0.75rem; color: #666; margin-top: 4px;">
                                OEIS API provides up to 1M primes. File upload: same ~300M browser limit applies.
                            </div>
                        </div>
                    </div>
                    
                    <div id="uploadStatus" style="margin-top: 12px; padding: 8px; background: rgba(139,99,16,0.07); border-radius: 4px; display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="color: var(--gold); font-size: 0.85rem;"></span>
                            <button class="btn btn-secondary" onclick="clearCustomPrimes()" style="padding: 4px 12px; font-size: 0.75rem;">
                                Clear & Use Sieve
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Comparison Mode -->
                <div style="margin-top: 20px; margin-bottom: 20px; padding: 16px; background: rgba(74,42,106,0.04); border-radius: 8px; border-left: 4px solid var(--purple-ink);">
                    <h4 style="margin: 0 0 12px 0; color: var(--purple-ink); font-size: 1rem;">Comparison Mode</h4>
                    <label style="display: flex; align-items: start; gap: 12px; cursor: pointer;">
                        <input type="checkbox" id="enableComparison" style="width: auto; margin-top: 4px;">
                        <div>
                            <span style="color: var(--ink-mid); font-weight: 600; font-size: 0.95rem;">Enable Comparison Mode</span>
                            <div style="font-size: 0.85rem; color: #888; margin-top: 4px;">
                                Compare how gap contributions change across different exponent values: s = [1.5, 2, 3, 4, 5, 10]. This generates multiple overlayed analyses to study how varying the zeta exponent affects the relative importance of different gap classes.
                            </div>
                        </div>
                    </label>
                </div>

                <!-- Chart Options -->
                <div style="padding: 16px; background: rgba(112,66,20,0.04); border-radius: 8px; border-left: 4px solid #3b82f6;">
                    <h4 style="margin: 0 0 16px 0; color: var(--sepia); font-size: 1rem;">Chart Options</h4>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showGapContributions" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Gap Contributions Chart</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showConvergence" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Progressive Convergence</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showGapDistribution" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Gap Distribution</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showPercentageContrib" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Percentage Contributions</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showErrorAnalysis" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Error Analysis</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showLogScale" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Log-Scale Product Analysis</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showGapRatio" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Gap Ratio Analysis (Twin Prime Evidence)</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showDecimalConvergence" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Decimal Convergence Analysis</span>
                    </div>
                    
                    <div class="toggle-wrapper">
                        <label class="toggle">
                            <input type="checkbox" id="showCustomGapCompare" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span>Show Custom Gap Comparison</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Analysis Statistics (Fixed toggle) -->
        <div id="statsPanel" class="dropdown-section" style="display: none; border: 2px solid var(--green-ink);">
            <div class="dropdown-header" onclick="toggleSection(this)" style="background: linear-gradient(135deg, #1a1e0a 0%, #2a3a12 100%);">
                <h3 style="color: var(--green-ink);">Analysis Statistics</h3>
                <span class="dropdown-icon" style="color: var(--green-ink);">v</span>
            </div>
            <div class="dropdown-content">
                <div class="stats-grid" id="statsGrid"></div>
            </div>
        </div>
        
        <div id="statusBar" class="status-bar" style="display: none;">
            Ready to compute...
        </div>
        
        <div id="progressContainer" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
    </div>
    
    
    <div class="charts-container">
        <div class="chart-wrapper" id="convergenceWrapper">
            <div class="chart-title">Progressive Convergence to ζ(2) = π²/6</div>
            <div class="chart-description">
                Shows how the cumulative product P₁ × P₂ × P₄ × ... converges to the target value π²/6 ≈ 1.6449 as additional gap families are included. Each gap family's product contributes multiplicatively toward the final value.
            </div>
            <canvas id="convergenceChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Progressive Convergence Data</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="convergencePrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('convergenceTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="convergenceTable">
                    <table class="stats-table" id="convergenceTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('convergence')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('convergenceChart', 'convergence')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: var(--sepia);">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('convergenceChart', 'convergence')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="gapContribWrapper">
            <div class="chart-title">Individual Gap Family Products P<sub>g</sub></div>
            <div class="chart-description">
                Displays the individual contribution of each gap family. Each bar shows P_g = ∏_{p: gap(p)=g} p²/(p²-1), the product over all primes with that specific gap size. Larger values indicate gap families that contribute more to ζ(2).
            </div>
            <canvas id="gapContribChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Gap Family Product Values <span style="font-size: 0.75rem; color: #888; font-weight: normal;">(Click row for details)</span></div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="gapContribPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('gapContribTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="gapContribTable" data-chart="gapContribChart">
                    <table class="stats-table" id="gapContribTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('gapContrib')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('gapContribChart', 'gap_contributions')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: var(--sepia);">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('gapContribChart', 'gap_contributions')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="gapDistWrapper">
            <div class="chart-title">Prime Distribution by Gap Class</div>
            <div class="chart-description">
                Shows how many primes belong to each gap family. Twin primes (gap 2) and cousin primes (gap 4) typically have the most members, while larger gaps become progressively rarer.
            </div>
            <canvas id="gapDistChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Prime Count and Distribution <span style="font-size: 0.75rem; color: #888; font-weight: normal;">(Click row for details)</span></div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="gapDistPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('gapDistTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="gapDistTable" data-chart="gapDistChart">
                    <table class="stats-table" id="gapDistTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('gapDist')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('gapDistChart', 'gap_distribution')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: var(--sepia);">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('gapDistChart', 'gap_distribution')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="gapRatioWrapper">
            <div class="chart-title">Gap Ratio Analysis: Twin Prime Conjecture Evidence</div>
            <div class="chart-description">
                Tracks Count(gap=2)/Count(gap=4) and other gap ratios. Hardy-Littlewood predicts twin primes (gap 2) and cousin primes (gap 4) have <em>identical</em> singular series constants, so their ratio should approach 1.0 as N→∞. Gap 6 (sexy primes) has a 2× larger constant due to the p=3 factor — so it is asymptotically <em>twice as frequent</em> as gap 2 or gap 4, not equal.
            </div>
            <canvas id="gapRatioChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Gap Ratio Data</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="gapRatioPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6" selected>6</option>
                            <option value="8">8</option>
                            <option value="10">10</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('gapRatioTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="gapRatioTable">
                    <table class="stats-table" id="gapRatioTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('gapRatio')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('gapRatioChart', 'gap_ratio_analysis')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: var(--sepia);">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('gapRatioChart', 'gap_ratio_analysis')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="customGapCompareWrapper">
            <div class="chart-title">Custom Gap Family Comparison</div>
            <div class="chart-description">
                Compare specific gap families. Test hypotheses such as "gaps divisible by 6 have more primes" 
                or "gap 6n > gap 6n±k for all k". Select up to 10 gaps to visualize side-by-side.
            </div>
            
            <!-- Gap Selection Controls -->
            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px; border-left: 4px solid #3b82f6; margin-bottom: 20px;">
                <h4 style="color: var(--sepia); margin: 0 0 16px 0;">Select Gaps to Compare</h4>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 6px; color: #aaa; font-size: 0.9rem;">
                        Enter gaps (comma-separated, even numbers only):
                    </label>
                    <input type="text" id="compareGapsInput" placeholder="e.g., 2, 4, 6, 8, 10, 12, 18, 24, 30"
                           style="width: 100%; padding: 12px; background: var(--parchment-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--ink-mid); font-size: 1rem;">
                    <div style="margin-top: 6px; font-size: 0.75rem; color: #666;">
                        Enter any even numbers separated by commas. Example: 6, 12, 18, 24, 30
                    </div>
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 6px; color: #aaa; font-size: 0.9rem;">Quick Presets:</label>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        <button onclick="loadGapPreset('twins_cousins')" class="preset-btn">Twins vs Cousins (2,4)</button>
                        <button onclick="loadGapPreset('small_gaps')" class="preset-btn">Small Gaps (2,4,6,8,10)</button>
                        <button onclick="loadGapPreset('mod6')" class="preset-btn">Gaps ≡ 0 (mod 6)</button>
                        <button onclick="loadGapPreset('mod6_nearby')" class="preset-btn">6n vs 6n±2 vs 6n±4</button>
                        <button onclick="loadGapPreset('powers_of_2')" class="preset-btn">Powers: 2,4,8,16,32</button>
                        <button onclick="loadGapPreset('clear')" class="preset-btn" style="background: var(--ink-light);">Clear</button>
                    </div>
                </div>
                
                <button onclick="renderCustomGapComparison()" class="btn" style="width: 100%;">
                    Compare Selected Gaps
                </button>
            </div>
            
            <canvas id="customGapCompareChart" width="3840" height="2160"></canvas>
            
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Comparison Statistics</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="customGapComparePrecision" onchange="renderCustomGapComparison()">
                            <option value="4">4</option>
                            <option value="6" selected>6</option>
                            <option value="8">8</option>
                            <option value="10">10</option>
                        </select>
                    </div>
                </div>
                <div class="stats-table-container" id="customGapCompareTable">
                    <table class="stats-table" id="customGapCompareTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportCustomGapCompareCSV()">Export Comparison CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('customGapCompareChart', 'custom_gap_comparison')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: var(--sepia);">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('customGapCompareChart', 'custom_gap_comparison')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        
        
        
        <div class="chart-wrapper" id="percentageWrapper">
            <div class="chart-title">Percentage Contribution to ζ(2) by Gap Family</div>
            <div class="chart-description">
                Shows each gap family's contribution as a percentage of log(ζ(2)). This reveals which gap sizes are most important for building up the final value. Typically gap 1 and gap 2 (twin primes) dominate.
            </div>
            <canvas id="percentageChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Contribution Percentages <span style="font-size: 0.75rem; color: #888; font-weight: normal;">(Click row for details)</span></div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="percentagePrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('percentageTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="percentageTable" data-chart="percentageChart">
                    <table class="stats-table" id="percentageTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('percentage')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('percentageChart', 'percentage_contributions')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: var(--sepia);">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('percentageChart', 'percentage_contributions')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="errorWrapper">
            <div class="chart-title">Convergence Error Analysis</div>
            <div class="chart-description">
                Tracks both absolute and relative error between the cumulative product and the target π²/6. As more gap families are included, the error decreases exponentially, showing convergence.
            </div>
            <canvas id="errorChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Error Metrics by Gap</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="errorPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('errorTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="errorTable">
                    <table class="stats-table" id="errorTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('error')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('errorChart', 'error_analysis')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: var(--sepia);">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('errorChart', 'error_analysis')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="logScaleWrapper">
            <div class="chart-title">Log-Scale Product Growth P<sub>g</sub></div>
            <div class="chart-description">
                Displays log(P_g) for each gap family, making it easier to compare contributions across many orders of magnitude. Since products become multiplicative in log space, this shows additive contributions to log(ζ(2)).
            </div>
            <canvas id="logScaleChart" width="3840" height="2160"></canvas>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Logarithmic Product Analysis</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="logScalePrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8" selected>8</option>
                            <option value="10">10</option>
                            <option value="12">12</option>
                            <option value="15">15</option>
                            <option value="18">18</option>
                            <option value="20">20</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('logScaleTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container" id="logScaleTable">
                    <table class="stats-table" id="logScaleTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('logScale')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('logScaleChart', 'log_scale_products')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: var(--sepia);">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('logScaleChart', 'log_scale_products')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <div class="chart-wrapper" id="hlDeepDiveWrapper" style="border: 2px solid var(--gold);">
            <div class="chart-title" style="color: var(--gold); font-size: 1.5rem; border-bottom-color: var(--gold);">
                Hardy-Littlewood Conjecture B: Step-by-Step Calculations for Every Gap Family
            </div>
            <div class="chart-description" style="border-left-color: var(--gold);">
                Full derivation of the singular series S(h), the logarithmic integral li₂(x), and the predicted prime-pair count
                for each gap family — with every arithmetic step shown and compared against the observed data.
            </div>

            <!-- PART 1: THE FORMULA -->
            <div style="background:#0d0d1a;border:1px solid #a855f7;border-radius:10px;padding:28px;margin-bottom:24px;">
                <h3 style="color:#a855f7;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 1 — The Hardy-Littlewood Formula</h3>
                <p style="color:#ccc;margin-bottom:16px;line-height:1.8;">Hardy &amp; Littlewood's Conjecture B (1923): for any even integer h ≥ 2, the count of primes p ≤ x where p+h is also prime satisfies:</p>
                <div class="formula-box" style="font-size:1.4rem;margin:20px 0;">π<sub>h</sub>(x) &nbsp;~&nbsp; S(h) · li<sub>2</sub>(x)</div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:20px;">
                    <div style="background:rgba(168,85,247,.08);border-left:3px solid #a855f7;padding:16px;border-radius:6px;">
                        <div style="color:#a855f7;font-weight:700;margin-bottom:10px;">S(h) — The Singular Series</div>
                        <div style="color:#e0e0e0;font-family:'EB Garamond',Georgia,serif;font-size:1.1rem;line-height:2.2;">S(h) = 2C<sub>2</sub> · ∏<sub>p | h, p odd prime</sub> (p−1)/(p−2)</div>
                        <div style="color:#888;font-size:.85rem;margin-top:8px;">Encodes how divisibility of h by small primes opens extra residue classes, making some gaps more probable than others.</div>
                    </div>
                    <div style="background:rgba(78,205,196,.08);border-left:3px solid #4ecdc4;padding:16px;border-radius:6px;">
                        <div style="color:#4ecdc4;font-weight:700;margin-bottom:10px;">li<sub>2</sub>(x) — The Logarithmic Integral</div>
                        <div style="color:#e0e0e0;font-family:'EB Garamond',Georgia,serif;font-size:1.1rem;line-height:2.2;">li<sub>2</sub>(x) = ∫<sub>2</sub><sup>x</sup> dt / ln²(t)</div>
                        <div style="color:#888;font-size:.85rem;margin-top:8px;">The density baseline — how many prime pairs would exist if distributed purely by logarithm. S(h) scales this per gap.</div>
                    </div>
                </div>
            </div>

            <!-- PART 2: C2 CONSTANT -->
            <div style="background:#0d0d1a;border:1px solid #ffd700;border-radius:10px;padding:28px;margin-bottom:24px;">
                <h3 style="color:#ffd700;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 2 — Where Does C₂ = 0.6601618… Come From?</h3>
                <p style="color:#ccc;margin-bottom:16px;line-height:1.8;">C₂ is the <strong style="color:#ffd700">twin prime constant</strong> — an infinite Euler product over all primes p ≥ 3, measuring how residue-class constraints reduce the density of twin primes relative to a random model:</p>
                <div class="formula-box">C<sub>2</sub> = ∏<sub>p ≥ 3</sub> p(p−2) / (p−1)²</div>
                <p style="color:#ccc;margin:0 0 16px 0;line-height:1.7;font-size:.9rem;">Each factor p(p−2)/(p−1)² &lt; 1 accounts for the fact that for a prime p, there is one forbidden residue class mod p for each element of a twin-prime pair. The infinite product converges slowly to ≈ 0.66016. Below: partial products through the first 20 primes.</p>
                <div style="background:#12121a;border-radius:8px;padding:20px;overflow-x:auto;">
                    <table style="width:100%;border-collapse:collapse;font-family:monospace;font-size:.83rem;min-width:600px;">
                        <thead><tr style="background:#1a1a2a;">
                            <th style="padding:8px 12px;text-align:left;color:#ffd700;border-bottom:1px solid #2a2a4a;">Prime p</th>
                            <th style="padding:8px 12px;text-align:left;color:#ffd700;border-bottom:1px solid #2a2a4a;">p(p−2)/(p−1)²</th>
                            <th style="padding:8px 12px;text-align:left;color:#ffd700;border-bottom:1px solid #2a2a4a;">Factor value</th>
                            <th style="padding:8px 12px;text-align:left;color:#ffd700;border-bottom:1px solid #2a2a4a;">Running C₂ product</th>
                            <th style="padding:8px 12px;text-align:left;color:#ffd700;border-bottom:1px solid #2a2a4a;">% of final C₂</th>
                        </tr></thead>
                        <tbody id="hl_c2_table_body"></tbody>
                    </table>
                </div>
                <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:16px;">
                    <div style="background:rgba(255,215,0,.07);border:1px solid #ffd700;border-radius:6px;padding:14px;text-align:center;">
                        <div style="color:#888;font-size:.78rem;margin-bottom:4px;">C₂ (full precision)</div>
                        <div style="color:#ffd700;font-family:monospace;font-size:.9rem;">0.6601618158468695…</div>
                    </div>
                    <div style="background:rgba(255,215,0,.07);border:1px solid #ffd700;border-radius:6px;padding:14px;text-align:center;">
                        <div style="color:#888;font-size:.78rem;margin-bottom:4px;">2·C₂ = S(2) = S(4) = S(8)</div>
                        <div style="color:#ffd700;font-family:monospace;font-size:.9rem;">1.3203236316937390…</div>
                    </div>
                    <div style="background:rgba(255,215,0,.07);border:1px solid #ffd700;border-radius:6px;padding:14px;text-align:center;">
                        <div style="color:#888;font-size:.78rem;margin-bottom:4px;">4·C₂ = S(6) = S(12) = S(18)</div>
                        <div style="color:#ffd700;font-family:monospace;font-size:.9rem;">2.6406472633874780…</div>
                    </div>
                </div>
            </div>

            <!-- PART 3: SINGULAR SERIES TABLE -->
            <div style="background:#0d0d1a;border:1px solid #22c55e;border-radius:10px;padding:28px;margin-bottom:24px;">
                <h3 style="color:#22c55e;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 3 — Singular Series S(h) for the First 30 Even Gaps: Full Derivation</h3>
                <p style="color:#ccc;margin-bottom:16px;line-height:1.8;">For each gap h, S(h) = 2C₂ · ∏<sub>(odd prime p | h)</sub> (p−1)/(p−2). The table below shows the factorisation of h, which odd primes divide it, each correction factor, and the final S(h). <strong style="color:#22c55e;">Only odd prime factors count</strong> — p=2 always divides even h but contributes no correction because 2 is already handled in the baseline C₂ Euler product.</p>
                <div style="background:#12121a;border-radius:8px;padding:20px;overflow-x:auto;">
                    <table style="width:100%;border-collapse:collapse;font-size:.82rem;min-width:900px;">
                        <thead><tr style="background:#1a1a2a;">
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">Gap h</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">h = 2^a × odd</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">Odd prime factors</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">Correction factors (p−1)/(p−2)</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">Product</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">S(h) = 2C₂ × product</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">S(h)/S(2)</th>
                            <th style="padding:8px 10px;text-align:left;color:#22c55e;border-bottom:1px solid #2a2a4a;">Name</th>
                        </tr></thead>
                        <tbody id="hl_singular_table_body"></tbody>
                    </table>
                </div>
                <div style="background:rgba(34,197,94,.07);border-left:4px solid #22c55e;padding:16px;border-radius:6px;margin-top:16px;">
                    <div style="color:#22c55e;font-weight:700;margin-bottom:8px;">The key insight: why gap 6 is twice as common as gap 2</div>
                    <div style="color:#ccc;font-size:.88rem;line-height:1.8;">
                        Gap 2: h=2, no odd prime factors → correction product = 1 → S(2) = 2C₂ ≈ 1.3203<br>
                        Gap 4: h=4=2², no odd prime factors → S(4) = 2C₂ <em>identical to gap 2</em><br>
                        Gap 6: h=6=2×3, odd factor p=3 → correction = (3−1)/(3−2) = 2/1 = <strong style="color:#ffd700">2</strong> → S(6) = 2 × 2C₂ = 4C₂ ≈ 2.6406<br><br>
                        Gap 30: h=30=2×3×5, corrections: (2/1)×(4/3) = 8/3 → S(30) = (8/3)×2C₂ = <strong style="color:#ffd700">16C₂/3 ≈ 3.5209</strong><br><br>
                        Because 3 | 6, the pair {p, p+6} satisfies p ≡ p+6 (mod 3), so <em>neither element is forced to be divisible by 3</em>.
                        This doubles admissible residue pairs. At 400M the observed ratio gap6/gap2 = 1.767, converging toward the theoretical limit of 2.0.
                    </div>
                </div>
            </div>

            <!-- PART 4: li2 EXPANSION -->
            <div style="background:#0d0d1a;border:1px solid #4ecdc4;border-radius:10px;padding:28px;margin-bottom:24px;">
                <h3 style="color:#4ecdc4;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 4 — The li₂(x) Expansion: Every Correction Term Analysed</h3>
                <p style="color:#ccc;margin-bottom:16px;line-height:1.8;">The integral li₂(x)=∫dt/ln²(t) has an asymptotic expansion. Each correction term below reduces prediction error. Changing x shows how the terms' magnitudes shift with the analysis range.</p>
                <div class="formula-box" style="font-size:1.05rem;">li₂(x) = (x/ln²x) · [ 1 + 2/ln x + 6/ln²x + 24/ln³x + 120/ln⁴x + … ]&nbsp;&nbsp;&nbsp;(k-th coefficient = (k+1)!)</div>
                <div style="background:#12121a;border-radius:8px;padding:14px;margin:16px 0;display:flex;align-items:center;gap:14px;flex-wrap:wrap;">
                    <label style="color:#4ecdc4;font-size:.9rem;">Compute at x =</label>
                    <input type="number" id="hl_li2_x_input" value="400000000" min="1000" max="10000000000" step="1000000"
                           oninput="hl_updateLi2Table()"
                           style="padding:8px 12px;background:#1a1a2a;border:1px solid #3a3a5a;border-radius:4px;color:#e0e0e0;font-size:.9rem;width:180px;">
                    <div id="hl_li2_lnx_display" style="color:#888;font-size:.82rem;"></div>
                </div>
                <div style="background:#12121a;border-radius:8px;padding:20px;overflow-x:auto;">
                    <table style="width:100%;border-collapse:collapse;font-family:monospace;font-size:.82rem;min-width:750px;">
                        <thead><tr style="background:#1a1a2a;">
                            <th style="padding:8px 12px;text-align:left;color:#4ecdc4;border-bottom:1px solid #2a2a4a;">Terms used</th>
                            <th style="padding:8px 12px;text-align:left;color:#4ecdc4;border-bottom:1px solid #2a2a4a;">Formula</th>
                            <th style="padding:8px 12px;text-align:left;color:#4ecdc4;border-bottom:1px solid #2a2a4a;">li₂(x) value</th>
                            <th style="padding:8px 12px;text-align:left;color:#4ecdc4;border-bottom:1px solid #2a2a4a;">2C₂·li₂ prediction</th>
                            <th style="padding:8px 12px;text-align:left;color:#4ecdc4;border-bottom:1px solid #2a2a4a;">Gain from prev term</th>
                            <th style="padding:8px 12px;text-align:left;color:#4ecdc4;border-bottom:1px solid #2a2a4a;">Error vs obs twins*</th>
                        </tr></thead>
                        <tbody id="hl_li2_table_body"></tbody>
                    </table>
                    <div style="color:#555;font-size:.75rem;margin-top:8px;">*Observed twin count auto-populated from the most recent analysis run; otherwise uses 1,507,733 (400M baseline)</div>
                </div>
                <div style="background:rgba(78,205,196,.07);border-left:4px solid #4ecdc4;padding:14px;border-radius:6px;margin-top:16px;">
                    <div style="color:#4ecdc4;font-weight:700;margin-bottom:6px;">Why the corrections are large at practical ranges</div>
                    <div style="color:#ccc;font-size:.85rem;line-height:1.7;">At x=400M, ln(x) ≈ 19.8, so the first correction 2/ln(x) ≈ 10.1% — far from negligible. The k-th term has coefficient (k+1)!, so the corrections form a divergent asymptotic series — accuracy peaks around the 4th–5th term for x in the billions, then worsens. The 4-term formula gives &lt;0.1% error at 400M.</div>
                </div>
            </div>

            <!-- PART 5: PER-GAP FULL TABLE (live from analysis) -->
            <div style="background:#0d0d1a;border:1px solid #f59e0b;border-radius:10px;padding:28px;margin-bottom:24px;">
                <h3 style="color:#f59e0b;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 5 — Full Gap-by-Gap H-L Prediction vs Observed Data</h3>
                <p style="color:#ccc;margin-bottom:16px;line-height:1.8;">Every gap family in the analysis: S(h) derived step-by-step, li₂ prediction computed, compared against the observed count. The obs/pred ratio converges to 1.0 as x→∞.</p>
                <div style="background:#12121a;border-radius:8px;padding:14px;margin-bottom:16px;display:flex;align-items:center;gap:14px;flex-wrap:wrap;">
                    <div style="color:#f59e0b;font-size:.9rem;">Analysis range:</div>
                    <div id="hl_range_display" style="color:#ffd700;font-family:monospace;font-size:.95rem;font-weight:700;">Run analysis above first</div>
                </div>
                <div style="background:#12121a;border-radius:8px;padding:20px;overflow-x:auto;">
                    <table style="width:100%;border-collapse:collapse;font-size:.8rem;min-width:1050px;">
                        <thead><tr style="background:#1a1a2a;">
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Gap h</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Name</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Odd prime factors of h</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">S(h)</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">S(h)/S(2)</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Predicted</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Observed</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Obs/Pred</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Error %</th>
                            <th style="padding:8px 10px;text-align:left;color:#f59e0b;border-bottom:1px solid #2a2a4a;">Convergence</th>
                        </tr></thead>
                        <tbody id="hl_full_table_body">
                            <tr><td colspan="10" style="padding:20px;text-align:center;color:#888;font-style:italic;">Run the prime analysis above to populate this table</td></tr>
                        </tbody>
                    </table>
                </div>
                <div class="export-row" style="margin-top:16px;">
                    <button class="export-btn csv" onclick="exportHLFullTableCSV()">Export Part 5 CSV</button>
                    <button class="export-btn png" onclick="exportHLFullTableDOM()" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: #3b82f6;">Export Part 5 PNG</button>
                </div>
            </div>

            <!-- PART 6: INTERACTIVE WALKTHROUGH -->
            <div style="background:#0d0d1a;border:1px solid #e879f9;border-radius:10px;padding:28px;margin-bottom:24px;">
                <h3 style="color:#e879f9;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 6 — Interactive: Full Arithmetic Walkthrough for Any Gap</h3>
                <p style="color:#ccc;margin-bottom:20px;line-height:1.8;">Select any gap to see every single arithmetic step: prime factorisation of h, identifying correction primes, computing each (p−1)/(p−2) factor, building S(h), expanding li₂(x) term by term, and arriving at the final prediction.</p>
                <div style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:20px;align-items:flex-end;">
                    <div style="display:flex;flex-direction:column;gap:6px;">
                        <label style="color:#e879f9;font-size:.85rem;">Gap h</label>
                        <input type="number" id="hl_gap_input" value="6" min="2" max="500" step="2"
                               style="padding:8px 12px;background:#1a1a2a;border:1px solid #3a3a5a;border-radius:4px;color:#e0e0e0;font-size:.9rem;width:100px;">
                    </div>
                    <div style="display:flex;flex-direction:column;gap:6px;">
                        <label style="color:#e879f9;font-size:.85rem;">At x =</label>
                        <input type="number" id="hl_x_input" value="400000000" min="1000" max="10000000000" step="1000000"
                               style="padding:8px 12px;background:#1a1a2a;border:1px solid #3a3a5a;border-radius:4px;color:#e0e0e0;font-size:.9rem;width:180px;">
                    </div>
                    <button onclick="hl_computeWalkthrough()"
                            style="padding:10px 24px;background:linear-gradient(135deg,#e879f9,#a855f7);border:none;border-radius:6px;color:#fff;font-weight:700;cursor:pointer;font-size:.95rem;">
                        Compute Step by Step
                    </button>
                    <div style="display:flex;gap:8px;flex-wrap:wrap;">
                        <button onclick="hl_setGap(2)"   class="hl-preset-btn">Gap 2 (twins)</button>
                        <button onclick="hl_setGap(4)"   class="hl-preset-btn">Gap 4 (cousins)</button>
                        <button onclick="hl_setGap(6)"   class="hl-preset-btn">Gap 6 (sexy)</button>
                        <button onclick="hl_setGap(10)"  class="hl-preset-btn">Gap 10</button>
                        <button onclick="hl_setGap(12)"  class="hl-preset-btn">Gap 12</button>
                        <button onclick="hl_setGap(30)"  class="hl-preset-btn">Gap 30</button>
                        <button onclick="hl_setGap(210)" class="hl-preset-btn">Gap 210 (2×3×5×7)</button>
                    </div>
                </div>
                <div id="hl_walkthrough_output" style="background:var(--parchment-deep);border-radius:8px;padding:24px;border:1px solid var(--border);min-height:80px;">
                    <div style="color:#666;font-style:italic;">Click "Compute Step by Step" to see the full arithmetic</div>
                </div>
                <div class="export-row" style="margin-top:16px;">
                    <button class="export-btn csv" onclick="exportHLWalkthroughCSV()">Export Walkthrough CSV</button>
                    <button class="export-btn png" onclick="exportHLWalkthroughDOM()" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: #3b82f6;">Export Walkthrough PNG</button>
                </div>
            </div>

            <!-- PART 7: RATIO CONVERGENCE TABLE -->
            <div style="background:#0d0d1a;border:1px solid #64748b;border-radius:10px;padding:28px;">
                <h3 style="color:#94a3b8;margin:0 0 20px 0;font-size:1.1rem;text-transform:uppercase;letter-spacing:.05em;">Part 7 — Convergence of Count Ratios to Theoretical Limits</h3>
                <p style="color:#ccc;margin-bottom:16px;line-height:1.8;">As x→∞, Count(gap=a)/Count(gap=b) → S(a)/S(b). This table shows current ratios from the computed data vs the theoretical limits, with a convergence bar showing proximity to the asymptotic value.</p>
                <div style="background:#12121a;border-radius:8px;padding:20px;overflow-x:auto;">
                    <table style="width:100%;border-collapse:collapse;font-size:.83rem;min-width:750px;">
                        <thead><tr style="background:#1a1a2a;">
                            <th style="padding:8px 12px;text-align:left;color:#94a3b8;border-bottom:1px solid #2a2a4a;">Ratio</th>
                            <th style="padding:8px 12px;text-align:left;color:#94a3b8;border-bottom:1px solid #2a2a4a;">Why this limit</th>
                            <th style="padding:8px 12px;text-align:left;color:#94a3b8;border-bottom:1px solid #2a2a4a;">Theoretical limit</th>
                            <th style="padding:8px 12px;text-align:left;color:#94a3b8;border-bottom:1px solid #2a2a4a;">Current value</th>
                            <th style="padding:8px 12px;text-align:left;color:#94a3b8;border-bottom:1px solid #2a2a4a;">% of limit reached</th>
                            <th style="padding:8px 12px;text-align:left;color:#94a3b8;border-bottom:1px solid #2a2a4a;">Visual</th>
                        </tr></thead>
                        <tbody id="hl_ratio_table_body">
                            <tr><td colspan="6" style="padding:20px;text-align:center;color:#888;font-style:italic;">Run analysis above to populate</td></tr>
                        </tbody>
                    </table>
                </div>
                <div class="export-row" style="margin-top:16px;">
                    <button class="export-btn csv" onclick="exportHLRatioTableCSV()">Export Ratios CSV</button>
                    <button class="export-btn png" onclick="exportHLSectionDOM()" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: #3b82f6;">Export Full Section PNG</button>
                </div>
            </div>
        </div>
        <!-- ── end HL deep dive section ── -->
        
<div class="chart-wrapper" id="stepByStepWrapper">
            <div class="chart-title">Step-by-Step Gap Accumulation: ζ(2) = P<sub>0</sub> × P<sub>2</sub> × P<sub>4</sub> × ...</div>
            <div class="chart-description">
                Shows the progressive buildup of the cumulative product as each gap family is added. This table view complements the convergence chart by providing exact numerical values at each step.
            </div>
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Progressive Product Construction</div>
                    <div class="precision-control">
                        <label>Decimals:</label>
                        <select id="stepByStepPrecision" onchange="updateStatsTables()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8">8</option>
                            <option value="10">10</option>
                            <option value="12" selected>12</option>
                            <option value="15">15</option>
                        </select>
                        <button class="show-all-toggle" onclick="toggleTable('stepByStepTable')">Show All</button>
                    </div>
                </div>
                <div class="stats-table-container expanded" id="stepByStepTable">
                    <table class="stats-table" id="stepByStepTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportTableCSV('stepByStep')">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportStepByStepTablePNG()">Export Table PNG</button>
                </div>
            </div>
        </div>
        
        <!-- COMPARISON CHART (Only shown when comparison mode enabled) -->
        <div class="chart-wrapper" id="comparisonWrapper" style="display: none;">
            <div class="chart-title">Gap Contribution Evolution Across ζ(s)</div>
            <canvas id="comparisonChart" width="3840" height="2400"></canvas>
            <div class="stats-table-wrapper">
                <div class="chart-description" style="background: rgba(74,42,106,0.06); padding: 16px; border-radius: 6px; border-left: 4px solid var(--purple-ink);">
                    <strong>How Gap Contributions Change with s:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>s → 1:</strong> All gaps contribute equally (divergent series)</li>
                        <li><strong>s = 1.5:</strong> Gap 1 (45%), Gap 2 (39%) - Balanced</li>
                        <li><strong>s = 2:</strong> Gap 1 (58%), Gap 2 (35%) - Current tool focus</li>
                        <li><strong>s = 4:</strong> Gap 1 (82%), Gap 2 (18%) - Gap 1 dominant</li>
                        <li><strong>s = 10:</strong> Gap 1 (98%), Gap 2 (2%) - Almost entirely Gap 1</li>
                    </ul>
                    <p style="margin-top: 12px; color: var(--purple-ink);">
                        <strong>Key Insight:</strong> Twin primes (Gap 2) dominate at s=2, but prime 2 (Gap 1) dominates at higher s values!
                    </p>
                </div>
                <div id="comparisonTableDiv"></div>
                <div class="export-row">
                    <button class="export-btn png" onclick="exportComparisonPNG()">Export Comparison PNG</button>
                </div>
            </div>
        </div>
        
        <!-- DECIMAL CONVERGENCE ANALYSIS -->
        <div class="chart-wrapper" id="decimalConvergenceWrapper">
            <div class="chart-title">Decimal Place Convergence Analysis: Weight Decay & Marginal Contribution</div>
            <div class="chart-description" style="background: rgba(45,90,39,0.06); padding: 16px; border-radius: 6px; border-left: 4px solid #22c55e; margin-bottom: 20px;">
                <strong>Understanding Weight Decay:</strong> As primes get larger, the factor p²/(p²-1) approaches 1.0, so later primes contribute less. 
                For example, prime 2 contributes 4/3 = 1.333... (fixed), but prime 1,000,003 contributes ≈1.000000000004.
                This analysis shows <strong>which primes "lock in" each decimal place</strong> of convergence for each gap family.
            </div>
            
            <canvas id="decimalConvergenceChart" width="3840" height="2160"></canvas>
            
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Per-Prime Marginal Contribution</div>
                    <div class="precision-control">
                        <label>Gap to Analyze:</label>
                        <select id="decimalGapSelect" onchange="updateDecimalAnalysis()">
                            <option value="1">Gap 1</option>
                            <option value="2" selected>Gap 2 (Twin Primes)</option>
                            <option value="4">Gap 4 (Cousin Primes)</option>
                            <option value="6">Gap 6 (Sexy Primes)</option>
                            <option value="8">Gap 8</option>
                            <option value="10">Gap 10</option>
                            <option value="12">Gap 12</option>
                        </select>
                        <label style="margin-left: 20px;">Show:</label>
                        <select id="decimalDetailLevel" onchange="updateDecimalAnalysis()">
                            <option value="summary" selected>Summary (First 20 primes)</option>
                            <option value="detailed">Detailed (First 100 primes)</option>
                            <option value="full">Full (All primes in gap)</option>
                        </select>
                        <label style="margin-left: 20px;">Decimals:</label>
                        <select id="decimalConvergencePrecision" onchange="updateDecimalAnalysis()">
                            <option value="4">4</option>
                            <option value="6">6</option>
                            <option value="8">8</option>
                            <option value="10">10</option>
                            <option value="12" selected>12</option>
                            <option value="15">15</option>
                        </select>
                    </div>
                </div>
                <div class="stats-table-container" id="decimalAnalysisTable">
                    <table class="stats-table" id="decimalAnalysisTableContent"></table>
                </div>
                <div class="export-row">
                    <button class="export-btn csv" onclick="exportDecimalAnalysisCSV()">Export Table CSV</button>
                    <button class="export-btn png" onclick="exportChartPNG_DOM('decimalConvergenceChart', 'decimal_convergence')" style="background: linear-gradient(135deg, #3b82f6 0%, #1e40af 100%); border-color: var(--sepia);">DOM Export</button>
                    <button class="export-btn png" onclick="exportChartPNG_Canvas('decimalConvergenceChart', 'decimal_convergence')" style="background: linear-gradient(135deg, #ef4444 0%, #991b1b 100%); border-color: #ef4444;">Canvas Export</button>
                </div>
            </div>
        </div>
        
        <!-- GAP RATIO ANALYSIS CHART -->

        <!-- ══ RIEMANN ZEROS ANALYSIS ══ -->
        <div class="chart-wrapper" id="riemannZerosSection" style="border:2px solid #a855f7;">
            <div class="chart-title" style="color:#a855f7;">Riemann Zeros &amp; Farey Structure</div>
            <div class="chart-description" style="background:rgba(168,85,247,0.06);padding:14px 16px;border-radius:6px;border-left:4px solid #a855f7;margin-bottom:16px;">
                Each non-trivial zero ρ = ½ + it&#8319; of ζ(s) contributes a rotating phase <strong>e<sup>it&#8319; log N</sup></strong> to the Farey discrepancy sum. Use the <strong style="color:#a855f7;">ζ Riemann t</strong> button in the Farey visualiser above to see these phases plotted on the outer ring — as mod N changes the dots rotate, and when they align the discrepancy spikes (Franel–Landau 1924). The two panels below show the frequency structure and the RH bound directly.
            </div>

            <!-- Panel A: DFT bar chart -->
            <div id="rz-dft-wrap" style="margin-bottom:6px;">
              <div style="font-family:'Cinzel',serif;font-size:0.6rem;letter-spacing:0.09em;text-transform:uppercase;color:#a855f7;margin-bottom:5px;padding:0 2px;">
                &#9656; Farey Angular DFT Spectrum
              </div>
              <div style="font-family:Georgia,serif;font-size:0.78rem;color:var(--ink-mid);line-height:1.6;margin-bottom:8px;padding:7px 12px;background:rgba(168,85,247,0.04);border-left:3px solid rgba(168,85,247,0.35);border-radius:0 4px 4px 0;">
                Fourier spectrum of the GCD=1 angular distribution at mod N. Gold lines mark predicted peaks at k&nbsp;≈&nbsp;t&#8319;/2π from each Riemann zero — peaks sharpen toward those positions as N grows. <span style="color:#9a8060;">Hover bars to read magnitude.</span>
              </div>
              <div style="position:relative;">
                <canvas id="rz-dft-canvas" width="1200" height="260" style="display:block;width:100%;background:var(--canvas-bg);border:1px solid var(--border);border-radius:4px;margin-bottom:4px;cursor:crosshair;"></canvas>
                <div id="rz-dft-tooltip" style="display:none;position:absolute;background:rgba(14,11,5,0.96);border:1px solid rgba(168,85,247,0.5);border-radius:4px;padding:8px 11px;font-family:'Cinzel',serif;font-size:0.6rem;color:#e8d9b0;pointer-events:none;z-index:50;white-space:nowrap;"></div>
              </div>
            </div>

            <!-- Panel B: Farey discrepancy vs RH bound -->
            <div id="rz-disc-wrap" style="margin-bottom:12px;">
              <div style="font-family:'Cinzel',serif;font-size:0.6rem;letter-spacing:0.09em;text-transform:uppercase;color:#ffd700;margin-bottom:5px;padding:0 2px;">
                &#9656; Farey Discrepancy vs Riemann Hypothesis Bound
              </div>
              <div style="font-family:Georgia,serif;font-size:0.78rem;color:var(--ink-mid);line-height:1.6;margin-bottom:8px;padding:7px 12px;background:rgba(255,215,0,0.04);border-left:3px solid rgba(255,215,0,0.35);border-radius:0 4px 4px 0;">
                Purple = actual Farey discrepancy D<sub>N</sub>. Gold dashed = RH bound log&nbsp;N/(2π√N). <strong style="color:#ffd700;">RH ↔ purple stays below gold.</strong> Pink lines mark zero heights t&#8319; on the N-axis. <span style="color:#9a8060;">Hover to read values.</span>
              </div>
              <div style="position:relative;">
                <canvas id="rz-spectrum-canvas" width="1200" height="260" style="display:block;width:100%;background:var(--canvas-bg);border:1px solid var(--border);border-radius:4px;margin-bottom:4px;cursor:crosshair;"></canvas>
                <div id="rz-disc-tooltip" style="display:none;position:absolute;background:rgba(14,11,5,0.96);border:1px solid rgba(255,215,0,0.5);border-radius:4px;padding:8px 11px;font-family:'Cinzel',serif;font-size:0.6rem;color:#e8d9b0;pointer-events:none;z-index:50;white-space:nowrap;"></div>
              </div>
            </div>

            <!-- Controls row -->
            <div style="display:flex;flex-wrap:wrap;gap:16px;align-items:center;justify-content:center;margin-bottom:16px;font-family:'Cinzel',serif;font-size:0.62rem;letter-spacing:0.07em;">
                <label style="color:var(--gold);">MOD N
                    <input id="rz-mod" type="number" min="2" max="9999" value="49" step="1"
                        style="width:60px;margin-left:8px;background:var(--parchment-deep);color:var(--ink);border:1px solid var(--border);padding:3px 6px;font-family:'Cinzel',serif;font-size:0.62rem;"
                        oninput="this.value=Math.max(2,Math.min(9999,Math.floor(+this.value||2)));rzDraw()">
                </label>
                <label style="color:var(--gold);">ZEROS
                    <input id="rz-nzeros" type="range" min="5" max="100" value="20"
                        style="width:80px;margin-left:8px;vertical-align:middle;accent-color:#a855f7;"
                        oninput="document.getElementById('rz-nzeros-val').textContent=this.value;rzDraw()">
                    <span id="rz-nzeros-val" style="color:#a855f7;min-width:20px;display:inline-block;">20</span>
                </label>

                <label style="color:var(--gold);">
                    <input type="checkbox" id="rz-show-dft" checked onchange="rzDraw()" style="accent-color:#a855f7;"> DFT Spectrum
                </label>
                <label style="color:var(--gold);">
                    <input type="checkbox" id="rz-show-disc" checked onchange="rzDraw()" style="accent-color:#ffd700;"> Discrepancy
                </label>
                <button onclick="rzDraw()" style="font-family:'Cinzel',serif;font-size:0.58rem;letter-spacing:0.08em;text-transform:uppercase;padding:4px 14px;border:1px solid #a855f7;background:var(--parchment-dark);color:#a855f7;cursor:pointer;">&#8635; Redraw</button>
            </div>

            <!-- Zero heights table -->
            <div class="stats-table-wrapper">
                <div class="stats-table-header">
                    <div class="stats-table-title">Known Non-Trivial Zero Heights t&#8319; of ζ(s) (first 30)</div>
                </div>
                <div class="stats-table-container" style="max-height:260px;">
                    <table class="stats-table" id="rz-zeros-table"></table>
                </div>
                <div id="rz-dft-legend" style="font-family:monospace;font-size:0.65rem;color:#a855f7;margin-top:10px;line-height:1.8;padding:10px 14px;background:rgba(168,85,247,0.05);border-left:3px solid #a855f7;border-radius:0 4px 4px 0;"></div>
                <div class="export-row">
                    <button class="export-btn png" onclick="rzExportPNG()" style="background:linear-gradient(135deg,#7c3aed,#4c1d95);border-color:#a855f7;">Export Canvas PNG</button>
                    <button class="export-btn png" onclick="rzExportDOM()" style="background:linear-gradient(135deg,#3b82f6,#1e40af);border-color:#3b82f6;">Export DOM PNG</button>
                    <button class="export-btn csv" onclick="rzExportCSV()">Export CSV</button>
                </div>
            </div>
        </div>
        <!-- ══ END RIEMANN ZEROS ══ -->

    </div>
    
    <div class="controls-container">
        <div class="control-panel">
            <h3>Composite Screenshot Export</h3>
            <p style="color:var(--ink-light); font-size: 0.9rem; margin-bottom: 20px;">
                Generate a comprehensive image combining selected charts with analysis summary and mathematical narrative
            </p>
            
            <div style="background: rgba(26,74,74,0.04); padding: 16px; border-radius: 8px; border-left: 4px solid var(--teal-ink); margin-bottom: 20px;">
                <h4 style="color: var(--teal-ink); margin: 0 0 12px 0; font-size: 1rem;">Global Export Settings</h4>
                <p style="margin: 0 0 12px 0; color: #888; font-size: 0.85rem;">
                    These settings apply to ALL chart exports (individual and composite)
                </p>
                
                <div class="control-grid" style="grid-template-columns: 1fr;">
                    <div class="control-group">
                        <label>Data Rows in Exported Tables</label>
                        <select id="globalExportRows">
                            <option value="5">5 rows</option>
                            <option value="10">10 rows</option>
                            <option value="15" selected>15 rows</option>
                            <option value="20">20 rows</option>
                            <option value="25">25 rows</option>
                            <option value="30">30 rows</option>
                            <option value="40">40 rows</option>
                            <option value="50">50 rows</option>
                            <option value="all">All rows (may be very large)</option>
                        </select>
                        <div style="margin-top: 4px; font-size: 0.75rem; color: #888;">
                            Applies to all chart PNG exports (individual and composite screenshots)
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="control-grid" style="grid-template-columns: repeat(3, 1fr);">
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotConvergence" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Progressive Convergence</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotGapContrib" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Gap Products</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotGapDist" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Gap Distribution</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotPercentage" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Percentage Contributions</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotError" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Error Analysis</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotLogScale" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Log-Scale Products</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotGapRatio" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Gap Ratio Analysis</span>
                </div>
                
                <div class="toggle-wrapper">
                    <label class="toggle">
                        <input type="checkbox" id="screenshotDecimalConv">
                        <span class="toggle-slider"></span>
                    </label>
                    <span>Decimal Convergence</span>
                </div>
            </div>
            
            <div class="section-divider"></div>
            
            <div class="control-group">
                <label>Main Title</label>
                <input type="text" id="screenshotTitle" value="Gap-Class Decomposition of ζ(2) = π²/6">
            </div>
            
            <div class="control-group">
                <label>Subtitle</label>
                <input type="text" id="screenshotSubtitle" value="Analytical Partition of the Euler Product">
            </div>
            
            <div class="control-group">
                <label>Layout</label>
                <select id="screenshotLayout">
                    <option value="grid">Grid (2×3)</option>
                    <option value="vertical">Vertical Stack</option>
                    <option value="horizontal">Horizontal (2 rows)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Resolution</label>
                <select id="screenshotResolution">
                    <option value="1920">HD (1920×1080)</option>
                    <option value="2560">QHD (2560×1440)</option>
                    <option value="3840" selected>4K (3840×2160)</option>
                    <option value="7680">8K (7680×4320)</option>
                </select>
            </div>
            
            <div class="section-divider"></div>
            
            <button class="btn" onclick="generateCompositeScreenshot()" style="width: 100%; margin-bottom: 12px;">
                Generate Composite Screenshot
            </button>
            
            <div id="screenshotStatus" class="status-bar" style="display: none; margin-top: 12px;">
                Generating screenshot...
            </div>
        </div>
    </div>
    
    <!-- MERTENS FUNCTION SECTION -->
    <div class="controls-container" style="margin-top: 40px;">
        <div class="dropdown-section" style="border: 2px solid var(--teal-ink);">
            <div class="dropdown-header" onclick="toggleSection(this)">
                <h3 style="color: var(--teal-ink); display: flex; align-items: center; gap: 12px;">
                    <span>⟨μ⟩</span> Mertens Function & Riemann Hypothesis Connection
                    <span style="background: rgba(78,205,196,0.2); color: var(--teal-ink); padding: 4px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: 600;">Companion Analysis</span>
                </h3>
                <span class="dropdown-icon" style="color: var(--teal-ink);">v</span>
            </div>
            <div class="dropdown-content">

                <!-- Mathematical Bridge -->
                <div style="background: var(--parchment-dark); border: 1px solid var(--panel-border); border-left: 4px solid var(--teal-ink); padding: 20px; margin-bottom: 20px;">
                    <h4 style="color: var(--teal-ink); margin: 0 0 14px 0; font-size: 1.1rem;">Connection to the Gap-Class Decomposition</h4>
                    <p style="color:var(--ink-mid); margin-bottom: 12px; line-height: 1.7;">
                        The gap-class decomposition above reorganises the Euler product <strong style="color:var(--gold);">ζ(2) = ∏ p²/(p²−1)</strong> by prime gap families. 
                        The Mertens function below probes the <em>same prime landscape</em> from a different angle: the Möbius function μ(n) encodes the exact prime-factorisation structure that drives those products, 
                        with μ(n) = ±1 for square-free n and 0 otherwise.
                    </p>
                    <p style="color:var(--ink-mid); margin-bottom: 12px; line-height: 1.7;">
                        Their deep link is the Riemann Hypothesis. The RH is equivalent to both:
                    </p>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                        <div style="background: rgba(255,215,0,0.07); border-left: 3px solid #ffd700; padding: 12px; border-radius: 4px;">
                            <div style="color: var(--gold); font-family: 'Times New Roman', serif; font-size: 1.1rem; margin-bottom: 6px;">|M(n)| = O(n^(½+ε))</div>
                            <div style="color:var(--ink-light); font-size: 0.85rem;">The Mertens wave stays within the ±√n boundary — visible in the chart below</div>
                        </div>
                        <div style="background: rgba(78,205,196,0.07); border-left: 3px solid #4ecdc4; padding: 12px; border-radius: 4px;">
                            <div style="color: var(--teal-ink); font-family: 'Times New Roman', serif; font-size: 1.1rem; margin-bottom: 6px;">log ζ(s) = Σ<sub>g</sub> log P<sub>g</sub></div>
                            <div style="color:var(--ink-light); font-size: 0.85rem;">The gap decomposition converges — witnessed by the error charts above</div>
                        </div>
                    </div>
                    <p style="color:var(--ink-light); font-size: 0.9rem; line-height: 1.6;">
                        Both functions are ultimately measuring whether primes are distributed "fairly" — without systematic bias toward any particular factorisation pattern. 
                        The tight convergence in the gap products above and M(n) staying within ±√n below are two faces of the same conjecture.
                    </p>
                </div>

                <!-- Mertens Stats Grid -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-bottom: 20px;">
                    <div style="background: var(--parchment-dark); border: 1px solid var(--panel-border); border-left: 3px solid var(--teal-ink); padding: 14px;">
                        <div style="color:var(--ink-light); font-size: 0.8rem; margin-bottom: 4px;">Current Range</div>
                        <div style="color: var(--teal-ink); font-size: 1.3rem; font-weight: bold;" id="m_statRange">n = 1 to 2,000</div>
                    </div>
                    <div style="background: var(--parchment-dark); border: 1px solid var(--panel-border); border-left: 3px solid var(--green-ink); padding: 14px;">
                        <div style="color:var(--ink-light); font-size: 0.8rem; margin-bottom: 4px;">Maximum Peak</div>
                        <div style="color: var(--green-ink); font-size: 1.3rem; font-weight: bold;" id="m_statMax">—</div>
                    </div>
                    <div style="background: var(--parchment-dark); border: 1px solid var(--panel-border); border-left: 3px solid var(--red-ink); padding: 14px;">
                        <div style="color:var(--ink-light); font-size: 0.8rem; margin-bottom: 4px;">Minimum Dip</div>
                        <div style="color: #ef4444; font-size: 1.3rem; font-weight: bold;" id="m_statMin">—</div>
                    </div>
                    <div style="background: var(--parchment-dark); border: 1px solid var(--panel-border); border-left: 3px solid var(--purple-ink); padding: 14px;">
                        <div style="color:var(--ink-light); font-size: 0.8rem; margin-bottom: 4px;">Zero Crossings</div>
                        <div style="color: #a855f7; font-size: 1.3rem; font-weight: bold;" id="m_statZeros">—</div>
                    </div>
                    <div style="background: var(--parchment-dark); border: 1px solid var(--panel-border); border-left: 3px solid var(--orange-ink); padding: 14px;">
                        <div style="color:var(--ink-light); font-size: 0.8rem; margin-bottom: 4px;">Square-Free</div>
                        <div style="color: #f59e0b; font-size: 1.3rem; font-weight: bold;" id="m_statSquareFree">—</div>
                    </div>
                    <div style="background: var(--parchment-dark); border: 1px solid var(--panel-border); border-left: 3px solid var(--teal-ink); padding: 14px;">
                        <div style="color:var(--ink-light); font-size: 0.8rem; margin-bottom: 4px;">Within ±√n</div>
                        <div style="color: var(--teal-ink); font-size: 1.3rem; font-weight: bold;" id="m_statBoundary">—</div>
                    </div>
                </div>

                <!-- Controls -->
                <div style="display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-end; margin-bottom: 16px; padding: 16px; background: var(--parchment-dark); border-radius: 8px; border: 1px solid var(--panel-border);">
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <label style="color:var(--ink-light); font-size: 0.85rem;">Range: n = 1 to <span style="color: var(--gold);" id="m_rangeValue">2000</span></label>
                        <input type="range" id="m_rangeSlider" min="100" max="10000" value="2000" step="100"
                               oninput="m_onRangeSlider(this.value)"
                               style="width: 220px; accent-color: var(--teal-ink);">
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <label style="color:var(--ink-light); font-size: 0.85rem;">Set n manually</label>
                        <input type="number" id="m_manualInput" min="100" max="100000" value="2000" step="1"
                               oninput="m_onManualInput(this.value)"
                               style="padding: 8px 12px; background: var(--parchment-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--ink-mid); font-size: 0.9rem; width: 110px;">
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <label style="color:var(--ink-light); font-size: 0.85rem;">Animation</label>
                        <div style="display: flex; gap: 8px;">
                            <button id="m_playBtn" onclick="m_startAnimation()"
                                    style="padding: 8px 16px; background: linear-gradient(135deg,#22c55e,#16a34a); border: none; border-radius: 4px; color: #fff; font-weight: 600; cursor: pointer; font-size: 0.85rem;">▶ Play</button>
                            <button id="m_pauseBtn" onclick="m_stopAnimation()"
                                    style="display:none; padding: 8px 16px; background: linear-gradient(135deg,#f59e0b,#d97706); border: none; border-radius: 4px; color: #fff; font-weight: 600; cursor: pointer; font-size: 0.85rem;">⏸ Pause</button>
                            <button onclick="m_startBackwardAnimation()"
                                    style="padding: 8px 16px; background: linear-gradient(135deg,#6366f1,#4f46e5); border: none; border-radius: 4px; color: #fff; font-weight: 600; cursor: pointer; font-size: 0.85rem;">◀ Rewind</button>
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 6px;">
                        <label style="color:var(--ink-light); font-size: 0.85rem;">Speed: <span style="color: var(--gold);" id="m_speedValue">50</span>ms</label>
                        <input type="range" id="m_speedSlider" min="10" max="200" value="50" step="10"
                               oninput="m_onSpeedSlider(this.value)"
                               style="width: 140px; accent-color: var(--teal-ink);">
                    </div>
                    <div style="display: flex; gap: 16px; align-items: center;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #ccc; font-size: 0.85rem;">
                            <input type="checkbox" id="m_showBounds" checked onchange="m_drawGraph()" style="accent-color: var(--teal-ink);"> ±√n boundary
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #ccc; font-size: 0.85rem;">
                            <input type="checkbox" id="m_showZeros" checked onchange="m_drawGraph()" style="accent-color: var(--teal-ink);"> Zero crossings
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #ccc; font-size: 0.85rem;">
                            <input type="checkbox" id="m_loopAnim" style="accent-color: var(--teal-ink);"> Loop
                        </label>
                    </div>
                </div>

                <!-- Canvas -->
                <div style="position: relative; background: var(--canvas-bg); border-radius: 8px; padding: 16px; margin-bottom: 20px; border: 1px solid var(--panel-border);">
                    <canvas id="m_graphCanvas" width="1400" height="500" style="display:block; width:100%; height:auto; background:var(--canvas-bg); border-radius:4px; cursor:crosshair;"></canvas>
                    <div id="m_tooltip" style="position:absolute; background:rgba(0,0,0,0.92); color:var(--ink-mid); padding:10px 14px; border-radius:6px; font-size:0.85rem; pointer-events:none; opacity:0; transition:opacity 0.15s; z-index:1000; border:1px solid #3a3a5a; max-width:260px;"></div>
                </div>
                <div style="text-align:center; margin:-12px 0 20px;">
                    <button onclick="mertensExportPNG()" style="font-family:'Cinzel',serif;font-size:0.62rem;letter-spacing:0.1em;text-transform:uppercase;background:#1e1008;color:#e0bc60;border:1px solid #c49b38;padding:6px 18px;cursor:pointer;">&#8615; Export PNG</button>
                </div>

                <!-- Data Table -->
                <div style="background: var(--parchment-dark); border-radius: 8px; padding: 16px; border: 1px solid var(--panel-border);">
                    <h4 style="color: var(--gold); margin: 0 0 12px 0;">Data Table</h4>
                    <div style="display: flex; gap: 12px; margin-bottom: 12px; flex-wrap: wrap; align-items: center;">
                        <input type="text" id="m_searchInput" placeholder="Search by n value…" oninput="m_populateTable()"
                               style="padding: 8px 12px; background: var(--parchment-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--ink-mid); font-size: 0.85rem; width: 180px;">
                        <select id="m_filterType" onchange="m_populateTable()"
                                style="padding: 8px 12px; background: var(--parchment-dark); border: 1px solid var(--border); border-radius: 4px; color: var(--ink-mid); font-size: 0.85rem;">
                            <option value="all">Show All</option>
                            <option value="zeros">Zero Crossings Only</option>
                            <option value="positive">Positive Only</option>
                            <option value="negative">Negative Only</option>
                            <option value="square-free">Square-Free Only</option>
                        </select>
                        <button onclick="m_exportCSV()"
                                style="padding: 8px 16px; background: #2a2a4a; border: none; border-radius: 4px; color: var(--ink-mid); cursor: pointer; font-size: 0.85rem;">Export CSV</button>
                    </div>
                    <div style="max-height: 400px; overflow: auto; border-radius: 6px;">
                        <table style="width:100%; border-collapse:collapse; background:var(--canvas-bg); font-size:0.82rem;">
                            <thead style="position:sticky; top:0; background:var(--parchment-dark); z-index:5;">
                                <tr>
                                    <th onclick="m_sortTable('n')" style="padding:10px 12px; text-align:left; color:var(--gold); cursor:pointer; border-bottom:1px solid #2a2a4a;">n</th>
                                    <th onclick="m_sortTable('mu')" style="padding:10px 12px; text-align:left; color:var(--gold); cursor:pointer; border-bottom:1px solid #2a2a4a;">μ(n)</th>
                                    <th onclick="m_sortTable('M')" style="padding:10px 12px; text-align:left; color:var(--gold); cursor:pointer; border-bottom:1px solid #2a2a4a;">M(n)</th>
                                    <th onclick="m_sortTable('delta')" style="padding:10px 12px; text-align:left; color:var(--gold); cursor:pointer; border-bottom:1px solid #2a2a4a;">ΔM</th>
                                    <th onclick="m_sortTable('sqFree')" style="padding:10px 12px; text-align:left; color:var(--gold); cursor:pointer; border-bottom:1px solid #2a2a4a;">Square-Free</th>
                                    <th onclick="m_sortTable('factors')" style="padding:10px 12px; text-align:left; color:var(--gold); cursor:pointer; border-bottom:1px solid #2a2a4a;">Prime Factors</th>
                                    <th onclick="m_sortTable('distance')" style="padding:10px 12px; text-align:left; color:var(--gold); cursor:pointer; border-bottom:1px solid #2a2a4a;">|M(n)|</th>
                                    <th onclick="m_sortTable('within')" style="padding:10px 12px; text-align:left; color:var(--gold); cursor:pointer; border-bottom:1px solid #2a2a4a;">Within ±√n</th>
                                    <th style="padding:10px 12px; text-align:left; color:var(--gold); border-bottom:1px solid #2a2a4a;">Status</th>
                                </tr>
                            </thead>
                            <tbody id="m_tableBody"></tbody>
                            <tfoot style="position:sticky; bottom:0; background:var(--parchment-dark);">
                                <tr>
                                    <td colspan="2" style="padding:10px 12px; color:#aaa; font-size:0.8rem;">Σμ(n) = <span id="m_sumMu" style="color:var(--gold);">—</span></td>
                                    <td style="padding:10px 12px; color:#aaa; font-size:0.8rem;">Final: <span id="m_finalM" style="color:var(--gold);">—</span></td>
                                    <td colspan="2" style="padding:10px 12px; color:#aaa; font-size:0.8rem;">Sq-Free: <span id="m_sqFreeCount" style="color:var(--gold);">—</span></td>
                                    <td style="padding:10px 12px; color:#aaa; font-size:0.8rem;">Avg |M|: <span id="m_avgDist" style="color:var(--gold);">—</span></td>
                                    <td colspan="2" style="padding:10px 12px; color:#aaa; font-size:0.8rem;">Within bound: <span id="m_withinCount" style="color:var(--gold);">—</span></td>
                                    <td style="padding:10px 12px; color:#aaa; font-size:0.8rem;">Zeros: <span id="m_zeroCount" style="color:var(--gold);">—</span></td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- CREDITS SECTION -->
    <div class="controls-container" style="margin-top: 40px;">
        <div class="dropdown-section" style="border: 2px solid #ffd700;">
            <div class="dropdown-header" onclick="toggleSection(this)">
                <h3 style="color: var(--gold);">Credits &amp; Attribution</h3>
                <span class="dropdown-icon" style="color: var(--gold);">v</span>
            </div>
            <div class="dropdown-content">
                <div style="display: grid; gap: 20px;">

                    <!-- Author -->
                    <div style="background: rgba(139,99,16,0.05); padding: 20px; border-radius: 8px; border-left: 4px solid var(--gold);">
                        <h4 style="color: var(--gold); margin: 0 0 12px 0; font-size: 1.1rem;">Author</h4>
                        <p style="margin: 0 0 14px 0; color: var(--ink-mid); line-height: 2.2;">
                            <strong>Wessen Getachew</strong><br>
                            Addis Ababa, Ethiopia<br>
                            Twitter/X: <a href="https://twitter.com/7dview" target="_blank" style="color: var(--teal-ink); text-decoration: none;">@7dview</a>
                        </p>
                        <h4 style="color: var(--gold); margin: 0 0 10px 0; font-size: 0.95rem; letter-spacing: 0.08em; text-transform: uppercase;">Mathematical Tools Suite</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">

                            <a href="https://wessengetachew.github.io/G/" target="_blank" style="color: var(--teal-ink); text-decoration: none; background: rgba(78,205,196,0.06); padding: 8px 12px; border-radius: 6px; border: 1px solid rgba(78,205,196,0.2); font-size: 0.85rem; display: block;">
                                <span style="color: var(--gold); font-size: 0.7rem; display: block; margin-bottom: 2px; text-transform: uppercase; letter-spacing: 0.06em;">Interactive Tool</span>
                                wessengetachew.github.io/G
                            </a>
                            <a href="https://wessengetachew.github.io/Primes/" target="_blank" style="color: var(--teal-ink); text-decoration: none; background: rgba(78,205,196,0.06); padding: 8px 12px; border-radius: 6px; border: 1px solid rgba(78,205,196,0.2); font-size: 0.85rem; display: block;">
                                <span style="color: var(--gold); font-size: 0.7rem; display: block; margin-bottom: 2px; text-transform: uppercase; letter-spacing: 0.06em;">Modular Sieve</span>
                                wessengetachew.github.io/Primes
                            </a>
                            <a href="https://wessengetachew.github.io/Composite/" target="_blank" style="color: var(--teal-ink); text-decoration: none; background: rgba(78,205,196,0.06); padding: 8px 12px; border-radius: 6px; border: 1px solid rgba(78,205,196,0.2); font-size: 0.85rem; display: block;">
                                <span style="color: var(--gold); font-size: 0.7rem; display: block; margin-bottom: 2px; text-transform: uppercase; letter-spacing: 0.06em;">Composite Explorer</span>
                                wessengetachew.github.io/Composite
                            </a>
                            <a href="https://wessengetachew.github.io/Transform/" target="_blank" style="color: var(--teal-ink); text-decoration: none; background: rgba(78,205,196,0.06); padding: 8px 12px; border-radius: 6px; border: 1px solid rgba(78,205,196,0.2); font-size: 0.85rem; display: block;">
                                <span style="color: var(--gold); font-size: 0.7rem; display: block; margin-bottom: 2px; text-transform: uppercase; letter-spacing: 0.06em;">Farey / Transform Explorer</span>
                                wessengetachew.github.io/Transform
                            </a>
                        </div>
                    </div>

                    <!-- Mathematical Context -->
                    <div style="background: rgba(74,42,106,0.04); padding: 20px; border-radius: 8px; border-left: 4px solid var(--purple-ink);">
                        <h4 style="color: var(--purple-ink); margin: 0 0 12px 0; font-size: 1.1rem;">Mathematical Context</h4>
                        <p style="margin: 0 0 12px 0; color: #ccc; line-height: 1.8;">
                            This work builds on Euler's 1737 product formula for ζ(2) = π²/6 (Basel problem, first solved by Euler in 1734).
                            The gap-class factorization ζ(2) = ∏<sub>g</sub> P<sub>g</sub> follows directly from absolute convergence of the Euler product —
                            it is a reorganization of a known result, not a new theorem. Its value is computational and structural.
                        </p>
                        <p style="margin: 0 0 12px 0; color: #ccc; line-height: 1.8;">
                            Hardy-Littlewood Conjecture B (1923) predicts asymptotic counts for prime pairs with fixed gap g via the singular
                            series S(g). The observation that S(g)/S(h) predicts the asymptotic ratio of log-weights w<sub>g</sub>/w<sub>h</sub>
                            in this decomposition follows from Conjecture B and is directly verifiable at finite N.
                            This consequence does not appear to have been stated explicitly in the literature.
                        </p>
                        <p style="margin: 0; color: #ccc; line-height: 1.8;">
                            The question of whether a finite twin prime set would be analytically incompatible with ζ(s)'s structure
                            via this product identity is raised as an open structural question — not a proof of the Twin Prime Conjecture.
                        </p>
                    </div>

                    <!-- What Is Known vs What Is New -->
                    <div style="background: rgba(255, 100, 100, 0.04); padding: 20px; border-radius: 8px; border-left: 4px solid var(--red-ink);">
                        <h4 style="color: var(--red-ink); margin: 0 0 12px 0; font-size: 1.1rem;">What Is Established vs. What Is New Here</h4>
                        <p style="margin: 0 0 10px 0; color: #aaa; font-size: 0.9rem; line-height: 1.7;">
                            <strong style="color:var(--ink-mid);">Established (prior literature):</strong> Euler product for ζ(s) (Euler, 1737); Basel problem solution π²/6
                            (Euler, 1734); Hardy-Littlewood Conjecture B and singular series (1923); twin prime constant C<sub>2</sub> ≈ 0.66016;
                            Cramér's model for prime gaps (1936).
                        </p>
                        <p style="margin: 0 0 10px 0; color: #aaa; font-size: 0.9rem; line-height: 1.7;">
                            <strong style="color:var(--ink-mid);">This work:</strong> The specific partition of the Euler product by forward gap class and its numerical analysis;
                            the observation that S(g)/S(h) governs log-weight ratios conditional on Conjecture B;
                            the structural question about analytic obstructions to a finite twin prime set via the product identity;
                            computational data at N up to 300M (browser) with verified estimates to 400M.
                        </p>
                        <p style="margin: 0; color: #666; font-size: 0.85rem; line-height: 1.6;">
                            The author makes no claim that these observations constitute a proof of any unsolved conjecture.
                            They are presented as computational evidence and structural observations for further investigation.
                        </p>
                    </div>

                    <!-- References -->
                    <div style="background: var(--parchment-dark); padding: 20px; border-radius: 8px; border: 1px solid var(--panel-border);">
                        <h4 style="color:var(--ink-light); margin: 0 0 14px 0; font-size: 1.1rem;">Mathematical References</h4>
                        <div style="color:var(--ink-light); font-size: 0.88rem; line-height: 2.2; font-family: serif;">
                            [1] L. Euler, <em>Variae observationes circa series infinitas</em>, Comm. Acad. Sci. Petrop. 9 (1737), 160–188.<br>
                            [2] G. H. Hardy &amp; J. E. Littlewood, <em>Some problems of 'Partitio Numerorum' III</em>, Acta Math. 44 (1923), 1–70.<br>
                            [3] H. Cramér, <em>On the order of magnitude of the difference between consecutive prime numbers</em>, Acta Arith. 2 (1936), 23–46.<br>
                            [4] A. Granville, <em>Harald Cramér and the distribution of prime numbers</em>, Scand. Actuarial J. 1 (1995), 12–28.<br>
                            [5] A. E. Ingham, <em>The Distribution of Prime Numbers</em>, Cambridge Tracts in Mathematics, Cambridge University Press (1932).<br>
                            [6] W. Getachew, <em>Gap-Class Decomposition of ζ(2) = π²/6</em>, 2025–2026.
                        </div>
                        <h4 style="color:var(--ink-light); margin: 18px 0 10px 0; font-size: 1.0rem;">Software &amp; Technology</h4>
                        <div style="color:var(--ink-light); font-size: 0.85rem; line-height: 2.0; font-family: serif;">
                            Segmented prime sieve implementation adapted from classical sieve of Eratosthenes; all computation in-browser (no server).<br>
                            Chart rendering: HTML5 Canvas API.<br>
                            Farey diagram &amp; interactive visualization: original implementation, W. Getachew (2025–2026).<br>
                            Mertens function / Möbius sieve: original implementation, W. Getachew (2026).<br>
                            Hardy-Littlewood singular series computation: original implementation, W. Getachew (2026).<br>
                            Development assistance: Claude (Anthropic), 2025–2026 — code generation, debugging, UI refinement.
                        </div>
                    </div>

                    <!-- License -->
                    <div style="background: var(--parchment-dark); padding: 16px; border-radius: 8px; border: 1px solid var(--panel-border);">
                        <h4 style="color: #555; margin: 0 0 10px 0; font-size: 0.95rem;">License &amp; Usage</h4>
                        <p style="margin: 0; color: #555; font-size: 0.85rem; line-height: 1.6;">
                            Provided for educational and research purposes. Use of this tool or citation of its findings in academic work should attribute <strong style="color:#777;">Wessen Getachew</strong> and reference the gap-class decomposition framework.
                        </p>
                    </div>

                    <!-- Build Info -->
                    <div style="text-align: center; padding: 12px; color: #333; font-size: 0.82rem; border-top: 1px solid #1a1a2a; font-family: monospace; letter-spacing: 0.04em;">
                        Gap-Class Decomposition Explorer v2.1 &nbsp;·&nbsp; February 2026 &nbsp;·&nbsp; MSC 2020: 11M06, 11N05, 11A41
                    </div>

                </div>
            </div>
        </div>
    </div>
    
    <canvas id="compositeCanvas" style="display: none;"></canvas>
    
    <!-- Modal Popup for Gap Details -->
    <div class="modal-overlay" id="gapModal" onclick="closeGapModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Gap Details</h2>
                <div style="display: flex; gap: 12px;">
                    <button class="modal-screenshot" onclick="screenshotModalPart1()" style="font-size: 0.85rem; padding: 8px 12px;">Part 1 (4K)</button>
                    <button class="modal-screenshot" onclick="screenshotModalPart2()" style="font-size: 0.85rem; padding: 8px 12px;">Part 2 (4K)</button>
                    <button class="modal-close" onclick="closeGapModal()">Close</button>
                </div>
            </div>
            <div id="modalBody"></div>
        </div>
    </div>
    
    </div>
    <!-- END TAB: Main -->

    <script>
        // Collapsible section toggle function
        function toggleSection(header) {
            const section = header.parentElement;
            section.classList.toggle('active');
        }
        // Dropdown toggle functionality
        function toggleDropdown(sectionId) {
            const section = document.getElementById(sectionId);
            section.classList.toggle('active');
        }
        
// Gap Decomposition Analyzer v2.1 - Fixed xPos scope issue
        // Global variables
        let analysisResults = null;
        window.analysisResults = null; // kept in sync below
        let animationId = null;
        let isAnimating = false;

        // Gap filter functions
        function toggleGapFilter() {
            const enabled = document.getElementById('enableGapFilter').checked;
            const controls = document.getElementById('gapFilterControls');
            controls.style.display = enabled ? 'block' : 'none';
            
            if (enabled) {
                updateGapFilterDisplay();
            } else {
                document.getElementById('gapFilterStatus').textContent = 'Showing all gaps';
            }
            
            if (analysisResults) {
                renderAllCharts();
            }
        }

        function setGapRange(min, max) {
            document.getElementById('minGapFilter').value = min;
            document.getElementById('maxGapFilter').value = max;
            document.getElementById('enableGapFilter').checked = true;
            toggleGapFilter();
            if (analysisResults) {
                renderAllCharts();
            }
        }

        function setGapRangeToLast(count) {
            if (!analysisResults || !analysisResults.evenGaps) {
                alert('Please run analysis first');
                return;
            }
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = canvasText();
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const lastGaps = gaps.slice(-count);
            const min = Math.min(...lastGaps);
            const max = Math.max(...lastGaps);
            
            setGapRange(min, max);
        }

        function resetGapFilter() {
            document.getElementById('minGapFilter').value = 2;
            document.getElementById('maxGapFilter').value = 50;
            document.getElementById('enableGapFilter').checked = false;
            toggleGapFilter();
        }

        function updateGapFilterDisplay() {
            const min = parseInt(document.getElementById('minGapFilter').value);
            const max = parseInt(document.getElementById('maxGapFilter').value);
            document.getElementById('gapFilterStatus').textContent = `Showing gaps ${min} to ${max}`;
            
            if (analysisResults) {
                renderAllCharts();
            }
        }

        function getFilteredGaps() {
            if (!analysisResults) return [];
            
            const filterEnabled = document.getElementById('enableGapFilter').checked;
            if (!filterEnabled) {
                return analysisResults.evenGaps;
            }
            
            const min = parseInt(document.getElementById('minGapFilter').value);
            const max = parseInt(document.getElementById('maxGapFilter').value);
            
            return analysisResults.evenGaps.filter(g => g >= min && g <= max);
        }

        function getFilteredProgressiveProducts() {
            if (!analysisResults) return [];
            
            const filteredGaps = getFilteredGaps();
            return analysisResults.progressiveProducts.filter(p => filteredGaps.includes(p.gap));
        }

        function getFilteredGapProducts() {
            if (!analysisResults) return {};
            
            const filteredGaps = getFilteredGaps();
            const filtered = {};
            filteredGaps.forEach(gap => {
                if (analysisResults.gapProducts[gap]) {
                    filtered[gap] = analysisResults.gapProducts[gap];
                }
            });
            return filtered;
        }
        
        // Segmented Sieve of Eratosthenes
        // NOTE: This solves the SIEVING memory problem (constant ~50 MB during generation).
        // The STORAGE problem remains — JavaScript must still hold all primes found.
        // Browser limit: ~300M (~16M primes, ~340 MB). Above that, use the Python script.
        function sievePrimes(max, progressCallback = null) {
            // If custom prime list is loaded, use it instead of computing
            if (customPrimeList && customPrimeList.length > 0) {
                // Filter to primes <= max
                return customPrimeList.filter(p => p <= max);
            }
            
            // For small ranges (< 10M), use simple sieve for speed
            if (max < 10000000) {
                return simpleSieve(max, progressCallback);
            }
            
            // For larger ranges, use segmented sieve (reduces sieving memory only)
            return segmentedSieve(max, progressCallback);
        }
        
        // Simple sieve for smaller ranges
        function simpleSieve(max, progressCallback = null) {
            const sieve = new Array(max + 1).fill(true);
            sieve[0] = sieve[1] = false;
            
            for (let i = 2; i * i <= max; i++) {
                if (sieve[i]) {
                    for (let j = i * i; j <= max; j += i) {
                        sieve[j] = false;
                    }
                }
            }
            
            const primes = [];
            for (let i = 2; i <= max; i++) {
                if (sieve[i]) primes.push(i);
            }
            
            if (progressCallback) {
                progressCallback(100, 100, primes.length);
            }
            
            return primes;
        }
        
        // Segmented sieve for memory-efficient large range processing
        function segmentedSieve(max, progressCallback = null) {
            // Generate small primes up to sqrt(max)
            const sqrtMax = Math.floor(Math.sqrt(max)) + 1;
            const smallPrimes = simpleSieve(sqrtMax);
            
            // Process in segments
            const segmentSize = 1000000; // 1 million per segment
            const primes = [];
            
            let currentSegmentStart = 0;
            let currentSegmentEnd = Math.min(segmentSize, max);
            
            while (currentSegmentStart <= max) {
                // Create segment
                const segmentLength = currentSegmentEnd - currentSegmentStart + 1;
                const segment = new Array(segmentLength).fill(true);
                
                // Mark composites in this segment using small primes
                for (let i = 0; i < smallPrimes.length; i++) {
                    const p = smallPrimes[i];
                    
                    // Find first multiple of p in segment
                    let start = Math.max(p * p, Math.ceil(currentSegmentStart / p) * p);
                    
                    // Mark multiples as composite
                    for (let j = start; j <= currentSegmentEnd; j += p) {
                        segment[j - currentSegmentStart] = false;
                    }
                }
                
                // Collect primes from this segment
                for (let i = 0; i < segmentLength; i++) {
                    const num = currentSegmentStart + i;
                    if (num >= 2 && segment[i]) {
                        primes.push(num);
                    }
                }
                
                // Report progress
                if (progressCallback) {
                    const percentComplete = Math.min(100, (currentSegmentEnd / max) * 100);
                    progressCallback(currentSegmentEnd, max, primes.length);
                }
                
                // Move to next segment
                currentSegmentStart = currentSegmentEnd + 1;
                currentSegmentEnd = Math.min(currentSegmentStart + segmentSize - 1, max);
                
                // Break if we've processed everything
                if (currentSegmentStart > max) break;
            }
            
            return primes;
        }
        
        // Core analysis function
        function computeGapDecomposition(maxPrime, gapRangeFilter = null, progressCallback = null) {
            const primes = sievePrimes(maxPrime, progressCallback);
            const targetZeta2 = Math.PI * Math.PI / 6;
            
            // Calculate gaps and classify primes
            const gapFamilies = {}; // Will be populated by loop - gap 1 gets prime 2 from 3-2=1
            const gaps = [];
            
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i + 1] - primes[i];
                gaps.push(gap);
                
                if (!gapFamilies[gap]) {
                    gapFamilies[gap] = [];
                }
                gapFamilies[gap].push(primes[i]);
            }
            
            // Calculate products for each gap family
            const gapProducts = {};
            
            // Find all unique gaps that actually exist in the data
            const uniqueGaps = new Set(gaps);
            let evenGaps = Array.from(uniqueGaps).sort((a, b) => a - b);
            
            // Apply gap range filter if specified
            if (gapRangeFilter && gapRangeFilter.mode === 'manual') {
                const minGap = gapRangeFilter.min;
                const maxGap = gapRangeFilter.max;
                evenGaps = evenGaps.filter(gap => gap >= minGap && gap <= maxGap);
            }
            
            evenGaps.forEach(gap => {
                if (gapFamilies[gap] && gapFamilies[gap].length > 0) {
                    let product = 1;
                    let logProduct = 0;
                    
                    gapFamilies[gap].forEach(p => {
                        const factor = (p * p) / (p * p - 1);
                        product *= factor;
                        logProduct += Math.log(factor);
                    });
                    
                    gapProducts[gap] = {
                        product: product,
                        logProduct: logProduct,
                        count: gapFamilies[gap].length,
                        primes: gapFamilies[gap] // Store ALL primes
                    };
                }
            });
            
            // Calculate progressive convergence
            const progressiveProducts = [];
            let cumulative = 1;
            let cumulativeLog = 0;
            
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    cumulative *= gapProducts[gap].product;
                    cumulativeLog += gapProducts[gap].logProduct;
                    
                    progressiveProducts.push({
                        gap: gap,
                        value: cumulative,
                        logValue: cumulativeLog,
                        error: Math.abs(cumulative - targetZeta2),
                        relativeError: Math.abs(cumulative - targetZeta2) / targetZeta2
                    });
                }
            });
            
            // Include the last prime's contribution (it has no gap after it, but still contributes to ζ(2))
            if (primes.length > 0) {
                const lastPrime = primes[primes.length - 1];
                const lastFactor = (lastPrime * lastPrime) / (lastPrime * lastPrime - 1);
                cumulative *= lastFactor;
                cumulativeLog += Math.log(lastFactor);
            }
            
            // Calculate total primes actually included in analysis (those with gaps in filtered range)
            const totalPrimesInAnalysis = evenGaps.reduce((sum, gap) => {
                return sum + (gapProducts[gap]?.count || 0);
            }, 0);
            
            // Calculate percentage contributions
            const percentageContributions = {};
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    const contribution = Math.log(gapProducts[gap].product) / Math.log(targetZeta2);
                    percentageContributions[gap] = contribution * 100;
                }
            });
            
            return {
                primes: primes,
                totalPrimes: totalPrimesInAnalysis,  // Only count primes with gaps in filtered range
                allPrimesFound: primes.length,        // Total primes found in range
                maxPrime: maxPrime,
                maxGapFound: evenGaps.length > 0 ? Math.max(...evenGaps) : 0,  // Largest gap in filtered range
                targetZeta2: targetZeta2,
                gapFamilies: gapFamilies,
                gapProducts: gapProducts,
                evenGaps: evenGaps,
                progressiveProducts: progressiveProducts,
                percentageContributions: percentageContributions,
                finalProduct: cumulative,
                finalError: Math.abs(cumulative - targetZeta2),
                finalRelativeError: Math.abs(cumulative - targetZeta2) / targetZeta2,
                s: 2  // This function always uses s=2
            };
        }
        
        function computeGapDecompositionWithS(maxPrime, s, gapRangeFilter = null, progressCallback = null) {
            const primes = sievePrimes(maxPrime, progressCallback);
            
            // Get target value
            const known = getKnownZetaValue(s);
            const targetZeta = known ? known.value : computeApproximateZeta(s);
            
            // Calculate gaps and classify primes
            const gapFamilies = {}; // Will be populated by loop - gap 1 gets prime 2 from 3-2=1
            const gaps = [];
            
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i + 1] - primes[i];
                gaps.push(gap);
                
                if (!gapFamilies[gap]) {
                    gapFamilies[gap] = [];
                }
                gapFamilies[gap].push(primes[i]);
            }
            
            // Calculate products for each gap family using p^s/(p^s-1)
            const gapProducts = {};
            
            // Find all unique gaps that actually exist in the data
            const uniqueGaps = new Set(gaps);
            let evenGaps = Array.from(uniqueGaps).sort((a, b) => a - b);
            
            // Apply gap range filter if specified
            if (gapRangeFilter && gapRangeFilter.mode === 'manual') {
                const minGap = gapRangeFilter.min;
                const maxGap = gapRangeFilter.max;
                evenGaps = evenGaps.filter(gap => gap >= minGap && gap <= maxGap);
            }
            
            evenGaps.forEach(gap => {
                if (gapFamilies[gap] && gapFamilies[gap].length > 0) {
                    let product = 1;
                    let logProduct = 0;
                    
                    gapFamilies[gap].forEach(p => {
                        const ps = Math.pow(p, s);
                        const factor = ps / (ps - 1);
                        product *= factor;
                        logProduct += Math.log(factor);
                    });
                    
                    gapProducts[gap] = {
                        product: product,
                        logProduct: logProduct,
                        count: gapFamilies[gap].length,
                        primes: gapFamilies[gap] // Store ALL primes
                    };
                }
            });
            
            // Add last prime contribution
            const lastPrime = primes[primes.length - 1];
            const lastPs = Math.pow(lastPrime, s);
            const lastFactor = lastPs / (lastPs - 1);
            
            // Calculate progressive convergence
            const progressiveProducts = [];
            let cumulative = 1;
            let cumulativeLog = 0;
            
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    cumulative *= gapProducts[gap].product;
                    cumulativeLog += gapProducts[gap].logProduct;
                    
                    progressiveProducts.push({
                        gap: gap,
                        value: cumulative,
                        logValue: cumulativeLog,
                        error: Math.abs(cumulative - targetZeta),
                        relativeError: Math.abs(cumulative - targetZeta) / targetZeta
                    });
                }
            });
            
            // Multiply by last prime
            cumulative *= lastFactor;
            const finalProduct = cumulative;
            const finalError = Math.abs(finalProduct - targetZeta);
            
            // Calculate percentage contributions
            const totalLogProduct = cumulativeLog + Math.log(lastFactor);
            const percentageContributions = {};
            evenGaps.forEach(gap => {
                if (gapProducts[gap]) {
                    const contribution = gapProducts[gap].logProduct / totalLogProduct;
                    percentageContributions[gap] = contribution * 100;
                }
            });
            
            return {
                s: s,
                primes: primes,
                totalPrimes: primes.length,
                allPrimesFound: primes.length,  // Total primes found - same as totalPrimes in this function
                maxPrime: maxPrime,
                targetZeta: targetZeta,
                targetZeta2: targetZeta, // Keep for compatibility
                gapFamilies: gapFamilies,
                evenGaps: evenGaps,
                gapProducts: gapProducts,
                progressiveProducts: progressiveProducts,
                percentageContributions: percentageContributions,
                finalProduct: finalProduct,
                finalError: finalError,
                finalRelativeError: finalError / targetZeta
            };
        }
        // Global variable to store uploaded/fetched primes
        let customPrimeList = null;
        
        // Handle file upload
        function handlePrimeFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.style.display = 'block';
            statusDiv.querySelector('span').textContent = 'Loading file...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    
                    // Parse primes from file (handle CSV or one-per-line)
                    let primes = [];
                    if (content.includes(',')) {
                        // CSV format
                        primes = content.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n) && n > 0);
                    } else {
                        // One per line
                        primes = content.split(/\r?\n/).map(s => parseInt(s.trim())).filter(n => !isNaN(n) && n > 0);
                    }
                    
                    // Sort and deduplicate
                    primes = Array.from(new Set(primes)).sort((a, b) => a - b);
                    
                    if (primes.length === 0) {
                        statusDiv.querySelector('span').textContent = 'Error: No valid primes found in file';
                        statusDiv.style.background = 'rgba(255, 100, 100, 0.1)';
                        return;
                    }
                    
                    customPrimeList = primes;
                    statusDiv.querySelector('span').textContent = `✓ Loaded ${primes.length.toLocaleString()} primes (max: ${primes[primes.length-1].toLocaleString()})`;
                    statusDiv.style.background = 'rgba(100, 255, 100, 0.1)';
                    
                    // Update max prime display
                    document.getElementById('maxPrime').value = primes[primes.length-1];
                    document.getElementById('maxPrimeDisplay').textContent = primes[primes.length-1].toLocaleString();
                    
                } catch (error) {
                    statusDiv.querySelector('span').textContent = `Error: ${error.message}`;
                    statusDiv.style.background = 'rgba(255, 100, 100, 0.1)';
                }
            };
            reader.readAsText(file);
        }
        
        // Fetch primes from OEIS
        async function fetchFromOEIS() {
            const count = parseInt(document.getElementById('oeisCount').value);
            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.style.display = 'block';
            statusDiv.querySelector('span').textContent = `Fetching ${count.toLocaleString()} primes from OEIS...`;
            
            try {
                // OEIS API endpoint for A000040 (prime numbers)
                // Note: Network access is disabled in this environment
                const url = `https://oeis.org/A000040/b000040.txt`;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error('Network access is disabled. Please download the file manually from OEIS and upload it instead.');
                
                const text = await response.text();
                
                // Parse OEIS b-file format: "n prime_n"
                const lines = text.split('\n');
                const primes = [];
                
                for (const line of lines) {
                    if (line.startsWith('#') || line.trim() === '') continue;
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 2) {
                        const prime = parseInt(parts[1]);
                        if (!isNaN(prime)) {
                            primes.push(prime);
                            if (primes.length >= count) break;
                        }
                    }
                }
                
                if (primes.length === 0) {
                    throw new Error('No primes found in OEIS response');
                }
                
                customPrimeList = primes;
                statusDiv.querySelector('span').textContent = `✓ Fetched ${primes.length.toLocaleString()} primes from OEIS (max: ${primes[primes.length-1].toLocaleString()})`;
                statusDiv.style.background = 'rgba(100, 255, 100, 0.1)';
                
                // Update max prime display
                document.getElementById('maxPrime').value = primes[primes.length-1];
                document.getElementById('maxPrimeDisplay').textContent = primes[primes.length-1].toLocaleString();
                
            } catch (error) {
                statusDiv.querySelector('span').textContent = `Network access disabled. Please: (1) Visit https://oeis.org/A000040/b000040.txt, (2) Download the file, (3) Upload it using the file input above.`;
                statusDiv.style.background = 'rgba(255, 215, 0, 0.2)';
                statusDiv.style.borderLeft = '4px solid #ffd700';
                console.error('OEIS fetch error:', error);
            }
        }
        
        // Clear custom prime list
        function clearCustomPrimes() {
            customPrimeList = null;
            document.getElementById('uploadStatus').style.display = 'none';
            document.getElementById('primeFileUpload').value = '';
            document.getElementById('maxPrime').value = 10000000;
            document.getElementById('maxPrimeDisplay').textContent = '10,000,000';
        }
        
        // Update displays
        function updateDisplays() {
            document.getElementById('maxPrimeDisplay').textContent = 
                parseInt(document.getElementById('maxPrime').value).toLocaleString();
            document.getElementById('animStartDisplay').textContent = 
                parseInt(document.getElementById('animStart').value).toLocaleString();
            document.getElementById('animEndDisplay').textContent = 
                parseInt(document.getElementById('animEnd').value).toLocaleString();
        }
        
        // Run analysis
        function runAnalysis() {
            const maxPrime = parseInt(document.getElementById('maxPrime').value);
            const s = parseFloat(document.getElementById('zetaS').value);
            const comparisonMode = document.getElementById('enableComparison').checked;
            const gapRangeFilter = getGapRangeFilter();
            
            // Validate gap range if in manual mode
            if (gapRangeFilter.mode === 'manual' && !validateGapRange()) {
                alert('Please fix the gap range errors before running analysis.');
                return;
            }
            
            const statusBar = document.getElementById('statusBar');
            statusBar.style.display = 'block';
            statusBar.className = 'status-bar computing';
            
            if (comparisonMode) {
                statusBar.textContent = `Computing comparison across s = [1.5, 2, 3, 4, 5, 10]...`;
            } else {
                const gapInfo = gapRangeFilter.mode === 'auto' ? 'all gaps' : `gaps ${gapRangeFilter.min}-${gapRangeFilter.max}`;
                statusBar.textContent = `Computing ζ(${s.toFixed(2)}) for primes up to ${maxPrime.toLocaleString()} (${gapInfo})...`;
            }
            
            // Use setTimeout to allow UI update
            setTimeout(() => {
                try {
                    // Progress callback for sieve computation
                    const progressCallback = (current, max, primesFound) => {
                        const percent = Math.min(100, (current / max) * 100).toFixed(1);
                        const statusBar = document.getElementById('statusBar');
                        statusBar.textContent = `Computing primes: ${percent}% (${current.toLocaleString()} / ${max.toLocaleString()}, ${primesFound.toLocaleString()} primes found)`;
                    };
                    
                    if (comparisonMode) {
                        // Compute for multiple s values
                        const compData = computeComparisonData(gapRangeFilter);
                        // Use s=2 as primary result for compatibility
                        analysisResults = compData[2]; window.analysisResults = analysisResults;
                        analysisResults.comparisonData = compData;
                        
                        statusBar.className = 'status-bar complete';
                        statusBar.textContent = `Comparison complete: Computed for s = [1.5, 2, 3, 4, 5, 10]`;
                    } else {
                        // Single s analysis
                        analysisResults = computeGapDecompositionWithS(maxPrime, s, gapRangeFilter, progressCallback); window.analysisResults = analysisResults;
                        
                        const known = getKnownZetaValue(s);
                        const zetaLabel = known ? `ζ(${s}) = ${known.formula}` : `ζ(${s.toFixed(2)})`;
                        const maxGapFound = Math.max(...analysisResults.evenGaps);
                        
                        statusBar.className = 'status-bar complete';
                        const gapInfo = gapRangeFilter.mode === 'auto' ? 'all gaps' : `gaps ${gapRangeFilter.min}-${gapRangeFilter.max}`;
                        statusBar.textContent = `${zetaLabel}: ${((analysisResults.allPrimesFound || analysisResults.totalPrimes) || analysisResults.totalPrimes).toLocaleString()} primes, ${analysisResults.evenGaps.length} gap families (${gapInfo}, max: ${maxGapFound}), error = ${(analysisResults.finalRelativeError * 100).toFixed(8)}%`;
                    }
                    
                    updateStatistics();
                    renderAllCharts();
                    
                    if (comparisonMode) {
                        showComparisonSummary();
                    }
                } catch (error) {
                    statusBar.className = 'status-bar';
                    statusBar.style.color = '#ff6464';
                    statusBar.textContent = `Error: ${error.message}`;
                    console.error(error);
                }
            }, 50);
        }
        
        function showComparisonSummary() {
            if (!analysisResults.comparisonData) return;
            
            console.log("=== Gap Contribution Comparison ===");
            const sValues = [1.5, 2, 3, 4, 5, 10];
            sValues.forEach(s => {
                const data = analysisResults.comparisonData[s];
                const gap1 = data.percentageContributions[1] || 0;
                const gap2 = data.percentageContributions[2] || 0;
                console.log(`s=${s}: Gap 1 = ${gap1.toFixed(1)}%, Gap 2 = ${gap2.toFixed(1)}%`);
            });
        }
        
        // Update statistics panel
        function updateStatistics() {
            if (!analysisResults) return;
            
            const statsPanel = document.getElementById('statsPanel');
            const statsGrid = document.getElementById('statsGrid');
            statsPanel.style.display = 'block';
            
            // Calculate π using the formula: π = √6 × √(∏P_g)
            const productRoot = Math.sqrt(analysisResults.finalProduct);
            const calculatedPi = Math.sqrt(6) * productRoot;
            const actualPi = Math.PI;
            const piError = Math.abs(calculatedPi - actualPi);
            const piRelError = (piError / actualPi) * 100;
            
            // Calculate additional stats
            // Use gapProducts for exact forward-gap counts (avoids overcounting cousins/sexy primes)
            const primes = analysisResults.primes;
            const twinCount   = analysisResults.gapProducts[2]?.count || 0;
            const cousinCount = analysisResults.gapProducts[4]?.count || 0;
            const sexyCount   = analysisResults.gapProducts[6]?.count || 0;
            
            // Find most common gap
            const gapCounts = {};
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i+1] - primes[i];
                gapCounts[gap] = (gapCounts[gap] || 0) + 1;
            }
            const mostCommonGap = Object.entries(gapCounts)
                .sort((a, b) => b[1] - a[1])[0];
            
            const s = analysisResults.s || 2;
            const stats = [
                { label: 'Total Primes', value: ((analysisResults.allPrimesFound || analysisResults.totalPrimes) || analysisResults.totalPrimes || primes.length).toLocaleString() },
                { label: 'Maximum Prime', value: analysisResults.maxPrime.toLocaleString() },
                { label: 'Gap Families', value: analysisResults.evenGaps.length },
                { label: 'Twin Primes', value: twinCount, info: 'Pairs (p, p+2)' },
                { label: 'Cousin Primes', value: cousinCount, info: 'Pairs (p, p+4)' },
                { label: 'Sexy Primes', value: sexyCount, info: 'Pairs (p, p+6)' },
                { label: 'Most Common Gap', value: `${mostCommonGap[0]} (${mostCommonGap[1]}×)` },
                { label: 'Largest Gap', value: Math.max(...analysisResults.evenGaps) },
                { label: `Target ζ(${s})`, value: analysisResults.targetZeta2.toFixed(12) },
                { label: 'Computed Product', value: analysisResults.finalProduct.toFixed(12) },
                { label: 'Absolute Error', value: analysisResults.finalError.toExponential(6) },
                { label: 'Relative Error', value: (analysisResults.finalRelativeError * 100).toFixed(10) + '%' },
                { label: 'Calculated π', value: calculatedPi.toFixed(12), formula: 'π = √6 × √(∏P_g)' },
                { label: 'Actual π', value: actualPi.toFixed(12) },
                { label: 'π Error', value: piError.toExponential(6) },
                { label: 'π Rel. Error', value: piRelError.toFixed(10) + '%' }
            ];
            
            statsGrid.innerHTML = stats.map(stat => `
                <div class="stat-card">
                    <div class="stat-label">${stat.label}${stat.info ? '<br><span style="font-size: 0.65rem; color: #666;">' + stat.info + '</span>' : ''}${stat.formula ? '<br><span style="font-size: 0.65rem; color: #666;">' + stat.formula + '</span>' : ''}</div>
                    <div class="stat-value">${stat.value}</div>
                </div>
            `).join('');
        }
        
        // Render classical sequential view
        function renderClassicalView() {
            if (!analysisResults) return;
            
            const tbody = document.getElementById('classicalTableBody');
            const primes = analysisResults.primes;
            const s = analysisResults.s || 2;
            
            // Gap color mapping - matching the legend
            const gapColors = {
                2: '#e74c3c',  // Twin - red
                4: '#f39c12',  // Cousin - orange
                6: '#9b59b6',  // Sexy - purple
            };
            
            let html = '';
            let cumulative = 1;
            
            // Limit display to first 10,000 primes for performance
            const displayLimit = Math.min(primes.length - 1, 10000);
            
            for (let i = 0; i < displayLimit; i++) {
                const p = primes[i];
                const gap = i < primes.length - 1 ? primes[i + 1] - p : 0;
                const ps = Math.pow(p, s);
                const factor = ps / (ps - 1);
                cumulative *= factor;
                
                const gapColor = gapColors[gap] || '#95a5a6'; // Default gray for other gaps
                const gapLabel = gap === 2 ? 'Twin' : gap === 4 ? 'Cousin' : gap === 6 ? 'Sexy' : gap;
                
                // Alternating row colors for better readability
                const rowBg = i % 2 === 0 ? 'rgba(255, 255, 255, 0.02)' : 'transparent';
                
                html += `
                    <tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.03); cursor: pointer; transition: all 0.2s; background: ${rowBg};" 
                        onmouseover="this.style.background='rgba(102, 126, 234, 0.15)'; this.style.transform='translateX(4px)'" 
                        onmouseout="this.style.background='${rowBg}'; this.style.transform='translateX(0)'"
                        onclick="showGapDetails(${gap})">
                        <td style="padding: 12px 10px; color: #888; font-size: 0.9rem;">${(i + 1).toLocaleString()}</td>
                        <td style="padding: 12px 10px; text-align: right; font-weight: bold; color: #fff; font-size: 1rem;">${p.toLocaleString()}</td>
                        <td style="padding: 12px 10px; text-align: center;">
                            <span style="display: inline-block; padding: 6px 14px; background: ${gapColor}; color: #000; border-radius: 6px; font-weight: bold; font-size: 0.85rem; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                                ${gapLabel}
                            </span>
                        </td>
                        <td style="padding: 12px 10px; text-align: right; color: #4ecdc4; font-family: 'Courier New', monospace;">${factor.toFixed(10)}</td>
                        <td style="padding: 12px 10px; text-align: right; color: #ffd700; font-family: 'Courier New', monospace; font-weight: bold;">${cumulative.toFixed(10)}</td>
                    </tr>
                `;
            }
            
            if (displayLimit < primes.length - 1) {
                html += `
                    <tr style="background: rgba(255, 215, 0, 0.05);">
                        <td colspan="5" style="padding: 20px; text-align: center; color: #ffd700; font-style: italic; font-size: 0.95rem;">
                            📊 Showing first ${displayLimit.toLocaleString()} primes for performance. 
                            ${(primes.length - 1 - displayLimit).toLocaleString()} additional primes not displayed.
                        </td>
                    </tr>
                `;
            }
            
            tbody.innerHTML = html;
        }
        
        // Find k-tuple constellation pairs
        // Each prime can appear in multiple pairs
        function classifyKtuples(primes, s) {
            const ktuples = {
                twins: [],      // (p, p+2) pairs
                cousins: [],    // (p, p+4) pairs
                sexy: [],       // (p, p+6) pairs
                triplets: [],   // not used
                quadruplets: [], // not used
                isolated: []    // only prime 2
            };
            
            const primeSet = new Set(primes);
            
            // Find all twin pairs (p, p+2)
            for (let i = 0; i < primes.length; i++) {
                const p = primes[i];
                if (primeSet.has(p + 2)) {
                    ktuples.twins.push([p, p + 2]);
                }
            }
            
            // Find all cousin pairs (p, p+4)
            for (let i = 0; i < primes.length; i++) {
                const p = primes[i];
                if (primeSet.has(p + 4)) {
                    ktuples.cousins.push([p, p + 4]);
                }
            }
            
            // Find all sexy pairs (p, p+6)
            for (let i = 0; i < primes.length; i++) {
                const p = primes[i];
                if (primeSet.has(p + 6)) {
                    ktuples.sexy.push([p, p + 6]);
                }
            }
            
            // Isolated: only prime 2 (and last prime in range)
            ktuples.isolated.push(2);
            if (primes.length > 0 && primes[primes.length - 1] > 2) {
                ktuples.isolated.push(primes[primes.length - 1]);
            }
            
            const totalClassified = primes.length; // All primes accounted for
            const totalPrimes = primes.length;
            
            // Calculate products for each category
            // For pairs: flatten and get unique primes to avoid double-counting
            const calculateProduct = (pairsList) => {
                let product = 1;
                const uniquePrimes = new Set();
                
                // Flatten pairs/tuples and collect unique primes
                pairsList.forEach(item => {
                    if (Array.isArray(item)) {
                        item.forEach(p => uniquePrimes.add(p));
                    } else {
                        uniquePrimes.add(item);
                    }
                });
                
                // Calculate Euler product over unique primes
                uniquePrimes.forEach(p => {
                    const ps = Math.pow(p, s);
                    product *= ps / (ps - 1);
                });
                return product;
            };
            
            return {
                twins: { primes: ktuples.twins, product: calculateProduct(ktuples.twins) },
                cousins: { primes: ktuples.cousins, product: calculateProduct(ktuples.cousins) },
                sexy: { primes: ktuples.sexy, product: calculateProduct(ktuples.sexy) },
                triplets: { primes: ktuples.triplets, product: calculateProduct(ktuples.triplets) },
                quadruplets: { primes: ktuples.quadruplets, product: calculateProduct(ktuples.quadruplets) },
                isolated: { primes: ktuples.isolated, product: calculateProduct(ktuples.isolated) },
                stats: { totalPrimes: totalPrimes, totalClassified: totalClassified, verified: totalClassified === totalPrimes }
            };
        }
        
        // Render k-tuple classification view
        function renderKtupleView() {
            if (!analysisResults) return;
            
            const { primes, s } = analysisResults;
            const ktuples = classifyKtuples(primes, s);
            const tbody = document.getElementById('ktupleTableBody');
            
            const categories = [
                { 
                    id: 'twins',
                    name: 'Twin Primes (p, p+2)', 
                    data: ktuples.twins,
                    color: '#e74c3c',
                    description: 'Consecutive primes differing by 2'
                },
                { 
                    id: 'cousins',
                    name: 'Cousin Primes (p, p+4)', 
                    data: ktuples.cousins,
                    color: '#f39c12',
                    description: 'Primes differing by 4'
                },
                { 
                    id: 'sexy',
                    name: 'Sexy Primes (p, p+6)', 
                    data: ktuples.sexy,
                    color: '#9b59b6',
                    description: 'Primes differing by 6'
                },
                { 
                    id: 'triplets',
                    name: 'Prime Triplets', 
                    data: ktuples.triplets,
                    color: '#3498db',
                    description: 'Three consecutive primes in constellation'
                },
                { 
                    id: 'quadruplets',
                    name: 'Prime Quadruplets (p, p+2, p+6, p+8)', 
                    data: ktuples.quadruplets,
                    color: '#1abc9c',
                    description: 'Four primes in arithmetic pattern'
                },
                { 
                    id: 'isolated',
                    name: 'Isolated Primes', 
                    data: ktuples.isolated,
                    color: '#95a5a6',
                    description: 'Not part of any close constellation'
                }
            ];
            
            // Store globally for click handlers
            window.ktupleCategories = {};
            categories.forEach(cat => {
                window.ktupleCategories[cat.id] = {
                    name: cat.name,
                    primes: cat.data.primes,
                    product: cat.data.product,
                    color: cat.color
                };
            });
            
            let html = '';
            // Total product should be the Euler product over ALL primes (already calculated)
            const totalProduct = analysisResults.finalProduct;
            
            categories.forEach(cat => {
                const count = cat.data.primes.length;
                const product = cat.data.product;
                
                let example = '';
                if (count > 0) {
                    const first = cat.data.primes[0];
                    example = Array.isArray(first) ? first.join(', ') : first;
                }
                
                const contribution = product > 1 ? ((product - 1) / product * 100).toFixed(4) + '%' : '0%';
                
                html += `
                    <tr style="border-bottom: 1px solid rgba(255, 255, 255, 0.05); cursor: pointer;" 
                        onmouseover="this.style.background='rgba(255, 107, 129, 0.1)'" 
                        onmouseout="this.style.background=''"
                        data-category="${cat.id}">
                        <td style="padding: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 12px; height: 12px; background: ${cat.color}; border-radius: 2px;"></div>
                                <strong>${cat.name}</strong>
                            </div>
                            <div style="font-size: 0.8rem; color: #888; margin-top: 4px; margin-left: 20px;">
                                ${cat.description}
                            </div>
                        </td>
                        <td style="padding: 12px; text-align: center; font-size: 1.2rem; font-weight: bold; color: ${cat.color};">
                            ${count.toLocaleString()}
                        </td>
                        <td style="padding: 12px; color: #aaa; font-family: 'Courier New', monospace;">
                            ${example}${count > 1 ? ', ...' : ''}
                        </td>
                        <td style="padding: 12px; text-align: right; color: #4ecdc4; font-family: 'Courier New', monospace;">
                            ${product.toFixed(12)}
                        </td>
                        <td style="padding: 12px; text-align: right; color: #ffd700;">
                            ${contribution}
                        </td>
                    </tr>
                `;
            });
            
            // Add total row
            html += `
                <tr style="border-top: 2px solid #ff6b81; background: rgba(255, 107, 129, 0.1); font-weight: bold;">
                    <td style="padding: 12px; color: #ff6b81;">TOTAL PRODUCT</td>
                    <td style="padding: 12px; text-align: center; color: #ff6b81;">-</td>
                    <td style="padding: 12px;">All constellations combined</td>
                    <td style="padding: 12px; text-align: right; color: #4ecdc4; font-family: 'Courier New', monospace;">
                        ${totalProduct.toFixed(12)}
                    </td>
                    <td style="padding: 12px; text-align: right; color: #ffd700;">
                        ζ(2) ≈ ${(Math.PI * Math.PI / 6).toFixed(12)}
                    </td>
                </tr>
            `;
            
            tbody.innerHTML = html;
            
            // Add event delegation for row clicks
            tbody.onclick = function(e) {
                const row = e.target.closest('tr[data-category]');
                if (row) {
                    const catId = row.getAttribute('data-category');
                    showKtupleDetails(catId);
                }
            };
            
            // Display verification stats
            const verificationDiv = document.getElementById('ktupleVerification');
            if (verificationDiv && ktuples.stats) {
                const verified = ktuples.stats.verified;
                const verifyIcon = verified ? '✓' : '✗';
                const verifyColor = verified ? '#4ecdc4' : '#ff6b81';
                verificationDiv.innerHTML = `
                    <strong style="color: ${verifyColor};">${verifyIcon} Classification Verification:</strong> 
                    ${ktuples.stats.totalClassified.toLocaleString()} of ${ktuples.stats.totalPrimes.toLocaleString()} primes classified
                    ${verified ? '(All primes accounted for)' : '(WARNING: Missing primes!)'}
                `;
            }
        }
        
        // Show detailed stats for a k-tuple category
        function showKtupleDetails(catId) {
            const cat = window.ktupleCategories[catId];
            if (!cat) return;
            
            const primes = cat.primes;
            const product = cat.product;
            const catName = cat.name;
            const color = cat.color;
            const count = primes.length; // number of pairs
            
            // Build grid of pairs/tuples
            let pairsList = '';
            const displayLimit = Math.min(count, 50);
            
            pairsList += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 8px;">';
            
            for (let i = 0; i < displayLimit; i++) {
                const item = primes[i];
                const display = Array.isArray(item) ? '(' + item.join(', ') + ')' : item;
                pairsList += '<div style="padding: 8px; background: var(--parchment-dark); border-radius: 4px; color: var(--ink); font-family: \'Courier New\', monospace; text-align: center; border: 1px solid ' + color + '40;">' + display + '</div>';
            }
            
            pairsList += '</div>';
            
            if (count > displayLimit) {
                pairsList += '<div style="padding: 8px; color: var(--ink-light); font-style: italic; text-align: center; margin-top: 8px;">... and ' + (count - displayLimit) + ' more</div>';
            }
            
            const contributionPct = product > 1 ? ((product - 1) / product * 100).toFixed(4) : '0';
            
            const modalHTML = 
                '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 10000; display: flex; align-items: center; justify-content: center;" onclick="this.remove()">' +
                    '<div style="background: var(--parchment-dark); border-radius: 12px; padding: 32px; max-width: 700px; max-height: 80vh; overflow-y: auto; border: 2px solid ' + color + ';" onclick="event.stopPropagation()">' +
                        '<div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">' +
                            '<div style="width: 20px; height: 20px; background: ' + color + '; border-radius: 4px;"></div>' +
                            '<h2 style="color: ' + color + '; margin: 0;">' + catName + '</h2>' +
                        '</div>' +
                        '<div style="background: var(--parchment-dark); padding: 16px; border-radius: 8px; margin-bottom: 20px;">' +
                            '<div style="color: var(--gold); font-size: 1.2rem; margin-bottom: 8px;">' +
                                '<strong>' + count.toLocaleString() + '</strong> ' + (catId === 'isolated' ? 'primes' : 'pairs') +
                            '</div>' +
                            '<div style="color: var(--teal-ink); font-size: 1.1rem; font-family: \'Courier New\', monospace;">Product: <strong>' + product.toFixed(12) + '</strong></div>' +
                            '<div style="color: var(--ink-mid); font-size: 0.9rem; margin-top: 8px;">Contribution: ' + contributionPct + '%</div>' +
                        '</div>' +
                        '<div style="margin-bottom: 16px;"><strong style="color: var(--red-ink); font-size: 1.1rem;">' + (catId === 'isolated' ? 'Isolated primes:' : 'Prime pairs:') + '</strong></div>' +
                        '<div style="max-height: 300px; overflow-y: auto; background: var(--parchment-deep); padding: 12px; border-radius: 6px;">' +
                            pairsList +
                        '</div>' +
                        '<div style="text-align: center; margin-top: 24px; display:flex; gap:12px; justify-content:center;">' +
                            '<button onclick="this.closest(\'div[onclick*=remove]\').remove()" style="padding: 10px 24px; background: ' + color + '; color: #000; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 1rem;">Close</button>' +
                            '<button onclick="fareyShowGapOverlay(' + catId + '); this.closest(\'div[onclick*=remove]\').remove();" style="padding: 10px 24px; background: #1a3a6a; color: #4a90d9; border: 1px solid #4a90d9; border-radius: 6px; cursor: pointer; font-weight: bold; font-size: 1rem;">&#9674; Show on Farey Canvas</button>' +
                        '</div>' +
                    '</div>' +
                '</div>';
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }
        
        // Screenshot k-tuple view
        function screenshotKtupleView() {
            const tableElement = document.getElementById('ktupleTableWrapper');
            const verificationElement = document.getElementById('ktupleVerification');
            
            if (!tableElement) {
                alert('k-Tuple view not found. Please run analysis first.');
                return;
            }
            
            // Create a temporary container with just the table and verification
            const tempContainer = document.createElement('div');
            tempContainer.style.cssText = 'background: #0a0a0f; padding: 20px; position: absolute; left: -9999px;';
            
            const titleDiv = document.createElement('div');
            titleDiv.style.cssText = 'color: #ffd700; font-size: 1.8rem; font-weight: bold; margin-bottom: 20px; text-align: center;';
            titleDiv.textContent = 'Prime k-Tuple (Constellation) Classification';
            
            tempContainer.appendChild(titleDiv);
            tempContainer.appendChild(tableElement.cloneNode(true));
            if (verificationElement) {
                tempContainer.appendChild(verificationElement.cloneNode(true));
            }
            
            document.body.appendChild(tempContainer);
            
            html2canvas(tempContainer, {
                scale: 2,
                backgroundColor: '#0a0a0f',
                logging: false
            }).then(function(canvas) {
                document.body.removeChild(tempContainer);
                const link = document.createElement('a');
                link.download = 'ktuple_classification.png';
                link.href = canvas.toDataURL();
                link.click();
            });
        }
        
        // Toggle between gap and classical views
        function toggleViewMode() {
            // Only gap view mode exists now
            const chartsContainer = document.querySelectorAll('.charts-container')[2]; // Third charts-container (gap charts)
            chartsContainer.style.display = 'grid';
        }
        
        // Render all charts
        function renderAllCharts() {
            if (!analysisResults) return;
            
            if (document.getElementById('showConvergence').checked) {
                renderConvergenceChart();
            }
            if (document.getElementById('showGapContributions').checked) {
                renderGapContributionsChart();
            }
            if (document.getElementById('showGapDistribution').checked) {
                renderGapDistributionChart();
            }
            if (document.getElementById('showPercentageContrib').checked) {
                renderPercentageChart();
            }
            if (document.getElementById('showErrorAnalysis').checked) {
                renderErrorChart();
            }
            if (document.getElementById('showLogScale').checked) {
                renderLogScaleChart();
            }
            if (document.getElementById('showGapRatio').checked) {
                renderGapRatioChart();
            }
            
            // Render decimal convergence analysis
            if (document.getElementById('showDecimalConvergence')?.checked) {
                updateDecimalAnalysis();
            }
            
            // Render comparison chart if in comparison mode
            if (analysisResults.comparisonData) {
                renderComparisonChartActual();
            }
            
            // Update statistical tables
            updateStatsTables();
        }
        
        // Chart rendering functions

        // CLICK-TO-HIGHLIGHT FUNCTIONALITY
        let highlightedGap = null;
        
        function addTableClickHandlers() {
            // Add click handlers to all stat tables after they're rendered
            const tables = [
                'convergenceTableContent',
                'gapContribTableContent', 
                'gapDistTableContent',
                'percentageTableContent',
                'errorTableContent',
                'logScaleTableContent',
                'stepByStepTableContent'
            ];
            
            tables.forEach(tableId => {
                const table = document.getElementById(tableId);
                if (!table) return;
                
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach((row, index) => {
                    row.style.cursor = 'pointer';
                    row.addEventListener('click', function() {
                        // Remove previous highlights
                        document.querySelectorAll('.stats-table tr.highlighted').forEach(r => {
                            r.classList.remove('highlighted');
                        });
                        
                        // Add highlight to clicked row
                        this.classList.add('highlighted');
                        
                        // Get gap value from the row
                        // For step-by-step table: cells[1] is the gap column
                        // For other tables: cells[0] might be the gap
                        let gapValue;
                        
                        // Try to find gap value - check if second cell looks like a gap (small number)
                        if (this.cells[1] && this.cells[1].textContent) {
                            const secondColValue = parseInt(this.cells[1].textContent);
                            if (!isNaN(secondColValue) && secondColValue < 1000) {
                                // Likely a gap value (gaps are typically < 1000)
                                gapValue = secondColValue;
                            }
                        }
                        
                        // If not found in second column, try first
                        if (gapValue === undefined && this.cells[0]) {
                            const firstColValue = parseInt(this.cells[0].textContent);
                            if (!isNaN(firstColValue) && firstColValue < 1000) {
                                gapValue = firstColValue;
                            }
                        }
                        
                        if (gapValue !== undefined && !isNaN(gapValue)) {
                            highlightedGap = gapValue;
                            highlightGapOnCharts(gapValue);
                            
                            // Show detailed popup
                            showGapDetails(gapValue);
                        }
                    });
                });
            });
        }
        
        function highlightGapOnCharts(gap) {
            // Re-render charts with highlight
            if (document.getElementById('showGapContributions').checked) {
                renderGapContributionsChart(gap);
            }
            if (document.getElementById('showGapDistribution').checked) {
                renderGapDistributionChart(gap);
            }
            if (document.getElementById('showPercentageContrib').checked) {
                renderPercentageChart(gap);
            }
        }
        // ── Theme helper for canvas rendering ─────────────────────────────────
        window.canvasBg   = function() { return document.body.classList.contains('dark-mode') ? '#0a0a10' : '#ffffff'; };
        window.canvasText = function() { return document.body.classList.contains('dark-mode') ? '#888'    : '#444'; };
        window.canvasTextBright = function() { return document.body.classList.contains('dark-mode') ? '#aaa' : '#222'; };
        window.canvasGrid = function() { return document.body.classList.contains('dark-mode') ? '#2a2a4a' : '#e0e0e8'; };
        window.canvasFaint   = function() { return document.body.classList.contains('dark-mode') ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.04)'; };
        window.canvasSubBg   = function() { return document.body.classList.contains('dark-mode') ? '#1a1a2a' : '#f0f0f8'; };
        window.canvasSubBg2  = function() { return document.body.classList.contains('dark-mode') ? '#12121a' : '#e8e8f4'; };
        window.canvasRowAlt  = function() { return document.body.classList.contains('dark-mode') ? 'rgba(255,255,255,0.02)' : 'rgba(0,0,0,0.02)'; };
        window.canvasHighlight = function() { return document.body.classList.contains('dark-mode') ? 'rgba(255,215,0,0.1)' : 'rgba(100,80,0,0.07)'; };
        window.canvasPurpleHL = function() { return document.body.classList.contains('dark-mode') ? 'rgba(139,92,246,0.1)' : 'rgba(100,60,200,0.07)'; };
        window.canvasTooltipBg = function() { return document.body.classList.contains('dark-mode') ? 'rgba(14,11,5,0.97)' : 'rgba(255,255,250,0.97)'; };
        window.canvasTooltipBg2 = function() { return document.body.classList.contains('dark-mode') ? 'rgba(14,11,5,0.85)' : 'rgba(255,255,250,0.85)'; };
        window.canvasInspectBg = function() { return document.body.classList.contains('dark-mode') ? 'rgba(10,8,3,0.88)' : 'rgba(255,255,250,0.92)'; };
        window.canvasZeroBg    = function() { return document.body.classList.contains('dark-mode') ? 'rgba(0,0,0,0.7)' : 'rgba(255,255,255,0.85)'; };
        var canvasBg = window.canvasBg, canvasText = window.canvasText,
            canvasTextBright = window.canvasTextBright, canvasGrid = window.canvasGrid,
            canvasFaint = window.canvasFaint, canvasSubBg = window.canvasSubBg,
            canvasSubBg2 = window.canvasSubBg2, canvasRowAlt = window.canvasRowAlt,
            canvasHighlight = window.canvasHighlight, canvasPurpleHL = window.canvasPurpleHL;

        function renderConvergenceChart() {
            const canvas = document.getElementById('convergenceChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            // Clear
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const data = getFilteredProgressiveProducts();
            if (data.length === 0) {
                ctx.fillStyle = canvasText();
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data in selected gap range', w/2, h/2);
                return;
            }
            
            const target = analysisResults.targetZeta2;
            
            // Margins
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Scales
            const maxY = Math.max(target * 1.1, ...data.map(d => d.value));
            const minY = Math.min(0.8, ...data.map(d => d.value));
            const xScale = chartW / (data.length - 1);
            const yScale = chartH / (maxY - minY);
            
            // Grid
            ctx.strokeStyle = canvasGrid();
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxY - (maxY - minY) * (i / 10);
                ctx.fillStyle = canvasText();
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(4), margin.left - 20, y + 12);
            }
            
            // Target line
            const targetY = margin.top + chartH - (target - minY) * yScale;
            ctx.strokeStyle = '#ff6464';
            ctx.lineWidth = 4;
            ctx.setLineDash([20, 20]);
            ctx.beginPath();
            ctx.moveTo(margin.left, targetY);
            ctx.lineTo(w - margin.right, targetY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#ff6464';
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`ζ(2) = π²/6 = ${target.toFixed(8)}`, margin.left + 40, targetY - 30);
            
            // Convergence line
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 6;
            ctx.beginPath();
            data.forEach((point, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - (point.value - minY) * yScale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Points
            ctx.fillStyle = '#ffd700';
            data.forEach((point, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - (point.value - minY) * yScale;
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // X-axis labels
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 28px monospace';
            ctx.textAlign = 'center';
            data.forEach((point, i) => {
                if (i % Math.max(1, Math.floor(data.length / 15)) === 0) {
                    const x = margin.left + i * xScale;
                    ctx.fillText(`Gap ${point.gap}`, x, h - margin.bottom + 60);
                }
            });
            
            // Axis labels
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Progressive Product Convergence to ζ(2)', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Product Value', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Family', w / 2, h - 40);
        }
        
        function renderGapContributionsChart(highlightGap) {
            const canvas = document.getElementById('gapContribChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = canvasText();
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data in selected gap range', w/2, h/2);
                return;
            }
            
            const products = gaps.map(g => analysisResults.gapProducts[g]);
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const barWidth = chartW / gaps.length;
            const maxProduct = Math.max(...products.map(p => p.product));
            const yScale = chartH / maxProduct;
            
            // Grid
            ctx.strokeStyle = canvasGrid();
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxProduct - (maxProduct * (i / 10));
                ctx.fillStyle = canvasText();
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(6), margin.left - 20, y + 12);
            }
            
            // Bars
            products.forEach((prod, i) => {
                const gap = gaps[i];
                const x = margin.left + i * barWidth;
                const barH = prod.product * yScale;
                const y = margin.top + chartH - barH;
                
                const isHighlighted = highlightGap && gap === highlightGap;
                
                const gradient = ctx.createLinearGradient(x, y, x, y + barH);
                if (isHighlighted) {
                    gradient.addColorStop(0, '#ff0000');
                    gradient.addColorStop(1, '#cc0000');
                } else {
                    gradient.addColorStop(0, '#ffd700');
                    gradient.addColorStop(1, '#ffaa00');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                ctx.strokeStyle = isHighlighted ? '#ff0000' : '#ffaa00';
                ctx.lineWidth = isHighlighted ? 8 : 3;
                ctx.strokeRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
            });
            
            // Labels
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            gaps.forEach((gap, i) => {
                const x = margin.left + i * barWidth + barWidth / 2;
                const isHighlighted = highlightGap && gap === highlightGap;
                ctx.fillStyle = isHighlighted ? '#ff0000' : '#aaa';
                ctx.font = isHighlighted ? 'bold 32px monospace' : 'bold 24px monospace';
                ctx.fillText(`${gap}`, x, h - margin.bottom + 50);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Individual Gap Family Products P_g', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Product P_g', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Size', w / 2, h - 40);
        }
        
        function renderGapDistributionChart(highlightGap) {
            const canvas = document.getElementById('gapDistChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = canvasText();
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data in selected gap range', w/2, h/2);
                return;
            }
            
            const counts = gaps.map(g => analysisResults.gapProducts[g].count);
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const barWidth = chartW / gaps.length;
            const maxCount = Math.max(...counts);
            const yScale = chartH / maxCount;
            
            // Grid
            ctx.strokeStyle = canvasGrid();
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxCount - (maxCount * (i / 10));
                ctx.fillStyle = canvasText();
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(Math.round(value).toLocaleString(), margin.left - 20, y + 12);
            }
            
            // Bars
            counts.forEach((count, i) => {
                const gap = gaps[i];
                const x = margin.left + i * barWidth;
                const barH = count * yScale;
                const y = margin.top + chartH - barH;
                
                const isHighlighted = highlightGap && gap === highlightGap;
                
                const gradient = ctx.createLinearGradient(x, y, x, y + barH);
                if (isHighlighted) {
                    gradient.addColorStop(0, '#ff0000');
                    gradient.addColorStop(1, '#cc0000');
                } else {
                    gradient.addColorStop(0, '#64ff64');
                    gradient.addColorStop(1, '#32aa32');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                ctx.strokeStyle = isHighlighted ? '#ff0000' : '#32aa32';
                ctx.lineWidth = isHighlighted ? 8 : 3;
                ctx.strokeRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
            });
            
            // Labels
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            gaps.forEach((gap, i) => {
                const x = margin.left + i * barWidth + barWidth / 2;
                const isHighlighted = highlightGap && gap === highlightGap;
                ctx.fillStyle = isHighlighted ? '#ff0000' : '#aaa';
                ctx.font = isHighlighted ? 'bold 32px monospace' : 'bold 24px monospace';
                ctx.fillText(`${gap}`, x, h - margin.bottom + 50);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Number of Primes per Gap Family', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Prime Count', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Size', w / 2, h - 40);
        }
        
        function renderPercentageChart(highlightGap) {
            const canvas = document.getElementById('percentageChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = canvasText();
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const percentages = gaps.map(g => analysisResults.percentageContributions[g]);
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const barWidth = chartW / gaps.length;
            const maxPct = Math.max(...percentages);
            const yScale = chartH / maxPct;
            
            // Grid
            ctx.strokeStyle = canvasGrid();
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxPct - (maxPct * (i / 10));
                ctx.fillStyle = canvasText();
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(2) + '%', margin.left - 20, y + 12);
            }
            
            // Bars
            percentages.forEach((pct, i) => {
                const gap = gaps[i];
                const x = margin.left + i * barWidth;
                const barH = pct * yScale;
                const y = margin.top + chartH - barH;
                
                const isHighlighted = highlightGap && gap === highlightGap;
                
                const gradient = ctx.createLinearGradient(x, y, x, y + barH);
                if (isHighlighted) {
                    gradient.addColorStop(0, '#ff0000');
                    gradient.addColorStop(1, '#cc0000');
                } else {
                    gradient.addColorStop(0, '#ff6464');
                    gradient.addColorStop(1, '#aa3232');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                ctx.strokeStyle = isHighlighted ? '#ff0000' : '#aa3232';
                ctx.lineWidth = isHighlighted ? 8 : 3;
                ctx.strokeRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
            });
            
            // Labels
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            gaps.forEach((gap, i) => {
                const x = margin.left + i * barWidth + barWidth / 2;
                const isHighlighted = highlightGap && gap === highlightGap;
                ctx.fillStyle = isHighlighted ? '#ff0000' : '#aaa';
                ctx.font = isHighlighted ? 'bold 32px monospace' : 'bold 24px monospace';
                ctx.fillText(`${gap}`, x, h - margin.bottom + 50);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Percentage Contribution to log(ζ(2))', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Contribution %', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Size', w / 2, h - 40);
        }
        
        function renderErrorChart() {
            const canvas = document.getElementById('errorChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const data = analysisResults.progressiveProducts;
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const xScale = chartW / (data.length - 1);
            const errors = data.map(d => d.relativeError);
            const maxError = Math.max(...errors);
            const minError = Math.min(...errors);
            const yScale = chartH / (maxError - minError);
            
            // Grid (log scale for y-axis)
            ctx.strokeStyle = canvasGrid();
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const logValue = Math.log10(maxError) - (Math.log10(maxError) - Math.log10(minError)) * (i / 10);
                const value = Math.pow(10, logValue);
                ctx.fillStyle = canvasText();
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText((value * 100).toExponential(2) + '%', margin.left - 20, y + 12);
            }
            
            // Error line
            ctx.strokeStyle = '#64ffff';
            ctx.lineWidth = 6;
            ctx.beginPath();
            data.forEach((point, i) => {
                const x = margin.left + i * xScale;
                const logError = Math.log10(point.relativeError);
                const normalizedLog = (logError - Math.log10(minError)) / (Math.log10(maxError) - Math.log10(minError));
                const y = margin.top + chartH * (1 - normalizedLog);
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Points
            ctx.fillStyle = '#64ffff';
            data.forEach((point, i) => {
                const x = margin.left + i * xScale;
                const logError = Math.log10(point.relativeError);
                const normalizedLog = (logError - Math.log10(minError)) / (Math.log10(maxError) - Math.log10(minError));
                const y = margin.top + chartH * (1 - normalizedLog);
                
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Labels
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 28px monospace';
            ctx.textAlign = 'center';
            data.forEach((point, i) => {
                if (i % Math.max(1, Math.floor(data.length / 15)) === 0) {
                    const x = margin.left + i * xScale;
                    ctx.fillText(`Gap ${point.gap}`, x, h - margin.bottom + 60);
                }
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Relative Error vs Target (Log Scale)', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Relative Error', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Family', w / 2, h - 40);
        }
        
        function renderLogScaleChart() {
            const canvas = document.getElementById('logScaleChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = canvasText();
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const logProducts = gaps.map(g => analysisResults.gapProducts[g].logProduct);
            
            const margin = { left: 200, right: 100, top: 100, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const barWidth = chartW / gaps.length;
            const maxLog = Math.max(...logProducts);
            const minLog = Math.min(0, ...logProducts);
            const yScale = chartH / (maxLog - minLog);
            
            // Grid
            ctx.strokeStyle = canvasGrid();
            ctx.lineWidth = 2;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxLog - (maxLog - minLog) * (i / 10);
                ctx.fillStyle = canvasText();
                ctx.font = 'bold 32px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(4), margin.left - 20, y + 12);
            }
            
            // Bars
            logProducts.forEach((logProd, i) => {
                const x = margin.left + i * barWidth;
                const barH = (logProd - minLog) * yScale;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(x, y, x, y + barH);
                gradient.addColorStop(0, '#aa64ff');
                gradient.addColorStop(1, '#6432aa');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                ctx.strokeStyle = '#6432aa';
                ctx.lineWidth = 3;
                ctx.strokeRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
            });
            
            // Labels
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            gaps.forEach((gap, i) => {
                const x = margin.left + i * barWidth + barWidth / 2;
                ctx.fillText(`${gap}`, x, h - margin.bottom + 50);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 48px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Log-Scale Product Growth: log(P_g)', w / 2, margin.top - 30);
            
            ctx.save();
            ctx.translate(60, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('log(P_g)', 0, 0);
            ctx.restore();
            
            ctx.font = 'bold 42px sans-serif';
            ctx.fillText('Gap Size', w / 2, h - 40);
        }
        
        function renderGapRatioChart() {
            const canvas = document.getElementById('gapRatioChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            if (!analysisResults || !analysisResults.gapProducts) {
                ctx.fillStyle = canvasText();
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Run analysis first', w/2, h/2);
                return;
            }
            
            const margin = { left: 250, right: 250, top: 120, bottom: 180 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Get key gap counts
            const gap2Count = analysisResults.gapProducts[2]?.count || 0;
            const gap4Count = analysisResults.gapProducts[4]?.count || 0;
            const gap6Count = analysisResults.gapProducts[6]?.count || 0;
            const gap10Count = analysisResults.gapProducts[10]?.count || 0;
            const gap12Count = analysisResults.gapProducts[12]?.count || 0;
            const totalPrimes = analysisResults.allPrimesFound - 1; // Exclude last prime
            
            // Hardy-Littlewood singular series constants per gap
            // S(h) = 2 * C2 * Prod_{odd prime p dividing h} (p-1)/(p-2)
            // Gap 2, 4, 8: S = 2*C2  (no odd prime factors, or p=2 only)
            // Gap 6, 12, 18, 24: S = 4*C2  (factor of 2 from p=3 dividing gap)
            // Gap 10, 20: S = 8/3 * C2  (factor 4/3 from p=5 dividing gap)
            const C2_FULL = 0.6601618158468695; // Full precision twin prime constant
            
            // li2 approximation: better estimate of ∫₂ˣ dt/ln²(t)
            // li2(x) ≈ x/ln²(x) * (1 + 2/ln(x) + 6/ln²(x) + 24/ln³(x))
            function li2(x) {
                const L = Math.log(x);
                return (x / (L * L)) * (1 + 2/L + 6/(L*L) + 24/(L*L*L));
            }
            
            const _ssMemo1 = Object.create(null);
            function singularSeries(h) {
                if (_ssMemo1[h] !== undefined) return _ssMemo1[h];
                // Compute Prod_{odd prime p | h} (p-1)/(p-2)
                let mult = 1.0;
                for (let p = 3; p <= h; p++) {
                    if (h % p === 0) {
                        let isPrime = true;
                        for (let d = 2; d * d <= p; d++) { if (p % d === 0) { isPrime = false; break; } }
                        if (isPrime) mult *= (p - 1) / (p - 2);
                    }
                }
                return (_ssMemo1[h] = 2 * C2_FULL * mult);
            }
            
            // Hardy-Littlewood predictions using li2 approximation
            const maxPrime = analysisResults.maxPrime;
            const predictedTwins = singularSeries(2) * li2(maxPrime);   // gap 2: S=2*C2
            const predictedCousins = singularSeries(4) * li2(maxPrime); // gap 4: S=2*C2 (same)
            const hlError = Math.abs(gap2Count - predictedTwins);
            const hlErrorPercent = (hlError / gap2Count) * 100;
            
            // Calculate ratios
            const ratio_2_4 = gap4Count > 0 ? gap2Count / gap4Count : 0;
            const ratio_2_6 = gap6Count > 0 ? gap2Count / gap6Count : 0;
            const ratio_4_6 = gap6Count > 0 ? gap4Count / gap6Count : 0;
            
            // Calculate percentages
            const pct2 = (gap2Count / totalPrimes) * 100;
            const pct4 = (gap4Count / totalPrimes) * 100;
            const pct6 = (gap6Count / totalPrimes) * 100;
            const pct10 = (gap10Count / totalPrimes) * 100;
            const pct12 = (gap12Count / totalPrimes) * 100;
            
            // Draw three subcharts: Ratios, Percentages, and HL Error
            const subChartW = chartW / 3 - 40;
            const subChartH = chartH;
            
            // SUBCHART 1: Gap Ratios
            const x1 = margin.left;
            renderRatioSubchart(ctx, x1, margin.top, subChartW, subChartH, ratio_2_4, ratio_2_6, ratio_4_6);
            
            // SUBCHART 2: Gap Percentages
            const x2 = margin.left + subChartW + 60;
            renderPercentageSubchart(ctx, x2, margin.top, subChartW, subChartH, pct2, pct4, pct6, pct10, pct12);
            
            // SUBCHART 3: Hardy-Littlewood Error
            const x3 = margin.left + 2 * (subChartW + 60);
            renderHLErrorSubchart(ctx, x3, margin.top, subChartW, subChartH, gap2Count, predictedTwins, hlErrorPercent);
            
            // Main title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 56px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Ratio Convergence: Twin Prime Conjecture Evidence', w / 2, 70);
            
            // Footer info
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 32px sans-serif';
            ctx.fillText(`Analysis: ${analysisResults.allPrimesFound.toLocaleString()} primes up to ${maxPrime.toLocaleString()}`, w / 2, h - 80);
            
            ctx.font = '28px sans-serif';
            ctx.fillText(`Twin Prime Constant C₂ = 0.6601618158...  |  H-L Predicted (li₂ formula): ${Math.round(predictedTwins).toLocaleString()} twins`, w / 2, h - 40);
        }
        
        function renderRatioSubchart(ctx, x, y, w, h, ratio_2_4, ratio_2_6, ratio_4_6) {
            // Title
            ctx.fillStyle = '#ff4081';
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Count Ratios', x + w/2, y - 40);
            
            // Draw bars for ratios
            const barW = w / 4;
            const maxRatio = Math.max(ratio_2_4, ratio_2_6, ratio_4_6, 1.5);
            const scale = h / maxRatio;
            
            // Horizontal line at ratio = 1.0
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 4;
            ctx.setLineDash([15, 10]);
            const oneY = y + h - scale * 1.0;
            ctx.beginPath();
            ctx.moveTo(x, oneY);
            ctx.lineTo(x + w, oneY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 24px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText('Ratio = 1.0', x - 10, oneY + 8);
            
            // Bar 1: Gap 2/Gap 4
            const h1 = ratio_2_4 * scale;
            const y1 = y + h - h1;
            ctx.fillStyle = ratio_2_4 > 0.98 && ratio_2_4 < 1.02 ? '#4caf50' : '#ff6b6b';
            ctx.fillRect(x + barW * 0.5, y1, barW * 0.8, h1);
            ctx.strokeStyle = canvasGrid();
            ctx.lineWidth = 3;
            ctx.strokeRect(x + barW * 0.5, y1, barW * 0.8, h1);
            
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 32px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(ratio_2_4.toFixed(4), x + barW * 0.9, y1 - 15);
            
            ctx.font = 'bold 28px sans-serif';
            ctx.fillText('Gap 2/', x + barW * 0.9, y + h + 40);
            ctx.fillText('Gap 4', x + barW * 0.9, y + h + 75);
            
            // Bar 2: Gap 2/Gap 6
            const h2 = ratio_2_6 * scale;
            const y2 = y + h - h2;
            ctx.fillStyle = '#64b5f6';
            ctx.fillRect(x + barW * 1.7, y2, barW * 0.8, h2);
            ctx.strokeRect(x + barW * 1.7, y2, barW * 0.8, h2);
            
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 32px monospace';
            ctx.fillText(ratio_2_6.toFixed(4), x + barW * 2.1, y2 - 15);
            
            ctx.font = 'bold 28px sans-serif';
            ctx.fillText('Gap 2/', x + barW * 2.1, y + h + 40);
            ctx.fillText('Gap 6', x + barW * 2.1, y + h + 75);
            
            // Bar 3: Gap 4/Gap 6
            const h3 = ratio_4_6 * scale;
            const y3 = y + h - h3;
            ctx.fillStyle = '#ba68c8';
            ctx.fillRect(x + barW * 2.9, y3, barW * 0.8, h3);
            ctx.strokeRect(x + barW * 2.9, y3, barW * 0.8, h3);
            
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 32px monospace';
            ctx.fillText(ratio_4_6.toFixed(4), x + barW * 3.3, y3 - 15);
            
            ctx.font = 'bold 28px sans-serif';
            ctx.fillText('Gap 4/', x + barW * 3.3, y + h + 40);
            ctx.fillText('Gap 6', x + barW * 3.3, y + h + 75);
        }
        
        function renderPercentageSubchart(ctx, x, y, w, h, pct2, pct4, pct6, pct10, pct12) {
            // Title
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('% of Total Primes', x + w/2, y - 40);
            
            const barW = w / 6;
            const maxPct = Math.max(pct2, pct4, pct6, pct10, pct12, 15);
            const scale = h / maxPct;
            
            const gaps = [2, 4, 6, 10, 12];
            const pcts = [pct2, pct4, pct6, pct10, pct12];
            const colors = ['#ff4081', '#64b5f6', '#4caf50', '#ffb74d', '#ba68c8'];
            
            gaps.forEach((gap, i) => {
                const barH = pcts[i] * scale;
                const barY = y + h - barH;
                const barX = x + barW * (i + 0.5);
                
                ctx.fillStyle = colors[i];
                ctx.fillRect(barX, barY, barW * 0.8, barH);
                ctx.strokeStyle = canvasGrid();
                ctx.lineWidth = 3;
                ctx.strokeRect(barX, barY, barW * 0.8, barH);
                
                ctx.fillStyle = canvasTextBright();
                ctx.font = 'bold 30px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(pcts[i].toFixed(2) + '%', barX + barW * 0.4, barY - 15);
                
                ctx.font = 'bold 32px sans-serif';
                ctx.fillText('Gap ' + gap, barX + barW * 0.4, y + h + 50);
            });
        }
        
        function renderHLErrorSubchart(ctx, x, y, w, h, observed, predicted, errorPct) {
            // Title
            ctx.fillStyle = '#ffb74d';
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Hardy-Littlewood Accuracy', x + w/2, y - 40);
            
            // Draw two bars: Predicted vs Observed
            const barW = w / 3;
            const maxVal = Math.max(observed, predicted);
            const scale = (h * 0.8) / maxVal;
            
            // Predicted bar
            const h1 = predicted * scale;
            const y1 = y + h * 0.9 - h1;
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(x + barW * 0.3, y1, barW * 0.8, h1);
            ctx.strokeStyle = canvasGrid();
            ctx.lineWidth = 3;
            ctx.strokeRect(x + barW * 0.3, y1, barW * 0.8, h1);
            
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 28px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(Math.round(predicted).toLocaleString(), x + barW * 0.7, y1 - 15);
            
            ctx.font = 'bold 28px sans-serif';
            ctx.fillText('Predicted', x + barW * 0.7, y + h * 0.9 + 40);
            ctx.fillText('(H-L)', x + barW * 0.7, y + h * 0.9 + 75);
            
            // Observed bar
            const h2 = observed * scale;
            const y2 = y + h * 0.9 - h2;
            ctx.fillStyle = '#4caf50';
            ctx.fillRect(x + barW * 1.6, y2, barW * 0.8, h2);
            ctx.strokeRect(x + barW * 1.6, y2, barW * 0.8, h2);
            
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 28px monospace';
            ctx.fillText(observed.toLocaleString(), x + barW * 2.0, y2 - 15);
            
            ctx.font = 'bold 28px sans-serif';
            ctx.fillText('Observed', x + barW * 2.0, y + h * 0.9 + 40);
            ctx.fillText('(Actual)', x + barW * 2.0, y + h * 0.9 + 75);
            
            // Error percentage display
            ctx.fillStyle = errorPct < 1.0 ? '#4caf50' : errorPct < 5.0 ? '#ffb74d' : '#ff6b6b';
            ctx.font = 'bold 48px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Error: ' + errorPct.toFixed(3) + '%', x + w/2, y + h * 0.3);
            
            ctx.fillStyle = canvasTextBright();
            ctx.font = '24px sans-serif';
            const diff = observed - predicted;
            const sign = diff > 0 ? '+' : '';
            ctx.fillText(`Difference: ${sign}${Math.round(diff).toLocaleString()}`, x + w/2, y + h * 0.4);
        }
        
        // Custom Gap Comparison Functions
        function loadGapPreset(presetName) {
            const input = document.getElementById('compareGapsInput');
            
            switch(presetName) {
                case 'twins_cousins':
                    input.value = '2, 4';
                    break;
                case 'small_gaps':
                    input.value = '2, 4, 6, 8, 10';
                    break;
                case 'mod6':
                    input.value = '6, 12, 18, 24, 30, 36, 42, 48';
                    break;
                case 'mod6_nearby':
                    input.value = '10, 12, 14, 16, 18, 20, 22, 24';
                    break;
                case 'powers_of_2':
                    input.value = '2, 4, 8, 16, 32';
                    break;
                case 'clear':
                    input.value = '';
                    break;
            }
        }
        
        function renderCustomGapComparison() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            // Parse comma-separated gaps
            const input = document.getElementById('compareGapsInput').value;
            const selectedGaps = input.split(',')
                .map(s => s.trim())
                .filter(s => s !== '')
                .map(s => parseInt(s))
                .filter(n => !isNaN(n) && n >= 0);
            
            if (selectedGaps.length === 0) {
                alert('Please enter at least one gap (comma-separated)');
                return;
            }
            
            // Check if gaps exist in data
            const validGaps = selectedGaps.filter(g => analysisResults.gapProducts[g]);
            const missingGaps = selectedGaps.filter(g => !analysisResults.gapProducts[g]);
            
            if (validGaps.length === 0) {
                alert(`None of the selected gaps exist in the current range. Missing: ${missingGaps.join(', ')}`);
                return;
            }
            
            if (missingGaps.length > 0) {
                console.warn('Some gaps not found in data:', missingGaps);
            }
            
            // Render the comparison chart
            const canvas = document.getElementById('customGapCompareChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const margin = { left: 250, right: 100, top: 120, bottom: 180 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Get data for valid gaps
            const gapData = validGaps.map(g => ({
                gap: g,
                count: analysisResults.gapProducts[g].count,
                product: analysisResults.gapProducts[g].product,
                logProduct: analysisResults.gapProducts[g].logProduct,
                primes: analysisResults.gapProducts[g].primes
            }));
            
            // Three subcharts: Count, Product, Percentage
            const subChartW = chartW / 3 - 40;
            const subChartH = chartH;
            
            // SUBCHART 1: Prime Counts
            const x1 = margin.left;
            renderCompareSubchart(ctx, x1, margin.top, subChartW, subChartH, gapData, 'count', 'Prime Count', '#4caf50');
            
            // SUBCHART 2: Products P_g
            const x2 = margin.left + subChartW + 60;
            renderCompareSubchart(ctx, x2, margin.top, subChartW, subChartH, gapData, 'product', 'Product P_g', '#ff4081');
            
            // SUBCHART 3: Percentage of Total
            const x3 = margin.left + 2 * (subChartW + 60);
            const totalPrimes = analysisResults.allPrimesFound - 1;
            const percentages = gapData.map(d => ({
                ...d,
                percentage: (d.count / totalPrimes) * 100
            }));
            renderCompareSubchart(ctx, x3, margin.top, subChartW, subChartH, percentages, 'percentage', '% of Total', '#64b5f6');
            
            // Main title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 56px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Custom Gap Family Comparison', w / 2, 70);
            
            // Footer
            ctx.fillStyle = canvasTextBright();
            ctx.font = 'bold 32px sans-serif';
            ctx.fillText(`Comparing gaps: ${validGaps.join(', ')}  |  ${analysisResults.allPrimesFound.toLocaleString()} primes up to ${analysisResults.maxPrime.toLocaleString()}`, w / 2, h - 80);
            
            if (missingGaps.length > 0) {
                ctx.font = '28px sans-serif';
                ctx.fillStyle = '#ff6b6b';
                ctx.fillText(`Note: Gaps not found in range: ${missingGaps.join(', ')}`, w / 2, h - 40);
            }
            
            // Update table
            updateCustomGapCompareTable(validGaps);
        }
        
        function renderCompareSubchart(ctx, x, y, w, h, gapData, metric, title, color) {
            // Title
            ctx.fillStyle = color;
            ctx.font = 'bold 40px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(title, x + w/2, y - 40);
            
            const barW = w / (gapData.length + 1);
            const values = gapData.map(d => d[metric]);
            const maxVal = Math.max(...values);
            const scale = (h * 0.85) / maxVal;
            
            gapData.forEach((data, i) => {
                const barH = data[metric] * scale;
                const barY = y + h - barH;
                const barX = x + (i + 0.5) * barW;
                
                // Gradient bar
                const gradient = ctx.createLinearGradient(barX, barY, barX, barY + barH);
                gradient.addColorStop(0, color);
                const darkColor = color.replace('4caf50', '388e3c').replace('ff4081', 'c2185b').replace('64b5f6', '1976d2');
                gradient.addColorStop(1, darkColor);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(barX, barY, barW * 0.7, barH);
                ctx.strokeStyle = canvasGrid();
                ctx.lineWidth = 3;
                ctx.strokeRect(barX, barY, barW * 0.7, barH);
                
                // Value on top
                ctx.fillStyle = canvasTextBright();
                ctx.font = 'bold 28px monospace';
                ctx.textAlign = 'center';
                const displayVal = metric === 'percentage' ? data[metric].toFixed(2) + '%' : 
                                   metric === 'product' ? data[metric].toFixed(4) :
                                   data[metric].toLocaleString();
                ctx.fillText(displayVal, barX + barW * 0.35, barY - 15);
                
                // Gap label
                ctx.font = 'bold 32px sans-serif';
                ctx.fillText('Gap ' + data.gap, barX + barW * 0.35, y + h + 50);
            });
        }
        
        function updateCustomGapCompareTable(gaps) {
            const precision = parseInt(document.getElementById('customGapComparePrecision').value);
            const table = document.getElementById('customGapCompareTableContent');
            const totalPrimes = analysisResults.allPrimesFound - 1;
            
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Prime Count</th>
                        <th>% of Total</th>
                        <th>Product P<sub>g</sub></th>
                        <th>Log(P<sub>g</sub>)</th>
                        <th>Avg Prime</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            gaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const pct = (data.count / totalPrimes) * 100;
                const avgPrime = data.primes.reduce((a, b) => a + b, 0) / data.primes.length;
                
                html += `
                    <tr class="gap-row" data-gap="${gap}" style="cursor: pointer;"
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td><strong>Gap ${gap}</strong></td>
                        <td>${data.count.toLocaleString()}</td>
                        <td>${pct.toFixed(precision)}%</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td>${data.logProduct.toFixed(precision)}</td>
                        <td>${avgPrime.toFixed(0)}</td>
                    </tr>
                `;
            });
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function exportCustomGapCompareCSV() {
            const input = document.getElementById('compareGapsInput').value;
            const selectedGaps = input.split(',')
                .map(s => s.trim())
                .filter(s => s !== '')
                .map(s => parseInt(s))
                .filter(n => !isNaN(n) && n >= 0 && analysisResults.gapProducts[n]);
            
            if (selectedGaps.length === 0) {
                alert('No valid gaps to export');
                return;
            }
            
            const precision = parseInt(document.getElementById('customGapComparePrecision').value);
            const totalPrimes = analysisResults.allPrimesFound - 1;
            
            let csv = '=================================================\n';
            csv += 'CUSTOM GAP FAMILY COMPARISON\n';
            csv += '=================================================\n\n';
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime.toLocaleString()}\n`;
            csv += `Total Primes:,${totalPrimes.toLocaleString()}\n`;
            csv += `Gaps Compared:,${selectedGaps.join(' vs ')}\n\n`;
            
            csv += 'COMPARISON DATA:\n';
            csv += 'Gap,Prime Count,% of Total,Product P_g,Log(P_g),Average Prime,Min Prime,Max Prime,All Primes in Family\n';
            
            selectedGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const pct = (data.count / totalPrimes) * 100;
                const avgPrime = data.primes.reduce((a, b) => a + b, 0) / data.primes.length;
                const allPrimes = (data.primes || []).join(' ');
                const minP = data.primes.length ? data.primes[0] : '';
                const maxP = data.primes.length ? data.primes[data.primes.length-1] : '';
                
                csv += `${gap},${data.count},${pct.toFixed(precision)}%,`;
                csv += `${data.product.toFixed(precision)},${data.logProduct.toFixed(precision)},`;
                csv += `${avgPrime.toFixed(0)},${minP},${maxP},"${allPrimes}"\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF COMPARISON\n';
            csv += '=================================================\n';
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            link.href = URL.createObjectURL(blob);
            link.download = `gap_comparison_${selectedGaps.join('_')}_${timestamp}.csv`;
            link.click();
        }
        
        // ========== DECIMAL CONVERGENCE ANALYSIS ==========
        
        function updateDecimalAnalysis() {
            if (!analysisResults) return;
            
            const gap = parseInt(document.getElementById('decimalGapSelect').value);
            const detailLevel = document.getElementById('decimalDetailLevel').value;
            
            renderDecimalConvergenceChart(gap);
            renderDecimalAnalysisTable(gap, detailLevel);
        }
        
        function renderDecimalConvergenceChart(focusGap = 2) {
            if (!analysisResults) return;
            
            const canvas = document.getElementById('decimalConvergenceChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const margin = { left: 300, right: 250, top: 150, bottom: 150 };
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Get primes for the selected gap
            const gapData = analysisResults.gapProducts[focusGap];
            if (!gapData || !gapData.primes) {
                ctx.fillStyle = canvasText();
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No data for selected gap', w/2, h/2);
                return;
            }
            
            const primes = gapData.primes.slice(0, Math.min(100, gapData.primes.length));
            
            // Calculate cumulative product and contribution for each prime
            const data = [];
            let cumProduct = 1;
            
            primes.forEach((p, idx) => {
                const factor = (p * p) / (p * p - 1);
                const prevProduct = cumProduct;
                cumProduct *= factor;
                
                const contribution = Math.log10(factor);  // log base 10 for decimal places
                const cumulativeLog = Math.log10(cumProduct);
                
                data.push({
                    index: idx + 1,
                    prime: p,
                    factor: factor,
                    cumProduct: cumProduct,
                    contribution: contribution,  // How much this prime contributes
                    cumulativeLog: cumulativeLog,
                    decimalPlacesStable: Math.floor(-Math.log10(Math.abs(cumProduct - prevProduct * factor)))
                });
            });
            
            // Draw TWO subcharts: contribution magnitude and cumulative product
            
            // SUBCHART 1: Log10 contribution (shows which decimal places affected)
            const x1 = margin.left;
            const subW = chartW / 2 - 40;
            
            ctx.fillStyle = '#4ade80';
            ctx.font = 'bold 42px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Marginal Contribution (log₁₀)', x1 + subW/2, margin.top - 20);
            
            const maxContrib = Math.max(...data.map(d => d.contribution));
            const yScale1 = chartH / maxContrib;
            
            data.forEach((d, i) => {
                const x = x1 + (i / data.length) * subW;
                const barH = d.contribution * yScale1;
                const y = margin.top + chartH - barH;
                
                ctx.fillStyle = i < 5 ? '#22c55e' : i < 20 ? '#4ade80' : '#86efac';
                ctx.fillRect(x, y, Math.max(3, subW / data.length * 0.8), barH);
            });
            
            // Y-axis for contribution
            ctx.fillStyle = canvasText();
            ctx.font = '28px monospace';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const val = (maxContrib / 5) * i;
                const y = margin.top + chartH - (chartH / 5) * i;
                ctx.fillText(val.toExponential(1), x1 - 20, y + 10);
            }
            
            // SUBCHART 2: Cumulative product convergence
            const x2 = margin.left + subW + 80;
            
            ctx.fillStyle = '#60a5fa';
            ctx.font = 'bold 42px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Cumulative Product P_g', x2 + subW/2, margin.top - 20);
            
            const minProd = Math.min(...data.map(d => d.cumProduct));
            const maxProd = Math.max(...data.map(d => d.cumProduct));
            const yScale2 = chartH / (maxProd - minProd);
            
            // Line chart
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 6;
            ctx.beginPath();
            
            data.forEach((d, i) => {
                const x = x2 + (i / data.length) * subW;
                const y = margin.top + chartH - (d.cumProduct - minProd) * yScale2;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();
            
            // Points
            data.forEach((d, i) => {
                const x = x2 + (i / data.length) * subW;
                const y = margin.top + chartH - (d.cumProduct - minProd) * yScale2;
                ctx.fillStyle = i < 5 ? '#ef4444' : '#3b82f6';
                ctx.beginPath();
                ctx.arc(x, y, i < 5 ? 12 : 8, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Y-axis for cumulative
            ctx.fillStyle = canvasText();
            ctx.font = '28px monospace';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const val = minProd + ((maxProd - minProd) / 5) * i;
                const y = margin.top + chartH - (chartH / 5) * i;
                ctx.fillText(val.toFixed(6), x2 - 20, y + 10);
            }
            
            // Legend
            ctx.fillStyle = canvasTextBright();
            ctx.font = '32px sans-serif';
            ctx.textAlign = 'left';
            let legendY = margin.top + 50;
            
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(w - 230, legendY, 40, 40);
            ctx.fillStyle = '#ccc';
            ctx.fillText('First 5 primes', w - 180, legendY + 30);
            legendY += 60;
            
            ctx.fillStyle = '#4ade80';
            ctx.fillRect(w - 230, legendY, 40, 40);
            ctx.fillStyle = '#ccc';
            ctx.fillText('Primes 6-20', w - 180, legendY + 30);
            legendY += 60;
            
            ctx.fillStyle = '#86efac';
            ctx.fillRect(w - 230, legendY, 40, 40);
            ctx.fillStyle = '#ccc';
            ctx.fillText('Primes 20+', w - 180, legendY + 30);
            
            // Footer annotations
            ctx.fillStyle = canvasText();
            ctx.font = '32px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Gap ${focusGap}: ${primes.length} primes analyzed | Final P_${focusGap} = ${data[data.length-1].cumProduct.toFixed(12)}`, w / 2, h - 60);
            
            ctx.font = '28px sans-serif';
            ctx.fillText(`First prime contributes log₁₀ ≈ ${data[0].contribution.toExponential(3)}, Last prime contributes log₁₀ ≈ ${data[data.length-1].contribution.toExponential(3)}`, w / 2, h - 20);
        }
        
        function renderDecimalAnalysisTable(gap, detailLevel) {
            if (!analysisResults) return;
            
            const gapData = analysisResults.gapProducts[gap];
            if (!gapData || !gapData.primes) return;
            
            const maxPrimes = detailLevel === 'summary' ? 20 : detailLevel === 'detailed' ? 100 : gapData.primes.length;
            const primes = gapData.primes.slice(0, maxPrimes);
            const precision = parseInt(document.getElementById('decimalConvergencePrecision')?.value || 12);
            
            const table = document.getElementById('decimalAnalysisTableContent');
            
            // Calculate data
            let cumProduct = 1;
            const rows = [];
            
            primes.forEach((p, idx) => {
                const factor = (p * p) / (p * p - 1);
                const prevProduct = cumProduct;
                cumProduct *= factor;
                
                const contribution = factor - 1;  // How much > 1
                const logContribution = Math.log10(factor);
                const percentChange = ((cumProduct - prevProduct) / prevProduct) * 100;
                
                // Calculate which decimal places are affected
                const decimalChange = Math.abs(cumProduct - prevProduct);
                const decimalPlace = decimalChange > 0 ? Math.ceil(-Math.log10(decimalChange)) : 15;
                
                rows.push({
                    index: idx + 1,
                    prime: p,
                    factor: factor.toFixed(precision),
                    contribution: contribution.toExponential(6),
                    logContrib: logContribution.toExponential(6),
                    cumProduct: cumProduct.toFixed(precision),
                    percentChange: percentChange.toExponential(4),
                    decimalPlace: Math.min(decimalPlace, 15)
                });
            });
            
            let html = `
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Prime p</th>
                        <th>p²/(p²-1)</th>
                        <th>Contribution<br>(factor - 1)</th>
                        <th>log₁₀(factor)</th>
                        <th>Cumulative P<sub>${gap}</sub></th>
                        <th>% Change</th>
                        <th>Decimal Places<br>Affected</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            rows.forEach(row => {
                const highlight = row.index <= 5 ? 'style="background: rgba(34, 197, 94, 0.1);"' : '';
                html += `
                    <tr ${highlight}>
                        <td style="font-weight: bold;">${row.index}</td>
                        <td style="font-family: monospace;">${row.prime.toLocaleString()}</td>
                        <td style="font-family: monospace; font-size: 0.9rem;">${row.factor}</td>
                        <td style="font-family: monospace; color: #4ade80;">${row.contribution}</td>
                        <td style="font-family: monospace;">${row.logContrib}</td>
                        <td style="font-family: monospace; color: #ffd700;">${row.cumProduct}</td>
                        <td style="font-family: monospace;">${row.percentChange}%</td>
                        <td style="text-align: center; color: ${row.decimalPlace > 10 ? '#22c55e' : '#ffd700'};">
                            ${row.decimalPlace}+
                        </td>
                    </tr>
                `;
            });
            
            // Add summary row
            html += `
                <tr style="border-top: 3px solid #ffd700; background: rgba(255, 215, 0, 0.05);">
                    <td colspan="3"><strong>Summary</strong></td>
                    <td colspan="5" style="text-align: left; padding-left: 20px;">
                        <strong>First prime (p=${primes[0]}):</strong> Contributes ${((primes[0]**2/(primes[0]**2-1) - 1)*100).toFixed(4)}% increase<br>
                        <strong>Last prime (p=${primes[primes.length-1]}):</strong> Contributes ${((primes[primes.length-1]**2/(primes[primes.length-1]**2-1) - 1)*100).toExponential(4)}% increase<br>
                        <strong>Weight ratio:</strong> First/Last = ${((primes[0]**2/(primes[0]**2-1) - 1) / (primes[primes.length-1]**2/(primes[primes.length-1]**2-1) - 1)).toExponential(2)}×
                    </td>
                </tr>
            `;
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function exportDecimalAnalysisCSV() {
            if (!analysisResults) return;
            
            const gap = parseInt(document.getElementById('decimalGapSelect').value);
            const detailLevel = document.getElementById('decimalDetailLevel').value;
            const precision = parseInt(document.getElementById('decimalConvergencePrecision')?.value || 12);
            const gapData = analysisResults.gapProducts[gap];
            
            if (!gapData || !gapData.primes) return;
            
            const maxPrimes = detailLevel === 'summary' ? 20 : detailLevel === 'detailed' ? 100 : gapData.primes.length;
            const primes = gapData.primes.slice(0, maxPrimes);
            
            const ts2 = new Date().toISOString().replace(/[:.]/g,'-').slice(0,-5);
            const gapData2 = analysisResults.gapProducts[gap];
            let csv = 'Decimal Convergence Analysis\n';
            csv += `Generated:,${new Date().toISOString()}\n`;
            csv += `Gap Family:,${gap}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime.toLocaleString()}\n`;
            csv += `Total Primes in Gap ${gap}:,${gapData2 ? gapData2.count : primes.length}\n`;
            csv += `Final P_${gap}:,${gapData2 ? gapData2.product.toFixed(precision) : ''}\n`;
            csv += `Precision:,${precision} decimal places\n\n`;
            csv += 'Index,Prime p,Factor p^2/(p^2-1),Contribution (factor-1),Log10(factor),Cumulative Product,Percent Change,Decimal Place Affected\n';
            
            let cumProduct = 1;
            primes.forEach((p, idx) => {
                const factor = (p * p) / (p * p - 1);
                const prevProduct = cumProduct;
                cumProduct *= factor;
                const contribution = factor - 1;
                const logContribution = Math.log10(factor);
                const percentChange = ((cumProduct - prevProduct) / prevProduct) * 100;
                const decimalChange = Math.abs(cumProduct - prevProduct);
                const decimalPlace = decimalChange > 0 ? Math.ceil(-Math.log10(decimalChange)) : 15;
                
                csv += `${idx+1},${p},${factor.toFixed(precision)},${contribution.toExponential(6)},${logContribution.toExponential(6)},${cumProduct.toFixed(precision)},${percentChange.toExponential(4)}%,${Math.min(decimalPlace,15)}+\n`;
            });
            csv += `\nEND OF DATASET — ${primes.length} primes in gap family ${gap}\n`;
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `gap${gap}_decimal_convergence_${analysisResults.maxPrime}_${ts2}.csv`;
            link.click();
        }
        
        // Animation functions
        function startAnimation() {
            if (isAnimating) return;
            
            const useMaxPrime = document.getElementById('useMaxPrimeForAnim').checked;
            let startRange, endRange;
            
            if (useMaxPrime) {
                startRange = 100;
                endRange = parseInt(document.getElementById('maxPrime').value);
            } else {
                startRange = parseInt(document.getElementById('animStart').value);
                endRange = parseInt(document.getElementById('animEnd').value);
            }
            
            if (startRange >= endRange) {
                alert('Animation start must be less than end');
                return;
            }
            
            const animSpeed = parseInt(document.getElementById('animSpeed').value);
            
            isAnimating = true;
            let currentRange = startRange;
            const step = Math.max(100, Math.floor((endRange - startRange) / 100));
            
            const statusBar = document.getElementById('statusBar');
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            
            statusBar.style.display = 'block';
            progressContainer.style.display = 'block';
            
            function animateFrame() {
                if (!isAnimating || currentRange > endRange) {
                    stopAnimation();
                    return;
                }
                
                analysisResults = computeGapDecomposition(currentRange); window.analysisResults = analysisResults;
                
                const progress = ((currentRange - startRange) / (endRange - startRange)) * 100;
                progressFill.style.width = progress + '%';
                
                statusBar.className = 'status-bar computing';
                statusBar.textContent = `Animating: ${currentRange.toLocaleString()} / ${endRange.toLocaleString()} primes (${progress.toFixed(1)}%)`;
                
                updateStatistics();
                renderAllCharts();
                
                currentRange += step;
                
                // Use setTimeout with speed control instead of requestAnimationFrame
                setTimeout(() => {
                    animationId = requestAnimationFrame(animateFrame);
                }, animSpeed);
            }
            
            animateFrame();
        }
        
        function stopAnimation() {
            isAnimating = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            const statusBar = document.getElementById('statusBar');
            const progressContainer = document.getElementById('progressContainer');
            
            statusBar.className = 'status-bar complete';
            statusBar.textContent = 'Animation complete';
            progressContainer.style.display = 'none';
        }
        
        // Export functions
        function exportAllData() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            let csv = 'Gap-Class Decomposition of zeta(2) = pi^2/6\n';
            csv += `Analysis Date,${new Date().toISOString()}\n`;
            csv += `Maximum Prime,${analysisResults.maxPrime}\n`;
            csv += `Total Primes,${(analysisResults.allPrimesFound || analysisResults.totalPrimes)}\n`;
            csv += `Target zeta(2),${analysisResults.targetZeta2}\n`;
            csv += `Computed Product,${analysisResults.finalProduct}\n`;
            csv += `Absolute Error,${analysisResults.finalError}\n`;
            csv += `Relative Error,${analysisResults.finalRelativeError}\n\n`;
            
            csv += 'Gap Family Analysis\n';
            csv += 'Gap,Prime Count,Product P_g,Log Product,Percentage Contribution,All Primes in Family\n';
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const pct = analysisResults.percentageContributions[gap];
                const primes = (data.primes || []).join(' ');
                csv += `${gap},${data.count},${data.product},${data.logProduct},${pct},"${primes}"\n`;
            });
            
            csv += '\nProgressive Convergence\n';
            csv += 'Gap,Cumulative Product,Log Product,Absolute Error,Relative Error\n';
            analysisResults.progressiveProducts.forEach(p => {
                csv += `${p.gap},${p.value},${p.logValue},${p.error},${p.relativeError}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.download = `gap_decomposition_${analysisResults.maxPrime}.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }
        
        function exportAllCharts() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const canvases = [
                { id: 'convergenceChart', name: 'convergence' },
                { id: 'gapContribChart', name: 'gap_contributions' },
                { id: 'gapDistChart', name: 'gap_distribution' },
                { id: 'percentageChart', name: 'percentage' },
                { id: 'errorChart', name: 'error_analysis' },
                { id: 'logScaleChart', name: 'log_scale' },
                { id: 'gapRatioChart', name: 'gap_ratio_analysis' }
            ];
            
            canvases.forEach(({ id, name }) => {
                const canvas = document.getElementById(id);
                const link = document.createElement('a');
                link.download = `${name}_${analysisResults.maxPrime}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            });
        }
        
        // Event listeners
        document.getElementById('maxPrime').addEventListener('input', updateDisplays);
        document.getElementById('animStart').addEventListener('input', updateDisplays);
        document.getElementById('animEnd').addEventListener('input', updateDisplays);
        
        // Table toggle function
        const tableStates = {
            convergenceTable: false,
            gapContribTable: false,
            gapDistTable: false,
            percentageTable: false,
            errorTable: false,
            logScaleTable: false,
            gapRatioTable: false,
            stepByStepTable: true
        };
        
        function toggleTable(tableId) {
            const container = document.getElementById(tableId);
            const button = event.target;
            
            tableStates[tableId] = !tableStates[tableId];
            
            if (tableStates[tableId]) {
                container.classList.add('expanded');
                button.textContent = 'Show Less';
            } else {
                container.classList.remove('expanded');
                button.textContent = 'Show All';
            }
            
            updateStatsTables();
        }
        
        // Update all stats tables
        function updateStatsTables() {
            if (!analysisResults) return;
            
            updateConvergenceTable();
            updateGapContribTable();
            updateGapDistTable();
            updatePercentageTable();
            updateErrorTable();
            updateLogScaleTable();
            updateStepByStepTable();
            updateGapRatioTable();
            
            // Add click handlers after tables are populated
            setTimeout(() => addTableClickHandlers(), 100);
        }
        
        function updateConvergenceTable() {
            const precision = parseInt(document.getElementById('convergencePrecision').value);
            const showAll = tableStates.convergenceTable;
            const data = analysisResults.progressiveProducts;
            const displayData = showAll ? data : data.slice(0, 5);
            
            const table = document.getElementById('convergenceTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Cumulative Product</th>
                        <th>Log Product</th>
                        <th>Target ζ(2)</th>
                        <th>Absolute Error</th>
                        <th>Relative Error (%)</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayData.forEach(row => {
                html += `
                    <tr class="gap-row" data-gap="${row.gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${row.gap}</td>
                        <td>${row.value.toFixed(precision)}</td>
                        <td>${row.logValue.toFixed(precision)}</td>
                        <td>${analysisResults.targetZeta2.toFixed(precision)}</td>
                        <td>${row.error.toExponential(precision)}</td>
                        <td>${(row.relativeError * 100).toFixed(precision)}</td>
                    </tr>
                `;
            });
            
            if (!showAll && data.length > 5) {
                html += `
                    <tr>
                        <td colspan="6" style="text-align: center; color: #888; font-style: italic;">
                            ... ${data.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateGapContribTable() {
            const precision = parseInt(document.getElementById('gapContribPrecision').value);
            const showAll = tableStates.gapContribTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = canvasText();
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            
            const table = document.getElementById('gapContribTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Product P<sub>g</sub></th>
                        <th>Log(P<sub>g</sub>)</th>
                        <th>Prime Count</th>
                        <th>First 10 Primes</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const primeList = data.primes.slice(0, 10).join(', ');
                html += `
                    <tr class="gap-row" data-gap="${gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${gap}</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td>${data.logProduct.toFixed(precision)}</td>
                        <td>${data.count}</td>
                        <td class="prime-list">${primeList}${data.count > 10 ? '...' : ''}</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateGapDistTable() {
            const precision = parseInt(document.getElementById('gapDistPrecision').value);
            const showAll = tableStates.gapDistTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = canvasText();
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            
            const totalPrimes = analysisResults.totalPrimes;
            
            const table = document.getElementById('gapDistTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Prime Count</th>
                        <th>Percentage of Total</th>
                        <th>Cumulative Count</th>
                        <th>Cumulative %</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            let cumulative = 0;
            displayGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                cumulative += data.count;
                const percentage = (data.count / totalPrimes) * 100;
                const cumulativePercentage = (cumulative / totalPrimes) * 100;
                
                html += `
                    <tr class="gap-row" data-gap="${gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${gap}</td>
                        <td>${data.count}</td>
                        <td>${percentage.toFixed(precision)}%</td>
                        <td>${cumulative}</td>
                        <td>${cumulativePercentage.toFixed(precision)}%</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updatePercentageTable() {
            const precision = parseInt(document.getElementById('percentagePrecision').value);
            const showAll = tableStates.percentageTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = canvasText();
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            
            const table = document.getElementById('percentageTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Contribution to log(ζ(2))</th>
                        <th>Product P<sub>g</sub></th>
                        <th>Ratio to ζ(2)</th>
                        <th>Log Contribution</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const percentage = analysisResults.percentageContributions[gap];
                const ratio = data.product / analysisResults.targetZeta2;
                
                html += `
                    <tr class="gap-row" data-gap="${gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${gap}</td>
                        <td>${percentage.toFixed(precision)}%</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td>${ratio.toFixed(precision)}</td>
                        <td>${data.logProduct.toFixed(precision)}</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateErrorTable() {
            const precision = parseInt(document.getElementById('errorPrecision').value);
            const showAll = tableStates.errorTable;
            const data = analysisResults.progressiveProducts;
            const displayData = showAll ? data : data.slice(0, 5);
            
            const table = document.getElementById('errorTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Product Value</th>
                        <th>Absolute Error</th>
                        <th>Relative Error</th>
                        <th>Log10(Error)</th>
                        <th>Error Reduction</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayData.forEach((row, idx) => {
                const logError = Math.log10(row.relativeError);
                const prevError = idx > 0 ? data[idx - 1].relativeError : row.relativeError;
                const errorReduction = idx > 0 ? ((prevError - row.relativeError) / prevError * 100) : 0;
                
                html += `
                    <tr class="gap-row" data-gap="${row.gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${row.gap}</td>
                        <td>${row.value.toFixed(precision)}</td>
                        <td>${row.error.toExponential(precision)}</td>
                        <td>${(row.relativeError * 100).toFixed(precision)}%</td>
                        <td>${logError.toFixed(precision)}</td>
                        <td>${errorReduction.toFixed(precision)}%</td>
                    </tr>
                `;
            });
            
            if (!showAll && data.length > 5) {
                html += `
                    <tr>
                        <td colspan="6" style="text-align: center; color: #888; font-style: italic;">
                            ... ${data.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateLogScaleTable() {
            const precision = parseInt(document.getElementById('logScalePrecision').value);
            const showAll = tableStates.logScaleTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = canvasText();
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            
            const table = document.getElementById('logScaleTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Gap</th>
                        <th>Log(P<sub>g</sub>)</th>
                        <th>P<sub>g</sub></th>
                        <th>Prime Count</th>
                        <th>Avg Log per Prime</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const avgLogPerPrime = data.logProduct / data.count;
                
                html += `
                    <tr class="gap-row" data-gap="${gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${gap}</td>
                        <td>${data.logProduct.toFixed(precision)}</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td>${data.count}</td>
                        <td>${avgLogPerPrime.toFixed(precision)}</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateStepByStepTable() {
            const precision = parseInt(document.getElementById('stepByStepPrecision').value);
            const showAll = tableStates.stepByStepTable;
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                ctx.fillStyle = canvasText();
                ctx.font = "48px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText("No data in selected gap range", w/2, h/2);
                return;
            }
            const displayGaps = showAll ? gaps : gaps.slice(0, 5);
            const target = analysisResults.targetZeta2;
            
            const table = document.getElementById('stepByStepTableContent');
            let html = `
                <thead>
                    <tr>
                        <th>Step</th>
                        <th>Gap Added</th>
                        <th>P<sub>g</sub></th>
                        <th>Formula</th>
                        <th>Cumulative Product</th>
                        <th>Distance to π²/6</th>
                        <th>% Complete</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            displayGaps.forEach((gap, idx) => {
                const data = analysisResults.gapProducts[gap];
                const cumulative = analysisResults.progressiveProducts[idx].value;
                const distance = target - cumulative;
                const percentComplete = (cumulative / target) * 100;
                
                // Build formula string showing multiplication
                let formula = 'P₁';
                for (let i = 1; i <= idx; i++) {
                    formula += ` × P${gaps[i]}`;
                }
                
                html += `
                    <tr class="gap-row" data-gap="${gap}" style="cursor: pointer; transition: background 0.2s;" 
                        onmouseover="this.style.background='rgba(78, 205, 196, 0.1)'" 
                        onmouseout="this.style.background=''">
                        <td>${idx + 1}</td>
                        <td>${gap}</td>
                        <td>${data.product.toFixed(precision)}</td>
                        <td style="font-size: 0.85rem; color: #aaa;">${formula}</td>
                        <td>${cumulative.toFixed(precision)}</td>
                        <td>${distance.toFixed(precision)}</td>
                        <td>${percentComplete.toFixed(precision)}%</td>
                    </tr>
                `;
            });
            
            if (!showAll && gaps.length > 5) {
                html += `
                    <tr>
                        <td colspan="7" style="text-align: center; color: #888; font-style: italic;">
                            ... ${gaps.length - 5} more rows (click "Show All" to expand)
                        </td>
                    </tr>
                `;
            }
            
            // Add final target row
            html += `
                <tr style="border-top: 3px solid #ffd700; background: rgba(255, 215, 0, 0.1); font-weight: 600;">
                    <td>Target</td>
                    <td colspan="3" style="text-align: center;">ζ(2) = π²/6</td>
                    <td>${target.toFixed(precision)}</td>
                    <td>0.${'0'.repeat(precision)}</td>
                    <td>100.${'0'.repeat(precision)}%</td>
                </tr>
            `;
            
            html += '</tbody>';
            table.innerHTML = html;
        }
        
        function updateGapRatioTable() {
            if (!analysisResults) return;
            
            const table = document.getElementById('gapRatioTableContent');
            const gap2Count = analysisResults.gapProducts[2]?.count || 0;
            const gap4Count = analysisResults.gapProducts[4]?.count || 0;
            const gap6Count = analysisResults.gapProducts[6]?.count || 0;
            const gap10Count = analysisResults.gapProducts[10]?.count || 0;
            const gap12Count = analysisResults.gapProducts[12]?.count || 0;
            const totalPrimes = analysisResults.allPrimesFound - 1;
            
            // Full precision constant, li2 approximation, and per-gap singular series
            const C2_FULL = 0.6601618158468695;
            function li2(x) { const L = Math.log(x); return (x/(L*L))*(1 + 2/L + 6/(L*L) + 24/(L*L*L)); }
            const _ssMemo2 = Object.create(null);
            function singularSeries(h) {
                if (_ssMemo2[h] !== undefined) return _ssMemo2[h];
                let mult = 1.0;
                for (let p = 3; p <= h; p++) {
                    if (h % p === 0) {
                        let ip = true; for (let d=2;d*d<=p;d++) if(p%d===0){ip=false;break;}
                        if (ip) mult *= (p-1)/(p-2);
                    }
                }
                return (_ssMemo2[h] = 2 * C2_FULL * mult);
            }
            const maxPrime = analysisResults.maxPrime;
            const predictedTwins = singularSeries(2) * li2(maxPrime);
            const hlError = Math.abs(gap2Count - predictedTwins);
            const hlErrorPercent = (hlError / gap2Count) * 100;
            
            // Calculate ratios
            const ratio_2_4 = gap4Count > 0 ? gap2Count / gap4Count : 0;
            const ratio_2_6 = gap6Count > 0 ? gap2Count / gap6Count : 0;
            const ratio_4_6 = gap6Count > 0 ? gap4Count / gap6Count : 0;
            
            // Calculate percentages
            const pct2 = (gap2Count / totalPrimes) * 100;
            const pct4 = (gap4Count / totalPrimes) * 100;
            const pct6 = (gap6Count / totalPrimes) * 100;
            const pct10 = (gap10Count / totalPrimes) * 100;
            const pct12 = (gap12Count / totalPrimes) * 100;
            
            let html = `
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Value</th>
                        <th>Interpretation</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Gap 2/Gap 4 Ratio</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem; color: ${ratio_2_4 > 0.98 && ratio_2_4 < 1.02 ? '#4caf50' : '#ff6b6b'};">
                            ${ratio_2_4.toFixed(6)}
                        </td>
                        <td>${ratio_2_4 > 0.98 && ratio_2_4 < 1.02 ? 
                            '✓ Near 1.0 - supports equal density' : 
                            'Deviates from 1.0 - check at higher N'}</td>
                    </tr>
                    <tr>
                        <td><strong>Gap 2/Gap 6 Ratio</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${ratio_2_6.toFixed(6)}</td>
                        <td>Gap 6 is asymptotically ~2× <em>more</em> frequent than gap 2 (S(6) = 2×S(2))</td>
                    </tr>
                    <tr>
                        <td><strong>Gap 4/Gap 6 Ratio</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${ratio_4_6.toFixed(6)}</td>
                        <td>Cousin vs Sexy prime density</td>
                    </tr>
                    <tr style="border-top: 2px solid #2a2a4a;">
                        <td><strong>Gap 2 % of Total</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${pct2.toFixed(4)}%</td>
                        <td>${gap2Count.toLocaleString()} twin primes found</td>
                    </tr>
                    <tr>
                        <td><strong>Gap 4 % of Total</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${pct4.toFixed(4)}%</td>
                        <td>${gap4Count.toLocaleString()} cousin primes found</td>
                    </tr>
                    <tr>
                        <td><strong>Gap 6 % of Total</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${pct6.toFixed(4)}%</td>
                        <td>${gap6Count.toLocaleString()} sexy primes found</td>
                    </tr>
                    <tr>
                        <td><strong>Gap 12 % of Total</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${pct12.toFixed(4)}%</td>
                        <td>${gap12Count.toLocaleString()} primes (largest small gap)</td>
                    </tr>
                    <tr style="border-top: 2px solid #2a2a4a;">
                        <td><strong>H-L Predicted Twins (li₂)</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${Math.round(predictedTwins).toLocaleString()}</td>
                        <td>Uses S(2)·li₂(x); S(2)=2C₂≈${(2*0.6601618158468695).toFixed(8)}</td>
                    </tr>
                    <tr>
                        <td><strong>H-L Predicted Cousins (li₂)</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">${Math.round(predictedTwins).toLocaleString()}</td>
                        <td>S(4)=S(2) — identical constant, so prediction equals twin prime prediction</td>
                    </tr>
                    <tr>
                        <td><strong>Hardy-Littlewood Error</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem; color: ${hlErrorPercent < 1.0 ? '#4caf50' : hlErrorPercent < 5.0 ? '#ffb74d' : '#ff6b6b'};">
                            ${hlErrorPercent.toFixed(4)}%
                        </td>
                        <td>${hlErrorPercent < 1.0 ? '✓ Excellent match!' : hlErrorPercent < 5.0 ? 'Good agreement' : 'Check computation'}</td>
                    </tr>
                    <tr>
                        <td><strong>Twin Difference</strong></td>
                        <td style="font-family: monospace; font-size: 1.1rem;">
                            ${gap2Count > predictedTwins ? '+' : ''}${Math.round(gap2Count - predictedTwins).toLocaleString()}
                        </td>
                        <td>${gap2Count > predictedTwins ? 'More twins than predicted' : 'Fewer twins than predicted'}</td>
                    </tr>
                </tbody>
            `;
            
            table.innerHTML = html;
        }
        
        // Export functions for individual tables and charts
        function exportTableCSV(tableType) {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const maxPrime = analysisResults.maxPrime;
            let csv = '';
            let filename = '';
            
            switch(tableType) {
                case 'convergence':
                    csv = generateConvergenceCSV();
                    filename = `convergence_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'gapContrib':
                    csv = generateGapContribCSV();
                    filename = `gap_contributions_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'gapDist':
                    csv = generateGapDistCSV();
                    filename = `gap_distribution_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'percentage':
                    csv = generatePercentageCSV();
                    filename = `percentage_contributions_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'error':
                    csv = generateErrorCSV();
                    filename = `error_analysis_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'logScale':
                    csv = generateLogScaleCSV();
                    filename = `log_scale_products_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'gapRatio':
                    csv = generateGapRatioCSV();
                    filename = `gap_ratio_analysis_${maxPrime}_${timestamp}.csv`;
                    break;
                case 'stepByStep':
                    csv = generateStepByStepCSV();
                    filename = `step_by_step_${maxPrime}_${timestamp}.csv`;
                    break;
            }
            
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }
        
        function exportChartPNG_DOM(canvasId, chartName) {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            
            // Find the chart wrapper that contains both canvas and table
            const chartWrapper = document.getElementById(canvasId).closest('.chart-wrapper');
            if (!chartWrapper) {
                alert('Chart wrapper not found');
                return;
            }
            
            // Use html2canvas to capture the entire chart wrapper (canvas + table)
            html2canvas(chartWrapper, {
                scale: 2, // High quality
                backgroundColor: '#0a0a0f',
                logging: false,
                useCORS: true,
                allowTaint: true
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = `${chartName}_DOM_${analysisResults.maxPrime}_${timestamp}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            }).catch(err => {
                console.error('Export failed:', err);
                alert('Export failed. See console for details.');
            });
        }
        
        function exportChartPNG_Canvas(canvasId, chartName) {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            
            // Create composite canvas
            const compositeCanvas = document.createElement('canvas');
            const ctx = compositeCanvas.getContext('2d');
            
            // Get source chart
            const sourceCanvas = document.getElementById(canvasId);
            const chartW = sourceCanvas.width;
            const chartH = sourceCanvas.height;
            
            // Get row count from global export setting
            const rowCountSetting = document.getElementById('globalExportRows')?.value || '15';
            const maxRows = rowCountSetting === 'all' ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            
            // Calculate dynamic dimensions
            const headerH = 250;
            const statsBarH = 120;
            const tableHeaderH = 60;
            const rowHeight = 50;
            const tableH = tableHeaderH + (maxRows * rowHeight) + 100;
            const padding = 40;
            const footerSpace = 80;
            
            compositeCanvas.width = chartW;
            compositeCanvas.height = headerH + statsBarH + chartH + tableH + footerSpace;
            
            // Background
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);
            
            // Title section
            const s = analysisResults.s || 2;
            const zetaFormula = s === 2 ? `ζ(${s}) = π²/6` : `ζ(${s})`;
            const titleMap = {
                'convergenceChart': `Progressive Product Convergence to ${zetaFormula}`,
                'gapContribChart': 'Individual Gap Family Products P_g',
                'gapDistChart': 'Prime Distribution by Gap Class',
                'percentageChart': `Percentage Contribution to log(ζ(${s}))`,
                'errorChart': 'Convergence Error Analysis',
                'logScaleChart': 'Log-Scale Product Growth: log(P_g)',
                'gapRatioChart': 'Gap Ratio Analysis: Twin Prime Conjecture Evidence',
                'customGapCompareChart': 'Custom Gap Family Comparison',
                'decimalConvergenceChart': `Decimal Convergence Analysis: Weight Decay & Precision`
            };
            
            // Draw title at TOP of image
            if (canvasId !== 'customGapCompareChart') {
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 72px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(titleMap[canvasId] || 'Chart', compositeCanvas.width / 2, 90);
                
                // Author credit instead of date
                ctx.fillStyle = canvasText();
                ctx.font = '36px sans-serif';
                ctx.fillText('by Wessen Getachew', compositeCanvas.width / 2, 160);
            }
            
            // Stats summary bar
            const statsY = headerH + padding;
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(padding, statsY, compositeCanvas.width - 2 * padding, statsBarH - 2 * padding);
            
            ctx.strokeStyle = '#3a3a5a';
            ctx.lineWidth = 3;
            ctx.strokeRect(padding, statsY, compositeCanvas.width - 2 * padding, statsBarH - 2 * padding);
            
            // Stats content - 6 boxes
            const boxW = (compositeCanvas.width - 2 * padding - 5 * 20) / 6;
            const statsData = [
                { label: 'N Range', value: analysisResults.maxPrime.toLocaleString() },
                { label: 'Total Primes', value: ((analysisResults.allPrimesFound || analysisResults.totalPrimes) || analysisResults.totalPrimes).toLocaleString() },
                { label: 'Gap Families', value: analysisResults.evenGaps.length.toString() },
                { label: 'Target ζ(2)', value: analysisResults.targetZeta2.toFixed(8) },
                { label: 'Final Product', value: analysisResults.finalProduct.toFixed(8) },
                { label: 'Rel. Error', value: (analysisResults.finalRelativeError * 100).toFixed(6) + '%' }
            ];
            
            statsData.forEach((stat, idx) => {
                const x = padding + idx * (boxW + 20);
                
                ctx.fillStyle = canvasText();
                ctx.font = '28px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(stat.label, x + boxW / 2, statsY + 30);
                
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 40px monospace';
                ctx.fillText(stat.value, x + boxW / 2, statsY + 70);
            });
            
            // Draw chart
            const chartY = headerH + statsBarH;
            ctx.drawImage(sourceCanvas, 0, chartY, chartW, chartH);
            
            // Draw stats table
            const tableY = chartY + chartH + padding;
            const actualTableHeight = renderStatsTableToCanvas(ctx, canvasId, tableY, compositeCanvas.width, maxRows);
            
            // Add footer info
            const footerY = tableY + actualTableHeight + 30;
            ctx.fillStyle = window.canvasText ? window.canvasText() : '#666';
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            
            if (canvasId === 'customGapCompareChart') {
                const input = document.getElementById('compareGapsInput')?.value || '';
                const gapCount = input.split(',').filter(s => s.trim() !== '').length;
                ctx.fillText(`Comparing ${gapCount} gaps | Analysis: ${analysisResults.allPrimesFound.toLocaleString()} primes up to ${analysisResults.maxPrime.toLocaleString()}`, compositeCanvas.width / 2, footerY);
            } else if (canvasId === 'decimalConvergenceChart') {
                const gap = parseInt(document.getElementById('decimalGapSelect')?.value || 2);
                const detailLevel = document.getElementById('decimalDetailLevel')?.value || 'summary';
                const detailText = detailLevel === 'summary' ? 'First 20 primes' : detailLevel === 'detailed' ? 'First 100 primes' : 'All primes';
                ctx.fillText(`Gap ${gap} - ${detailText} | Showing ${maxRows} table rows | Analysis: ${analysisResults.totalPrimes.toLocaleString()} primes up to ${analysisResults.maxPrime.toLocaleString()}`, compositeCanvas.width / 2, footerY);
            } else {
                ctx.fillText(`Showing ${maxRows} rows | Analysis: ${analysisResults.totalPrimes.toLocaleString()} primes up to ${analysisResults.maxPrime.toLocaleString()}`, compositeCanvas.width / 2, footerY);
            }
            
            // Export
            const link = document.createElement('a');
            link.download = `${chartName}_Canvas_${analysisResults.maxPrime}_${timestamp}.png`;
            link.href = compositeCanvas.toDataURL('image/png');
            link.click();
        }
        
        function renderStatsTableToCanvas(ctx, canvasId, startY, canvasWidth, maxRows) {
            // Determine which table data to render based on canvasId
            const tableMap = {
                'convergenceChart': renderConvergenceTableData,
                'gapContribChart': renderGapContribTableData,
                'gapDistChart': renderGapDistTableData,
                'percentageChart': renderPercentageTableData,
                'errorChart': renderErrorTableData,
                'logScaleChart': renderLogScaleTableData,
                'gapRatioChart': renderGapRatioTableData,
                'customGapCompareChart': renderCustomGapCompareTableData,
                'decimalConvergenceChart': renderDecimalConvergenceTableData
            };
            
            const renderFunc = tableMap[canvasId];
            if (renderFunc) {
                return renderFunc(ctx, startY, canvasWidth, maxRows);
            }
            return 0;
        }
        
        function renderConvergenceTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                // Fallback if called without maxRows
                const rowCountSetting = document.getElementById('globalExportRows')?.value || '15';
                maxRows = rowCountSetting === 'all' ? analysisResults.progressiveProducts.length : parseInt(rowCountSetting);
            }
            
            const precision = parseInt(document.getElementById('convergencePrecision').value);
            const data = analysisResults.progressiveProducts.slice(0, maxRows);
            
            const headers = ['Gap', 'Cumulative Product', 'Log Product', 'Target ζ(2)', 'Abs Error', 'Rel Error (%)'];
            const colW = (canvasWidth - 80) / headers.length;
            
            // Header background
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            // Headers
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            // Rows
            ctx.font = '28px monospace';
            data.forEach((row, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                
                // Alternating row background
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = canvasRowAlt();
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const rowData = [
                    row.gap.toString(),
                    row.value.toFixed(precision),
                    row.logValue.toFixed(precision),
                    analysisResults.targetZeta2.toFixed(precision),
                    row.error.toExponential(precision),
                    (row.relativeError * 100).toFixed(precision)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add DISPLAYED row (last gap's actual state)
            const displayedY = startY + 60 + data.length * 50;
            ctx.fillStyle = 'rgba(78, 205, 196, 0.1)';
            ctx.fillRect(40, displayedY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, displayedY, canvasWidth - 80, 50);
            
            const lastRow = data[data.length - 1];
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 32px monospace';
            const displayedData = [
                'Displayed',
                lastRow.value.toFixed(precision),
                lastRow.logValue.toFixed(precision),
                analysisResults.targetZeta2.toFixed(precision),
                lastRow.error.toExponential(precision),
                (lastRow.relativeError * 100).toFixed(precision) + '%'
            ];
            
            displayedData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + colIdx * colW + colW / 2, displayedY + 35);
            });
            
            // Add LIMIT row (theoretical target at ∞)
            const limitY = displayedY + 50;
            ctx.fillStyle = canvasHighlight();
            ctx.fillRect(40, limitY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, limitY, canvasWidth - 80, 50);
            
            const s = analysisResults.s || 2;
            const known = getKnownZetaValue(s);
            const zetaLabel = known ? known.formula : `ζ(${s.toFixed(1)})`;
            const targetLogValue = Math.log(analysisResults.targetZeta2);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const limitData = [
                'Limit',
                analysisResults.targetZeta2.toFixed(precision),
                targetLogValue.toFixed(precision),
                analysisResults.targetZeta2.toFixed(precision),
                '0.0',
                '0.0%'
            ];
            
            limitData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + colIdx * colW + colW / 2, limitY + 35);
            });
            
            // Return actual height used (including both rows)
            const tableHeaderH = 60;
            const rowHeight = 50;
            return tableHeaderH + (data.length * rowHeight) + (2 * rowHeight); // +2 for displayed and limit rows
        }
        
        function renderGapContribTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            }
            
            const precision = parseInt(document.getElementById('gapContribPrecision').value);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const headers = ['Gap', 'Product P_g', 'Log(P_g)', 'Prime Count', 'First Primes'];
            const colWidths = [0.1, 0.2, 0.2, 0.15, 0.35];
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            let xPos = 40;
            headers.forEach((header, idx) => {
                const w = (canvasWidth - 80) * colWidths[idx];
                ctx.fillText(header, xPos + w / 2, startY + 40);
                xPos += w;
            });
            
            ctx.font = '28px monospace';
            gaps.forEach((gap, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = canvasRowAlt();
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const primes = data.primes.slice(0, 5).join(', ');
                const rowData = [
                    gap.toString(),
                    data.product.toFixed(precision),
                    data.logProduct.toFixed(precision),
                    data.count.toString(),
                    primes
                ];
                
                xPos = 40;
                rowData.forEach((cell, colIdx) => {
                    const w = (canvasWidth - 80) * colWidths[colIdx];
                    ctx.textAlign = colIdx === 4 ? 'left' : 'center';
                    const textX = colIdx === 4 ? xPos + 10 : xPos + w / 2;
                    ctx.fillText(cell, textX, y + 35);
                    xPos += w;
                });
            });
            
            // Add DISPLAYED row (cumulative totals for shown gaps only)
            const displayedY = startY + 60 + gaps.length * 50;
            ctx.fillStyle = canvasHighlight();
            ctx.fillRect(40, displayedY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, displayedY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const totalLogProduct = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.logProduct || 0), 0);
            const totalProduct = Math.exp(totalLogProduct);
            const totalPrimesDisplayed = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.count || 0), 0);
            
            ctx.textAlign = 'left';
            ctx.fillText('Displayed', 50, displayedY + 35);
            
            const displayedData = [totalProduct.toFixed(precision), totalLogProduct.toFixed(precision), totalPrimesDisplayed.toLocaleString(), 'Shown'];
            
            xPos = colWidths[0] * (canvasWidth - 80);
            displayedData.forEach((cell, colIdx) => {
                const w = (canvasWidth - 80) * colWidths[colIdx + 1];
                ctx.textAlign = colIdx === 3 ? 'left' : 'center';
                const textX = colIdx === 3 ? 40 + xPos + 10 : 40 + xPos + w / 2;
                ctx.fillText(cell, textX, displayedY + 35);
                xPos += w;
            });
            
            // Add LIMIT row (theoretical limits as gap→∞)
            const limitY = displayedY + 50;
            ctx.fillStyle = canvasPurpleHL();
            ctx.fillRect(40, limitY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, limitY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#8b5cf6';
            ctx.font = 'bold 32px monospace';
            
            ctx.textAlign = 'left';
            ctx.fillText('Limit', 50, limitY + 35);
            
            const s = analysisResults.s || 2;
            const known = getKnownZetaValue(s);
            const zetaLabel = known ? known.formula : `ζ(${s.toFixed(1)})`;
            const limitData = ['1.0', '0.0', analysisResults.totalPrimes.toLocaleString(), '—'];
            
            xPos = colWidths[0] * (canvasWidth - 80);
            limitData.forEach((cell, colIdx) => {
                const w = (canvasWidth - 80) * colWidths[colIdx + 1];
                ctx.textAlign = colIdx === 3 ? 'left' : 'center';
                const textX = colIdx === 3 ? 40 + xPos + 10 : 40 + xPos + w / 2;
                ctx.fillText(cell, textX, limitY + 35);
                xPos += w;
            });
            
            return 60 + (gaps.length * 50) + 100; // Header + rows + 2 summary rows
        }
        
        function renderGapDistTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            }
            const precision = parseInt(document.getElementById('gapDistPrecision').value);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const headers = ['Gap', 'Count', '% of Total', 'Cumulative', 'Cumulative %'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            ctx.font = '28px monospace';
            let cumulative = 0;
            gaps.forEach((gap, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                cumulative += data.count;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = canvasRowAlt();
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const percentage = (data.count / analysisResults.totalPrimes) * 100;
                const cumulativePercentage = (cumulative / analysisResults.totalPrimes) * 100;
                
                const rowData = [
                    gap.toString(),
                    data.count.toString(),
                    percentage.toFixed(precision) + '%',
                    cumulative.toString(),
                    cumulativePercentage.toFixed(precision) + '%'
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add DISPLAYED row (totals for shown gaps only)
            const displayedY = startY + 60 + gaps.length * 50;
            ctx.fillStyle = canvasHighlight();
            ctx.fillRect(40, displayedY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, displayedY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('Displayed', 50, displayedY + 35);
            
            ctx.textAlign = 'center';
            const displayedTotal = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.count || 0), 0);
            const displayedPercentage = (displayedTotal / analysisResults.totalPrimes * 100).toFixed(precision);
            const displayedData = [displayedTotal.toLocaleString(), displayedPercentage + '%', displayedTotal.toLocaleString(), displayedPercentage + '%'];
            
            displayedData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, displayedY + 35);
            });
            
            // Add LIMIT row (all primes analyzed)
            const limitY = displayedY + 50;
            ctx.fillStyle = canvasPurpleHL();
            ctx.fillRect(40, limitY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, limitY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#8b5cf6';
            ctx.font = 'bold 32px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('Limit', 50, limitY + 35);
            
            ctx.textAlign = 'center';
            const limitData = [analysisResults.totalPrimes.toLocaleString(), '100.0%', analysisResults.totalPrimes.toLocaleString(), '100.0%'];
            
            limitData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, limitY + 35);
            });
            
            return 60 + (gaps.length * 50) + 100; // Header + rows + 2 summary rows
        }
        
        function renderPercentageTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            }
            const precision = parseInt(document.getElementById('percentagePrecision').value);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const headers = ['Gap', 'Contribution %', 'Product P_g', 'Ratio', 'Log Contrib'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            ctx.font = '28px monospace';
            gaps.forEach((gap, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = canvasRowAlt();
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const percentage = analysisResults.percentageContributions[gap];
                const ratio = data.product / analysisResults.targetZeta2;
                
                const rowData = [
                    gap.toString(),
                    percentage.toFixed(precision) + '%',
                    data.product.toFixed(precision),
                    ratio.toFixed(precision),
                    data.logProduct.toFixed(precision)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add DISPLAYED row (totals for shown gaps only)
            const displayedY = startY + 60 + gaps.length * 50;
            ctx.fillStyle = canvasHighlight();
            ctx.fillRect(40, displayedY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, displayedY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const totalLogProduct = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.logProduct || 0), 0);
            const totalPercentage = gaps.reduce((sum, gap) => sum + (analysisResults.percentageContributions[gap] || 0), 0);
            const totalProduct = Math.exp(totalLogProduct);
            const totalRatio = totalProduct / analysisResults.targetZeta2;
            
            ctx.textAlign = 'left';
            ctx.fillText('Displayed', 50, displayedY + 35);
            
            ctx.textAlign = 'center';
            const displayedData = [totalPercentage.toFixed(precision) + '%', totalProduct.toFixed(precision), totalRatio.toFixed(precision), totalLogProduct.toFixed(precision)];
            
            displayedData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, displayedY + 35);
            });
            
            // Add LIMIT row (theoretical limits)
            const limitY = displayedY + 50;
            ctx.fillStyle = canvasPurpleHL();
            ctx.fillRect(40, limitY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, limitY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#8b5cf6';
            ctx.font = 'bold 32px monospace';
            
            ctx.textAlign = 'left';
            ctx.fillText('Limit', 50, limitY + 35);
            
            ctx.textAlign = 'center';
            const limitData = ['100.0%', analysisResults.targetZeta2.toFixed(precision), '1.0', '—'];
            
            limitData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, limitY + 35);
            });
            
            return 60 + (gaps.length * 50) + 100;
        }
        
        function renderErrorTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.progressiveProducts.length : parseInt(rowCountSetting);
            }
            const precision = parseInt(document.getElementById('errorPrecision').value);
            const data = analysisResults.progressiveProducts.slice(0, maxRows);
            
            const headers = ['Gap', 'Product', 'Abs Error', 'Rel Error', 'Log10(Error)'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            ctx.font = '28px monospace';
            data.forEach((row, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = canvasRowAlt();
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const logError = Math.log10(row.relativeError);
                
                const rowData = [
                    row.gap.toString(),
                    row.value.toFixed(precision),
                    row.error.toExponential(precision),
                    (row.relativeError * 100).toFixed(precision) + '%',
                    logError.toFixed(precision)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add DISPLAYED row (last gap's actual state)
            const displayedY = startY + 60 + data.length * 50;
            ctx.fillStyle = 'rgba(78, 205, 196, 0.1)';
            ctx.fillRect(40, displayedY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, displayedY, canvasWidth - 80, 50);
            
            const lastRow = data[data.length - 1];
            const lastLogError = Math.log10(lastRow.relativeError);
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 32px monospace';
            
            ctx.textAlign = 'left';
            ctx.fillText('Displayed', 50, displayedY + 35);
            
            ctx.textAlign = 'center';
            const displayedData = [
                lastRow.value.toFixed(precision),
                lastRow.error.toExponential(precision),
                (lastRow.relativeError * 100).toFixed(precision) + '%',
                lastLogError.toFixed(precision)
            ];
            
            displayedData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, displayedY + 35);
            });
            
            // Add LIMIT row (theoretical target)
            const limitY = displayedY + 50;
            ctx.fillStyle = canvasHighlight();
            ctx.fillRect(40, limitY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, limitY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            
            ctx.textAlign = 'left';
            ctx.fillText('Limit', 50, limitY + 35);
            
            ctx.textAlign = 'center';
            const limitData = [analysisResults.targetZeta2.toFixed(precision), '0.0', '0.0%', '—'];
            
            limitData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, limitY + 35);
            });
            
            return 60 + (data.length * 50) + 100;
        }
        
        function renderLogScaleTableData(ctx, startY, canvasWidth, maxRows) {
            if (!maxRows) {
                const rowCountSetting = document.getElementById("globalExportRows")?.value || "15";
                maxRows = rowCountSetting === "all" ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            }
            const precision = parseInt(document.getElementById('logScalePrecision').value);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const headers = ['Gap', 'Log(P_g)', 'P_g', 'Count', 'Avg/Prime'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            ctx.font = '28px monospace';
            gaps.forEach((gap, rowIdx) => {
                const y = startY + 60 + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = canvasRowAlt();
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const avgLogPerPrime = data.logProduct / data.count;
                
                const rowData = [
                    gap.toString(),
                    data.logProduct.toFixed(precision),
                    data.product.toFixed(precision),
                    data.count.toString(),
                    avgLogPerPrime.toFixed(precision)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            // Add DISPLAYED row (totals for shown gaps only)
            const displayedY = startY + 60 + gaps.length * 50;
            ctx.fillStyle = canvasHighlight();
            ctx.fillRect(40, displayedY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, displayedY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px monospace';
            const totalLog = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.logProduct || 0), 0);
            const totalCount = gaps.reduce((sum, gap) => sum + (analysisResults.gapProducts[gap]?.count || 0), 0);
            const totalProduct = Math.exp(totalLog);
            const avgLogPerPrime = totalCount > 0 ? (totalLog / totalCount).toFixed(precision) : '—';
            
            ctx.textAlign = 'left';
            ctx.fillText('Displayed', 50, displayedY + 35);
            
            ctx.textAlign = 'center';
            const displayedData = [totalLog.toFixed(precision), totalProduct.toFixed(precision), totalCount.toLocaleString(), avgLogPerPrime];
            
            displayedData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, displayedY + 35);
            });
            
            // Add LIMIT row (theoretical limits)
            const limitY = displayedY + 50;
            ctx.fillStyle = canvasPurpleHL();
            ctx.fillRect(40, limitY, canvasWidth - 80, 50);
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, limitY, canvasWidth - 80, 50);
            
            ctx.fillStyle = '#8b5cf6';
            ctx.font = 'bold 32px monospace';
            
            ctx.textAlign = 'left';
            ctx.fillText('Limit', 50, limitY + 35);
            
            ctx.textAlign = 'center';
            const limitData = ['0.0', '1.0', analysisResults.totalPrimes.toLocaleString(), '—'];
            
            limitData.forEach((cell, colIdx) => {
                ctx.fillText(cell, 40 + (colIdx + 1) * colW + colW / 2, limitY + 35);
            });
            
            return 60 + (gaps.length * 50) + 100;
        }
        
        function renderGapRatioTableData(ctx, startY, canvasWidth, maxRows) {
            const precision = parseInt(document.getElementById('gapRatioPrecision')?.value || 6);
            
            // Calculate all the statistics
            const gap2Count = analysisResults.gapProducts[2]?.count || 0;
            const gap4Count = analysisResults.gapProducts[4]?.count || 0;
            const gap6Count = analysisResults.gapProducts[6]?.count || 0;
            const gap10Count = analysisResults.gapProducts[10]?.count || 0;
            const gap12Count = analysisResults.gapProducts[12]?.count || 0;
            const totalPrimes = analysisResults.allPrimesFound - 1;
            
            const C2_FULL = 0.6601618158468695;
            const maxPrime = analysisResults.maxPrime;
            function li2scr(x) { const L = Math.log(x); return (x/(L*L))*(1 + 2/L + 6/(L*L) + 24/(L*L*L)); }
            function singSerScr(h) {
                let mult = 1.0;
                for (let p = 3; p <= h; p++) {
                    if (h % p === 0) {
                        let ip = true; for (let d=2;d*d<=p;d++) if(p%d===0){ip=false;break;}
                        if (ip) mult *= (p-1)/(p-2);
                    }
                }
                return 2 * C2_FULL * mult;
            }
            const predictedTwins = singSerScr(2) * li2scr(maxPrime);
            
            const ratio_2_4 = gap4Count > 0 ? gap2Count / gap4Count : 0;
            const ratio_2_6 = gap6Count > 0 ? gap2Count / gap6Count : 0;
            const ratio_4_6 = gap6Count > 0 ? gap4Count / gap6Count : 0;
            
            const pct2 = (gap2Count / totalPrimes) * 100;
            const pct4 = (gap4Count / totalPrimes) * 100;
            const pct6 = (gap6Count / totalPrimes) * 100;
            const pct10 = (gap10Count / totalPrimes) * 100;
            const pct12 = (gap12Count / totalPrimes) * 100;
            
            const hlError = Math.abs(gap2Count - predictedTwins);
            const hlErrorPercent = (hlError / gap2Count) * 100;
            
            // Table 1: Gap Ratios
            const headers1 = ['Ratio', 'Value', 'Convergence'];
            const colW1 = (canvasWidth - 80) / 3;
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ff4081';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Count Ratios', canvasWidth / 2, startY + 40);
            
            startY += 60;
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 50);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 30px sans-serif';
            headers1.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW1 + colW1 / 2, startY + 35);
            });
            
            startY += 50;
            
            const ratioData = [
                ['Gap 2 / Gap 4', ratio_2_4, ratio_2_4 > 0.98 && ratio_2_4 < 1.02 ? '✓ Near 1.0' : 'Diverging'],
                ['Gap 2 / Gap 6', ratio_2_6, '—'],
                ['Gap 4 / Gap 6', ratio_4_6, '—']
            ];
            
            ctx.font = '28px monospace';
            ratioData.forEach((row, rowIdx) => {
                const y = startY + rowIdx * 50;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = canvasRowAlt();
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                ctx.textAlign = 'left';
                ctx.fillText(row[0], 60, y + 35);
                
                ctx.textAlign = 'center';
                ctx.fillText(row[1].toFixed(precision), 40 + colW1 + colW1 / 2, y + 35);
                ctx.fillText(row[2], 40 + 2 * colW1 + colW1 / 2, y + 35);
            });
            
            startY += ratioData.length * 50 + 60;
            
            // Table 2: Gap Percentages
            const headers2 = ['Gap', 'Count', '% of Total'];
            const colW2 = (canvasWidth - 80) / 3;
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Family Percentages', canvasWidth / 2, startY + 40);
            
            startY += 60;
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 50);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 30px sans-serif';
            headers2.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW2 + colW2 / 2, startY + 35);
            });
            
            startY += 50;
            
            const pctData = [
                [2, gap2Count, pct2],
                [4, gap4Count, pct4],
                [6, gap6Count, pct6],
                [10, gap10Count, pct10],
                [12, gap12Count, pct12]
            ];
            
            ctx.font = '28px monospace';
            pctData.forEach((row, rowIdx) => {
                const y = startY + rowIdx * 50;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = canvasRowAlt();
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                ctx.textAlign = 'center';
                ctx.fillText(row[0].toString(), 40 + colW2 / 2, y + 35);
                ctx.fillText(row[1].toLocaleString(), 40 + colW2 + colW2 / 2, y + 35);
                ctx.fillText(row[2].toFixed(2) + '%', 40 + 2 * colW2 + colW2 / 2, y + 35);
            });
            
            startY += pctData.length * 50 + 60;
            
            // Table 3: Hardy-Littlewood Analysis
            const headers3 = ['Metric', 'Value'];
            const colW3 = (canvasWidth - 80) / 2;
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffb74d';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Hardy-Littlewood Prediction Analysis', canvasWidth / 2, startY + 40);
            
            startY += 60;
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 50);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 30px sans-serif';
            headers3.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW3 + colW3 / 2, startY + 35);
            });
            
            startY += 50;
            
            const hlData = [
                ['Twin Prime Count (Observed)', gap2Count.toLocaleString()],
                ['Twin Prime Count (Predicted, li₂)', Math.round(predictedTwins).toLocaleString()],
                ['Absolute Error', Math.round(hlError).toLocaleString()],
                ['Relative Error', hlErrorPercent.toFixed(3) + '%'],
                ['Twin Prime Constant C₂', C2_FULL.toFixed(10)]
            ];
            
            ctx.font = '28px monospace';
            hlData.forEach((row, rowIdx) => {
                const y = startY + rowIdx * 50;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = canvasRowAlt();
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                ctx.textAlign = 'left';
                ctx.fillText(row[0], 60, y + 35);
                
                ctx.textAlign = 'center';
                ctx.fillText(row[1], 40 + colW3 + colW3 / 2, y + 35);
            });
            
            startY += hlData.length * 50;
            
            return startY - arguments[1] + 60; // Return total height used
        }
        
        function renderDecimalConvergenceTableData(ctx, startY, canvasWidth, maxRows) {
            // Get selected gap from dropdown, default to 2
            const gap = parseInt(document.getElementById('decimalGapSelect')?.value || 2);
            const precision = parseInt(document.getElementById('decimalConvergencePrecision')?.value || 12);
            const gapData = analysisResults.gapProducts[gap];
            
            if (!gapData || !gapData.primes) {
                return 0;
            }
            
            const originalStartY = startY;
            const numPrimes = Math.min(maxRows || 20, gapData.primes.length);
            const primes = gapData.primes.slice(0, numPrimes);
            
            // Title
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#22c55e';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Gap ${gap} - Per-Prime Marginal Contribution (First ${numPrimes})`, canvasWidth / 2, startY + 40);
            
            startY += 60;
            
            // Headers
            const headers = ['#', 'Prime', 'Factor', 'Contrib.', 'Cumulative', 'Decimal'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 50);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 28px sans-serif';
            ctx.textAlign = 'center';
            
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 35);
            });
            
            startY += 50;
            
            // Data rows
            let cumProduct = 1;
            ctx.font = '24px monospace';
            
            primes.forEach((p, idx) => {
                const factor = (p * p) / (p * p - 1);
                const prevProduct = cumProduct;
                cumProduct *= factor;
                
                const contribution = factor - 1;
                const decimalChange = Math.abs(cumProduct - prevProduct);
                const decimalPlace = decimalChange > 0 ? Math.ceil(-Math.log10(decimalChange)) : 15;
                
                const y = startY + idx * 45;
                
                // Alternate row background + highlight first 5
                if (idx < 5) {
                    ctx.fillStyle = 'rgba(34, 197, 94, 0.1)';
                    ctx.fillRect(40, y, canvasWidth - 80, 45);
                } else if (idx % 2 === 0) {
                    ctx.fillStyle = canvasRowAlt();
                    ctx.fillRect(40, y, canvasWidth - 80, 45);
                }
                
                ctx.fillStyle = idx < 5 ? '#4ade80' : '#e0e0e0';
                ctx.textAlign = 'center';
                
                // Index
                ctx.fillText((idx + 1).toString(), 40 + 0 * colW + colW / 2, y + 32);
                // Prime
                ctx.fillText(p.toLocaleString(), 40 + 1 * colW + colW / 2, y + 32);
                // Factor
                const displayPrecision = Math.min(precision, 9); // Canvas display limited to 9 for space
                ctx.fillText(factor.toFixed(displayPrecision), 40 + 2 * colW + colW / 2, y + 32);
                // Contribution
                ctx.fillText(contribution.toExponential(2), 40 + 3 * colW + colW / 2, y + 32);
                // Cumulative Product
                ctx.fillText(cumProduct.toFixed(displayPrecision), 40 + 4 * colW + colW / 2, y + 32);
                // Decimal Places
                ctx.fillStyle = decimalPlace > 10 ? '#22c55e' : '#ffd700';
                ctx.fillText(`${Math.min(decimalPlace, 15)}+`, 40 + 5 * colW + colW / 2, y + 32);
            });
            
            startY += primes.length * 45 + 20;
            
            // Add summary row
            const firstPrime = primes[0];
            const lastPrime = primes[primes.length - 1];
            const firstFactor = (firstPrime * firstPrime) / (firstPrime * firstPrime - 1);
            const lastFactor = (lastPrime * lastPrime) / (lastPrime * lastPrime - 1);
            const firstContrib = ((firstFactor - 1) * 100);
            const lastContrib = ((lastFactor - 1) * 100);
            const weightRatio = firstContrib / lastContrib;
            
            // Summary box background
            ctx.fillStyle = canvasHighlight();
            ctx.fillRect(40, startY, canvasWidth - 80, 120);
            
            // Border
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 3;
            ctx.strokeRect(40, startY, canvasWidth - 80, 120);
            
            // Summary title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Summary:', 60, startY + 35);
            
            // Summary content
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '26px sans-serif';
            ctx.fillText(`First prime (p=${firstPrime}): Contributes ${firstContrib.toFixed(4)}% increase`, 60, startY + 70);
            ctx.fillText(`Last prime (p=${lastPrime}): Contributes ${lastContrib.toExponential(4)}% increase`, 60, startY + 100);
            
            ctx.fillStyle = '#4ade80';
            ctx.font = 'bold 26px sans-serif';
            ctx.fillText(`Weight ratio: First/Last = ${weightRatio.toExponential(2)}×`, canvasWidth - 500, startY + 85);
            
            startY += 120 + 40;
            
            return startY - originalStartY;
        }
        
        function renderCustomGapCompareTableData(ctx, startY, canvasWidth, maxRows) {
            // Get selected gaps from input
            const input = document.getElementById('compareGapsInput')?.value || '';
            const selectedGaps = input.split(',')
                .map(s => s.trim())
                .filter(s => s !== '')
                .map(s => parseInt(s))
                .filter(n => !isNaN(n) && n >= 0 && analysisResults.gapProducts[n]);
            
            if (selectedGaps.length === 0) {
                // No gaps selected, return minimal height
                return 100;
            }
            
            // Limit to maxRows if provided
            const rowCountSetting = document.getElementById('globalExportRows')?.value || 'all';
            const displayGaps = (rowCountSetting === 'all') ? selectedGaps : selectedGaps.slice(0, parseInt(rowCountSetting));
            
            const precision = parseInt(document.getElementById('customGapComparePrecision')?.value || 6);
            const totalPrimes = analysisResults.allPrimesFound - 1;
            
            const headers = ['Gap', 'Prime Count', '% of Total', 'Product P_g', 'Log(P_g)', 'Avg Prime'];
            const colW = (canvasWidth - 80) / headers.length;
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(40, startY, canvasWidth - 80, 60);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 28px sans-serif'; // Reduced from 32px to match smaller data
            ctx.textAlign = 'center';
            headers.forEach((header, idx) => {
                ctx.fillText(header, 40 + idx * colW + colW / 2, startY + 40);
            });
            
            startY += 60;
            
            ctx.font = '24px monospace'; // Reduced from 28px
            displayGaps.forEach((gap, rowIdx) => {
                const y = startY + rowIdx * 50;
                const data = analysisResults.gapProducts[gap];
                const pct = (data.count / totalPrimes) * 100;
                const avgPrime = data.primes.reduce((a, b) => a + b, 0) / data.primes.length;
                
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = canvasRowAlt();
                    ctx.fillRect(40, y, canvasWidth - 80, 50);
                }
                
                ctx.fillStyle = '#e0e0e0';
                
                // Format product - use scientific notation if very close to 1
                let productStr;
                if (Math.abs(data.product - 1.0) < 0.0001) {
                    // Very close to 1, show deviation
                    const deviation = data.product - 1.0;
                    productStr = `1+${deviation.toExponential(2)}`;
                } else {
                    productStr = data.product.toFixed(Math.min(4, precision));
                }
                
                const rowData = [
                    gap.toString(),
                    data.count.toLocaleString(),
                    pct.toFixed(Math.min(4, precision)) + '%',
                    productStr,
                    data.logProduct.toFixed(Math.min(4, precision)),
                    avgPrime.toFixed(0)
                ];
                
                rowData.forEach((cell, colIdx) => {
                    ctx.textAlign = 'center';
                    ctx.fillText(cell, 40 + colIdx * colW + colW / 2, y + 35);
                });
            });
            
            startY += displayGaps.length * 50;
            
            // Add summary row if not showing all
            if (selectedGaps.length > displayGaps.length) {
                ctx.fillStyle = canvasHighlight();
                ctx.fillRect(40, startY, canvasWidth - 80, 50);
                
                ctx.fillStyle = '#ffd700';
                ctx.font = 'italic 28px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`... ${selectedGaps.length - displayGaps.length} more gaps (adjust "Data Rows" setting to see all)`, canvasWidth / 2, startY + 35);
                startY += 50;
            }
            
            return startY - arguments[1] + 60;
        }
        
        function generateConvergenceCSV() {
            const precision = parseInt(document.getElementById('convergencePrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Progressive Convergence Analysis\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset presents the progressive convergence of the gap-class decomposition\n';
            csv += 'of the Riemann zeta function at s=2. By partitioning the Euler product according\n';
            csv += 'to prime gap classes, showing how each gap family P_g contributes to the final\n';
            csv += 'value of pi^2/6. The cumulative product demonstrates geometric convergence as\n';
            csv += 'additional gap families are incorporated into the decomposition.\n\n';
            
            csv += 'METHODOLOGY:\n';
            csv += 'For each even gap g, we compute P_g = product over all primes p with gap(p)=g of p^2/(p^2-1)\n';
            csv += 'The progressive product tracks: zeta(2) = P_1 × P_2 × P_4 × P_6 × ...\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime Analyzed:,${analysisResults.maxPrime}\n`;
            csv += `Total Primes Found:,${(analysisResults.allPrimesFound || analysisResults.totalPrimes)}\n`;
            csv += `Number of Gap Families:,${analysisResults.evenGaps.length}\n`;
            csv += `Target Value (pi^2/6):,${analysisResults.targetZeta2}\n`;
            csv += `Final Computed Product:,${analysisResults.finalProduct}\n`;
            csv += `Final Absolute Error:,${analysisResults.finalError}\n`;
            csv += `Final Relative Error:,${analysisResults.finalRelativeError}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Cumulative Product,Log Product,Target zeta(2),Absolute Error,Relative Error (%)\n';
            
            analysisResults.progressiveProducts.forEach(row => {
                csv += `${row.gap},${row.value.toFixed(precision)},${row.logValue.toFixed(precision)},`;
                csv += `${analysisResults.targetZeta2.toFixed(precision)},${row.error.toExponential(precision)},`;
                csv += `${(row.relativeError * 100).toFixed(precision)}\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateGapContribCSV() {
            const precision = parseInt(document.getElementById('gapContribPrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Individual Gap Family Products\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset contains the individual product values P_g for each gap family.\n';
            csv += 'Each P_g represents the contribution of all primes with forward gap g to the\n';
            csv += 'overall Euler product. The data includes prime counts, product values, logarithmic\n';
            csv += 'contributions, and the first primes in each family for verification and further analysis.\n\n';
            
            csv += 'FORMULA:\n';
            csv += 'P_g = product over all primes p where gap(p)=g of [p^2 / (p^2 - 1)]\n';
            csv += 'where gap(p) = next_prime(p) - p\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Total Primes:,${(analysisResults.allPrimesFound || analysisResults.totalPrimes)}\n`;
            csv += `Total Gap Families:,${analysisResults.evenGaps.length}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Product P_g,Log(P_g),Prime Count,% of Total Primes,All Primes in Family\n';
            
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const pct = (data.count / analysisResults.totalPrimes * 100).toFixed(4);
                const primes = (data.primes || []).join(' ');
                csv += `${gap},${data.product.toFixed(precision)},${data.logProduct.toFixed(precision)},`;
                csv += `${data.count},${pct}%,"${primes}"\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateGapDistCSV() {
            const precision = parseInt(document.getElementById('gapDistPrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Prime Distribution by Gap Class\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset analyzes how primes distribute across different gap classes.\n';
            csv += 'For each even gap g, counts how many primes have forward gap g, computes\n';
            csv += 'the percentage of total primes this represents, and track cumulative statistics.\n';
            csv += 'This data is essential for understanding prime constellation frequencies and\n';
            csv += 'testing conjectures about gap distribution (e.g., Twin Prime Conjecture).\n\n';
            
            csv += 'DEFINITIONS:\n';
            csv += '- Gap g: The difference between consecutive primes (p_n+1 - p_n)\n';
            csv += '- Count: Number of primes p where gap(p) = g\n';
            csv += '- Percentage: (Count / Total Primes) × 100\n';
            csv += '- Cumulative: Running total of primes accounted for\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Total Primes Analyzed:,${(analysisResults.allPrimesFound || analysisResults.totalPrimes)}\n`;
            csv += `Distinct Gap Families:,${analysisResults.evenGaps.length}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Prime Count,Percentage of Total,Cumulative Count,Cumulative Percentage\n';
            
            let cumulative = 0;
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                cumulative += data.count;
                const percentage = (data.count / analysisResults.totalPrimes) * 100;
                const cumulativePercentage = (cumulative / analysisResults.totalPrimes) * 100;
                
                csv += `${gap},${data.count},${percentage.toFixed(precision)}%,`;
                csv += `${cumulative},${cumulativePercentage.toFixed(precision)}%\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generatePercentageCSV() {
            const precision = parseInt(document.getElementById('percentagePrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Percentage Contribution Analysis\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset quantifies the relative contribution of each gap family to the\n';
            csv += 'final value of zeta(2) = pi^2/6. Contributions are measured logarithmically\n';
            csv += 'since the Euler product is multiplicative. The data reveals which gap classes\n';
            csv += 'dominate the convergence and how contribution scales with gap size.\n\n';
            
            csv += 'METHODOLOGY:\n';
            csv += 'Contribution percentage = [log(P_g) / log(zeta(2))] × 100\n';
            csv += 'This measures what fraction of the logarithmic sum comes from each gap class.\n';
            csv += 'Ratio = P_g / zeta(2) shows the multiplicative contribution.\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Target zeta(2):,${analysisResults.targetZeta2}\n`;
            csv += `Final Product:,${analysisResults.finalProduct}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Contribution to log(zeta(2)) (%),Product P_g,Ratio to zeta(2),Log Contribution\n';
            
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const percentage = analysisResults.percentageContributions[gap];
                const ratio = data.product / analysisResults.targetZeta2;
                
                csv += `${gap},${percentage.toFixed(precision)}%,${data.product.toFixed(precision)},`;
                csv += `${ratio.toFixed(precision)},${data.logProduct.toFixed(precision)}\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateErrorCSV() {
            const precision = parseInt(document.getElementById('errorPrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Convergence Error Analysis\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset tracks the convergence error as additional gap families are\n';
            csv += 'incorporated into the decomposition. Multiple error metrics are provided:\n';
            csv += 'absolute error, relative error, logarithmic error, and error reduction rate.\n';
            csv += 'The data demonstrates geometric convergence to pi^2/6 and can be used to\n';
            csv += 'estimate asymptotic convergence rates.\n\n';
            
            csv += 'ERROR DEFINITIONS:\n';
            csv += '- Absolute Error: |Product - pi^2/6|\n';
            csv += '- Relative Error: Absolute Error / pi^2/6\n';
            csv += '- Log10(Error): Logarithmic scale for visualization\n';
            csv += '- Error Reduction: Percentage decrease from previous step\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Target zeta(2):,${analysisResults.targetZeta2}\n`;
            csv += `Final Relative Error:,${(analysisResults.finalRelativeError * 100).toFixed(precision)}%\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Product Value,Absolute Error,Relative Error (%),Log10(Error),Error Reduction (%)\n';
            
            const data = analysisResults.progressiveProducts;
            data.forEach((row, idx) => {
                const logError = Math.log10(row.relativeError);
                const prevError = idx > 0 ? data[idx - 1].relativeError : row.relativeError;
                const errorReduction = idx > 0 ? ((prevError - row.relativeError) / prevError * 100) : 0;
                
                csv += `${row.gap},${row.value.toFixed(precision)},${row.error.toExponential(precision)},`;
                csv += `${(row.relativeError * 100).toFixed(precision)}%,${logError.toFixed(precision)},`;
                csv += `${errorReduction.toFixed(precision)}%\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateLogScaleCSV() {
            const precision = parseInt(document.getElementById('logScalePrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Logarithmic Product Analysis\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset presents logarithmic analysis of gap family products.\n';
            csv += 'Working in log space reveals linear patterns that may be obscured in\n';
            csv += 'multiplicative form. The average log contribution per prime in each\n';
            csv += 'gap family can reveal scaling relationships and potential closed-form\n';
            csv += 'expressions for P_g involving pi or other fundamental constants.\n\n';
            
            csv += 'ANALYTICAL VALUE:\n';
            csv += 'Log-scale analysis is crucial for:\n';
            csv += '- Detecting power-law relationships in P_g vs g\n';
            csv += '- Identifying potential pi-based formulas for individual gap products\n';
            csv += '- Computing asymptotic behavior as g → infinity\n';
            csv += '- Stable numerical analysis of very small/large products\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Total Gap Families:,${analysisResults.evenGaps.length}\n`;
            csv += `log(zeta(2)):,${Math.log(analysisResults.targetZeta2).toFixed(precision)}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Gap,Log(P_g),P_g,Prime Count,Average Log per Prime,Log Density\n';
            
            analysisResults.evenGaps.forEach(gap => {
                const data = analysisResults.gapProducts[gap];
                const avgLogPerPrime = data.logProduct / data.count;
                const logDensity = data.logProduct / gap;
                
                csv += `${gap},${data.logProduct.toFixed(precision)},${data.product.toFixed(precision)},`;
                csv += `${data.count},${avgLogPerPrime.toFixed(precision)},${logDensity.toFixed(precision)}\n`;
            });
            
            csv += '\n=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateGapRatioCSV() {
            const precision = parseInt(document.getElementById('gapRatioPrecision')?.value || 6);
            let csv = '=================================================\n';
            csv += 'GAP RATIO ANALYSIS: TWIN PRIME CONJECTURE EVIDENCE\n';
            csv += 'Hardy-Littlewood Equal Density Hypothesis Test\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset tests the Hardy-Littlewood conjecture that twin primes (gap 2)\n';
            csv += 'and cousin primes (gap 4) have equal asymptotic density. If true, the ratio\n';
            csv += 'Count(gap=2)/Count(gap=4) should approach 1.0 as N → ∞, providing strong\n';
            csv += 'computational evidence for infinite twin primes.\n\n';
            
            csv += 'THEORETICAL FOUNDATION:\n';
            csv += 'Hardy-Littlewood Conjecture B: the number of prime pairs (p, p+h) up to x is:\n';
            csv += '  π_h(x) ~ S(h) · li₂(x)  where  li₂(x) ≈ x/ln²(x)·(1 + 2/ln(x) + ...)\n';
            csv += 'The singular series S(h) = 2·C₂ · ∏_{odd prime p|h} (p-1)/(p-2)\n';
            csv += 'Key values: S(2)=S(4)=S(8)=2·C₂≈1.3203  S(6)=S(12)=4·C₂≈2.6406\n';
            csv += 'IMPORTANT: Gap 6 is asymptotically TWICE as frequent as gap 2 or 4 (not equal).\n';
            csv += 'Only gaps 2 and 4 are predicted to have equal asymptotic density.\n\n';
            
            const gap2Count = analysisResults.gapProducts[2]?.count || 0;
            const gap4Count = analysisResults.gapProducts[4]?.count || 0;
            const gap6Count = analysisResults.gapProducts[6]?.count || 0;
            const gap10Count = analysisResults.gapProducts[10]?.count || 0;
            const gap12Count = analysisResults.gapProducts[12]?.count || 0;
            const totalPrimes = analysisResults.allPrimesFound - 1;
            
            const C2_FULL = 0.6601618158468695;
            const maxPrime = analysisResults.maxPrime;
            function li2csv(x) { const L = Math.log(x); return (x/(L*L))*(1 + 2/L + 6/(L*L) + 24/(L*L*L)); }
            function singularSeriesCSV(h) {
                let mult = 1.0;
                for (let p = 3; p <= h; p++) {
                    if (h % p === 0) {
                        let ip = true; for (let d=2;d*d<=p;d++) if(p%d===0){ip=false;break;}
                        if (ip) mult *= (p-1)/(p-2);
                    }
                }
                return 2 * C2_FULL * mult;
            }
            const predictedTwins = singularSeriesCSV(2) * li2csv(maxPrime);
            
            const ratio_2_4 = gap4Count > 0 ? gap2Count / gap4Count : 0;
            const ratio_2_6 = gap6Count > 0 ? gap2Count / gap6Count : 0;
            const ratio_4_6 = gap6Count > 0 ? gap4Count / gap6Count : 0;
            
            const pct2 = (gap2Count / totalPrimes) * 100;
            const pct4 = (gap4Count / totalPrimes) * 100;
            const pct6 = (gap6Count / totalPrimes) * 100;
            const pct10 = (gap10Count / totalPrimes) * 100;
            const pct12 = (gap12Count / totalPrimes) * 100;
            
            const hlError = Math.abs(gap2Count - predictedTwins);
            const hlErrorPercent = (hlError / gap2Count) * 100;
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${maxPrime.toLocaleString()}\n`;
            csv += `Total Primes Analyzed:,${totalPrimes.toLocaleString()}\n`;
            csv += `Twin Prime Constant C₂ (full):,${C2_FULL.toFixed(16)}\n`;
            csv += `S(2) = S(4) = 2·C₂:,${(2*C2_FULL).toFixed(10)}\n`;
            csv += `S(6) = S(12) = 4·C₂:,${(4*C2_FULL).toFixed(10)}\n\n`;
            
            csv += 'GAP COUNT RATIOS:\n';
            csv += 'Ratio,Value,Expected limit,Interpretation\n';
            csv += `Gap 2 / Gap 4,${ratio_2_4.toFixed(precision)},1.0000,${ratio_2_4 > 0.98 && ratio_2_4 < 1.02 ? '✓ Near 1.0 - S(2)=S(4) confirmed' : 'Check at higher N'}\n`;
            csv += `Gap 2 / Gap 6,${ratio_2_6.toFixed(precision)},0.5000,Gap 6 is 2x more frequent (S(6)=2·S(2)) - ratio converges to 0.5\n`;
            csv += `Gap 4 / Gap 6,${ratio_4_6.toFixed(precision)},0.5000,Same: S(4)=S(2) so gap4/gap6 also converges to 0.5\n\n`;
            
            csv += 'GAP FAMILY STATISTICS:\n';
            csv += 'Gap,Count,Percentage of Total,S(h),Asymptotic frequency relative to gap 2,Note\n';
            csv += `2,${gap2Count.toLocaleString()},${pct2.toFixed(4)}%,${(2*C2_FULL).toFixed(6)},1.0x baseline,Twin Primes\n`;
            csv += `4,${gap4Count.toLocaleString()},${pct4.toFixed(4)}%,${(2*C2_FULL).toFixed(6)},1.0x (equal to gap 2),Cousin Primes\n`;
            csv += `6,${gap6Count.toLocaleString()},${pct6.toFixed(4)}%,${(4*C2_FULL).toFixed(6)},2.0x more frequent,Sexy Primes\n`;
            csv += `10,${gap10Count.toLocaleString()},${pct10.toFixed(4)}%,${(8/3*2*C2_FULL).toFixed(6)},4/3x more frequent,\n`;
            csv += `12,${gap12Count.toLocaleString()},${pct12.toFixed(4)}%,${(4*C2_FULL).toFixed(6)},2.0x more frequent,\n\n`;
            
            csv += 'HARDY-LITTLEWOOD PREDICTION ANALYSIS (using li₂ approximation):\n';
            csv += 'Formula: π₂(x) ~ S(2)·li₂(x)  where li₂(x)=x/ln²(x)·(1+2/ln(x)+6/ln²(x)+24/ln³(x))\n';
            csv += 'Metric,Value\n';
            csv += `Twin Primes Observed,${gap2Count.toLocaleString()}\n`;
            csv += `Twin Primes Predicted (H-L li₂),${Math.round(predictedTwins).toLocaleString()}\n`;
            csv += `Absolute Error,${Math.round(hlError).toLocaleString()}\n`;
            csv += `Relative Error,${hlErrorPercent.toFixed(precision)}%\n`;
            csv += `Difference (Observed - Predicted),${gap2Count > predictedTwins ? '+' : ''}${Math.round(gap2Count - predictedTwins).toLocaleString()}\n\n`;
            
            csv += 'INTERPRETATION:\n';
            if (ratio_2_4 > 0.98 && ratio_2_4 < 1.02) {
                csv += '✓ Gap 2/Gap 4 ratio near 1.0 — confirms S(2)=S(4), supporting HL equal-density prediction\n';
            } else {
                csv += '! Gap 2/Gap 4 ratio deviates from 1.0 — try larger N for convergence\n';
            }
            csv += `✓ Gap 2/Gap 6 ratio converging toward 0.5 (currently ${ratio_2_6.toFixed(4)}) — confirms S(6)=2·S(2)\n`;
            if (hlErrorPercent < 1.0) {
                csv += '✓ H-L li₂ formula predicts twin prime count with <1% error — excellent\n';
            } else if (hlErrorPercent < 5.0) {
                csv += '✓ H-L li₂ formula shows good agreement (<5% error)\n';
            } else {
                csv += `Note: ${hlErrorPercent.toFixed(2)}% error — at small N the simple formula underestimates; use larger N\n`;
            }
            csv += '\nCONCLUSION:\n';
            csv += 'Gap 2/Gap 4 ratio converges to 1.0 (equal density, same S constant).\n';
            csv += 'Gap 2/Gap 6 ratio converges to 0.5 (gap 6 twice as frequent, S(6)=2·S(2)).\n';
            csv += 'The H-L li₂ prediction matches observed twin prime counts within ~1% at large N.\n\n';
            
            csv += '=================================================\n';
            csv += 'END OF DATASET\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function generateStepByStepCSV() {
            const precision = parseInt(document.getElementById('stepByStepPrecision').value);
            let csv = '=================================================\n';
            csv += 'GAP-CLASS DECOMPOSITION OF ZETA(2) = PI^2/6\n';
            csv += 'Step-by-Step Accumulation Process\n';
            csv += '=================================================\n\n';
            
            csv += 'ABSTRACT:\n';
            csv += 'This dataset provides a sequential view of how the gap-class decomposition\n';
            csv += 'builds toward pi^2/6. Each row shows the addition of one gap family to the\n';
            csv += 'cumulative product, demonstrating the geometric convergence process step by step.\n';
            csv += 'The formula column explicitly shows which gap families have been multiplied together.\n\n';
            
            csv += 'INTERPRETATION GUIDE:\n';
            csv += '- Step: Sequential order of gap family addition\n';
            csv += '- Gap Added: The gap g being incorporated in this step\n';
            csv += '- P_g: The product value for this specific gap family\n';
            csv += '- Formula: Explicit product notation (P_1 × P_2 × P_4 × ...)\n';
            csv += '- Cumulative Product: Running product after this step\n';
            csv += '- Distance to pi^2/6: How far from target value\n';
            csv += '- Percent Complete: (Cumulative / pi^2/6) × 100\n\n';
            
            csv += `Analysis Date:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${analysisResults.maxPrime}\n`;
            csv += `Target zeta(2):,${analysisResults.targetZeta2}\n`;
            csv += `Total Gap Families:,${analysisResults.evenGaps.length}\n\n`;
            
            csv += 'DATA TABLE:\n';
            csv += 'Step,Gap Added,P_g,Formula,Cumulative Product,Distance to pi^2/6,Percent Complete\n';
            
            const gaps = getFilteredGaps();
            if (gaps.length === 0) {
                return 'No data in selected gap range\n';
            }
            gaps.forEach((gap, idx) => {
                const data = analysisResults.gapProducts[gap];
                const cumulative = analysisResults.progressiveProducts[idx].value;
                const distance = analysisResults.targetZeta2 - cumulative;
                const percentComplete = (cumulative / analysisResults.targetZeta2) * 100;
                
                let formula = 'P_1';
                for (let i = 1; i <= idx; i++) {
                    formula += ` × P_${gaps[i]}`;
                }
                
                csv += `${idx + 1},${gap},${data.product.toFixed(precision)},"${formula}",`;
                csv += `${cumulative.toFixed(precision)},${distance.toFixed(precision)},`;
                csv += `${percentComplete.toFixed(precision)}%\n`;
            });
            
            csv += `\nFINAL TARGET,∞,1.0,"zeta(2) = pi^2/6",${analysisResults.targetZeta2.toFixed(precision)},0.0,100.0%\n`;
            
            csv += '\n=================================================\n';
            csv += 'RESEARCH NOTES:\n';
            csv += 'This decomposition provides a novel perspective on the Basel problem.\n';
            csv += 'By organizing the Euler product by prime gaps rather than sequential primes,\n';
            csv += 'revealing connections between prime constellation distributions and the\n';
            csv += 'fundamental constant pi. The rapid convergence suggests each gap family P_g\n';
            csv += 'may admit closed-form expressions in terms of pi and gap parameters.\n';
            csv += '=================================================\n';
            
            return csv;
        }
        
        function exportStepByStepTablePNG() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const precision = parseInt(document.getElementById('stepByStepPrecision').value);
            
            // Get row count from global export setting
            const rowCountSetting = document.getElementById('globalExportRows')?.value || '15';
            
            const maxRows = rowCountSetting === 'all' ? analysisResults.evenGaps.length : parseInt(rowCountSetting);
            const gaps = analysisResults.evenGaps.slice(0, maxRows);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Calculate dimensions
            const headerH = 200;
            const tableHeaderH = 80;
            const rowH = 60;
            const footerH = 100;
            const padding = 40;
            
            const canvasW = 3840;
            const canvasH = headerH + tableHeaderH + (gaps.length + 2) * rowH + footerH; // +2 for displayed and limit rows
            
            canvas.width = canvasW;
            canvas.height = canvasH;
            
            // Background
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, canvasW, canvasH);
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 64px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Step-by-Step Gap Accumulation: ζ(2) = P₁ × P₂ × P₄ × ...', canvasW / 2, 80);
            
            ctx.fillStyle = canvasText();
            ctx.font = '32px monospace';
            ctx.fillText(`Analysis: ${analysisResults.totalPrimes.toLocaleString()} primes up to ${analysisResults.maxPrime.toLocaleString()}`, canvasW / 2, 140);
            
            // Table headers
            const tableY = headerH + padding;
            const headers = ['Step', 'Gap', 'P_g', 'Cumulative Product', 'Distance to π²/6', '% Complete'];
            const colWidths = [0.08, 0.08, 0.18, 0.24, 0.22, 0.20];
            
            ctx.fillStyle = canvasSubBg();
            ctx.fillRect(padding, tableY, canvasW - 2 * padding, tableHeaderH);
            
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 4;
            ctx.strokeRect(padding, tableY, canvasW - 2 * padding, tableHeaderH);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            
            let xPos = padding;
            headers.forEach((header, idx) => {
                const w = (canvasW - 2 * padding) * colWidths[idx];
                ctx.fillText(header, xPos + w / 2, tableY + 50);
                xPos += w;
            });
            
            // Table rows
            ctx.font = '32px monospace';
            gaps.forEach((gap, rowIdx) => {
                const y = tableY + tableHeaderH + rowIdx * rowH;
                const data = analysisResults.gapProducts[gap];
                const cumulative = analysisResults.progressiveProducts[rowIdx].value;
                const distance = analysisResults.targetZeta2 - cumulative;
                const percentComplete = (cumulative / analysisResults.targetZeta2) * 100;
                
                // Alternating row background
                if (rowIdx % 2 === 0) {
                    ctx.fillStyle = canvasRowAlt();
                    ctx.fillRect(padding, y, canvasW - 2 * padding, rowH);
                }
                
                ctx.fillStyle = '#e0e0e0';
                const rowData = [
                    (rowIdx + 1).toString(),
                    gap.toString(),
                    data.product.toFixed(precision),
                    cumulative.toFixed(precision),
                    distance.toFixed(precision),
                    percentComplete.toFixed(precision) + '%'
                ];
                
                xPos = padding;
                rowData.forEach((cell, colIdx) => {
                    const w = (canvasW - 2 * padding) * colWidths[colIdx];
                    ctx.fillText(cell, xPos + w / 2, y + 42);
                    xPos += w;
                });
            });
            
            // DISPLAYED row (actual state at last gap)
            const displayedY = tableY + tableHeaderH + gaps.length * rowH;
            ctx.fillStyle = 'rgba(78, 205, 196, 0.1)';
            ctx.fillRect(padding, displayedY, canvasW - 2 * padding, rowH);
            
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 4;
            ctx.strokeRect(padding, displayedY, canvasW - 2 * padding, rowH);
            
            const lastGap = gaps[gaps.length - 1];
            const lastData = analysisResults.gapProducts[lastGap];
            const lastCumulative = analysisResults.progressiveProducts[gaps.length - 1].value;
            const lastDistance = analysisResults.targetZeta2 - lastCumulative;
            const lastPercentComplete = (lastCumulative / analysisResults.targetZeta2) * 100;
            
            ctx.fillStyle = '#4ecdc4';
            ctx.font = 'bold 36px monospace';
            const displayedData = [
                'Displayed',
                lastGap.toString(),
                lastData.product.toFixed(precision),
                lastCumulative.toFixed(precision),
                lastDistance.toFixed(precision),
                lastPercentComplete.toFixed(precision) + '%'
            ];
            
            xPos = padding;
            displayedData.forEach((cell, colIdx) => {
                const w = (canvasW - 2 * padding) * colWidths[colIdx];
                ctx.fillText(cell, xPos + w / 2, displayedY + 42);
                xPos += w;
            });
            
            // LIMIT row (theoretical target at infinity)
            const limitY = displayedY + rowH;
            ctx.fillStyle = canvasHighlight();
            ctx.fillRect(padding, limitY, canvasW - 2 * padding, rowH);
            
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 4;
            ctx.strokeRect(padding, limitY, canvasW - 2 * padding, rowH);
            
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 36px monospace';
            const limitData = [
                'Limit',
                '∞',
                '1.0',
                analysisResults.targetZeta2.toFixed(precision),
                '0.' + '0'.repeat(precision),
                '100.' + '0'.repeat(precision) + '%'
            ];
            
            xPos = padding;
            limitData.forEach((cell, colIdx) => {
                const w = (canvasW - 2 * padding) * colWidths[colIdx];
                ctx.fillText(cell, xPos + w / 2, limitY + 42);
                xPos += w;
            });
            
            // Footer
            ctx.fillStyle = window.canvasText ? window.canvasText() : '#666';
            ctx.font = '28px monospace';
            ctx.textAlign = 'right';
            const dateStr = new Date().toLocaleDateString('en-GB', { 
                day: '2-digit', 
                month: 'long', 
                year: 'numeric' 
            });
            ctx.fillText(dateStr, canvasW - padding, canvasH - 40);
            
            // Export
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const link = document.createElement('a');
            link.download = `step_by_step_table_${analysisResults.maxPrime}_${timestamp}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
        
        // Composite screenshot generation
        function generateCompositeScreenshot() {
            if (!analysisResults) {
                alert('Please run analysis first');
                return;
            }
            
            const statusBar = document.getElementById('screenshotStatus');
            statusBar.style.display = 'block';
            statusBar.className = 'status-bar computing';
            statusBar.textContent = 'Generating composite screenshot...';
            
            setTimeout(() => {
                try {
                    // Collect selected charts
                    const chartSelections = {
                        convergence: document.getElementById('screenshotConvergence').checked,
                        gapContrib: document.getElementById('screenshotGapContrib').checked,
                        gapDist: document.getElementById('screenshotGapDist').checked,
                        percentage: document.getElementById('screenshotPercentage').checked,
                        error: document.getElementById('screenshotError').checked,
                        logScale: document.getElementById('screenshotLogScale').checked,
                        gapRatio: document.getElementById('screenshotGapRatio').checked,
                        decimalConv: document.getElementById('screenshotDecimalConv').checked
                    };
                    
                    const selectedCharts = [];
                    const chartCanvasIds = {
                        convergence: 'convergenceChart',
                        gapContrib: 'gapContribChart',
                        gapDist: 'gapDistChart',
                        percentage: 'percentageChart',
                        error: 'errorChart',
                        logScale: 'logScaleChart',
                        gapRatio: 'gapRatioChart',
                        decimalConv: 'decimalConvergenceChart'
                    };
                    
                    Object.keys(chartSelections).forEach(key => {
                        if (chartSelections[key]) {
                            selectedCharts.push({
                                name: key,
                                canvasId: chartCanvasIds[key]
                            });
                        }
                    });
                    
                    if (selectedCharts.length === 0) {
                        statusBar.className = 'status-bar';
                        statusBar.style.color = '#ff6464';
                        statusBar.textContent = 'Please select at least one chart';
                        return;
                    }
                    
                    const baseRes = parseInt(document.getElementById('screenshotResolution').value);
                    const scale = baseRes / 1920;
                    
                    const layout = document.getElementById('screenshotLayout').value;
                    const title = document.getElementById('screenshotTitle').value;
                    const subtitle = document.getElementById('screenshotSubtitle').value;
                    
                    // Calculate dimensions
                    let cols, rows;
                    if (layout === 'grid') {
                        cols = 2;
                        rows = Math.ceil(selectedCharts.length / 2);
                    } else if (layout === 'vertical') {
                        cols = 1;
                        rows = selectedCharts.length;
                    } else { // horizontal
                        cols = Math.min(3, selectedCharts.length);
                        rows = Math.ceil(selectedCharts.length / cols);
                    }
                    
                    const chartW = 1920 * scale;
                    const chartH = 1080 * scale;
                    const headerH = 250 * scale;
                    // Adjust footer based on number of charts - less space for single chart
                    const footerH = selectedCharts.length === 1 ? 400 * scale : 600 * scale;
                    const padding = 40 * scale;
                    const statsH = 100 * scale;
                    
                    const canvasW = cols * chartW + (cols + 1) * padding;
                    const canvasH = headerH + statsH + rows * chartH + (rows + 1) * padding + footerH;
                    
                    const canvas = document.getElementById('compositeCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = canvasW;
                    canvas.height = canvasH;
                    
                    // Background
                    ctx.fillStyle = canvasBg();
                    ctx.fillRect(0, 0, canvasW, canvasH);
                    
                    // Header section
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `bold ${72 * scale}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText(title, canvasW / 2, 80 * scale);
                    
                    ctx.fillStyle = canvasTextBright();
                    ctx.font = `${36 * scale}px sans-serif`;
                    ctx.fillText(subtitle, canvasW / 2, 140 * scale);
                    
                    // Stats summary bar
                    const statsY = headerH + 20 * scale;
                    ctx.fillStyle = canvasSubBg();
                    ctx.fillRect(padding, statsY, canvasW - 2 * padding, statsH - 40 * scale);
                    
                    ctx.strokeStyle = '#3a3a5a';
                    ctx.lineWidth = 2 * scale;
                    ctx.strokeRect(padding, statsY, canvasW - 2 * padding, statsH - 40 * scale);
                    
                    const statsText = `${analysisResults.totalPrimes.toLocaleString()} primes analyzed | Maximum: ${analysisResults.maxPrime.toLocaleString()} | ${analysisResults.evenGaps.length} gap families | Final error: ${(analysisResults.finalRelativeError * 100).toFixed(8)}%`;
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `${28 * scale}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.fillText(statsText, canvasW / 2, statsY + (statsH - 40 * scale) / 2 + 10 * scale);
                    
                    // Draw charts
                    selectedCharts.forEach((chart, idx) => {
                        const row = Math.floor(idx / cols);
                        const col = idx % cols;
                        
                        const x = col * chartW + (col + 1) * padding;
                        const y = headerH + statsH + row * chartH + (row + 1) * padding;
                        
                        const sourceCanvas = document.getElementById(chart.canvasId);
                        
                        // Draw border
                        ctx.strokeStyle = canvasGrid();
                        ctx.lineWidth = 3 * scale;
                        ctx.strokeRect(x - 2 * scale, y - 2 * scale, chartW + 4 * scale, chartH + 4 * scale);
                        
                        // Draw chart
                        ctx.drawImage(sourceCanvas, x, y, chartW, chartH);
                    });
                    
                    // Footer narrative section
                    const footerY = headerH + statsH + rows * chartH + (rows + 1) * padding + 40 * scale;
                    
                    ctx.fillStyle = canvasSubBg2();
                    ctx.fillRect(padding, footerY, canvasW - 2 * padding, footerH - 80 * scale);
                    
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 4 * scale;
                    ctx.strokeRect(padding, footerY, canvasW - 2 * padding, footerH - 80 * scale);
                    
                    // Narrative title
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `bold ${38 * scale}px serif`;
                    ctx.textAlign = 'left';
                    ctx.fillText('Mathematical Observations', padding + 30 * scale, footerY + 50 * scale);
                    
                    // Generate and render narrative
                    const narrative = generateRamanujanNarrative();
                    ctx.fillStyle = '#e0e0e0';
                    // Smaller font for single chart to fit better
                    const fontSize = selectedCharts.length === 1 ? 22 : 26;
                    ctx.font = `${fontSize * scale}px Georgia, serif`;
                    
                    const maxLineWidth = canvasW - 2 * padding - 60 * scale;
                    const lineHeight = (fontSize + 12) * scale;
                    let currentY = footerY + 100 * scale;
                    
                    const paragraphs = narrative.split('\n\n');
                    paragraphs.forEach(para => {
                        const words = para.split(' ');
                        let line = '';
                        
                        for (let i = 0; i < words.length; i++) {
                            const testLine = line + words[i] + ' ';
                            const metrics = ctx.measureText(testLine);
                            
                            if (metrics.width > maxLineWidth && line !== '') {
                                ctx.fillText(line.trim(), padding + 30 * scale, currentY);
                                currentY += lineHeight;
                                line = words[i] + ' ';
                            } else {
                                line = testLine;
                            }
                        }
                        
                        if (line.trim() !== '') {
                            ctx.fillText(line.trim(), padding + 30 * scale, currentY);
                            currentY += lineHeight;
                        }
                        currentY += lineHeight * 0.3;
                    });
                    
                    // Date stamp
                    ctx.fillStyle = window.canvasText ? window.canvasText() : '#666';
                    ctx.font = `${22 * scale}px monospace`;
                    ctx.textAlign = 'right';
                    const dateStr = new Date().toLocaleDateString('en-GB', { 
                        day: '2-digit', 
                        month: 'long', 
                        year: 'numeric' 
                    });
                    ctx.fillText(dateStr, canvasW - padding - 30 * scale, canvasH - 30 * scale);
                    
                    // Export
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const resLabel = baseRes >= 3840 ? (baseRes >= 7680 ? '8K' : '4K') : (baseRes >= 2560 ? 'QHD' : 'HD');
                    const link = document.createElement('a');
                    link.download = `gap_decomposition_composite_${analysisResults.maxPrime}_${resLabel}_${timestamp}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    
                    statusBar.className = 'status-bar complete';
                    statusBar.textContent = `Composite screenshot generated: ${selectedCharts.length} charts, ${resLabel} resolution`;
                    
                } catch (error) {
                    statusBar.className = 'status-bar';
                    statusBar.style.color = '#ff6464';
                    statusBar.textContent = `Error: ${error.message}`;
                    console.error(error);
                }
            }, 100);
        }
        
        function generateRamanujanNarrative() {
            const r = analysisResults;
            
            // Extract key numerical insights
            const twinCount = r.gapProducts[2] ? r.gapProducts[2].count : 0;
            const twinPct = r.percentageContributions[2] ? r.percentageContributions[2].toFixed(3) : 0;
            
            const gap4Count = r.gapProducts[4] ? r.gapProducts[4].count : 0;
            const gap4Pct = r.percentageContributions[4] ? r.percentageContributions[4].toFixed(3) : 0;
            
            const gap6Count = r.gapProducts[6] ? r.gapProducts[6].count : 0;
            const gap6Pct = r.percentageContributions[6] ? r.percentageContributions[6].toFixed(3) : 0;
            
            const errorExp = Math.floor(Math.log10(r.finalRelativeError));
            const errorMantissa = (r.finalRelativeError / Math.pow(10, errorExp)).toFixed(2);
            
            // Random variation selector - always Euler style
            const variation = Math.floor(Math.random() * 5);
            
            const eulerVariations = [
                `Concerning the partition of ζ(2) by prime gaps: among ${(r.allPrimesFound || r.totalPrimes).toLocaleString()} primes, the ${twinCount} twin pairs contribute ${twinPct}% logarithmically. With ${r.evenGaps.length} gap families, ${errorMantissa} × 10^${errorExp} precision is achieved relative to π²/6. The geometric rapidity of convergence suggests π emerges from prime gap arithmetic itself.`,
                
                `The decomposition ∏P_g reveals that ${twinCount} twin primes provide ${twinPct}% of log(ζ(2)). Partitioning ${(r.allPrimesFound || r.totalPrimes).toLocaleString()} primes across ${r.evenGaps.length} gap classes yields error ${errorMantissa} × 10^${errorExp}. This elegant structure connects circular geometry to prime distribution.`,
                
                `By gap-class partition, ζ(2) = ∏P_g exhibits rapid convergence. The ${twinCount} twins contribute ${twinPct}%, while ${r.evenGaps.length} families suffice for ${errorMantissa} × 10^${errorExp} precision. A remarkable bridge between discrete gaps and π²/6.`,
                
                `The ${r.evenGaps.length} gap families demonstrate hierarchical contribution: twins (${twinCount} pairs) at ${twinPct}%, cousins (${gap4Count} pairs) at ${gap4Pct}%, sexy primes (${gap6Count} pairs) at ${gap6Pct}%. Convergence to π²/6 proceeds with error ${errorMantissa} × 10^${errorExp}, revealing π's arithmetic foundation.`,
                
                `Among ${(r.allPrimesFound || r.totalPrimes).toLocaleString()} primes examined, the gap decomposition yields ${r.evenGaps.length} distinct families. Twin primes alone account for ${twinPct}% of the logarithmic sum. The finite product approximates π²/6 with merely ${errorMantissa} × 10^${errorExp} relative deviation, a testament to the profound regularity underlying prime distribution.`
            ];
            
            return eulerVariations[variation];
        }
        
        // Initialize
        updateDisplays();

        // ========== ZETA(S) GENERALIZATION ==========
        
        function getKnownZetaValue(s) {
            const knownValues = {
                2: { value: Math.PI**2 / 6, formula: "π²/6" },
                4: { value: Math.PI**4 / 90, formula: "π⁴/90" },
                6: { value: Math.PI**6 / 945, formula: "π⁶/945" },
                8: { value: Math.PI**8 / 9450, formula: "π⁸/9450" },
                10: { value: Math.PI**10 / 93555, formula: "π¹⁰/93555" }
            };
            return knownValues[s] || null;
        }
        
        function setZetaS(value) {
            document.getElementById('zetaS').value = value;
            updateZetaSDisplay();
        }
        
        function updateZetaSDisplay() {
            const s = parseFloat(document.getElementById('zetaS').value);
            document.getElementById('zetaSDisplay').textContent = s.toFixed(2);
            
            const known = getKnownZetaValue(s);
            const infoDiv = document.getElementById('zetaSInfo');
            const behaviorDiv = document.getElementById('zetaSBehavior');
            
            if (known) {
                infoDiv.innerHTML = `<strong>ζ(${s}) = ${known.formula} ≈ ${known.value.toFixed(6)}</strong>`;
            } else {
                const approx = computeApproximateZeta(s);
                infoDiv.innerHTML = `ζ(${s.toFixed(2)}) ≈ ${approx.toFixed(6)}`;
            }
            
            // Update behavioral description
            if (s < 1.3) {
                behaviorDiv.textContent = 'Approaches divergence - all gaps contribute equally';
            } else if (s < 1.8) {
                behaviorDiv.textContent = 'Gap 1 and Gap 2 nearly balanced (~45% vs 39%)';
            } else if (s < 2.5) {
                behaviorDiv.textContent = 'Twin primes (Gap 2) dominate - optimal for twin prime research';
            } else if (s < 3.5) {
                behaviorDiv.textContent = 'Gap 1 begins to dominate - twin prime influence fading';
            } else if (s < 5) {
                behaviorDiv.textContent = 'Gap 1 strongly dominant (~80%) - small primes control ζ(s)';
            } else {
                behaviorDiv.textContent = 'Gap 1 nearly total dominance (>90%) - prime 2 dominates everything';
            }
        }
        
        function computeApproximateZeta(s) {
            // Quick approximation using first 1000 terms
            let sum = 0;
            for (let n = 1; n <= 1000; n++) {
                sum += 1 / Math.pow(n, s);
            }
            return sum;
        }
        

        
        function computeComparisonData(gapRangeFilter = null) {
            const maxPrime = parseInt(document.getElementById('maxPrime').value);
            const sValues = [1.5, 2, 3, 4, 5, 10];
            
            const comparisonResults = {};
            
            sValues.forEach(s => {
                comparisonResults[s] = computeGapDecompositionWithS(maxPrime, s, gapRangeFilter);
            });
            
            return comparisonResults;
        }
        
        function renderComparisonChart() {
            const canvas = document.createElement('canvas');
            canvas.width = 3840;
            canvas.height = 2400;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, 3840, 2400);
            
            const compData = computeComparisonData();
            const sValues = [1.5, 2, 3, 4, 5, 10];
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 72px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Contribution Evolution Across ζ(s)', 1920, 100);
            
            // Draw comparison bars
            const margin = {left: 250, right: 100, top: 200, bottom: 150};
            const chartW = 3840 - margin.left - margin.right;
            const chartH = 2400 - margin.top - margin.bottom;
            
            const barWidth = chartW / (sValues.length * 5); // 5 gaps shown
            
            sValues.forEach((s, sIdx) => {
                const data = compData[s];
                const topGaps = [1, 2, 4, 6, 8].filter(g => data.percentageContributions[g]);
                
                topGaps.forEach((gap, gapIdx) => {
                    const pct = data.percentageContributions[gap] || 0;
                    const x = margin.left + (sIdx * 5 + gapIdx) * barWidth;
                    const barH = (pct / 100) * chartH;
                    const y = margin.top + chartH - barH;
                    
                    const colors = ['#ff4444', '#ffd700', '#4ecdc4', '#8b5cf6', '#06b6d4'];
                    ctx.fillStyle = colors[gapIdx];
                    ctx.fillRect(x, y, barWidth * 0.8, barH);
                });
                
                // Label s value
                ctx.fillStyle = canvasTextBright();
                ctx.font = 'bold 32px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`s=${s}`, margin.left + (sIdx * 5 + 2) * barWidth, 2400 - 50);
            });
            
            // Legend
            const legendX = margin.left;
            const legendY = 150;
            const gapLabels = ['Gap 1', 'Gap 2', 'Gap 4', 'Gap 6', 'Gap 8'];
            const colors = ['#ff4444', '#ffd700', '#4ecdc4', '#8b5cf6', '#06b6d4'];
            
            gapLabels.forEach((label, i) => {
                ctx.fillStyle = colors[i];
                ctx.fillRect(legendX + i * 180, legendY, 40, 40);
                ctx.fillStyle = '#ccc';
                ctx.font = 'bold 28px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(label, legendX + i * 180 + 50, legendY + 30);
            });
            
            return canvas;
        }
        function applyResearchPreset(preset) {
            const presets = {
                'complete': { maxPrime: 10000000, gapRangeMode: 'auto', minGapRange: 0, maxGapRange: 500, gapFilter: false, minGap: 0, maxGapFilter: 500, desc: 'Complete Analysis - 10 Million Primes (All Gaps)' },
                'twins': { maxPrime: 100000, gapRangeMode: 'manual', minGapRange: 0, maxGapRange: 10, gapFilter: true, minGap: 2, maxGapFilter: 10, desc: 'Twin Prime Focus (Gaps 0-10)' },
                'goldbach': { maxPrime: 500000, gapRangeMode: 'manual', minGapRange: 0, maxGapRange: 30, gapFilter: false, minGap: 0, maxGapFilter: 30, desc: 'Goldbach Range (Gaps 0-30)' },
                'topology': { maxPrime: 1000000, gapRangeMode: 'manual', minGapRange: 30, maxGapRange: 90, gapFilter: true, minGap: 30, maxGapFilter: 90, desc: 'Large Gap Topology (Gaps 30-90)' },
                'extreme': { maxPrime: 5000000, gapRangeMode: 'manual', minGapRange: 100, maxGapRange: 500, gapFilter: true, minGap: 100, maxGapFilter: 500, desc: 'Extreme Range (Gaps 100-500)' },
                'full': { maxPrime: 1000000, gapRangeMode: 'auto', minGapRange: 0, maxGapRange: 200, gapFilter: false, minGap: 0, maxGapFilter: 200, desc: 'Full Spectrum (All Gaps)' },
                'rh': { maxPrime: 2000000, gapRangeMode: 'manual', minGapRange: 0, maxGapRange: 50, gapFilter: false, minGap: 0, maxGapFilter: 50, desc: 'RH Investigation (Gaps 0-50)' }
            };
            const config = presets[preset];
            if (!config) return;
            
            document.getElementById('maxPrime').value = config.maxPrime;
            document.getElementById('maxPrimeDisplay').textContent = config.maxPrime.toLocaleString();
            
            // Set gap range mode
            document.querySelector(`input[name="gapRangeMode"][value="${config.gapRangeMode}"]`).checked = true;
            document.getElementById('minGapRange').value = config.minGapRange;
            document.getElementById('maxGapRange').value = config.maxGapRange;
            updateGapRangeMode();
            
            // Only set gap filter if the checkbox exists
            const gapFilterCheckbox = document.getElementById('enableGapFilter');
            if (gapFilterCheckbox) {
                gapFilterCheckbox.checked = config.gapFilter;
            }
            
            // Only set gap filter values if the inputs exist
            const minGapFilter = document.getElementById('minGapFilter');
            const maxGapFilter = document.getElementById('maxGapFilter');
            if (minGapFilter) minGapFilter.value = config.minGap;
            if (maxGapFilter) maxGapFilter.value = config.maxGapFilter;
            
            if (typeof toggleGapFilter === 'function') {
                toggleGapFilter();
            }
            
            const statusBar = document.getElementById('statusBar');
            if (statusBar) {
                statusBar.style.display = 'block';
                statusBar.style.background = 'rgba(34, 197, 94, 0.2)';
                statusBar.style.borderLeft = '4px solid #22c55e';
                statusBar.textContent = 'Applied preset: ' + config.desc + '. Click "Run Analysis" to compute.';
                setTimeout(() => statusBar.style.display = 'none', 4000);
            }
        }
        
        function updateMaxPrimeDisplay() {
            const value = parseInt(document.getElementById('maxPrime').value);
            document.getElementById('maxPrimeDisplay').textContent = value.toLocaleString();
        }
        
        function updateGapRangeMode() {
            const manualMode = document.querySelector('input[name="gapRangeMode"]:checked').value === 'manual';
            const controls = document.getElementById('manualGapRangeControls');
            controls.style.display = manualMode ? 'block' : 'none';
            
            if (manualMode) {
                validateGapRange();
            }
        }
        
        function validateGapRange() {
            const minGap = parseInt(document.getElementById('minGapRange').value) || 0;
            const maxGap = parseInt(document.getElementById('maxGapRange').value) || 0;
            const errorDiv = document.getElementById('gapRangeError');
            
            // Check if both are even (or min is 0 for gap-1)
            const minValid = minGap === 0 || minGap % 2 === 0;
            const maxValid = maxGap % 2 === 0;
            
            // Check if min < max
            const rangeValid = minGap < maxGap;
            
            if (!minValid || !maxValid || !rangeValid) {
                errorDiv.style.display = 'block';
                return false;
            } else {
                errorDiv.style.display = 'none';
                return true;
            }
        }
        
        function getGapRangeFilter() {
            const mode = document.querySelector('input[name="gapRangeMode"]:checked').value;
            
            if (mode === 'auto') {
                return { mode: 'auto', min: null, max: null };
            } else {
                const min = parseInt(document.getElementById('minGapRange').value) || 0;
                const max = parseInt(document.getElementById('maxGapRange').value) || 50;
                return { mode: 'manual', min: min, max: max };
            }
        }


        // TAB SWITCHING
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById('tab-' + tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // PRIME DENSITY ANALYSIS
        let densityData = null;
        
        function computeDensity() {
            if (!analysisResults || !analysisResults.primes) {
                alert('Please run main analysis first!');
                return;
            }
            
            const primes = analysisResults.primes;
            const maxPrime = primes[primes.length - 1];
            const intervalSize = Math.max(1000, Math.floor(maxPrime / 20));
            
            densityData = [];
            let intervalStart = 2;
            
            while (intervalStart < maxPrime) {
                const intervalEnd = Math.min(intervalStart + intervalSize, maxPrime);
                const primesInInterval = primes.filter(p => p >= intervalStart && p < intervalEnd).length;
                const density = primesInInterval / intervalSize;
                const midpoint = (intervalStart + intervalEnd) / 2;
                const predicted = 1 / Math.log(midpoint);
                
                densityData.push({
                    start: intervalStart,
                    end: intervalEnd,
                    count: primesInInterval,
                    density: density.toFixed(6),
                    predicted: predicted.toFixed(6)
                });
                
                intervalStart = intervalEnd;
            }
            
            document.getElementById('densityStatus').style.display = 'block';
            document.getElementById('densityStatus').innerHTML = `
                <strong>Prime Density Analysis Complete</strong><br>
                Analyzed ${densityData.length} intervals of size ~${intervalSize.toLocaleString()}<br>
                Max prime: ${maxPrime.toLocaleString()}
            `;
            
            renderDensityTable();
            renderDensityChart();
        }

        function renderDensityTable() {
            const tbody = document.getElementById('densityTableBody');
            tbody.innerHTML = '';
            
            densityData.forEach(item => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = item.start.toLocaleString();
                row.insertCell(1).textContent = item.end.toLocaleString();
                row.insertCell(2).textContent = item.count;
                row.insertCell(3).textContent = item.density;
                row.insertCell(4).textContent = item.predicted;
            });
        }

        function renderDensityChart() {
            const canvas = document.getElementById('densityChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const margin = {left: 250, right: 150, top: 200, bottom: 200};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const densities = densityData.map(d => parseFloat(d.density));
            const maxDensity = Math.max(...densities);
            
            const xScale = chartW / densityData.length;
            const yScale = chartH / maxDensity;
            
            // Grid
            ctx.strokeStyle = canvasGrid();
            ctx.lineWidth = 3;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
            }
            
            // Bars
            densityData.forEach((item, i) => {
                const barH = parseFloat(item.density) * yScale;
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(0, y, 0, y + barH);
                gradient.addColorStop(0, '#ffd700');
                gradient.addColorStop(1, '#ff8800');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + xScale * 0.1, y, xScale * 0.8, barH);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Prime Density by Interval', w / 2, 120);
            
            // Y-axis label
            ctx.save();
            ctx.translate(100, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 60px sans-serif';
            ctx.fillText('Density (primes per unit)', 0, 0);
            ctx.restore();
            
            // X-axis label
            ctx.font = 'bold 60px sans-serif';
            ctx.fillText('Interval Number', w / 2, h - 80);
        }

        function copyDensityList() {
            const text = densityData.map(d => `[${d.start}-${d.end}]: ${d.count} primes, density ${d.density}`).join('\n');
            navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
        }

        function exportDensityCSV() {
            const maxP = analysisResults ? analysisResults.maxPrime : (densityData.length ? densityData[densityData.length-1].end : 0);
            const ts   = new Date().toISOString().replace(/[:.]/g,'-').slice(0,-5);
            let csv  = 'Prime Density Analysis\n';
            csv += `Generated:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${maxP.toLocaleString()}\n`;
            csv += `Total Intervals:,${densityData.length}\n`;
            csv += `Total Primes:,${densityData.reduce((s,d)=>s+d.count,0).toLocaleString()}\n\n`;
            csv += 'Range Start,Range End,Interval Width,Prime Count,Actual Density,Predicted Density (1/ln n),Actual/Predicted Ratio\n';
            densityData.forEach(item => {
                const width = item.end - item.start;
                const pred  = item.predicted || (1/Math.log((item.start+item.end)/2));
                const ratio = item.density > 0 && pred > 0 ? (item.density/pred).toFixed(6) : '';
                csv += `${item.start},${item.end},${width},${item.count},${item.density},${typeof item.predicted!=='undefined'?item.predicted:pred.toFixed(8)},${ratio}\n`;
            });
            csv += `\nEND OF DATASET — ${densityData.length} intervals\n`;
            const blob = new Blob([csv], {type:'text/csv'});
            const a    = document.createElement('a');
            a.href     = URL.createObjectURL(blob);
            a.download = `prime_density_${maxP}_${ts}.csv`;
            a.click();
        }

        // TWIN PRIMES
        let twinsData = null;
        
        function computeTwinPrimes() {
            if (!analysisResults || !analysisResults.primes) {
                alert('Please run main analysis first!');
                return;
            }
            
            const primes = analysisResults.primes;
            twinsData = [];
            
            for (let i = 0; i < primes.length - 1; i++) {
                if (primes[i+1] - primes[i] === 2) {
                    const gapBefore = i > 0 ? primes[i] - primes[i-1] : 0;
                    const gapAfter = i < primes.length - 2 ? primes[i+2] - primes[i+1] : 0;
                    twinsData.push({
                        p: primes[i],
                        q: primes[i+1],
                        gapBefore,
                        gapAfter
                    });
                }
            }
            
            document.getElementById('twinsStatus').style.display = 'block';
            document.getElementById('twinsStatus').innerHTML = `
                <strong>Twin Prime Search Complete</strong><br>
                Found ${twinsData.length} twin prime pairs<br>
                Largest pair: (${twinsData[twinsData.length-1].p}, ${twinsData[twinsData.length-1].q})
            `;
            
            renderTwinsTable();
            renderTwinsChart();
        }

        function renderTwinsTable() {
            const tbody = document.getElementById('twinsTableBody');
            tbody.innerHTML = '';
            
            twinsData.forEach((item, idx) => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = idx + 1;
                row.insertCell(1).textContent = `(${item.p}, ${item.q})`;
                row.insertCell(2).textContent = item.gapBefore || 'N/A';
                row.insertCell(3).textContent = item.gapAfter || 'N/A';
            });
        }

        function renderTwinsChart() {
            const canvas = document.getElementById('twinsChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const margin = {left: 250, right: 150, top: 200, bottom: 200};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Sample every Nth twin to avoid overcrowding
            const sampleRate = Math.max(1, Math.floor(twinsData.length / 100));
            const sampledTwins = twinsData.filter((_, i) => i % sampleRate === 0);
            
            const xScale = chartW / sampledTwins.length;
            const maxP = twinsData[twinsData.length - 1].p;
            const yScale = chartH / maxP;
            
            // Plot twin primes
            ctx.fillStyle = '#ffd700';
            sampledTwins.forEach((twin, i) => {
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - (twin.p * yScale);
                ctx.fillRect(x, y, xScale * 0.6, 10);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`Twin Primes Distribution (${twinsData.length} pairs)`, w/2, 120);
            
            ctx.font = 'bold 50px sans-serif';
            ctx.fillText(`Sampled every ${sampleRate} pairs for visualization`, w/2, h - 80);
        }

        function copyTwinsList() {
            const text = twinsData.map(d => `(${d.p}, ${d.q})`).join('\n');
            navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
        }

        function exportTwinsCSV() {
            const maxP = analysisResults ? analysisResults.maxPrime : (twinsData.length ? twinsData[twinsData.length-1].q : 0);
            const ts   = new Date().toISOString().replace(/[:.]/g,'-').slice(0,-5);
            let csv  = 'Twin Primes Export\n';
            csv += `Generated:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${maxP.toLocaleString()}\n`;
            csv += `Total Twin Pairs:,${twinsData.length.toLocaleString()}\n`;
            csv += `First Twin Pair:,${twinsData.length?twinsData[0].p+' '+twinsData[0].q:''}\n`;
            csv += `Last Twin Pair:,${twinsData.length?twinsData[twinsData.length-1].p+' '+twinsData[twinsData.length-1].q:''}\n\n`;
            csv += 'Index,p (smaller twin),q = p+2,p mod 6,q mod 6,Gap before p,Gap after q,|p·q|\n';
            twinsData.forEach((item, idx) => {
                csv += `${idx+1},${item.p},${item.q},${item.p%6},${item.q%6},${item.gapBefore},${item.gapAfter},${item.p*item.q}\n`;
            });
            csv += `\nEND OF DATASET — ${twinsData.length} twin pairs up to ${maxP.toLocaleString()}\n`;
            const blob = new Blob([csv], {type:'text/csv'});
            const a    = document.createElement('a');
            a.href     = URL.createObjectURL(blob);
            a.download = `twin_primes_${maxP}_${ts}.csv`;
            a.click();
        }

        // PRIME GAPS
        let gapsStatsData = null;
        
        function computeGapStats() {
            if (!analysisResults || !analysisResults.primes) {
                alert('Please run main analysis first!');
                return;
            }
            
            const primes = analysisResults.primes;
            const gapCounts = {};
            const firstOccurrence = {};
            
            for (let i = 0; i < primes.length - 1; i++) {
                const gap = primes[i+1] - primes[i];
                gapCounts[gap] = (gapCounts[gap] || 0) + 1;
                if (!firstOccurrence[gap]) {
                    firstOccurrence[gap] = `${primes[i]} → ${primes[i+1]}`;
                }
            }
            
            const totalGaps = primes.length - 1;
            gapsStatsData = Object.entries(gapCounts).map(([gap, count]) => ({
                gap: parseInt(gap),
                count,
                percentage: (count / totalGaps * 100).toFixed(2),
                first: firstOccurrence[gap]
            })).sort((a, b) => a.gap - b.gap);
            
            const mostCommon = gapsStatsData.reduce((a,b) => a.count > b.count ? a : b);
            
            document.getElementById('gapsStatus').style.display = 'block';
            document.getElementById('gapsStatus').innerHTML = `
                <strong>Gap Analysis Complete</strong><br>
                Found ${gapsStatsData.length} different gap sizes<br>
                Most common: gap ${mostCommon.gap} (${mostCommon.count} occurrences, ${mostCommon.percentage}%)
            `;
            
            renderGapsTable();
            renderGapsChart();
        }

        function renderGapsTable() {
            const tbody = document.getElementById('gapsTableBody');
            tbody.innerHTML = '';
            
            gapsStatsData.forEach(item => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = item.gap;
                row.insertCell(1).textContent = item.count;
                row.insertCell(2).textContent = item.percentage + '%';
                row.insertCell(3).textContent = item.first;
            });
        }

        function renderGapsChart() {
            const canvas = document.getElementById('gapsChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const margin = {left: 250, right: 150, top: 200, bottom: 200};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Show top 50 most frequent gaps
            const topGaps = [...gapsStatsData].sort((a,b) => b.count - a.count).slice(0, 50);
            
            const xScale = chartW / topGaps.length;
            const maxCount = Math.max(...topGaps.map(g => g.count));
            const yScale = chartH / maxCount;
            
            // Grid
            ctx.strokeStyle = canvasGrid();
            ctx.lineWidth = 3;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
            }
            
            // Bars
            topGaps.forEach((item, i) => {
                const barH = item.count * yScale;
                const x = margin.left + i * xScale;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(0, y, 0, y + barH);
                gradient.addColorStop(0, '#4ecdc4');
                gradient.addColorStop(1, '#2a7a73');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + xScale * 0.1, y, xScale * 0.8, barH);
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Prime Gap Frequency Distribution (Top 50)', w / 2, 120);
            
            ctx.save();
            ctx.translate(100, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 60px sans-serif';
            ctx.fillText('Frequency', 0, 0);
            ctx.restore();
        }

        function copyGapsList() {
            const text = gapsStatsData.map(d => `Gap ${d.gap}: ${d.count} (${d.percentage}%)`).join('\n');
            navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
        }

        function exportGapsCSV() {
            const maxP = analysisResults ? analysisResults.maxPrime : 0;
            const ts   = new Date().toISOString().replace(/[:.]/g,'-').slice(0,-5);
            const total = gapsStatsData.reduce((s,d)=>s+d.count,0);
            let csv  = 'Prime Gap Frequency Distribution\n';
            csv += `Generated:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${maxP.toLocaleString()}\n`;
            csv += `Distinct Gap Sizes:,${gapsStatsData.length}\n`;
            csv += `Total Gaps Counted:,${total.toLocaleString()}\n\n`;
            csv += 'Gap Size,Frequency,Percentage (%),Cumulative Count,Cumulative %,First Occurrence (prime p where gap(p)=g)\n';
            let cumul = 0;
            gapsStatsData.forEach(item => {
                cumul += item.count;
                const pct  = total > 0 ? (item.count/total*100).toFixed(6) : '';
                const cpct = total > 0 ? (cumul/total*100).toFixed(4) : '';
                csv += `${item.gap},${item.count},${pct},${cumul},${cpct},${item.first||''}\n`;
            });
            csv += `\nEND OF DATASET — ${gapsStatsData.length} distinct gaps up to ${maxP.toLocaleString()}\n`;
            const blob = new Blob([csv], {type:'text/csv'});
            const a    = document.createElement('a');
            a.href     = URL.createObjectURL(blob);
            a.download = `prime_gaps_${maxP}_${ts}.csv`;
            a.click();
        }

        // PRIME CONSTELLATIONS
        let constellationsData = null;
        
        function computeConstellations() {
            if (!analysisResults || !analysisResults.primes) {
                alert('Please run main analysis first!');
                return;
            }
            
            const primes = analysisResults.primes;
            const primeSet = new Set(primes);
            
            constellationsData = {
                twins: [],
                cousins: [],
                sexy: [],
                triplets: [],
                quadruplets: []
            };
            
            primes.forEach(p => {
                if (primeSet.has(p+2)) constellationsData.twins.push([p, p+2]);
                if (primeSet.has(p+4)) constellationsData.cousins.push([p, p+4]);
                if (primeSet.has(p+6)) constellationsData.sexy.push([p, p+6]);
                if (primeSet.has(p+2) && primeSet.has(p+6)) constellationsData.triplets.push([p, p+2, p+6]);
                if (primeSet.has(p+2) && primeSet.has(p+6) && primeSet.has(p+8)) constellationsData.quadruplets.push([p, p+2, p+6, p+8]);
            });
            
            document.getElementById('constellationsStatus').style.display = 'block';
            document.getElementById('constellationsStatus').innerHTML = `
                <strong>Constellation Search Complete</strong><br>
                Twins: ${constellationsData.twins.length} | Cousins: ${constellationsData.cousins.length} | Sexy: ${constellationsData.sexy.length}<br>
                Triplets: ${constellationsData.triplets.length} | Quadruplets: ${constellationsData.quadruplets.length}
            `;
            
            renderConstellationsTable();
            renderConstellationsChart();
        }

        function renderConstellationsTable() {
            const tbody = document.getElementById('constellationsTableBody');
            tbody.innerHTML = '';
            
            Object.entries(constellationsData).forEach(([type, items]) => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = type.charAt(0).toUpperCase() + type.slice(1);
                row.insertCell(1).textContent = items.length;
                const examples = items.slice(0, 5).map(p => '(' + p.join(',') + ')').join(' ');
                row.insertCell(2).textContent = examples;
            });
        }

        function renderConstellationsChart() {
            const canvas = document.getElementById('constellationsChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const margin = {left: 300, right: 150, top: 200, bottom: 250};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            const types = Object.entries(constellationsData);
            const counts = types.map(([_, items]) => items.length);
            const maxCount = Math.max(...counts);
            
            const barWidth = chartW / types.length;
            const yScale = chartH / maxCount;
            
            // Grid
            ctx.strokeStyle = canvasGrid();
            ctx.lineWidth = 3;
            for (let i = 0; i <= 10; i++) {
                const y = margin.top + (chartH / 10) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(w - margin.right, y);
                ctx.stroke();
                
                const value = maxCount - (maxCount * (i / 10));
                ctx.fillStyle = canvasText();
                ctx.font = 'bold 40px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(Math.floor(value).toLocaleString(), margin.left - 30, y + 15);
            }
            
            // Bars
            const colors = ['#ffd700', '#ff8800', '#ff4444', '#8b5cf6', '#06b6d4'];
            types.forEach(([name, items], i) => {
                const barH = items.length * yScale;
                const x = margin.left + i * barWidth;
                const y = margin.top + chartH - barH;
                
                const gradient = ctx.createLinearGradient(0, y, 0, y + barH);
                gradient.addColorStop(0, colors[i]);
                gradient.addColorStop(1, colors[i] + '88');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barH);
                
                // Labels
                ctx.fillStyle = '#ccc';
                ctx.font = 'bold 50px sans-serif';
                ctx.textAlign = 'center';
                ctx.save();
                ctx.translate(x + barWidth / 2, h - margin.bottom + 80);
                ctx.rotate(-Math.PI / 4);
                ctx.fillText(name.charAt(0).toUpperCase() + name.slice(1), 0, 0);
                ctx.restore();
            });
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Prime Constellation Counts', w / 2, 120);
            
            ctx.save();
            ctx.translate(100, h / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = 'bold 60px sans-serif';
            ctx.fillText('Count', 0, 0);
            ctx.restore();
        }

        function copyConstellationsList() {
            let text = '';
            Object.entries(constellationsData).forEach(([type, items]) => {
                text += `${type}: ${items.length}\n`;
            });
            navigator.clipboard.writeText(text);
            alert('Copied to clipboard!');
        }

        function exportConstellationsCSV() {
            const maxP = analysisResults ? analysisResults.maxPrime : 0;
            const ts   = new Date().toISOString().replace(/[:.]/g,'-').slice(0,-5);
            let csv  = 'Prime Constellations Export\n';
            csv += `Generated:,${new Date().toISOString()}\n`;
            csv += `Maximum Prime:,${maxP.toLocaleString()}\n\n`;
            // Summary sheet
            csv += 'SUMMARY\n';
            csv += 'Type,Total Count,First Example,Last Example\n';
            Object.entries(constellationsData).forEach(([type, items]) => {
                const first = items.length ? '('+items[0].join(',')+')'  : '';
                const last  = items.length ? '('+items[items.length-1].join(',')+')'  : '';
                csv += `${type},${items.length},"${first}","${last}"\n`;
            });
            // Full listings per type
            Object.entries(constellationsData).forEach(([type, items]) => {
                csv += `\n${type.toUpperCase()} — ${items.length} instances\n`;
                // header: number of primes in tuple
                if (items.length === 0) return;
                const cols = items[0].map((_,i)=>'p'+(i+1)).join(',');
                csv += `Index,${cols},Base prime mod 30\n`;
                items.forEach((tuple, idx) => {
                    csv += `${idx+1},${tuple.join(',')},${tuple[0]%30}\n`;
                });
            });
            csv += `\nEND OF DATASET\n`;
            const blob = new Blob([csv], {type:'text/csv'});
            const a    = document.createElement('a');
            a.href     = URL.createObjectURL(blob);
            a.download = `prime_constellations_${maxP}_${ts}.csv`;
            a.click();
        }
        
        // Auto-run analysis on page load with 10M default
        window.addEventListener('DOMContentLoaded', function() {
            console.log('Auto-running analysis with 10M primes...');
            
            // Load default preset for custom gap comparison
            loadGapPreset('small_gaps');
            
            setTimeout(() => {
                runAnalysis();
            }, 500); // Small delay to ensure everything is loaded
            
            // Add event listeners for chart toggle checkboxes
            const chartToggles = [
                'showGapContributions',
                'showConvergence',
                'showGapDistribution',
                'showPercentageContrib',
                'showErrorAnalysis',
                'showLogScale',
                'showGapRatio',
                'showDecimalConvergence',
                'showCustomGapCompare'
            ];
            
            chartToggles.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', function() {
                        if (analysisResults) {
                            renderAllCharts();
                        }
                    });
                }
            });
        });

        function renderComparisonChartActual() {
            if (!analysisResults?.comparisonData) {
                document.getElementById('comparisonWrapper').style.display = 'none';
                return;
            }
            
            document.getElementById('comparisonWrapper').style.display = 'block';
            
            const canvas = document.getElementById('comparisonChart');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.fillStyle = canvasBg();
            ctx.fillRect(0, 0, w, h);
            
            const sValues = [1.5, 2, 3, 4, 5, 10];
            const gapColors = {1: '#ff4444', 2: '#ffd700', 4: '#4ecdc4', 6: '#8b5cf6', 8: '#06b6d4'};
            
            const margin = {left: 250, right: 200, top: 200, bottom: 200};
            const chartW = w - margin.left - margin.right;
            const chartH = h - margin.top - margin.bottom;
            
            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Gap Contribution Evolution: How ζ(s) Changes Gap Dominance', w/2, 120);
            
            // Draw stacked bars for each s
            const barW = chartW / sValues.length * 0.8;
            const spacing = chartW / sValues.length;
            
            sValues.forEach((s, idx) => {
                const data = analysisResults.comparisonData[s];
                const x = margin.left + idx * spacing + spacing * 0.1;
                let yOffset = 0;
                
                [1, 2, 4, 6, 8].forEach(gap => {
                    const pct = data.percentageContributions[gap] || 0;
                    const barH = (pct / 100) * chartH;
                    
                    ctx.fillStyle = gapColors[gap];
                    ctx.fillRect(x, margin.top + chartH - yOffset - barH, barW, barH);
                    
                    yOffset += barH;
                });
                
                // Label
                ctx.fillStyle = canvasTextBright();
                ctx.font = 'bold 40px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`s=${s}`, x + barW/2, h - 100);
            });
            
            // Legend
            let legendY = margin.top + 50;
            Object.entries(gapColors).forEach(([gap, color]) => {
                ctx.fillStyle = color;
                ctx.fillRect(w - margin.right + 20, legendY, 50, 50);
                ctx.fillStyle = '#ccc';
                ctx.font = 'bold 36px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`Gap ${gap}`, w - margin.right + 80, legendY + 38);
                legendY += 80;
            });
        }
        
        function exportComparisonPNG() {
            const canvas = document.getElementById('comparisonChart');
            const link = document.createElement('a');
            link.download = `zeta_s_comparison_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // ========== CONVERGENCE ANALYSIS FUNCTIONS ==========
        
        function getConvergenceAnalysis(gap, product, s) {
            const TWIN_PRIME_CONSTANT = 0.6601618158468695739278121100145557784326233602847334;
            console.log('getConvergenceAnalysis called with gap:', gap, 'product:', product);
            
            if (gap === 1) {
                const exact = Math.pow(2, s) / (Math.pow(2, s) - 1);
                const error = Math.abs(product - exact);
                
                return `
                    <strong>Observed Value:</strong> P<sub>1</sub>(${s}) = ${product.toFixed(15)}<br><br>
                    
                    <strong>Theoretical:</strong> 2<sup>${s}</sup>/(2<sup>${s}</sup>-1) = ${exact.toFixed(15)}<br><br>
                    
                    <strong>Discrepancy:</strong> ${error.toExponential(3)}<br><br>
                    
                    <strong>Note:</strong> Gap 1 contains only prime 2. The product reduces to a single term: 2<sup>${s}</sup>/(2<sup>${s}</sup>-1).
                `;
            }
            
            if (gap === 2) {
                const C2_FULL = 0.6601618158468695739278121100145557784326233602847334;
                const x = analysisResults.maxPrime;
                const L = Math.log(x);
                const li2_approx = (x/(L*L)) * (1 + 2/L + 6/(L*L) + 24/(L*L*L));
                const twinPrimeCount_predicted = 2 * C2_FULL * li2_approx;
                const twinPrimeCount_actual = analysisResults.gapProducts[gap].count;
                const remaining = (Math.PI**2 / 6) / ((4/3) * product);
                
                return `
                    <strong>Observed:</strong> P<sub>2</sub>(2) = ${product.toFixed(15)}<br><br>
                    
                    <strong>Contribution to log(ζ(2)):</strong><br>
                    log(P<sub>2</sub>) = ${Math.log(product).toFixed(12)}<br>
                    ${((Math.log(product) / Math.log(Math.PI**2/6)) * 100).toFixed(2)}% of total log(π²/6)<br><br>
                    
                    <strong>Combined with P<sub>1</sub>:</strong><br>
                    P<sub>1</sub> × P<sub>2</sub> = ${(4/3 * product).toFixed(15)}<br>
                    Remaining product (P<sub>4</sub> × P<sub>6</sub> × ...): ${remaining.toFixed(15)}<br><br>
                    
                    <strong>Twin Prime Count (up to ${analysisResults.maxPrime.toLocaleString()}):</strong><br>
                    H-L Formula: π₂(x) ~ 2C₂·li₂(x)<br>
                    Predicted: ${Math.round(twinPrimeCount_predicted).toLocaleString()}<br>
                    Observed: ${twinPrimeCount_actual.toLocaleString()}<br>
                    Ratio obs/pred: ${(twinPrimeCount_actual / twinPrimeCount_predicted).toFixed(4)}<br><br>
                    
                    <strong>Note on gap 6 vs gap 2:</strong><br>
                    S(6) = 2·S(2), so gap 6 (sexy primes) is asymptotically <em>twice</em> as frequent as twins or cousins.
                `;
            }
            
            if (gap === 4) {
                return `
                    <strong>Observed:</strong> P<sub>4</sub>(2) = ${product.toFixed(15)}<br><br>
                    
                    <strong>Log contribution:</strong> ${Math.log(product).toFixed(15)}<br><br>
                    
                    <strong>Pattern:</strong> Cousin primes (p, p+4) less frequent than twin primes.<br>
                    Deviation from 1: ${((product - 1) * 100).toFixed(3)}%
                `;
            }
            
            if (gap === 6) {
                return `
                    <strong>Observed:</strong> P<sub>6</sub>(2) = ${product.toFixed(15)}<br><br>
                    
                    <strong>Log contribution:</strong> ${Math.log(product).toFixed(15)}<br><br>
                    
                    <strong>Pattern:</strong> Sexy primes (p, p+6) show notable contribution.<br>
                    Gap divisible by 6 creates modular patterns.<br>
                    Deviation from 1: ${((product - 1) * 100).toFixed(3)}%
                `;
            }
            
            const logContrib = Math.log(product);
            const percentAbove = ((product - 1) * 100);
            
            return `
                <strong>Observed:</strong> P<sub>${gap}</sub>(${s}) = ${product.toFixed(15)}<br><br>
                
                <strong>Log contribution:</strong> ${logContrib.toFixed(15)}<br><br>
                
                <strong>Pattern:</strong> As gap size increases, prime density decreases.<br>
                P<sub>${gap}</sub> approaches 1.<br>
                Deviation from 1: ${percentAbove.toFixed(6)}%
            `;
        }

        // ========== MODAL POPUP FUNCTIONS ==========
        
        // Expand inline detail section for a specific gap in all chart tables
        function expandInlineGapDetail(gap) {
            // This function is now disabled - no dropdowns, no row highlighting
            // Highlighting is done in the chart bars instead
        }
        
        // Close inline detail section
        function closeInlineDetail(gap) {
            const details = document.querySelectorAll(`#gapDetail${gap}`);
            details.forEach(detail => {
                detail.style.animation = 'slideUp 0.3s';
                setTimeout(() => detail.remove(), 300);
            });
            unhighlightAllRows();
        }
        
        // Highlight gap row in all tables
        function highlightGapRow(gap) {
            const tables = document.querySelectorAll('.stats-table');
            tables.forEach(table => {
                const rows = table.querySelectorAll('tr');
                rows.forEach(row => {
                    const firstCell = row.querySelector('td');
                    if (firstCell && firstCell.textContent.trim() === gap.toString()) {
                        row.style.background = 'rgba(78, 205, 196, 0.2)';
                        row.style.outline = '2px solid #4ecdc4';
                    }
                });
            });
        }
        
        // Remove all row highlights
        function unhighlightAllRows() {
            const tables = document.querySelectorAll('.stats-table');
            tables.forEach(table => {
                const rows = table.querySelectorAll('tr');
                rows.forEach(row => {
                    row.style.background = '';
                    row.style.outline = '';
                });
            });
        }
        
        function showGapDetails(gap) {
            console.log('=== showGapDetails DEBUG ===');
            console.log('Input gap:', gap, 'type:', typeof gap);
            
            if (!analysisResults) {
                console.error('No analysisResults!');
                return;
            }
            
            // Ensure gap is a number (might come as string from onclick attribute)
            gap = parseInt(gap);
            console.log('After parseInt, gap:', gap, 'type:', typeof gap);
            
            // First, expand inline detail sections
            expandInlineGapDetail(gap);
            
            // Then show modal popup
            const modal = document.getElementById('gapModal');
            const title = document.getElementById('modalTitle');
            const body = document.getElementById('modalBody');
            
            console.log('Available keys in gapProducts:', Object.keys(analysisResults.gapProducts));
            console.log('Attempting to retrieve gapProducts[' + gap + ']...');
            
            const gapData = analysisResults.gapProducts[gap];
            console.log('Retrieved gapData:', gapData);
            
            if (gapData) {
                console.log('gapData.product:', gapData.product);
                console.log('gapData.count:', gapData.count);
                console.log('gapData.primes (first 5):', gapData.primes?.slice(0, 5));
            }
            
            if (!gapData) {
                console.error('No gapData found for gap:', gap);
                alert(`No data available for gap ${gap}`);
                return;
            }
            
            const s = analysisResults.s || 2;
            const known = getKnownZetaValue(s);
            const zetaLabel = known ? `ζ(${s}) = ${known.formula}` : `ζ(${s.toFixed(2)})`;
            
            // Calculate additional statistics
            const pctContribution = analysisResults.percentageContributions[gap] || 0;
            const avgPrimeInGap = gapData.primes.reduce((a, b) => a + b, 0) / gapData.primes.length;
            
            // Find constellation type
            let gapType = '';
            if (gap === 1) gapType = 'Only Odd Gap (3-2=1)';
            else if (gap === 2) gapType = 'Twin Primes (p, p+2)';
            else if (gap === 4) gapType = 'Cousin Primes (p, p+4)';
            else if (gap === 6) gapType = 'Sexy Primes (p, p+6)';
            else if (gap % 6 === 0) gapType = 'Divisible by 6';
            else gapType = 'General Gap';
            
            title.textContent = `Gap ${gap} - Detailed Analysis`;
            
            body.innerHTML = `
                <div id="modalPart1">
                <div class="modal-section">
                    <div class="modal-section-title">Basic Information</div>
                    <div class="modal-stat-grid">
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Gap Size</div>
                            <div class="modal-stat-value">${gap}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Constellation Type</div>
                            <div class="modal-stat-value" style="font-size: 1rem;">${gapType}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Prime Count in Gap Family (up to ${analysisResults.maxPrime.toLocaleString()})</div>
                            <div class="modal-stat-value">${gapData.count.toLocaleString()}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Current s Value</div>
                            <div class="modal-stat-value">s = ${s.toFixed(2)}</div>
                        </div>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Gap Product: P<sub>${gap}</sub>(s)</div>
                    <div class="modal-stat-grid">
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Product Value P<sub>${gap}</sub></div>
                            <div class="modal-stat-value">${gapData.product.toFixed(12)}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Log Product (log P<sub>${gap}</sub>)</div>
                            <div class="modal-stat-value">${gapData.logProduct.toFixed(12)}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Contribution to log(${zetaLabel})</div>
                            <div class="modal-stat-value">${pctContribution.toFixed(6)}%</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Formula</div>
                            <div class="modal-stat-value" style="font-size: 0.9rem;">∏<sub>p∈Gap${gap}</sub> p<sup>${s.toFixed(1)}</sup>/(p<sup>${s.toFixed(1)}</sup>-1)</div>
                        </div>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Statistical Properties</div>
                    <div class="modal-stat-grid">
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Average Prime in Gap</div>
                            <div class="modal-stat-value">${avgPrimeInGap.toFixed(2)}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Smallest Prime</div>
                            <div class="modal-stat-value">${Math.min(...gapData.primes).toLocaleString()}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">Largest Prime in Range</div>
                            <div class="modal-stat-value">${Math.max(...gapData.primes).toLocaleString()}</div>
                        </div>
                        <div class="modal-stat-item">
                            <div class="modal-stat-label">
                                Density (primes per 
                                <input type="number" id="densityRange_${gap}" value="1000" min="1" max="1000000" 
                                       style="width: 80px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; padding: 4px 8px; color: #ffd700; font-family: 'Courier New', monospace; margin: 0 4px;"
                                       onchange="updateDensity(${gap}, this.value)">)
                            </div>
                            <div class="modal-stat-value" id="densityValue_${gap}">${((gapData.count / analysisResults.maxPrime) * 1000).toFixed(3)}</div>
                        </div>
                    </div>
                </div>
                
                <div class="modal-section">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div class="modal-section-title" style="margin-bottom: 0;">All ${gapData.count.toLocaleString()} Primes in Gap ${gap} Family (up to ${analysisResults.maxPrime.toLocaleString()})</div>
                        <button class="btn btn-secondary" onclick="copyPrimesToClipboard(${gap})" style="padding: 6px 12px; font-size: 0.85rem;">
                            Copy All Primes
                        </button>
                    </div>
                    <div class="modal-prime-list" id="primeList${gap}">
                        <code>${gapData.primes.map(p => p.toLocaleString()).join(', ')}</code>
                    </div>
                    <div style="margin-top: 8px; font-size: 0.8rem; color: #888;">
                        Showing all ${gapData.count.toLocaleString()} primes. Scroll to see more.
                    </div>
                </div>
                </div>
                
                <div id="modalPart2">
                <div class="modal-section">
                    <div class="modal-section-title">Convergence Analysis: What does P<sub>${gap}</sub> converge to?</div>
                    <div style="background: rgba(255, 215, 0, 0.05); padding: 16px; border-radius: 6px; border-left: 3px solid #ffd700; color: #ccc; line-height: 1.8;">
                        ${getConvergenceAnalysis(gap, gapData.product, s)}
                    </div>
                </div>
                
                <div class="modal-section">
                    <div class="modal-section-title">Mathematical Context</div>
                    <div style="background: rgba(139, 92, 246, 0.05); padding: 16px; border-radius: 6px; border-left: 3px solid #8b5cf6; color: #ccc; line-height: 1.8;">
                        <strong>Gap Decomposition Theorem:</strong><br>
                        ζ(s) = ∏<sub>g∈{1,2,4,6,...}</sub> P<sub>g</sub>(s)<br><br>
                        
                        For this gap:<br>
                        P<sub>${gap}</sub>(${s.toFixed(2)}) = ${gapData.product.toFixed(6)}<br>
                        Contributing ${pctContribution.toFixed(2)}% to the logarithmic product.<br><br>
                        
                        ${gap === 1 ? '<strong style="color: #ffd700;">Special Note:</strong> Gap 1 contains only prime 2, the only even prime and the only odd gap (3-2=1).' : ''}
                        ${gap === 2 ? '<strong style="color: #ffd700;">Twin Prime Note:</strong> These are primes p where p+2 is also prime. They dominate ζ(2) decomposition!' : ''}
                        ${gap === 6 ? '<strong style="color: #4ecdc4;">Sexy Prime Note:</strong> These are primes p where p+6 is also prime, named "sexy" from Latin "sex" (six).' : ''}
                    </div>
                </div>
                </div>
            `;
            
            // Add Farey overlay button to gap modal footer
            const modalFooter = body.querySelector('.modal-section:last-child') || body;
            const fareyBtn = document.createElement('div');
            fareyBtn.style.cssText = 'text-align:center;margin-top:20px;padding-top:16px;border-top:1px solid rgba(255,255,255,0.1);';
            fareyBtn.innerHTML = '<button onclick="fareyShowGapOverlay(' + gap + '); document.getElementById(\'gapModal\').classList.remove(\'active\')" style="padding:10px 24px;background:#0d2340;color:#4a90d9;border:1px solid #4a90d9;border-radius:6px;cursor:pointer;font-weight:bold;font-size:1rem;">&#9674; Show Gap ' + gap + ' on Farey Canvas</button>';
            body.appendChild(fareyBtn);

            modal.classList.add('active');
        }
        
        function closeGapModal(event) {
            if (event && event.target.className !== 'modal-overlay') return;
            document.getElementById('gapModal').classList.remove('active');
        }
        
        function screenshotModalPart1() {
            const modalHeader = document.querySelector('.modal-header');
            const modalPart1 = document.getElementById('modalPart1');
            
            if (!modalPart1) {
                alert('Modal content not found');
                return;
            }
            
            // Clone header and part 1
            const headerClone = modalHeader.cloneNode(true);
            const part1Clone = modalPart1.cloneNode(true);
            
            // Find the prime list container and preserve its current scroll state/visible content
            const originalPrimeList = modalPart1.querySelector('.modal-prime-list');
            const clonedPrimeList = part1Clone.querySelector('.modal-prime-list');
            
            if (originalPrimeList && clonedPrimeList) {
                // Set max-height to match what's visible (not expanded)
                const visibleHeight = originalPrimeList.clientHeight;
                clonedPrimeList.style.maxHeight = visibleHeight + 'px';
                clonedPrimeList.style.overflow = 'hidden';
                
                // Preserve scroll position
                clonedPrimeList.scrollTop = originalPrimeList.scrollTop;
            }
            
            // Create a temporary container with header and part 1
            const tempContainer = document.createElement('div');
            tempContainer.style.cssText = 'position: absolute; left: -9999px; background: #1a1a2e; padding: 24px; max-width: 1200px;';
            
            tempContainer.appendChild(headerClone);
            tempContainer.appendChild(part1Clone);
            document.body.appendChild(tempContainer);
            
            // Use html2canvas to capture
            html2canvas(tempContainer, {
                scale: 3, // 4K quality (3x scale)
                backgroundColor: '#1a1a2e',
                logging: false,
                useCORS: true,
                width: tempContainer.scrollWidth,
                height: tempContainer.scrollHeight
            }).then(canvas => {
                // Remove temp container
                document.body.removeChild(tempContainer);
                
                // Convert to blob and download
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const modalTitle = document.getElementById('modalTitle').textContent.replace(/[^a-zA-Z0-9]/g, '_');
                    link.download = `${modalTitle}_Part1_${timestamp}_4K.png`;
                    link.href = url;
                    link.click();
                });
            });
        }
        
        function screenshotModalPart2() {
            const modalHeader = document.querySelector('.modal-header');
            const modalPart2 = document.getElementById('modalPart2');
            
            if (!modalPart2) {
                alert('Modal content not found');
                return;
            }
            
            // Create a temporary container with header and part 2
            const tempContainer = document.createElement('div');
            tempContainer.style.cssText = 'position: absolute; left: -9999px; background: #1a1a2e; padding: 24px;';
            
            // Clone header and part 2
            const headerClone = modalHeader.cloneNode(true);
            const part2Clone = modalPart2.cloneNode(true);
            
            tempContainer.appendChild(headerClone);
            tempContainer.appendChild(part2Clone);
            document.body.appendChild(tempContainer);
            
            // Use html2canvas to capture
            html2canvas(tempContainer, {
                scale: 3, // 4K quality (3x scale)
                backgroundColor: '#1a1a2e',
                logging: false,
                useCORS: true,
                width: tempContainer.scrollWidth,
                height: tempContainer.scrollHeight
            }).then(canvas => {
                // Remove temp container
                document.body.removeChild(tempContainer);
                
                // Convert to blob and download
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const modalTitle = document.getElementById('modalTitle').textContent.replace(/[^a-zA-Z0-9]/g, '_');
                    link.download = `${modalTitle}_Part2_${timestamp}_4K.png`;
                    link.href = url;
                    link.click();
                });
            });
        }
        
        // Update density calculation when user changes the range
        function updateDensity(gap, range) {
            const gapData = analysisResults.gapProducts[gap];
            if (!gapData) return;
            
            const density = (gapData.count / analysisResults.maxPrime) * parseFloat(range);
            document.getElementById(`densityValue_${gap}`).textContent = density.toFixed(3);
        }
        
        // Screenshot the classical or gap view at the bottom
        function screenshotClassicalView() {
            // Check which view is currently shown
            const classicalView = document.getElementById('classicalView');
            const isClassicalViewVisible = classicalView.style.display !== 'none';
            
            if (!isClassicalViewVisible) {
                alert('Please switch to Classical Sequential View mode to take a screenshot of it.');
                return;
            }
            
            const tableWrapper = document.getElementById('classicalTableWrapper');
            const table = document.getElementById('classicalTable');
            
            if (!table || !tableWrapper) {
                alert('Classical view table not found.');
                return;
            }
            
            // Create a temporary container with visible rows + summary
            const tempContainer = document.createElement('div');
            tempContainer.style.cssText = 'background: #0a0a0f; padding: 20px; position: absolute; left: -9999px; top: 0;';
            
            // Add title
            const titleDiv = document.createElement('div');
            titleDiv.style.cssText = 'color: #4ecdc4; font-size: 1.8rem; font-weight: bold; margin-bottom: 20px; text-align: center;';
            titleDiv.textContent = 'Classical Sequential Prime View';
            tempContainer.appendChild(titleDiv);
            
            // Clone the table structure
            const tableClone = document.createElement('table');
            tableClone.style.cssText = table.style.cssText;
            tableClone.innerHTML = table.querySelector('thead').outerHTML;
            
            const tbody = document.createElement('tbody');
            
            // Get visible rows from the scrollable container
            const rows = Array.from(table.querySelectorAll('tbody tr'));
            const scrollTop = tableWrapper.scrollTop;
            const containerHeight = tableWrapper.clientHeight;
            
            // Find visible rows
            let visibleRows = [];
            rows.forEach(row => {
                const rowTop = row.offsetTop;
                const rowBottom = rowTop + row.offsetHeight;
                if (rowBottom > scrollTop && rowTop < scrollTop + containerHeight) {
                    visibleRows.push(row);
                }
            });
            
            // Add visible rows
            visibleRows.forEach(row => {
                tbody.appendChild(row.cloneNode(true));
            });
            
            tableClone.appendChild(tbody);
            
            const tableDiv = document.createElement('div');
            tableDiv.style.cssText = 'background: rgba(0, 0, 0, 0.2); border-radius: 6px; padding: 16px; margin-bottom: 20px;';
            tableDiv.appendChild(tableClone);
            tempContainer.appendChild(tableDiv);
            
            // Add convergence summary
            if (analysisResults) {
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = 'background: rgba(78, 205, 196, 0.1); padding: 16px; border-radius: 6px; border: 1px solid #4ecdc4; text-align: center;';
                const target = Math.PI * Math.PI / 6;
                const finalProduct = analysisResults.finalProduct;
                const error = Math.abs(finalProduct - target);
                summaryDiv.innerHTML = `
                    <div style="color: #4ecdc4; font-size: 1.2rem; font-weight: bold; margin-bottom: 8px;">
                        Convergence to ζ(2) = π²/6
                    </div>
                    <div style="color: #ffd700; font-family: 'Courier New', monospace; font-size: 1rem;">
                        Product: ${finalProduct.toFixed(12)}
                    </div>
                    <div style="color: #ffd700; font-family: 'Courier New', monospace; font-size: 1rem;">
                        Target:  ${target.toFixed(12)}
                    </div>
                    <div style="color: var(--ink-mid); font-size: 0.9rem; margin-top: 8px;">
                        Error: ${error.toExponential(4)}
                    </div>
                `;
                tempContainer.appendChild(summaryDiv);
            }
            
            document.body.appendChild(tempContainer);
            
            // Use html2canvas to capture the temp container
            html2canvas(tempContainer, {
                scale: 2,
                backgroundColor: '#0a0a0f',
                logging: false
            }).then(canvas => {
                document.body.removeChild(tempContainer);
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    link.download = `Classical_Prime_Sequence_${timestamp}.png`;
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                });
            });
        }
        
        // Copy all primes in gap family to clipboard
        function copyPrimesToClipboard(gap) {
            if (!analysisResults || !analysisResults.gapProducts[gap]) return;
            
            const primes = analysisResults.gapProducts[gap].primes;
            
            // Format options: comma-separated or one-per-line
            const commaFormat = primes.join(', ');
            const lineFormat = primes.join('\n');
            
            // Copy comma-separated by default
            navigator.clipboard.writeText(commaFormat).then(() => {
                // Show feedback
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '✓ Copied!';
                button.style.background = '#22c55e';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
            }).catch(err => {
                alert('Failed to copy. Error: ' + err);
            });
        }
        
        // Make charts clickable
        function addChartClickHandlers() {
            const chartIds = ['gapContribChart', 'gapDistChart', 'percentageChart', 'errorChart', 'logScaleChart'];
            
            chartIds.forEach(chartId => {
                const canvas = document.getElementById(chartId);
                if (!canvas) return;
                
                canvas.style.cursor = 'pointer';
                canvas.onclick = (e) => handleChartClick(e, chartId);
            });
        }
        
        function handleChartClick(event, canvasId) {
            if (!analysisResults) return;
            
            const canvas = event.target;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Scale to canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = x * scaleX;
            const canvasY = y * scaleY;
            
            // Determine which gap was clicked based on chart type
            const gaps = getFilteredGaps();
            if (!gaps || gaps.length === 0) return;
            
            // Use the CORRECT margins that match the render functions
            const margin = {left: 200, right: 100, top: 100, bottom: 150};
            const chartW = canvas.width - margin.left - margin.right;
            const chartH = canvas.height - margin.top - margin.bottom;
            
            // Check if click is in chart area
            if (canvasX < margin.left || canvasX > canvas.width - margin.right ||
                canvasY < margin.top || canvasY > canvas.height - margin.bottom) {
                return;
            }
            
            // Bars are rendered with full barWidth spacing between centers
            // Each bar uses barWidth * 0.8 centered within barWidth space
            const barWidth = chartW / gaps.length;
            
            // Determine which bar slot was clicked
            const relativeX = canvasX - margin.left;
            const clickedIndex = Math.floor(relativeX / barWidth);
            
            // Check if click is within the actual bar (not the 10% margin on sides)
            const barStartX = clickedIndex * barWidth;
            const clickXInBar = relativeX - barStartX;
            const barActualStart = barWidth * 0.1;
            const barActualEnd = barWidth * 0.9;
            
            // Ensure index is valid and click is on the actual bar
            if (clickedIndex >= 0 && clickedIndex < gaps.length && 
                clickXInBar >= barActualStart && clickXInBar <= barActualEnd) {
                const clickedGap = parseInt(gaps[clickedIndex]);
                console.log('Chart bar clicked, gap:', clickedGap, 'from chart:', canvasId, 'index:', clickedIndex, 'of', gaps.length);
                showGapDetails(clickedGap);
            }
        }
        
        // Chart Animation System
        const chartAnimations = {
            convergenceChart: { isPlaying: false, currentRange: 100, intervalId: null, speed: 1.0 },
            gapContribChart: { isPlaying: false, currentRange: 100, intervalId: null, speed: 1.0 },
            gapDistChart: { isPlaying: false, currentRange: 100, intervalId: null, speed: 1.0 },
            percentageChart: { isPlaying: false, currentRange: 100, intervalId: null, speed: 1.0 },
            errorChart: { isPlaying: false, currentRange: 100, intervalId: null, speed: 1.0 },
            logScaleChart: { isPlaying: false, currentRange: 100, intervalId: null, speed: 1.0 }
        };
        
        function toggleChartAnimation(chartId) {
            const anim = chartAnimations[chartId];
            if (!anim) return;
            
            const btn = event.target.closest('.chart-play-pause-btn');
            
            if (anim.isPlaying) {
                // Pause
                anim.isPlaying = false;
                btn.classList.remove('playing');
                btn.innerHTML = 'Play';
                if (anim.intervalId) {
                    clearInterval(anim.intervalId);
                    anim.intervalId = null;
                }
            } else {
                // Play
                if (!analysisResults) {
                    alert('Please run the analysis first!');
                    return;
                }
                
                // Reset to starting range
                anim.currentRange = 100;
                
                anim.isPlaying = true;
                btn.classList.add('playing');
                btn.innerHTML = 'Pause';
                startChartAnimation(chartId);
            }
        }
        
        function startChartAnimation(chartId) {
            const anim = chartAnimations[chartId];
            if (!anim) return;
            
            const maxRange = parseInt(document.getElementById('maxPrime').value);
            const baseInterval = 100; // Base update interval in ms
            const interval = baseInterval / anim.speed;
            
            anim.intervalId = setInterval(() => {
                if (anim.currentRange >= maxRange) {
                    // Animation complete - reset to start and stop
                    anim.currentRange = 100;
                    const btn = document.querySelector(`[onclick="toggleChartAnimation('${chartId}')"]`);
                    if (btn) {
                        anim.isPlaying = false;
                        btn.classList.remove('playing');
                        btn.innerHTML = 'Play';
                    }
                    clearInterval(anim.intervalId);
                    anim.intervalId = null;
                    
                    // Re-render with full range
                    renderIndividualChart(chartId, maxRange);
                    return;
                }
                
                // Increment range
                const increment = Math.max(1, Math.floor(maxRange / 100));
                anim.currentRange = Math.min(anim.currentRange + increment, maxRange);
                
                // Re-render chart with current range
                renderIndividualChart(chartId, anim.currentRange);
            }, interval);
        }
        
        function updateChartSpeed(chartId) {
            const anim = chartAnimations[chartId];
            if (!anim) return;
            
            const slider = document.getElementById(chartId + 'SpeedSlider');
            const speedDisplay = document.getElementById(chartId + 'Speed');
            
            anim.speed = parseFloat(slider.value);
            speedDisplay.textContent = anim.speed.toFixed(1) + 'x';
            
            // If playing, restart with new speed
            if (anim.isPlaying) {
                clearInterval(anim.intervalId);
                anim.intervalId = null;
                startChartAnimation(chartId);
            }
        }
        
        function renderIndividualChart(chartId, maxPrime) {
            // Get current s value
            const s = analysisResults.s || 2;
            
            // Calculate gap decomposition for the specified range
            const tempResults = computeGapDecompositionWithS(maxPrime, s);
            
            // Store original results
            const originalResults = analysisResults;
            
            // Temporarily use the new results for rendering
            analysisResults = tempResults;
            
            // Render the specific chart - these functions use the global analysisResults
            switch(chartId) {
                case 'convergenceChart':
                    renderConvergenceChart();
                    break;
                case 'gapContribChart':
                    renderGapContribChart();
                    break;
                case 'gapDistChart':
                    renderGapDistChart();
                    break;
                case 'percentageChart':
                    renderPercentageChart();
                    break;
                case 'errorChart':
                    renderErrorChart();
                    break;
                case 'logScaleChart':
                    renderLogScaleChart();
                    break;
            }
            
            // Restore original results
            analysisResults = originalResults;
        }
        
        // Event delegation for gap row clicks - highlights bar in associated chart AND opens modal
        document.addEventListener('click', function(e) {
            const row = e.target.closest('.gap-row');
            if (row && row.dataset.gap) {
                const gap = parseInt(row.dataset.gap);
                console.log('Row clicked, gap:', gap);
                
                // Find which table this row belongs to
                const tableContainer = row.closest('.stats-table-container');
                if (tableContainer && tableContainer.dataset.chart) {
                    const chartId = tableContainer.dataset.chart;
                    console.log('Chart to highlight:', chartId);
                    
                    // Re-render the specific chart with this gap highlighted
                    highlightGapInChart(chartId, gap);
                }
                
                // Always open the modal popup when clicking a row
                showGapDetails(gap);
            }
        });
        
        // Highlight a specific gap in a specific chart
        function highlightGapInChart(chartId, gap) {
            switch(chartId) {
                case 'gapContribChart':
                    renderGapContributionsChart(gap);
                    break;
                case 'gapDistChart':
                    renderGapDistributionChart(gap);
                    break;
                case 'percentageChart':
                    renderPercentageChart(gap);
                    break;
            }
        }
        // ============================================================
        // MERTENS FUNCTION MODULE — all vars/functions prefixed m_
        // ============================================================
        (function() {
            // Data stores
            const m_mobius  = [];
            const m_mertens = [];
            const m_sqFree  = [];
            const m_nFactors = [];
            let   m_maxComputed = 0;

            // State
            let m_currentRange = 2000;
            let m_animId = null;
            let m_isAnimating = false;
            let m_animSpeed = 50;
            let m_selectedRow = null;
            let m_sortCol = 'n';
            let m_sortAsc = true;

            // Expose to global scope so onclick="" handlers work
            window.m_onRangeSlider  = v => { m_currentRange = parseInt(v); document.getElementById('m_rangeValue').textContent = v; document.getElementById('m_manualInput').value = v; m_drawGraph(); m_updateStats(); m_populateTable(); };
            window.m_onManualInput  = v => { const n = parseInt(v); if (n >= 100 && n <= 100000) { m_currentRange = n; document.getElementById('m_rangeValue').textContent = n; if (n <= 10000) document.getElementById('m_rangeSlider').value = n; m_drawGraph(); m_updateStats(); m_populateTable(); } };
            window.m_onSpeedSlider  = v => { m_animSpeed = parseInt(v); document.getElementById('m_speedValue').textContent = v; };
            window.m_startAnimation = m_startAnimation;
            window.m_stopAnimation  = m_stopAnimation;
            window.m_startBackwardAnimation = m_startBackwardAnimation;
            window.m_drawGraph      = m_drawGraph;
            window.m_populateTable  = m_populateTable;
            window.m_sortTable      = col => { if (m_sortCol === col) m_sortAsc = !m_sortAsc; else { m_sortCol = col; m_sortAsc = true; } m_populateTable(); };
            window.m_exportCSV      = m_exportCSV;

            // ----- Computation -----
            function m_primeFactors(n) {
                const f = []; let d = 2;
                while (d * d <= n) { while (n % d === 0) { f.push(d); n /= d; } d++; }
                if (n > 1) f.push(n);
                return f;
            }

            function m_computeMobius(n) {
                if (n === 1) return 1;
                const f = m_primeFactors(n);
                const u = [...new Set(f)];
                if (f.length !== u.length) return 0;
                return u.length % 2 === 0 ? 1 : -1;
            }

            function m_extendTo(target) {
                if (target <= m_maxComputed) return;
                for (let n = m_maxComputed + 1; n <= target; n++) {
                    const mu  = m_computeMobius(n);
                    const M   = (n === 1 ? 0 : m_mertens[n - 2]) + mu;
                    const f   = m_primeFactors(n);
                    const u   = [...new Set(f)];
                    m_mobius.push(mu);
                    m_mertens.push(M);
                    m_sqFree.push(mu !== 0 ? 1 : 0);
                    m_nFactors.push(u.length);
                }
                m_maxComputed = target;
            }

            // ----- Stats -----
            function m_updateStats() {
                m_extendTo(m_currentRange);
                const d = m_mertens.slice(0, m_currentRange);
                const s = m_sqFree.slice(0, m_currentRange);
                let maxV = d[0], minV = d[0], maxI = 0, minI = 0;
                let zeros = 0, within = 0;
                for (let i = 0; i < d.length; i++) {
                    if (d[i] > maxV) { maxV = d[i]; maxI = i; }
                    if (d[i] < minV) { minV = d[i]; minI = i; }
                    if (d[i] === 0) zeros++;
                    if (Math.abs(d[i]) <= Math.sqrt(i + 1)) within++;
                }
                const sqF = s.reduce((a, b) => a + b, 0);
                document.getElementById('m_statRange').textContent   = `n = 1 to ${m_currentRange.toLocaleString()}`;
                document.getElementById('m_statMax').textContent     = `M(${maxI+1}) = ${maxV}`;
                document.getElementById('m_statMin').textContent     = `M(${minI+1}) = ${minV}`;
                document.getElementById('m_statZeros').textContent   = `${zeros} points`;
                document.getElementById('m_statSquareFree').textContent = `${sqF.toLocaleString()} / ${m_currentRange.toLocaleString()}`;
                document.getElementById('m_statBoundary').textContent = `${((within / m_currentRange) * 100).toFixed(1)}%`;
            }

            // ----- Graph -----
            function m_drawGraph() {
                m_extendTo(m_currentRange);
                const canvas = document.getElementById('m_graphCanvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const W = canvas.width, H = canvas.height, pad = 65;
                const gW = W - 2*pad, gH = H - 2*pad;
                ctx.clearRect(0, 0, W, H);

                const d = m_mertens.slice(0, m_currentRange);
                const maxV = Math.max(...d,  Math.sqrt(m_currentRange));
                const minV = Math.min(...d, -Math.sqrt(m_currentRange));
                const range = maxV - minV || 1;

                const toY = v => pad + ((maxV - v) / range) * gH;
                const toX = i => pad + ((i + 1) / m_currentRange) * gW;

                // Grid lines
                ctx.strokeStyle = window.canvasGrid ? window.canvasGrid() : '#1a1a2a'; ctx.lineWidth = 1;
                const yStep = range > 40 ? 5 : range > 15 ? 2 : 1;
                for (let v = Math.ceil(minV); v <= Math.floor(maxV); v += yStep) {
                    const y = toY(v);
                    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(W - pad, y); ctx.stroke();
                }

                // Axes
                ctx.strokeStyle = window.canvasGrid ? window.canvasGrid() : '#3a3a5a'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(pad, H - pad); ctx.lineTo(W - pad, H - pad); ctx.stroke();

                // Zero line
                const zeroY = toY(0);
                ctx.strokeStyle = window.canvasGrid ? window.canvasGrid() : '#4a4a6a'; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.moveTo(pad, zeroY); ctx.lineTo(W - pad, zeroY); ctx.stroke();
                ctx.setLineDash([]);

                // Y labels
                ctx.fillStyle = canvasText(); ctx.font = '11px monospace'; ctx.textAlign = 'right';
                for (let v = Math.ceil(minV); v <= Math.floor(maxV); v += yStep) {
                    ctx.fillText(v, pad - 8, toY(v) + 4);
                }

                // X labels
                ctx.textAlign = 'center';
                const xStep = m_currentRange > 10000 ? 2000 : m_currentRange > 1000 ? 500 : 200;
                for (let i = 0; i <= m_currentRange; i += xStep) {
                    ctx.fillText(i.toLocaleString(), pad + (i / m_currentRange) * gW, H - pad + 18);
                }

                // Axis titles
                ctx.fillStyle = window.canvasText ? window.canvasText() : '#666'; ctx.font = '11px sans-serif';
                ctx.textAlign = 'right'; ctx.fillText('M(n)', pad - 8, pad - 10);
                ctx.textAlign = 'center'; ctx.fillText('n', W - pad + 30, H - pad + 18);

                // √n boundaries
                if (document.getElementById('m_showBounds').checked) {
                    ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.5;
                    const step = Math.max(3, Math.floor(m_currentRange / 500));
                    [1, -1].forEach(sign => {
                        ctx.beginPath();
                        for (let i = 1; i <= m_currentRange; i += step) {
                            const x = pad + (i / m_currentRange) * gW;
                            const y = toY(sign * Math.sqrt(i));
                            i === 1 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    });
                    ctx.globalAlpha = 1;
                    // Label
                    ctx.fillStyle = '#ef4444'; ctx.font = '11px sans-serif'; ctx.textAlign = 'left'; ctx.globalAlpha = 0.7;
                    ctx.fillText('±√n (RH boundary)', pad + 6, toY(Math.sqrt(m_currentRange)) - 6);
                    ctx.globalAlpha = 1;
                }

                // Zero crossing highlights
                if (document.getElementById('m_showZeros').checked) {
                    ctx.fillStyle = '#22c55e'; ctx.globalAlpha = 0.25;
                    for (let i = 0; i < m_currentRange; i++) {
                        if (d[i] === 0) {
                            const x = toX(i);
                            ctx.fillRect(x - 1, pad, 2, gH);
                        }
                    }
                    ctx.globalAlpha = 1;
                }

                // Mertens line
                ctx.strokeStyle = '#4ecdc4'; ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < m_currentRange; i++) {
                    const x = toX(i), y = toY(d[i]);
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Selected point
                if (m_selectedRow !== null && m_selectedRow <= m_currentRange) {
                    const x = pad + (m_selectedRow / m_currentRange) * gW;
                    const y = toY(d[m_selectedRow - 1]);
                    ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(x, y, 7, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#b8860b'; ctx.lineWidth = 2; ctx.stroke();
                }
            }

            // ----- Animation -----
            function m_startAnimation() {
                if (m_isAnimating) return;
                m_isAnimating = true;
                document.getElementById('m_playBtn').style.display = 'none';
                document.getElementById('m_pauseBtn').style.display = 'inline-block';
                const max = parseInt(document.getElementById('m_rangeSlider').max);
                function step() {
                    if (!m_isAnimating) return;
                    if (m_currentRange < max) {
                        m_currentRange = Math.min(m_currentRange + Math.max(10, Math.floor(max / 300)), max);
                        document.getElementById('m_rangeSlider').value = Math.min(m_currentRange, 10000);
                        document.getElementById('m_rangeValue').textContent = m_currentRange;
                        document.getElementById('m_manualInput').value = m_currentRange;
                        m_drawGraph(); m_updateStats();
                        m_animId = setTimeout(step, m_animSpeed);
                    } else {
                        if (document.getElementById('m_loopAnim').checked) {
                            m_currentRange = 100;
                            m_animId = setTimeout(step, m_animSpeed * 3);
                        } else { m_stopAnimation(); }
                    }
                }
                step();
            }

            function m_startBackwardAnimation() {
                if (m_isAnimating) return;
                m_isAnimating = true;
                document.getElementById('m_playBtn').style.display = 'none';
                document.getElementById('m_pauseBtn').style.display = 'inline-block';
                function step() {
                    if (!m_isAnimating) return;
                    if (m_currentRange > 100) {
                        m_currentRange = Math.max(m_currentRange - Math.max(10, Math.floor(m_currentRange / 100)), 100);
                        document.getElementById('m_rangeSlider').value = Math.min(m_currentRange, 10000);
                        document.getElementById('m_rangeValue').textContent = m_currentRange;
                        document.getElementById('m_manualInput').value = m_currentRange;
                        m_drawGraph(); m_updateStats();
                        m_animId = setTimeout(step, m_animSpeed);
                    } else {
                        if (document.getElementById('m_loopAnim').checked) {
                            m_currentRange = parseInt(document.getElementById('m_rangeSlider').max);
                            m_animId = setTimeout(step, m_animSpeed * 3);
                        } else { m_stopAnimation(); }
                    }
                }
                step();
            }

            function m_stopAnimation() {
                m_isAnimating = false;
                document.getElementById('m_playBtn').style.display = 'inline-block';
                document.getElementById('m_pauseBtn').style.display = 'none';
                clearTimeout(m_animId); m_animId = null;
                m_populateTable();
            }

            // ----- Table -----
            function m_populateTable() {
                m_extendTo(m_currentRange);
                const body = document.getElementById('m_tableBody');
                if (!body) return;

                const search = document.getElementById('m_searchInput').value.trim();
                const filter = document.getElementById('m_filterType').value;

                let rows = [];
                for (let i = 0; i < m_currentRange; i++) {
                    const n = i + 1;
                    const mu = m_mobius[i], M = m_mertens[i];
                    const delta = i === 0 ? mu : M - m_mertens[i - 1];
                    const sqF = m_sqFree[i] === 1;
                    const factors = m_nFactors[i];
                    const distance = Math.abs(M);
                    const within = distance <= Math.sqrt(n);
                    const isZero = M === 0;
                    if (filter === 'zeros'       && !isZero)   continue;
                    if (filter === 'positive'    && M <= 0)    continue;
                    if (filter === 'negative'    && M >= 0)    continue;
                    if (filter === 'square-free' && !sqF)      continue;
                    if (search && !n.toString().includes(search)) continue;
                    rows.push({n, mu, M, delta, sqF, factors, distance, within, isZero});
                }

                rows.sort((a, b) => {
                    const av = a[m_sortCol === 'sqFree' ? 'sqF' : m_sortCol === 'within' ? 'within' : m_sortCol];
                    const bv = b[m_sortCol === 'sqFree' ? 'sqF' : m_sortCol === 'within' ? 'within' : m_sortCol];
                    const r = (av > bv ? 1 : av < bv ? -1 : 0);
                    return m_sortAsc ? r : -r;
                });

                // Limit display for performance
                const display = rows.slice(0, 500);

                body.innerHTML = display.map(r => {
                    const muCls = r.mu > 0 ? 'color:#22c55e' : r.mu < 0 ? 'color:#ef4444' : 'color:#a855f7';
                    const MCls  = r.M  > 0 ? 'color:#22c55e' : r.M  < 0 ? 'color:#ef4444' : 'color:#4ecdc4';
                    const dCls  = r.delta > 0 ? 'color:#22c55e' : r.delta < 0 ? 'color:#ef4444' : 'color:#888';
                    const rowBg = r.isZero ? 'background:rgba(34,197,94,0.08)' : (r.n === m_selectedRow ? 'background:rgba(255,215,0,0.08)' : '');
                    return `<tr data-n="${r.n}" style="${rowBg}; border-bottom:1px solid #1a1a2a; cursor:pointer;">
                        <td style="padding:8px 12px; color:#e0e0e0;">${r.n}</td>
                        <td style="padding:8px 12px; ${muCls}; font-weight:600;">${r.mu}</td>
                        <td style="padding:8px 12px; ${MCls}; font-weight:700;">${r.M}</td>
                        <td style="padding:8px 12px; ${dCls};">${r.delta > 0 ? '+' : ''}${r.delta}</td>
                        <td style="padding:8px 12px;">${r.sqF ? '<span style="background:rgba(34,197,94,0.2);color:#22c55e;padding:2px 8px;border-radius:10px;font-size:0.78rem;">Yes</span>' : '<span style="background:rgba(239,68,68,0.2);color:#ef4444;padding:2px 8px;border-radius:10px;font-size:0.78rem;">No</span>'}</td>
                        <td style="padding:8px 12px; color:#ccc;">${r.factors}</td>
                        <td style="padding:8px 12px; color:#ccc;">${r.distance}</td>
                        <td style="padding:8px 12px;">${r.within ? '<span style="background:rgba(34,197,94,0.2);color:#22c55e;padding:2px 8px;border-radius:10px;font-size:0.78rem;">Yes</span>' : '<span style="background:rgba(239,68,68,0.2);color:#ef4444;padding:2px 8px;border-radius:10px;font-size:0.78rem;">No</span>'}</td>
                        <td style="padding:8px 12px;">${r.isZero ? '<span style="background:rgba(78,205,196,0.2);color:#4ecdc4;padding:2px 8px;border-radius:10px;font-size:0.78rem;">Equilibrium</span>' : r.M > 0 ? '<span style="color:#22c55e;">Positive</span>' : '<span style="color:#ef4444;">Negative</span>'}</td>
                    </tr>`;
                }).join('');

                // Row click handler
                body.querySelectorAll('tr[data-n]').forEach(tr => {
                    tr.addEventListener('click', () => {
                        m_selectedRow = parseInt(tr.dataset.n);
                        m_drawGraph();
                        m_populateTable();
                    });
                });

                // Footer
                const full = m_mertens.slice(0, m_currentRange);
                const muFull = m_mobius.slice(0, m_currentRange);
                const sfFull = m_sqFree.slice(0, m_currentRange);
                document.getElementById('m_sumMu').textContent      = muFull.reduce((a,b) => a+b, 0);
                document.getElementById('m_finalM').textContent     = full[full.length - 1];
                document.getElementById('m_sqFreeCount').textContent = sfFull.reduce((a,b) => a+b, 0).toLocaleString();
                document.getElementById('m_avgDist').textContent    = (full.reduce((a,b) => a + Math.abs(b), 0) / m_currentRange).toFixed(2);
                document.getElementById('m_withinCount').textContent = full.filter((m,i) => Math.abs(m) <= Math.sqrt(i+1)).length.toLocaleString();
                document.getElementById('m_zeroCount').textContent  = full.filter(m => m === 0).length;

                if (rows.length > 500) {
                    const info = document.createElement('tr');
                    info.innerHTML = `<td colspan="9" style="padding:10px; text-align:center; color:#888; font-size:0.8rem;">Showing first 500 of ${rows.length} matching rows. Use filters to narrow results.</td>`;
                    body.appendChild(info);
                }
            }

            // ----- CSV Export -----
            function m_exportCSV() {
                m_extendTo(m_currentRange);
                const N = m_currentRange;
                const ts = new Date().toISOString().replace(/[:.]/g,'-').slice(0,-5);
                // summary stats
                let zeros=0, positives=0, negatives=0, maxAbsM=0, maxAbsN=1;
                let lastZero=0;
                for (let i=0;i<N;i++){
                    const M=m_mertens[i];
                    if(M===0){zeros++;lastZero=i+1;}
                    else if(M>0) positives++;
                    else negatives++;
                    if(Math.abs(M)>maxAbsM){maxAbsM=Math.abs(M);maxAbsN=i+1;}
                }
                let csv  = 'Mertens Function M(n) = sum of mu(k) for k=1..n\n';
                csv += `Generated:,${new Date().toISOString()}\n`;
                csv += `Range:,n = 1 to ${N.toLocaleString()}\n`;
                csv += `Zero crossings M(n)=0:,${zeros.toLocaleString()}\n`;
                csv += `Positive values:,${positives.toLocaleString()}\n`;
                csv += `Negative values:,${negatives.toLocaleString()}\n`;
                csv += `Max |M(n)|:,${maxAbsM} at n=${maxAbsN.toLocaleString()}\n`;
                csv += `Last zero crossing:,n=${lastZero.toLocaleString()}\n`;
                csv += `RH boundary sqrt(n) at n=${N}: ,${Math.sqrt(N).toFixed(4)}\n\n`;
                csv += 'n,mu(n),M(n),delta (M(n)-M(n-1)),square_free,prime_factor_count,|M(n)|,|M(n)|/sqrt(n),within_sqrt_boundary,status\n';
                for (let i = 0; i < N; i++) {
                    const n = i+1, mu = m_mobius[i], M = m_mertens[i];
                    const delta = i === 0 ? mu : M - m_mertens[i-1];
                    const ratio = (Math.abs(M)/Math.sqrt(n)).toFixed(6);
                    csv += `${n},${mu},${M},${delta},${m_sqFree[i]?1:0},${m_nFactors[i]},${Math.abs(M)},${ratio},${Math.abs(M)<=Math.sqrt(n)?1:0},${M===0?'equilibrium':M>0?'positive':'negative'}\n`;
                }
                csv += `\nEND OF DATASET — n=1 to ${N.toLocaleString()}\n`;
                const a = document.createElement('a');
                a.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);
                a.download = `mertens_n${N}_${ts}.csv`;
                a.click();
            }

            // ----- Tooltip -----
            const m_canvas = document.getElementById('m_graphCanvas');
            if (m_canvas) {
                m_canvas.addEventListener('mousemove', e => {
                    const rect = m_canvas.getBoundingClientRect();
                    const scaleX = m_canvas.width / rect.width;
                    const cx = (e.clientX - rect.left) * scaleX;
                    const pad = 65, gW = m_canvas.width - 2*pad;
                    const i = Math.round((cx - pad) / gW * m_currentRange) - 1;
                    if (i < 0 || i >= m_currentRange) return;
                    m_extendTo(m_currentRange);
                    const n = i+1, mu = m_mobius[i], M = m_mertens[i];
                    const tip = document.getElementById('m_tooltip');
                    tip.innerHTML = `<strong style="color:#4ecdc4">n = ${n}</strong><br>μ(n) = <span style="color:${mu>0?'#22c55e':mu<0?'#ef4444':'#a855f7'}">${mu}</span><br>M(n) = <span style="color:${M>0?'#22c55e':M<0?'#ef4444':'#4ecdc4'}">${M}</span><br>|M(n)| / √n = ${(Math.abs(M)/Math.sqrt(n)).toFixed(4)}`;
                    tip.style.opacity = '1';
                    tip.style.left = (e.clientX - rect.left + 12) + 'px';
                    tip.style.top  = (e.clientY - rect.top  - 40) + 'px';
                });
                m_canvas.addEventListener('mouseleave', () => {
                    document.getElementById('m_tooltip').style.opacity = '0';
                });
                m_canvas.addEventListener('click', e => {
                    const rect = m_canvas.getBoundingClientRect();
                    const scaleX = m_canvas.width / rect.width;
                    const cx = (e.clientX - rect.left) * scaleX;
                    const pad = 65, gW = m_canvas.width - 2*pad;
                    const i = Math.round((cx - pad) / gW * m_currentRange) - 1;
                    if (i >= 0 && i < m_currentRange) { m_selectedRow = i+1; m_drawGraph(); m_populateTable(); }
                });
            }

            // ----- Init -----
            window.addEventListener('load', () => {
                m_extendTo(2000);
                m_drawGraph();
                m_updateStats();
                m_populateTable();
            });

        })(); // end Mertens module
        // ============================================================
        // HARDY-LITTLEWOOD DEEP DIVE MODULE
        // ============================================================
        (function() {
            const C2 = 0.6601618158468695;

            // ── helpers ──────────────────────────────────────────────
            function isPrime(n) {
                if (n < 2) return false;
                if (n === 2) return true;
                if (n % 2 === 0) return false;
                for (let d = 3; d * d <= n; d += 2) if (n % d === 0) return false;
                return true;
            }

            function oddPrimeFactors(h) {
                // unique odd prime factors of h
                const factors = [];
                let n = h;
                while (n % 2 === 0) n /= 2;
                for (let p = 3; p * p <= n; p += 2) {
                    if (n % p === 0) { factors.push(p); while (n % p === 0) n /= p; }
                }
                if (n > 1) factors.push(n);
                return factors;
            }

            const _ssMemo3 = Object.create(null);
            function singularSeries(h) {
                if (_ssMemo3[h] !== undefined) return _ssMemo3[h];
                const opf = oddPrimeFactors(h);
                let mult = 1;
                opf.forEach(p => mult *= (p - 1) / (p - 2));
                return (_ssMemo3[h] = 2 * C2 * mult);
            }

            function li2(x, terms = 4) {
                // li_2(x) = integral_2^x dt/ln^2(t)
                // Asymptotic expansion: x/ln^2(x) * sum_{k=0}^{terms-1} (k+1)!/1 / ln^k(x)
                // Coefficients: k=0:1, k=1:2, k=2:6, k=3:24, k=4:120 = (k+1)!
                const L = Math.log(x);
                let sum = 1;
                let coeff = 1;
                for (let k = 1; k < terms; k++) {
                    coeff *= (k + 1); // (k+1)! — NOT k!, which was the bug
                    sum += coeff / Math.pow(L, k);
                }
                return (x / (L * L)) * sum;
            }

            function gapName(h) {
                const names = { 2:'Twin', 4:'Cousin', 6:'Sexy', 8:'', 10:'', 12:'', 14:'',
                    18:'', 20:'', 24:'', 30:'', 42:'', 60:'', 70:'', 78:'', 102:'', 210:'' };
                return names[h] || '';
            }

            function factorString(h) {
                // return "2^a × p × q…" nicely
                let n = h, pow2 = 0;
                while (n % 2 === 0) { pow2++; n /= 2; }
                let s = pow2 > 1 ? `2^${pow2}` : pow2 === 1 ? '2' : '';
                const opf = oddPrimeFactors(h);
                if (opf.length) s += (s ? '×' : '') + opf.join('×');
                return s || String(h);
            }

            // ── Part 2: C2 partial products table ────────────────────
            function buildC2Table() {
                const tbody = document.getElementById('hl_c2_table_body');
                if (!tbody) return;
                const primes = [3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73];
                let running = 1;
                const C2_TARGET = 0.6601618158468695;
                let rows = '';
                primes.forEach(p => {
                    const factor = p * (p - 2) / ((p - 1) * (p - 1));
                    running *= factor;
                    const pctOfFinal = (running / C2_TARGET * 100).toFixed(3);
                    const factorColor = factor < 0.97 ? '#ef4444' : '#f59e0b';
                    rows += `<tr style="border-bottom:1px solid #1a1a2a;">
                        <td style="padding:6px 12px;color:#e0e0e0;">${p}</td>
                        <td style="padding:6px 12px;color:#ccc;">${p}×${p-2}/${(p-1)}² = ${p*(p-2)}/${(p-1)*(p-1)}</td>
                        <td style="padding:6px 12px;color:${factorColor};">${factor.toFixed(8)}</td>
                        <td style="padding:6px 12px;color:#ffd700;">${running.toFixed(10)}</td>
                        <td style="padding:6px 12px;">
                            <div style="display:flex;align-items:center;gap:8px;">
                                <div style="background:var(--parchment-dark);border-radius:3px;width:80px;height:8px;overflow:hidden;">
                                    <div style="background:${parseFloat(pctOfFinal)>100?'#ef4444':'#ffd700'};height:100%;width:${Math.min(parseFloat(pctOfFinal),100)}%;"></div>
                                </div>
                                <span style="color:${parseFloat(pctOfFinal)>100?'#ef4444':'#888'};">${pctOfFinal}%${parseFloat(pctOfFinal)>100?' ↑':''}</span>
                            </div>
                        </td>
                    </tr>`;
                });
                rows += `<tr style="background:var(--parchment-dark);font-weight:700;">
                    <td colspan="3" style="padding:8px 12px;color:#4ecdc4;">Limit (infinite product)</td>
                    <td style="padding:8px 12px;color:#ffd700;">0.6601618158468695…</td>
                    <td style="padding:8px 12px;color:#22c55e;">100.000%</td>
                </tr>
                <tr>
                    <td colspan="5" style="padding:8px 12px;color:#888;font-size:.8rem;font-style:italic;">
                        Note: the partial product starts <em>above</em> C₂ (red ↑ bars) because the first few factors pull it down from 1.0 quickly but overshoot. It converges monotonically downward toward C₂ once the large early corrections (p=3,5,7) have been applied. The product never passes below C₂.
                    </td>
                </tr>`;
                tbody.innerHTML = rows;
            }

            // ── Part 3: Singular series table ─────────────────────────
            function buildSingularTable() {
                const tbody = document.getElementById('hl_singular_table_body');
                if (!tbody) return;
                const gaps = [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,36,42,48,60,66,70,78,90,102,110,120,150,180,210,330];
                const S2 = 2 * C2;
                let rows = '';
                gaps.forEach((h, idx) => {
                    const opf = oddPrimeFactors(h);
                    const factors = opf.map(p => `(${p-1})/(${p-2})=${((p-1)/(p-2)).toFixed(4)}`);
                    const product = opf.reduce((a, p) => a * (p-1)/(p-2), 1);
                    const Sh = 2 * C2 * product;
                    const ratio = Sh / S2;
                    const rowBg = idx % 2 === 0 ? '' : 'background:rgba(255,255,255,.02)';
                    const ratioColor = ratio > 1.5 ? '#22c55e' : ratio > 1.1 ? '#f59e0b' : '#4ecdc4';
                    rows += `<tr style="border-bottom:1px solid #1a1a2a;${rowBg}">
                        <td style="padding:6px 10px;color:#ffd700;font-weight:700;">${h}</td>
                        <td style="padding:6px 10px;color:#ccc;font-family:monospace;font-size:.8rem;">${factorString(h)}</td>
                        <td style="padding:6px 10px;color:#a855f7;">${opf.length ? opf.join(', ') : '(none)'}</td>
                        <td style="padding:6px 10px;color:#ccc;font-size:.8rem;">${factors.length ? factors.join(' × ') : '—'}</td>
                        <td style="padding:6px 10px;color:#f59e0b;font-family:monospace;">${product.toFixed(6)}</td>
                        <td style="padding:6px 10px;color:#22c55e;font-family:monospace;font-weight:700;">${Sh.toFixed(8)}</td>
                        <td style="padding:6px 10px;color:${ratioColor};font-weight:700;">${ratio.toFixed(4)}×</td>
                        <td style="padding:6px 10px;color:#888;font-size:.8rem;">${gapName(h)}</td>
                    </tr>`;
                });
                tbody.innerHTML = rows;
            }

            // ── Part 4: li2 expansion table ────────────────────────────
            window.hl_updateLi2Table = function() {
                const tbody = document.getElementById('hl_li2_table_body');
                if (!tbody) return;
                const xEl = document.getElementById('hl_li2_x_input');
                const x = xEl ? parseFloat(xEl.value) || 400000000 : 400000000;
                const L = Math.log(x);
                const lnDisp = document.getElementById('hl_li2_lnx_display');
                if (lnDisp) lnDisp.textContent = `ln(x) = ${L.toFixed(6)}   x/ln²(x) = ${(x/(L*L)).toLocaleString('en', {maximumFractionDigits:0})}`;

                // observed twins: use analysis results if available
                const obsTwins = (typeof analysisResults !== 'undefined' && analysisResults && analysisResults.gapProducts && analysisResults.gapProducts[2])
                    ? analysisResults.gapProducts[2].count : 1507733;

                const termLabels = [
                    '1 term (crude)',
                    '2 terms (+ 2/lnx)',
                    '3 terms (+ 6/ln²x)',
                    '4 terms (+ 24/ln³x)',
                    '5 terms (+ 120/ln⁴x)',
                    '6 terms (+ 720/ln⁵x)'
                ];
                const termFormulas = [
                    'x/ln²(x)',
                    'x/ln²(x)·(1+2/L)',
                    'x/ln²(x)·(1+2/L+6/L²)',
                    'x/ln²(x)·(1+2/L+6/L²+24/L³)',
                    'x/ln²(x)·(1+…+120/L⁴)',
                    'x/ln²(x)·(1+…+720/L⁵)'
                ];
                const coeffs = [1, 2, 6, 24, 120, 720];
                let prevErr = null;
                let rows = '';

                for (let t = 1; t <= 6; t++) {
                    let sum = 1;
                    for (let k = 1; k < t; k++) sum += coeffs[k] / Math.pow(L, k);
                    const li2val = (x / (L * L)) * sum;
                    const pred = 2 * C2 * li2val;
                    const err = Math.abs(obsTwins - pred) / obsTwins * 100;
                    const improvement = prevErr !== null ? (prevErr - err).toFixed(3) + '%' : '—';
                    const errColor = err < 1 ? '#22c55e' : err < 5 ? '#f59e0b' : '#ef4444';
                    const isActive = t === 4 ? 'background:#1e1e30;' : '';
                    rows += `<tr style="border-bottom:1px solid #1a1a2a;${isActive}">
                        <td style="padding:7px 12px;color:${t===4?'#4ecdc4':'#ccc'};">${termLabels[t-1]}${t===4?' ✓':''}</td>
                        <td style="padding:7px 12px;color:#888;font-size:.78rem;">${termFormulas[t-1]}</td>
                        <td style="padding:7px 12px;color:#e0e0e0;font-family:monospace;">${Math.round(li2val).toLocaleString()}</td>
                        <td style="padding:7px 12px;color:#ffd700;font-family:monospace;">${Math.round(pred).toLocaleString()}</td>
                        <td style="padding:7px 12px;color:#22c55e;font-size:.82rem;">${improvement}</td>
                        <td style="padding:7px 12px;color:${errColor};font-weight:600;">${err.toFixed(4)}%</td>
                    </tr>`;
                    prevErr = err;
                }
                tbody.innerHTML = rows;
            };

            // ── Part 5: Full gap-by-gap table (live from analysis) ─────
            window.hl_populateFullTable = function() {
                const tbody = document.getElementById('hl_full_table_body');
                const rangeDisp = document.getElementById('hl_range_display');
                if (!tbody) return;
                if (typeof analysisResults === 'undefined' || !analysisResults || !analysisResults.gapProducts) {
                    return; // leave placeholder
                }
                const x = analysisResults.maxPrime;
                if (rangeDisp) rangeDisp.textContent = `N = ${x.toLocaleString()}  |  ${analysisResults.allPrimesFound.toLocaleString()} primes`;

                const li2x = li2(x, 4);
                const S2 = singularSeries(2);
                const gaps = analysisResults.evenGaps || [];
                let rows = '';
                gaps.forEach((h, idx) => {
                    const obs = analysisResults.gapProducts[h]?.count || 0;
                    const opf = oddPrimeFactors(h);
                    const Sh = singularSeries(h);
                    const pred = Sh * li2x;
                    const ratio = obs / pred;
                    const err = Math.abs(obs - pred) / Math.max(obs, 1) * 100;
                    const ratioColor = ratio > 0.99 && ratio < 1.01 ? '#22c55e' : ratio > 0.95 && ratio < 1.05 ? '#f59e0b' : '#ef4444';
                    const errColor = err < 2 ? '#22c55e' : err < 10 ? '#f59e0b' : '#ef4444';
                    const pctConv = Math.min(100, 100 - Math.abs(100 * (ratio - 1)));
                    const rowBg = idx % 2 === 0 ? '' : 'background:rgba(255,255,255,.015)';
                    rows += `<tr style="border-bottom:1px solid #1a1a2a;${rowBg}">
                        <td style="padding:6px 10px;color:#ffd700;font-weight:700;">${h}</td>
                        <td style="padding:6px 10px;color:#888;font-size:.78rem;">${gapName(h)}</td>
                        <td style="padding:6px 10px;color:#a855f7;font-size:.78rem;">${opf.length ? opf.join(', ') : 'none'}</td>
                        <td style="padding:6px 10px;color:#22c55e;font-family:monospace;">${Sh.toFixed(6)}</td>
                        <td style="padding:6px 10px;color:#4ecdc4;font-family:monospace;">${(Sh/S2).toFixed(4)}×</td>
                        <td style="padding:6px 10px;color:#ffd700;font-family:monospace;">${Math.round(pred).toLocaleString()}</td>
                        <td style="padding:6px 10px;color:#e0e0e0;font-family:monospace;">${obs.toLocaleString()}</td>
                        <td style="padding:6px 10px;color:${ratioColor};font-weight:700;">${ratio.toFixed(4)}</td>
                        <td style="padding:6px 10px;color:${errColor};">${err.toFixed(2)}%</td>
                        <td style="padding:6px 10px;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <div style="background:var(--parchment-dark);border-radius:3px;width:70px;height:6px;overflow:hidden;">
                                    <div style="background:${ratioColor};height:100%;width:${Math.max(0,Math.min(100,pctConv))}%;transition:width .3s;"></div>
                                </div>
                                <span style="color:#888;font-size:.75rem;">${pctConv.toFixed(0)}%</span>
                            </div>
                        </td>
                    </tr>`;
                });
                tbody.innerHTML = rows || '<tr><td colspan="10" style="padding:14px;color:#888;text-align:center;">No gap data found</td></tr>';

                // Also update Part 7 ratios table
                hl_populateRatioTable(x);
                // Also refresh li2 table with current observed twins
                hl_updateLi2Table();
                // Sync x input
                const xEl = document.getElementById('hl_x_input');
                const li2El = document.getElementById('hl_li2_x_input');
                if (xEl) xEl.value = x;
                if (li2El) li2El.value = x;
            };

            // ── Part 7: ratio convergence table ────────────────────────
            function hl_populateRatioTable(x) {
                const tbody = document.getElementById('hl_ratio_table_body');
                if (!tbody || typeof analysisResults === 'undefined' || !analysisResults) return;
                const gp = analysisResults.gapProducts;

                const ratioSpecs = [
                    { label:'Count(2)/Count(4)', a:2, b:4,
                      why:'S(2)=S(4)=2C₂ (neither 2 nor 4 has odd prime factors) — both gaps equally likely' },
                    { label:'Count(6)/Count(2)', a:6, b:2,
                      why:'S(6)=4C₂, S(2)=2C₂ → ratio=2. Factor of 2 from p=3 dividing 6.' },
                    { label:'Count(6)/Count(4)', a:6, b:4,
                      why:'Same as above: S(6)/S(4) = 4C₂/2C₂ = 2' },
                    { label:'Count(12)/Count(6)', a:12, b:6,
                      why:'S(12)=S(6)=4C₂ (12=4×3, same odd factor 3). Ratio → 1.' },
                    { label:'Count(10)/Count(2)', a:10, b:2,
                      why:'S(10)=8C₂/3 (factor 4/3 from p=5). Ratio → 4/3 ≈ 1.333.' },
                    { label:'Count(30)/Count(6)', a:30, b:6,
                      why:'S(30)=16C₂/3 (corrections (2/1)×(4/3)=8/3 from p=3 and p=5). Ratio → S(30)/S(6) = 4/3 ≈ 1.333.' },
                ];

                let rows = '';
                ratioSpecs.forEach(spec => {
                    const ca = gp[spec.a]?.count || 0;
                    const cb = gp[spec.b]?.count || 0;
                    if (!cb) return;
                    const theoryLimit = singularSeries(spec.a) / singularSeries(spec.b);
                    const current = ca / cb;
                    const pctReached = Math.min(100, Math.max(0, 100 - Math.abs((current/theoryLimit - 1)*100)));
                    const barColor = pctReached > 95 ? '#22c55e' : pctReached > 80 ? '#f59e0b' : '#ef4444';
                    rows += `<tr style="border-bottom:1px solid #1a1a2a;">
                        <td style="padding:8px 12px;color:#ffd700;font-family:monospace;">${spec.label}</td>
                        <td style="padding:8px 12px;color:#888;font-size:.8rem;">${spec.why}</td>
                        <td style="padding:8px 12px;color:#4ecdc4;font-family:monospace;font-weight:700;">${theoryLimit.toFixed(6)}</td>
                        <td style="padding:8px 12px;color:#e0e0e0;font-family:monospace;">${current.toFixed(6)}</td>
                        <td style="padding:8px 12px;color:${barColor};">${pctReached.toFixed(1)}%</td>
                        <td style="padding:8px 12px;">
                            <div style="display:flex;align-items:center;gap:6px;">
                                <div style="background:var(--parchment-dark);border-radius:3px;width:90px;height:8px;overflow:hidden;">
                                    <div style="background:${barColor};height:100%;width:${pctReached}%;"></div>
                                </div>
                            </div>
                        </td>
                    </tr>`;
                });
                tbody.innerHTML = rows || '<tr><td colspan="6" style="padding:14px;text-align:center;color:#888;">No data</td></tr>';
            }

            // ── Part 6: interactive walkthrough ───────────────────────
            window.hl_setGap = function(h) {
                const el = document.getElementById('hl_gap_input');
                if (el) { el.value = h; hl_computeWalkthrough(); }
            };

            window.hl_computeWalkthrough = function() {
                const h = parseInt(document.getElementById('hl_gap_input')?.value || 6);
                const x = parseFloat(document.getElementById('hl_x_input')?.value || 400000000);
                const out = document.getElementById('hl_walkthrough_output');
                if (!out) return;

                const L = Math.log(x);
                const opf = oddPrimeFactors(h);
                const S2 = 2 * C2;
                const Sh = singularSeries(h);
                const li2val = li2(x, 4);
                const prediction = Sh * li2val;
                const obs = (typeof analysisResults !== 'undefined' && analysisResults?.gapProducts?.[h])
                    ? analysisResults.gapProducts[h].count : null;

                let html = '';

                // Step 1: factorise h
                html += `<div class="hl-step-block">
                    <div class="hl-step-num">Step 1 — Factorise h</div>
                    <div class="hl-step-math">h = ${h} = ${factorString(h)}</div>
                    <div class="hl-step-explain">The required factors are the <strong>odd prime factors</strong> of h. Even prime factor p=2 is already absorbed into the baseline C₂ and contributes no extra correction. Odd prime factors: <strong>${opf.length ? opf.join(', ') : '(none — h is a power of 2)'}</strong></div>
                </div>`;

                // Step 2: correction factors
                if (opf.length === 0) {
                    html += `<div class="hl-step-block" style="border-left-color:#4ecdc4">
                        <div class="hl-step-num">Step 2 — Correction Factors</div>
                        <div class="hl-step-math">No odd prime factors → correction product = 1</div>
                        <div class="hl-step-explain">Since h = ${factorString(h)} has no odd prime factors, there is no "extra opening" of residue classes. S(h) = S(2) — gap ${h} has identical asymptotic density to gap 2.</div>
                    </div>`;
                } else {
                    let corrHtml = '';
                    let product = 1;
                    opf.forEach(p => {
                        const factor = (p-1)/(p-2);
                        product *= factor;
                        corrHtml += `<div style="background:var(--parchment-deep);border-radius:4px;padding:8px 12px;margin-bottom:6px;">
                            <span style="color:#a855f7;font-weight:600;">p = ${p}:</span>
                            <span style="color:#ffd700;font-family:'Times New Roman',serif;font-size:1rem;margin-left:8px;">(${p}−1)/(${p}−2) = ${p-1}/${p-2} = ${factor.toFixed(6)}</span>
                            <span style="color:#888;font-size:.82rem;margin-left:12px;">
                                Because ${p} | ${h}, the pair {p, p+${h}} has p ≡ p+${h} (mod ${p}), so neither is forced to be divisible by ${p}. This ${factor > 1.5 ? 'more than doubles' : factor > 1.1 ? 'significantly boosts' : 'boosts'} the density by factor ${factor.toFixed(4)}.
                            </span>
                        </div>`;
                    });
                    html += `<div class="hl-step-block">
                        <div class="hl-step-num">Step 2 — Correction Factors for Each Odd Prime p | h</div>
                        ${corrHtml}
                        <div class="hl-step-math" style="margin-top:10px;">Product of all corrections = ${product.toFixed(8)}</div>
                    </div>`;
                }

                // Step 3: compute S(h)
                const product_opf = opf.reduce((a,p) => a*(p-1)/(p-2), 1);
                html += `<div class="hl-step-block" style="border-left-color:#22c55e">
                    <div class="hl-step-num">Step 3 — Compute S(h)</div>
                    <div class="hl-step-math">S(${h}) = 2 × C₂ × ${product_opf.toFixed(6)}</div>
                    <div class="hl-step-math">= 2 × 0.6601618… × ${product_opf.toFixed(6)}</div>
                    <div class="hl-step-math">= <strong style="color:#22c55e">${Sh.toFixed(10)}</strong></div>
                    <div class="hl-step-explain">Compared to S(2) = ${S2.toFixed(8)}: S(${h})/S(2) = <strong style="color:#ffd700">${(Sh/S2).toFixed(6)}×</strong>
                    — gap ${h} is ${(Sh/S2).toFixed(4)} times as frequent as twin primes asymptotically.</div>
                </div>`;

                // Step 4: compute li2
                const base = x / (L*L);
                const coeffs = [1, 2, 6, 24, 120];
                let termBreakdown = '';
                let cumsum = 0;
                coeffs.slice(0,4).forEach((c, k) => {
                    const term = c / Math.pow(L, k);
                    cumsum += term;
                    termBreakdown += `<div style="color:#ccc;font-family:monospace;font-size:.82rem;margin-bottom:3px;">
                        ${k===0?'':'  + '}${c}/ln${k===0?'':'^'+k}(x) = ${c}/${Math.pow(L,k).toFixed(4)} = <span style="color:#4ecdc4">${term.toFixed(6)}</span>  ${k>0?`(${(term*100).toFixed(2)}% correction)`:'(base term)'}
                    </div>`;
                });
                html += `<div class="hl-step-block" style="border-left-color:#4ecdc4">
                    <div class="hl-step-num">Step 4 — Compute li₂(x) with 4 Terms</div>
                    <div class="hl-step-math">x = ${x.toLocaleString()},  ln(x) = ${L.toFixed(6)},  x/ln²(x) = ${Math.round(base).toLocaleString()}</div>
                    <div style="margin:10px 0;">${termBreakdown}</div>
                    <div class="hl-step-math">Sum of terms = ${cumsum.toFixed(8)}</div>
                    <div class="hl-step-math">li₂(x) = ${Math.round(base).toLocaleString()} × ${cumsum.toFixed(8)} = <strong style="color:#4ecdc4">${Math.round(li2val).toLocaleString()}</strong></div>
                </div>`;

                // Step 5: final prediction
                html += `<div class="hl-step-block" style="border-left-color:#f59e0b">
                    <div class="hl-step-num">Step 5 — Final Prediction</div>
                    <div class="hl-step-math">π<sub>${h}</sub>(${x.toLocaleString()}) ~ S(${h}) × li₂(x)</div>
                    <div class="hl-step-math">= ${Sh.toFixed(8)} × ${Math.round(li2val).toLocaleString()}</div>
                    <div class="hl-step-math">= <strong style="color:#f59e0b">${Math.round(prediction).toLocaleString()}</strong></div>
                    <div class="hl-step-explain">Predicted prime pairs (p, p+${h}) up to ${x.toLocaleString()}: approximately <strong style="color:#ffd700">${Math.round(prediction).toLocaleString()}</strong></div>
                </div>`;

                // Step 6: vs observed (if available)
                if (obs !== null) {
                    const analysisX = analysisResults.maxPrime;
                    const xMatchesAnalysis = Math.abs(x - analysisX) / analysisX < 0.001;
                    const err = Math.abs(obs - prediction) / obs * 100;
                    const errColor = err < 1 ? '#22c55e' : err < 5 ? '#f59e0b' : '#ef4444';
                    const mismatchNote = !xMatchesAnalysis 
                        ? `<div style="margin-top:10px;padding:8px 12px;background:rgba(139,99,16,0.12);border-left:3px solid var(--gold);font-size:.78rem;color:var(--ink-mid);">
                            <strong style="color:var(--gold);">Note:</strong> Observed count is from the analysis at N = ${analysisX.toLocaleString()}, 
                            but prediction here uses x = ${x.toLocaleString()}. 
                            For a valid comparison, set x = ${analysisX.toLocaleString()} (your analysis range) or run a new analysis with N = ${Math.round(x).toLocaleString()}.
                          </div>`
                        : '';
                    html += `<div class="hl-result-box">
                        <div style="color:var(--gold);font-family:'Cinzel',serif;font-weight:700;font-size:.82rem;letter-spacing:.08em;text-transform:uppercase;margin-bottom:12px;">Step 6 — Comparison with Observed Data</div>
                        ${mismatchNote}
                        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:10px;">
                            <div><div style="font-family:'Cinzel',serif;font-size:.65rem;letter-spacing:.08em;text-transform:uppercase;color:var(--gold);margin-bottom:4px;">H-L Predicted (x=${x.toLocaleString()})</div><div style="color:var(--ink);font-size:1.2rem;font-weight:700;font-family:'EB Garamond',serif;">${Math.round(prediction).toLocaleString()}</div></div>
                            <div><div style="font-family:'Cinzel',serif;font-size:.65rem;letter-spacing:.08em;text-transform:uppercase;color:var(--gold);margin-bottom:4px;">Observed (N=${analysisX.toLocaleString()})</div><div style="color:var(--ink-mid);font-size:1.2rem;font-weight:700;font-family:'EB Garamond',serif;">${obs.toLocaleString()}</div></div>
                            <div><div style="font-family:'Cinzel',serif;font-size:.65rem;letter-spacing:.08em;text-transform:uppercase;color:var(--gold);margin-bottom:4px;">Relative Error</div><div style="color:${xMatchesAnalysis ? errColor : '#888'};font-size:1.2rem;font-weight:700;font-family:'EB Garamond',serif;">${xMatchesAnalysis ? err.toFixed(3)+'%' : 'N/A (x mismatch)'}</div></div>
                        </div>
                        ${xMatchesAnalysis ? `<div style="margin-top:10px;color:var(--ink-light);font-size:.82rem;font-style:italic;">Obs/Pred ratio = ${(obs/prediction).toFixed(6)} (converges to 1.0 as x→∞)</div>` : ''}
                    </div>`;
                } else {
                    html += `<div class="hl-result-box">
                        <div style="color:#e879f9;font-weight:700;margin-bottom:8px;">Final Result for Gap ${h}</div>
                        <div style="color:#ffd700;font-size:1.2rem;font-family:monospace;">${Math.round(prediction).toLocaleString()} predicted prime pairs (p, p+${h}) up to ${x.toLocaleString()}</div>
                        <div style="color:#888;font-size:.82rem;margin-top:8px;">Run analysis above to compare against observed count</div>
                    </div>`;
                }

                out.innerHTML = html;
            };

            // ── Init on load ───────────────────────────────────────────
            window.addEventListener('load', () => {
                buildC2Table();
                buildSingularTable();
                hl_updateLi2Table();
                // Try to auto-populate if analysis already ran
                if (typeof analysisResults !== 'undefined' && analysisResults) {
                    hl_populateFullTable();
                }
            });

            // Hook into the existing runAnalysis so tables auto-update after analysis
            const _origRun = window.runAnalysis;
            if (typeof _origRun === 'function') {
                window.runAnalysis = function() {
                    const result = _origRun.apply(this, arguments);
                    // Delay to let analysis complete
                    setTimeout(() => {
                        if (typeof analysisResults !== 'undefined' && analysisResults) {
                            hl_populateFullTable();
                        }
                    }, 2000);
                    return result;
                };
            }

            // ── HL Export Functions ─────────────────────────────────────

            // Export Part 5 full table as CSV
            window.exportHLFullTableCSV = function() {
                if (typeof analysisResults === 'undefined' || !analysisResults || !analysisResults.gapProducts) {
                    alert('Run analysis first.'); return;
                }
                const x = analysisResults.maxPrime;
                const li2x = li2(x, 4);
                const S2 = singularSeries(2);
                const gaps = analysisResults.evenGaps || [];
                let csv = 'Hardy-Littlewood Conjecture B: Full Gap-by-Gap Prediction vs Observed\n';
                csv += `Analysis range: N = ${x.toLocaleString()}\n\n`;
                csv += 'Gap h,Name,Odd Prime Factors,S(h),S(h)/S(2),Predicted,Observed,Obs/Pred,Error %\n';
                gaps.forEach(h => {
                    const obs = analysisResults.gapProducts[h]?.count || 0;
                    const opf = oddPrimeFactors(h);
                    const Sh = singularSeries(h);
                    const pred = Sh * li2x;
                    const ratio = obs / pred;
                    const err = Math.abs(obs - pred) / Math.max(obs, 1) * 100;
                    csv += `${h},${gapName(h)},"${opf.length ? opf.join(';') : 'none'}",${Sh.toFixed(8)},${(Sh/S2).toFixed(6)},${Math.round(pred)},${obs},${ratio.toFixed(6)},${err.toFixed(3)}%\n`;
                });
                downloadCSV(csv, 'hl_full_prediction_table.csv');
            };

            // Export Part 5 full table as DOM image
            window.exportHLFullTableDOM = function() {
                exportElementAsPNG(document.querySelector('#hlDeepDiveWrapper [style*="f59e0b"]').parentElement || document.getElementById('hlDeepDiveWrapper'), 'hl_full_table');
            };

            // Export Part 7 ratio table as CSV
            window.exportHLRatioTableCSV = function() {
                if (typeof analysisResults === 'undefined' || !analysisResults) {
                    alert('Run analysis first.'); return;
                }
                const gp = analysisResults.gapProducts;
                const ratioSpecs = [
                    { label:'Count(2)/Count(4)', a:2, b:4 },
                    { label:'Count(6)/Count(2)', a:6, b:2 },
                    { label:'Count(6)/Count(4)', a:6, b:4 },
                    { label:'Count(12)/Count(6)', a:12, b:6 },
                    { label:'Count(10)/Count(2)', a:10, b:2 },
                    { label:'Count(30)/Count(6)', a:30, b:6 },
                ];
                let csv = 'Hardy-Littlewood Ratio Convergence\n';
                csv += `N = ${analysisResults.maxPrime.toLocaleString()}\n\n`;
                csv += 'Ratio,Theoretical Limit,Current Value,% of Limit Reached\n';
                ratioSpecs.forEach(spec => {
                    const ca = gp[spec.a]?.count || 0;
                    const cb = gp[spec.b]?.count || 0;
                    if (!cb) return;
                    const theory = singularSeries(spec.a) / singularSeries(spec.b);
                    const current = ca / cb;
                    const pct = Math.min(100, Math.max(0, 100 - Math.abs((current/theory - 1)*100)));
                    csv += `${spec.label},${theory.toFixed(6)},${current.toFixed(6)},${pct.toFixed(1)}%\n`;
                });
                downloadCSV(csv, 'hl_ratio_convergence.csv');
            };

            // Export full HL section DOM
            window.exportHLSectionDOM = function() {
                exportElementAsPNG(document.getElementById('hlDeepDiveWrapper'), 'hl_deep_dive_section');
            };

            // Export Part 6 walkthrough as CSV
            window.exportHLWalkthroughCSV = function() {
                const h = parseInt(document.getElementById('hl_gap_input')?.value || 6);
                const x = parseFloat(document.getElementById('hl_x_input')?.value || 400000000);
                const L = Math.log(x);
                const opf = oddPrimeFactors(h);
                const Sh = singularSeries(h);
                const S2 = singularSeries(2);
                const li2val = li2(x, 4);
                const prediction = Sh * li2val;
                const obs = (typeof analysisResults !== 'undefined' && analysisResults?.gapProducts?.[h])
                    ? analysisResults.gapProducts[h].count : null;
                const base = x / (L*L);
                const coeffs = [1, 2, 6, 24, 120];
                let cumsum = 0;

                let csv = `Hardy-Littlewood Walkthrough for Gap h = ${h} at x = ${x.toLocaleString()}\n\n`;
                csv += `Step 1 — Factorisation\n`;
                csv += `h = ${h} = ${factorString(h)}\n`;
                csv += `Odd prime factors: ${opf.length ? opf.join(', ') : 'none'}\n\n`;
                csv += `Step 2 — Correction Factors\n`;
                opf.forEach(p => { csv += `p=${p}: (${p}-1)/(${p}-2) = ${p-1}/${p-2} = ${((p-1)/(p-2)).toFixed(8)}\n`; });
                const prodOpf = opf.reduce((a,p) => a*(p-1)/(p-2), 1);
                csv += `Product of corrections: ${prodOpf.toFixed(8)}\n\n`;
                csv += `Step 3 — Singular Series S(h)\n`;
                csv += `S(${h}) = 2 × C2 × ${prodOpf.toFixed(8)} = ${Sh.toFixed(10)}\n`;
                csv += `S(2) = ${S2.toFixed(10)}\nS(${h})/S(2) = ${(Sh/S2).toFixed(6)}\n\n`;
                csv += `Step 4 — li2(x) Expansion (4 terms)\n`;
                csv += `x = ${x.toLocaleString()}, ln(x) = ${L.toFixed(6)}, x/ln2(x) = ${Math.round(base)}\n`;
                coeffs.slice(0,4).forEach((c, k) => {
                    const term = c / Math.pow(L, k);
                    cumsum += term;
                    csv += `Term k=${k}: ${c}/ln^${k}(x) = ${term.toFixed(8)}\n`;
                });
                csv += `Sum = ${cumsum.toFixed(8)}\nli2(x) = ${Math.round(li2val).toLocaleString()}\n\n`;
                csv += `Step 5 — Prediction\n`;
                csv += `pi_${h}(${x.toLocaleString()}) ~ ${Sh.toFixed(8)} × ${Math.round(li2val)} = ${Math.round(prediction).toLocaleString()}\n\n`;
                if (obs !== null) {
                    const analysisX = analysisResults.maxPrime;
                    const xMatch = Math.abs(x - analysisX) / analysisX < 0.001;
                    csv += `Step 6 — Comparison\n`;
                    csv += `Observed (N=${analysisX.toLocaleString()}): ${obs.toLocaleString()}\n`;
                    csv += `Predicted (x=${x.toLocaleString()}): ${Math.round(prediction).toLocaleString()}\n`;
                    if (xMatch) {
                        const err = Math.abs(obs - prediction) / obs * 100;
                        csv += `Obs/Pred: ${(obs/prediction).toFixed(6)}\nError: ${err.toFixed(3)}%\n`;
                    } else {
                        csv += `Note: x mismatch — observed at N=${analysisX.toLocaleString()}, prediction at x=${x.toLocaleString()}\n`;
                    }
                }
                downloadCSV(csv, `hl_walkthrough_gap${h}.csv`);
            };

            // Export Part 6 walkthrough as DOM image
            window.exportHLWalkthroughDOM = function() {
                exportElementAsPNG(document.getElementById('hl_walkthrough_output').parentElement, 'hl_walkthrough');
            };

            // Helper: generic DOM-to-PNG export
            function exportElementAsPNG(el, filename) {
                if (!el) { alert('Element not found.'); return; }
                if (typeof html2canvas !== 'undefined') {
                    html2canvas(el, { scale: 2, useCORS: true }).then(canvas => {
                        const link = document.createElement('a');
                        link.download = filename + '.png';
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                    });
                } else {
                    alert('html2canvas not loaded.');
                }
            }

            // Helper: download CSV
            function downloadCSV(content, filename) {
                const blob = new Blob([content], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = filename; a.click();
                URL.revokeObjectURL(url);
            }

        })(); // end HL module
    </script>
<script>
(function(){
  // ── helpers ──────────────────────────────────────────────────────────────
  function gcd(a,b){while(b){var t=b;b=a%b;a=t;}return a;}

  var _angles = {coprime:90, noncoprime:90};
  var _lastHighlit = -1;

  function highlightNavLink(){
    var links = document.querySelectorAll('.tool-nav-link');
    if(!links.length) return;
    var idx;
    do{idx=Math.floor(Math.random()*links.length);}while(links.length>1&&idx===_lastHighlit);
    _lastHighlit=idx;
    links.forEach(function(a,i){a.classList.toggle('nav-highlight',i===idx);});
  }

  window.fareyRotate = function(which){
    _angles[which] = (_angles[which]||0)+90;
    drawFarey(which);
    highlightNavLink();
  };

  window.buildFractions = buildFractions;

  window.fareyRedraw = function(){
    clearAncestorCache();
    if(document.getElementById('farey-combined-view').style.display!=='none'){
      syncCombinedSize(); drawCombined();
    } else {
      drawFarey('coprime'); drawFarey('noncoprime');
    }
    // Keep rz section mod in sync with top Farey tool
    var rzMod  = document.getElementById('rz-mod');
    var topMod = document.getElementById('f-mod-num');
    if (rzMod && topMod && rzMod.value !== topMod.value) {
      rzMod.value = topMod.value;
      if (window._rzVisible && typeof rzDraw === 'function') rzDraw();
    }
    // Update live stats panel
    fareyUpdateLiveStats();
  };

  // ── Live stats updater ───────────────────────────────────────────────────
  function fareyUpdateLiveStats() {
    var el = document.getElementById('farey-live-stats');
    if (!el) return;
    var modN = parseInt(document.getElementById('f-mod-num').value) || 49;
    var fracs = buildFractions(modN);
    var cop = fracs.cop.length, ncp = fracs.ncp.length, total = cop + ncp;
    var ratio = total > 0 ? (cop / total) : 0;
    // ζ(2) = π²/6, expected GCD=1 ratio = 6/π²
    var zetaRatio = 6 / (Math.PI * Math.PI);
    var diff = Math.abs(ratio - zetaRatio);
    var diffPct = (diff / zetaRatio * 100).toFixed(3);
    // Euler phi sum = Σφ(m) for m=1..N ≈ 3N²/π²
    var phiSum = fracs.cop.filter(function(p){ return p.m >= 1; }).length;
    el.innerHTML =
      '<span style="color:var(--gold);">Mod N</span>: <strong>' + modN + '</strong>'
      + ' &nbsp;·&nbsp; <span style="color:var(--gold);">Total points</span>: <strong>' + total.toLocaleString() + '</strong>'
      + ' &nbsp;·&nbsp; <span style="color:#4a90d9;">gcd=1 (coprime)</span>: <strong>' + cop.toLocaleString() + '</strong>'
      + ' &nbsp;·&nbsp; <span style="color:#c94040;">gcd&gt;1</span>: <strong>' + ncp.toLocaleString() + '</strong>'
      + '<br>'
      + '<span style="color:var(--gold);">Ratio cop/total</span>: <strong>' + ratio.toFixed(6) + '</strong>'
      + ' &nbsp;·&nbsp; <span style="color:var(--gold);">6/π² (1/ζ(2))</span>: <strong>' + zetaRatio.toFixed(6) + '</strong>'
      + ' &nbsp;·&nbsp; <span style="color:' + (diff < 0.005 ? '#a8e6cf' : '#ffd700') + ';">Δ = ' + diffPct + '%</span>'
      + '<br>'
      + '<span style="color:#9a8060;font-size:0.58rem;">As mod N → ∞, cop/total → 6/π² ≈ ' + zetaRatio.toFixed(8) + ' (the density of square-free integers)</span>';
  }

  window.fareyResize = function(){
    var sz = parseInt(document.getElementById('f-size-num').value)||260;
    ['coprime','noncoprime','combined'].forEach(function(w){
      var c=document.getElementById('fc-'+w);
      if(!c) return;
      c.width=sz; c.height=sz;
      c.style.width=sz+'px'; c.style.height=sz+'px';
    });
    fareyRedraw();
  };

  function buildFractions(modN){
    var cop=[], ncp=[];
    for(var m=1;m<=modN;m++){
      for(var r=0;r<=m;r++){
        var g=gcd(r,m);
        if(r===0||r===m){
          // 0/1 and 1/1 are the canonical endpoints (coprime by convention)
          if(m===1){ cop.push({r:r,m:m}); }
          // 0/m and m/m for m>1 are gcd=m (non-coprime) — include in ncp
          // so "all points" polygon gets the full 0..m vertex set
          else { ncp.push({r:r,m:m}); }
        } else if(g===1){
          cop.push({r:r,m:m});
        } else {
          ncp.push({r:r,m:m});
        }
      }
    }
    return {cop:cop, ncp:ncp};
  }

  // ── draw ─────────────────────────────────────────────────────────────────
  function drawFarey(which, overrideCanvas){
    var c = overrideCanvas || document.getElementById('fc-'+which);
    if(!c) return;
    var ctx = c.getContext('2d');
    var W=c.width, H=c.height;
    ctx.clearRect(0,0,W,H);

    // options
    var modN  = parseInt(document.getElementById('f-mod-num').value)||30;
    var labelMode  = document.getElementById('f-label').value;
    var labelStyle = document.getElementById('f-label-style').value;
    var lsize = parseInt(document.getElementById('f-lsize').value)||7;
    var col1  = document.getElementById('f-col1').value;
    var col2  = document.getElementById('f-col2').value;
    var showChords  = document.getElementById('f-chords').checked;
    var showSpokes  = document.getElementById('f-spokes').checked;
    var showSameMod = document.getElementById('f-samemod').checked;
    var showCrossMod= document.getElementById('f-crossmod').checked;
    var sameModColMode = document.getElementById('f-samemod-colmode').value;
    var sameModFixedCol= document.getElementById('f-samemod-col').value;
    var sameModThick= parseInt(document.getElementById('f-samemod-thick').value)/10;
    var crossModThick= parseInt(document.getElementById('f-crossmod-thick').value)/10;
    var _bright = getBrightness();
    var color = brightenColor(which==='coprime'?col1:col2, _bright);

    var fracs = buildFractions(modN);
    var pts = which==='coprime'?fracs.cop:fracs.ncp;

    var cx=W/2, cy=H/2;
    var _spacing = (parseInt(document.getElementById('f-spacing').value)||100)/100;
    var _rinner  = (parseInt(document.getElementById('f-rinner').value)||4)/100;
    var _zoom    = (parseInt(document.getElementById('f-zoom').value)||100)/100;
    var _invert  = document.getElementById('f-invert-order').checked;
    var rBase = W*0.42*_spacing; if(rBase > W*0.49) rBase=W*0.49;
    var rMin = W*_rinner*_zoom, rMax = rBase*_zoom;
    var ang = _angles[which]||0;

    function radius(m){
      var t = _invert ? (modN-m)/(modN-1||1) : (m-1)/(modN-1||1);
      return rMin+(rMax-rMin)*t;
    }
    function ptXY(r,m){
      var dir = parseFloat(document.getElementById('f-dir').value)||1;
      var base = dir * 2*Math.PI*r/(m||1);
      var rad  = radius(m);
      var a    = base + ang*Math.PI/180 + ringOffset(m, modN)*Math.PI/180;
      return {x: cx+rad*Math.sin(a), y: cy-rad*Math.cos(a)};
    }

    // bg transparent
    ctx.save();

    // rings
    var ringColor = which==='coprime'?'#2a5a9a':'#8a2020';
    for(var m=1;m<=modN;m++){
      var rr=radius(m);
      ctx.beginPath();
      ctx.arc(cx,cy,rr,0,2*Math.PI);
      ctx.strokeStyle=ringColor;
      ctx.lineWidth = m===modN?1.2:0.4;
      ctx.globalAlpha = m===modN?0.7:0.12;
      ctx.stroke();
    }
    ctx.globalAlpha=1;

    // build lookup for chords/spokes
    var ptMap={};
    pts.forEach(function(p){ ptMap[p.r+'/'+p.m]=p; });

    // chords (involution: r/m <-> (m-r)/m)
    if(showChords){
      var done={};
      pts.forEach(function(p){
        var pr=p.m-p.r, key1=p.r+'/'+p.m, key2=pr+'/'+p.m;
        if(done[key1]||done[key2]) return;
        if(ptMap[key2] && p.r!==pr){
          done[key1]=done[key2]=1;
          var p1=ptXY(p.r,p.m), p2=ptXY(pr,p.m);
          ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y);
          ctx.strokeStyle=color;
          ctx.lineWidth=0.4;
          ctx.globalAlpha=0.04+0.14*p.m/modN;
          ctx.stroke();
        }
      });
      ctx.globalAlpha=1;
    }

    // spokes (same rational value across denominators)
    if(showSpokes){
      var byVal={};
      pts.forEach(function(p){
        var v=(p.r/p.m).toFixed(10);
        if(!byVal[v]) byVal[v]=[];
        byVal[v].push(p);
      });
      Object.keys(byVal).forEach(function(v){
        var arr=byVal[v].sort(function(a,b){return a.m-b.m;});
        for(var i=0;i<arr.length-1;i++){
          var pa=ptXY(arr[i].r,arr[i].m), pb=ptXY(arr[i+1].r,arr[i+1].m);
          ctx.beginPath(); ctx.moveTo(pa.x,pa.y); ctx.lineTo(pb.x,pb.y);
          ctx.strokeStyle=color; ctx.lineWidth=0.3; ctx.globalAlpha=0.06; ctx.stroke();
        }
      });
      ctx.globalAlpha=1;
    }

    // ── ring polygon ───────────────────────────────────────────────────────
    if(showSameMod){
      var polyFilter = (document.getElementById('f-samemod-filter')||{value:'gcd1'}).value;
      var polyRings  = (document.getElementById('f-samemod-rings')||{value:'outer'}).value;
      function gcdLoc(a,b){while(b){var t=b;b=a%b;a=t;}return a;}
      var allF = buildFractions(modN);
      var srcPts2;
      if      (polyFilter==='gcd1') srcPts2 = allF.cop;
      else if (polyFilter==='gcd2') srcPts2 = allF.ncp;
      else                          srcPts2 = allF.cop.concat(allF.ncp);
      var byM2={};
      srcPts2.forEach(function(p){ if(!byM2[p.m]) byM2[p.m]=[]; byM2[p.m].push(p); });
      var mList2=Object.keys(byM2).map(Number).sort(function(a,b){return a-b;});
      var ringsToDraw2;
      if      (polyRings==='outer')  ringsToDraw2=[modN];
      else if (polyRings==='outer5') ringsToDraw2=mList2.slice(-5);
      else                           ringsToDraw2=mList2;
      ringsToDraw2.forEach(function(m){
        var ring=(byM2[m]||[]).slice().sort(function(a,b){return a.r/a.m-b.r/b.m;});
        if(ring.length<2) return;
        var mi=mList2.indexOf(m);
        var lc;
        if(sameModColMode==='permod'){
          var h=Math.round(360*mi/Math.max(mList2.length-1,1));
          lc='hsl('+h+',72%,58%)';
        } else if(sameModColMode==='gradient'){
          var t=(m-1)/(modN-1||1);
          lc='rgb('+Math.round(42+(180-42)*t)+','+Math.round(90+(60-90)*t)+','+Math.round(180+(20-180)*t)+')';
        } else { lc=sameModFixedCol; }
        ctx.strokeStyle=lc; ctx.lineWidth=sameModThick;
        ctx.globalAlpha=0.25+0.75*(m/modN);
        ctx.beginPath();
        var f2=ptXY(ring[0].r,ring[0].m); ctx.moveTo(f2.x,f2.y);
        for(var i=1;i<ring.length;i++){ var pp2=ptXY(ring[i].r,ring[i].m); ctx.lineTo(pp2.x,pp2.y); }
        ctx.lineTo(f2.x,f2.y); ctx.stroke();
      });
      ctx.globalAlpha=1;
    }

    // ── cross-mod connections: only connect r/m → r/(m+1) if EXACT same r exists ──
    if(showCrossMod){
      // build lookup: r → set of m values that contain this r
      var rToMs={};
      pts.forEach(function(p){
        if(!rToMs[p.r]) rToMs[p.r]=[];
        rToMs[p.r].push(p.m);
      });
      var ptByRM={};
      pts.forEach(function(p){ ptByRM[p.r+','+p.m]=p; });

      var drawnCross={};
      pts.forEach(function(p){
        if(p.m>=modN) return;
        var nextM=p.m+1;
        // only connect if exact same r exists in the next ring
        if(!ptByRM[p.r+','+nextM]) return;
        var edgeKey=p.r+':'+p.m+'-'+nextM;
        if(drawnCross[edgeKey]) return;
        drawnCross[edgeKey]=1;

        var lc;
        if(sameModColMode==='permod'){
          // color by the r value so same r tracks are the same color
          var h2=Math.round(360*(p.r % modN)/modN);
          lc='hsl('+h2+',65%,55%)';
        } else if(sameModColMode==='gradient'){
          var t2=(p.m-1)/(modN-1||1);
          var ri2=Math.round(42+(180-42)*t2), gi2=Math.round(90+(60-90)*t2), bi2=Math.round(180+(20-180)*t2);
          lc='rgb('+ri2+','+gi2+','+bi2+')';
        } else {
          lc=sameModFixedCol;
        }

        var xy1=ptXY(p.r,p.m), xy2=ptXY(p.r,nextM);
        ctx.beginPath(); ctx.moveTo(xy1.x,xy1.y); ctx.lineTo(xy2.x,xy2.y);
        ctx.strokeStyle=lc; ctx.lineWidth=crossModThick;
        ctx.globalAlpha=0.15+0.35*(p.m/modN);
        ctx.stroke();
      });
      ctx.globalAlpha=1;
    }

    // dots and labels
    pts.forEach(function(p){
      var xy=ptXY(p.r,p.m);
      var _ptScale=(parseInt(document.getElementById('f-ptsize')&&document.getElementById('f-ptsize').value)||100)/100;
      var dotR=Math.max(0.3, (1.0*(1-p.m/modN*0.3)) * Math.max(0.4, 2.2 - modN/18) * (W/400) * _ptScale);
      ctx.globalAlpha=1;

      // label text
      var lbl='';
      if(labelMode==='fraction') lbl=p.r+'/'+p.m;
      else if(labelMode==='r')   lbl=''+p.r;
      else if(labelMode==='m')   lbl='m='+p.m;
      else if(labelMode==='angle') lbl=Math.round(360*p.r/p.m)+'°';
      else if(labelMode==='radian') lbl=(2*p.r/p.m).toFixed(2)+'π';
      else if(labelMode==='decimal') lbl=(p.r/p.m).toFixed(2);

      if(labelMode==='none'||labelStyle==='dot+label'){
        // draw dot
        ctx.beginPath(); ctx.arc(xy.x,xy.y,dotR,0,2*Math.PI);
        ctx.fillStyle=color; ctx.fill();
      }
      if(labelMode!=='none' && lbl){
        ctx.font = lsize+'px Cinzel, serif';
        ctx.fillStyle = color;
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.globalAlpha=1;
        var offset = labelStyle==='label-only'?0:dotR+2;
        ctx.fillText(lbl, xy.x, xy.y - (labelStyle==='label-only'?0:dotR+lsize*0.6));
      }
    });

    // center dot
    ctx.globalAlpha=1;
    ctx.beginPath(); ctx.arc(cx,cy,3*(W/400),0,2*Math.PI);
    ctx.fillStyle=ringColor; ctx.fill();

    ctx.restore();
  }

  // init on load
  document.addEventListener('DOMContentLoaded', function(){
    fareyRedraw();
  });

;


  // ── Color brightness helper (hue-preserving, no glow) ────────────────────
  function brightenColor(hex, amount){
    // amount: 0-100 extra lightness %
    if(!amount) return hex;
    // parse hex
    var r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
    // to hsl
    r/=255; g/=255; b/=255;
    var max=Math.max(r,g,b), min=Math.min(r,g,b);
    var h,s,l=(max+min)/2;
    if(max===min){ h=s=0; }
    else{
      var d=max-min;
      s = l>0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h=((g-b)/d+(g<b?6:0))/6; break;
        case g: h=((b-r)/d+2)/6; break;
        case b: h=((r-g)/d+4)/6; break;
      }
    }
    // increase lightness, clamp to 0.88 to avoid white-out
    var newL = Math.min(0.88, l + amount/100 * (0.88-l));
    // hsl back to rgb
    function hue2rgb(p,q,t){ if(t<0)t+=1; if(t>1)t-=1; if(t<1/6)return p+(q-p)*6*t; if(t<1/2)return q; if(t<2/3)return p+(q-p)*(2/3-t)*6; return p; }
    var q2 = newL<0.5 ? newL*(1+s) : newL+s-newL*s;
    var p2 = 2*newL-q2;
    var rr=Math.round(hue2rgb(p2,q2,h+1/3)*255);
    var gg=Math.round(hue2rgb(p2,q2,h)*255);
    var bb=Math.round(hue2rgb(p2,q2,h-1/3)*255);
    return '#'+((1<<24)+(rr<<16)+(gg<<8)+bb).toString(16).slice(1);
  }

  function getBrightness(){ return parseInt(document.getElementById('f-bright').value)||0; }

  // ── Per-ring cumulative rotation ─────────────────────────────────────────
  var _ringOffsets   = {};
  var _ringAnimTimer = null;

  function ringOffset(m, modN){
    var a    = parseFloat(document.getElementById('f-ringstep-a').value)||0;
    var b    = parseFloat(document.getElementById('f-ringstep-b').value)||2;
    var rdir = parseFloat(document.getElementById('f-ringdir').value)||1;
    return rdir*(m-1)*(a/b)*360 + (_ringOffsets[m]||0);
  }

  window.fareyToggleRingAnim = function(){
    var btn = document.getElementById('f-ringanim-btn');
    if(_ringAnimTimer){
      clearInterval(_ringAnimTimer); _ringAnimTimer=null;
      btn.style.background='var(--parchment-dark)'; btn.style.color='var(--ink-mid)';
      btn.textContent='▶ Spin';
    } else {
      btn.style.background='var(--gold)'; btn.style.color='var(--parchment)';
      btn.textContent='■ Stop';
      _ringAnimTimer = setInterval(function(){
        var modN  = parseInt(document.getElementById('f-mod-num').value)||49;
        var speed = parseInt(document.getElementById('f-ringspeed').value)||20;
        var rdir  = parseFloat(document.getElementById('f-ringdir').value)||1;
        for(var m=1; m<=modN; m++){
          var t = rdir===1 ? m/modN : (modN-m+1)/modN;
          _ringOffsets[m] = (_ringOffsets[m]||0) + speed*t*0.04;
        }
        fareyRedraw();
      }, 16);
    }
  };

  window.fareyResetRings = function(){
    _ringOffsets = {};
    fareyRedraw();
  };

  // ── Mertens PNG export ────────────────────────────────────────────────────
  // ── Farey DOM export ──────────────────────────────────────────────────────
  window.fareyExportDOM = function() {
    var root = document.getElementById('farey-root');
    if (!root) { alert('Farey section not found.'); return; }
    if (typeof html2canvas === 'undefined') { alert('html2canvas not loaded.'); return; }
    html2canvas(root, { backgroundColor: '#0a0a0f', scale: 2, useCORS: true }).then(function(canvas) {
      var a = document.createElement('a');
      a.download = 'farey_mod' + (document.getElementById('f-mod-num').value||'?') + '.png';
      a.href = canvas.toDataURL('image/png');
      a.click();
    });
  };

  // ── Farey CSV export ──────────────────────────────────────────────────────
  window.fareyExportCSV = function() {
    var modN = parseInt(document.getElementById('f-mod-num').value) || 49;
    var fracs = buildFractions(modN);
    var rows = ['r,m,gcd,fraction,angle_deg,type'];
    function gcdLocal(a,b){while(b){var t=b;b=a%b;a=t;}return a;}
    fracs.cop.concat(fracs.ncp).sort(function(a,b){return a.m-b.m||a.r-b.r;}).forEach(function(p){
      var g = gcdLocal(p.r, p.m);
      rows.push([p.r, p.m, g, (p.r/p.m).toFixed(8), (360*p.r/p.m).toFixed(4), g===1?'coprime':'noncoprime'].join(','));
    });
    var blob = new Blob([rows.join('\n')], {type:'text/csv'});
    var a = document.createElement('a');
    a.download = 'farey_mod' + modN + '.csv';
    a.href = URL.createObjectURL(blob);
    a.click();
  };

  // ── Gap stats CSV export ───────────────────────────────────────────────────
  window.fareyGapStatsExportCSV = function() {
    var el = document.getElementById('farey-gap-stats-content');
    if (!el || !window._overlayGap) { alert('No gap data active.'); return; }
    var modN = parseInt(document.getElementById('f-mod-num').value) || 49;
    var pairs = window._overlayPairs || [];
    var rows = ['prime,r1,r2,gap,modN'];
    pairs.forEach(function(p){ rows.push([p.p, p.r1, p.r2, p.gap||window._overlayGap, modN].join(',')); });
    var blob = new Blob([rows.join('\n')], {type:'text/csv'});
    var a = document.createElement('a');
    a.download = 'farey_gap' + window._overlayGap + '_mod' + modN + '.csv';
    a.href = URL.createObjectURL(blob);
    a.click();
  };

  // ── Gap stats DOM PNG export ───────────────────────────────────────────────
  window.fareyGapStatsExportDOM = function() {
    var panel = document.getElementById('farey-gap-stats-panel');
    if (!panel || !window._overlayGap) { alert('No gap data active.'); return; }
    // Temporarily show the body if hidden
    var body = document.getElementById('farey-gap-stats-body') || panel.querySelector('div:nth-child(2)');
    var wasHidden = body && body.style.display === 'none';
    if (wasHidden && body) body.style.display = 'block';
    if (typeof html2canvas === 'undefined') { alert('html2canvas not loaded.'); return; }
    html2canvas(panel, { backgroundColor: '#0a0a0f', scale: 2 }).then(function(canvas) {
      if (wasHidden && body) body.style.display = 'none';
      var a = document.createElement('a');
      a.download = 'farey_gap_data_mod' + (document.getElementById('f-mod-num').value||'?') + '.png';
      a.href = canvas.toDataURL('image/png');
      a.click();
    });
  };

  window.mertensExportPNG = function(){
    var src = document.getElementById('m_graphCanvas');
    if(!src){ alert('Mertens chart not rendered yet.'); return; }
    var PAD=24, FOOT=32;
    var W=src.width+PAD*2, H=src.height+PAD+FOOT;
    var off=document.createElement('canvas'); off.width=W; off.height=H;
    var ctx=off.getContext('2d');
    ctx.fillStyle=canvasBg(); ctx.fillRect(0,0,W,H);
    ctx.drawImage(src, PAD, PAD, src.width, src.height);
    // border
    ctx.strokeStyle='rgba(90,90,140,0.5)'; ctx.lineWidth=1;
    ctx.strokeRect(PAD,PAD,src.width,src.height);
    // label
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font='10px "Cinzel",Georgia,serif'; ctx.fillStyle='#9a8060';
    var nMax=document.getElementById('m_nMax')?document.getElementById('m_nMax').value:'';
    ctx.fillText('Mertens Function M(n) = Σμ(k)  ·  n = 1…'+(nMax||'N'), W/2, PAD+src.height+FOOT/2);
    var a=document.createElement('a');
    a.download='mertens_'+(nMax||'N')+'.png';
    a.href=off.toDataURL('image/png'); a.click();
  };


  var _autoRotateTimer = null;
  var _autoRotateDir = 1;  // 1 = outer (forward), -1 = inner (backward)
  var _inspectMode = false;
  var _activeTooltipPt = null;
  var _lastCombinedPts = [];
  var _combinedMode = 'both';
  var _combinedAngle = 90;
  Object.defineProperty(window, '_combinedAngle', { get: function(){ return _combinedAngle; }, set: function(v){ _combinedAngle=v; } });

  window.toggleFareyPanel = function(){
    var p=document.getElementById('farey-panel');
    var open = p.style.display==='none';
    p.style.display = open ? 'block' : 'none';
    document.getElementById('farey-split-view').style.display    = open ? 'none'  : 'flex';
    document.getElementById('farey-combined-view').style.display = open ? 'block' : 'none';
    if(open){
      // jump to 800px when Advanced opens
      document.getElementById('f-size').value     = 800;
      document.getElementById('f-size-num').value = 800;
      syncCombinedSize();
      drawCombined();
    } else {
      // stop auto-rotate when closing
      if(_autoRotateTimer){ clearInterval(_autoRotateTimer); _autoRotateTimer=null; }
      _inspectMode=false;
      hideTooltip();
      fareyRedraw();
    }
  };

  window.fareyToggleAutoRotate = function(dir){
    // dir: 'out' = cumulative outer→inner (outer rings spin faster)
    //      'in'  = cumulative inner→outer (inner rings spin faster)
    //      undefined = toggle uniform canvas rotation on/off
    var btn    = document.getElementById('fcm-autorotate');
    var dirOut = document.getElementById('fcm-ar-out');
    var dirIn  = document.getElementById('fcm-ar-in');

    function stopTimer(){
      if(_autoRotateTimer){ clearInterval(_autoRotateTimer); _autoRotateTimer=null; }
      if(btn)  { btn.style.background='var(--parchment-dark)';  btn.style.color='var(--ink-mid)'; }
      if(dirOut){ dirOut.style.background='var(--parchment-dark)'; dirOut.style.color='var(--ink-mid)'; }
      if(dirIn) { dirIn.style.background='var(--parchment-dark)';  dirIn.style.color='var(--ink-mid)'; }
    }

    function redrawWithOverlay(){
      fareyRedraw();
      if(_overlayGap !== null && _overlayPairs.length > 0) drawGapOverlay();
    }

    if(dir === 'out' || dir === 'in'){
      // If already running in same direction, stop (toggle off)
      if(_autoRotateTimer && _autoRotateDir === (dir==='out'?1:-1)){
        stopTimer(); return;
      }
      stopTimer();
      _autoRotateDir = (dir === 'out') ? 1 : -1;
      var activeBtn = dir==='out' ? dirOut : dirIn;
      if(activeBtn){ activeBtn.style.background='var(--gold)'; activeBtn.style.color='var(--parchment)'; }

      if(_inspectMode) fareyToggleInspect();
      _autoRotateTimer = setInterval(function(){
        var modN  = parseInt(document.getElementById('f-mod-num').value)||49;
        var speed = parseInt(document.getElementById('f-ringspeed').value)||20;
        // cumulative per-ring: outer faster for 'out', inner faster for 'in'
        for(var m=1; m<=modN; m++){
          var t = _autoRotateDir===1 ? m/modN : (modN-m+1)/modN;
          _ringOffsets[m] = (_ringOffsets[m]||0) + _autoRotateDir * speed * t * 0.04;
        }
        redrawWithOverlay();
      }, 16);
      return;
    }

    // Plain toggle — uniform canvas rotation
    if(_autoRotateTimer && _autoRotateDir === 0){
      stopTimer(); return;
    }
    stopTimer();
    _autoRotateDir = 0;
    if(btn){ btn.style.background='var(--gold)'; btn.style.color='var(--parchment)'; }
    if(_inspectMode) fareyToggleInspect();
    _autoRotateTimer = setInterval(function(){
      _combinedAngle = ((_combinedAngle + 1) % 360 + 360) % 360;
      redrawWithOverlay();
    }, 30);
  };

  window.fareyRotateReset = function(){
    if(_autoRotateTimer){ clearInterval(_autoRotateTimer); _autoRotateTimer=null; }
    var btn=document.getElementById('fcm-autorotate');
    var dirOut=document.getElementById('fcm-ar-out');
    var dirIn=document.getElementById('fcm-ar-in');
    if(btn)  { btn.style.background='var(--parchment-dark)';  btn.style.color='var(--ink-mid)'; }
    if(dirOut){ dirOut.style.background='var(--parchment-dark)'; dirOut.style.color='var(--ink-mid)'; }
    if(dirIn) { dirIn.style.background='var(--parchment-dark)';  dirIn.style.color='var(--ink-mid)'; }
    _autoRotateDir = 1;
    _combinedAngle = 90;
    _ringOffsets   = {};
    fareyRedraw();
    if(_overlayGap !== null && _overlayPairs.length > 0) drawGapOverlay();
  };

  window.fareyToggleInspect = function(){
    _inspectMode = !_inspectMode;
    var btn = document.getElementById('fcm-inspect');
    var c   = document.getElementById('fc-combined');
    var sizeEl = document.getElementById('f-size-num');
    var sizeSlider = document.getElementById('f-size');
    var INSPECT_SIZE = 600;
    if(_inspectMode){
      // stop auto-rotate
      if(_autoRotateTimer){ clearInterval(_autoRotateTimer); _autoRotateTimer=null;
        var arBtn=document.getElementById('fcm-autorotate');
        arBtn.style.background='var(--parchment-dark)'; arBtn.style.color='var(--ink-mid)'; }
      btn.style.background='var(--gold)'; btn.style.color='var(--parchment)';
      c.style.cursor='crosshair';
      document.getElementById('fc-combined-label').textContent='Inspect mode · click a point for details';
      // grow canvas to 600 if currently smaller
      var curSize = parseInt(sizeEl.value) || 400;
      if(curSize < INSPECT_SIZE){
        _preinspect_size = curSize;
        sizeEl.value = INSPECT_SIZE;
        if(sizeSlider) sizeSlider.value = INSPECT_SIZE;
        syncCombinedSize();
        drawCombined();
      }
    } else {
      btn.style.background='var(--parchment-dark)'; btn.style.color='var(--ink-mid)';
      c.style.cursor='crosshair';
      document.getElementById('fc-combined-label').textContent='Combined · click canvas to rotate 90°';
      hideTooltip();
      // clear chain
      _chain.length = 0;
      document.getElementById('fcm-chain-clear').style.display   = 'none';
      document.getElementById('farey-chain-panel').style.display  = 'none';
      // restore previous size if we bumped it
      if(typeof _preinspect_size !== 'undefined' && _preinspect_size !== null){
        sizeEl.value = _preinspect_size;
        if(sizeSlider) sizeSlider.value = _preinspect_size;
        _preinspect_size = null;
        syncCombinedSize();
        drawCombined();
      }
    }
  };

  function hideTooltip(){
    _activeTooltipPt=null;
    document.getElementById('farey-tooltip').style.display='none';
  }

  function showTooltip(pt, canvasX, canvasY){
    var tt  = document.getElementById('farey-tooltip');
    var c   = document.getElementById('fc-combined');
    var modN= parseInt(document.getElementById('f-mod-num').value)||49;
    var dir = parseFloat(document.getElementById('f-dir').value)||1;
    var g   = gcd(pt.r, pt.m);
    var frac= pt.r+'/'+pt.m;
    var ang = dir * 2*Math.PI*pt.r/(pt.m||1) + _combinedAngle*Math.PI/180;
    var deg = ((ang*180/Math.PI) % 360 + 360) % 360;
    var rad = dir*2*pt.r/(pt.m||1); // in units of π
    var phi = eulerPhi(pt.m);
    var typeStr = g===1 ? 'gcd(r, m) = 1' : 'gcd(r, m) = '+g;
    var color   = g===1 ? document.getElementById('f-col1').value : document.getElementById('f-col2').value;

    tt.innerHTML =
      '<div style="color:'+color+';font-size:0.72rem;font-weight:bold;margin-bottom:6px;letter-spacing:0.1em;">'+frac+'</div>'+
      '<div>r &nbsp;= &nbsp;<span style="color:'+color+'">'+pt.r+'</span></div>'+
      '<div>m &nbsp;= &nbsp;<span style="color:'+color+'">'+pt.m+'</span></div>'+
      '<div>gcd &nbsp;= &nbsp;<span style="color:'+color+'">'+g+'</span></div>'+
      '<div style="border-top:1px solid rgba(196,155,56,0.2);margin:6px 0;"></div>'+
      '<div>angle &nbsp;= &nbsp;'+deg.toFixed(2)+'°</div>'+
      '<div>radian = '+rad.toFixed(4)+'\u03c0</div>'+
      '<div>decimal = '+(pt.r/pt.m).toFixed(6)+'</div>'+
      '<div style="border-top:1px solid rgba(196,155,56,0.2);margin:6px 0;"></div>'+
      '<div style="color:#9a8060;">ring m = '+pt.m+' &nbsp;\u00b7 &nbsp;\u03c6('+pt.m+') = '+phi+'</div>'+
      '<div style="color:#9a8060;">'+typeStr+'</div>';

    // position near point but keep in canvas bounds
    var scale = c.width / c.offsetWidth;
    var px = canvasX / scale;
    var py = canvasY / scale;
    var tw = 180, th = 160;
    var left = px + 12;
    var top  = py - th/2;
    if(left + tw > c.offsetWidth)  left = px - tw - 12;
    if(top < 0)                    top  = 4;
    if(top + th > c.offsetHeight)  top  = c.offsetHeight - th - 4;

    tt.style.left    = left+'px';
    tt.style.top     = top+'px';
    tt.style.display = 'block';
  }

  function eulerPhi(n){
    var r=n, m=n;
    for(var p=2;p*p<=m;p++){
      if(m%p===0){ r -= r/p; while(m%p===0) m/=p; }
    }
    if(m>1) r -= r/m;
    return Math.round(r);
  }

  // ── Multi-point chain state ──────────────────────────────────────────────
  var _chain = [];  // [{r,m,px,py,angle,gcd1}]
  var _preinspect_size = null;
  window._chain = _chain;

  window.fareyChainCopy = function(){
    if(_chain.length === 0) return;
    var modN = parseInt(document.getElementById('f-mod-num').value)||49;
    var dir  = parseFloat(document.getElementById('f-dir').value)||1;
    var lines = ['idx,r,m,gcd,phi_m,angle_deg,decimal,delta_ang_deg,chord_norm,delta_frac'];
    for(var i=0; i<_chain.length; i++){
      var pt  = _chain[i];
      var ang = dir*2*Math.PI*pt.r/(pt.m||1)+_combinedAngle*Math.PI/180;
      var deg = ((ang*180/Math.PI)%360+360)%360;
      var g   = gcd(pt.r, pt.m);
      var phi = eulerPhi(pt.m);
      var dAng='',chordN='',dFrac='';
      if(i>0){
        var prev=_chain[i-1];
        var pd=((dir*2*Math.PI*prev.r/(prev.m||1)+_combinedAngle*Math.PI/180)*180/Math.PI%360+360)%360;
        var cd=((dir*2*Math.PI*pt.r/(pt.m||1)+_combinedAngle*Math.PI/180)*180/Math.PI%360+360)%360;
        var da=cd-pd; if(da>180)da-=360; if(da<-180)da+=360; dAng=da.toFixed(4);
        var W=(document.getElementById('fc-combined')||{width:800}).width;
        chordN=(Math.sqrt(Math.pow(pt.px-prev.px,2)+Math.pow(pt.py-prev.py,2))/(W*0.5)).toFixed(6);
        dFrac=(pt.r/pt.m-prev.r/prev.m).toFixed(8);
      }
      lines.push([i+1,pt.r,pt.m,g,phi,deg.toFixed(4),(pt.r/pt.m).toFixed(8),dAng,chordN,dFrac].join(','));
    }
    var csv=lines.join('\n');
    navigator.clipboard.writeText(csv).then(function(){
      var btn=document.querySelector('[onclick="fareyChainCopy()"]');
      if(btn){var o=btn.textContent;btn.textContent='✓ Copied!';setTimeout(function(){btn.textContent=o;},1500);}
    }).catch(function(){prompt('Copy CSV:',csv);});
  };

  window.fareyClearChain = function(){
    _chain = [];
    _activeTooltipPt = null;
    document.getElementById('farey-chain-panel').style.display = 'none';
    document.getElementById('fcm-chain-clear').style.display   = 'none';
    hideTooltip();
    drawCombined();
  };

  function updateChainPanel(){
    var panel = document.getElementById('farey-chain-panel');
    var info  = document.getElementById('farey-chain-info');
    if(_chain.length < 1){ panel.style.display='none'; return; }
    panel.style.display = 'block';
    // Update canvas label to show chain count
    var lbl = document.getElementById('fc-combined-label');
    if(lbl && _inspectMode) lbl.textContent = 'Inspect · chain: '+_chain.length+' point'+(_chain.length!==1?'s — click to add, right-click to undo, re-click to remove':'  — click more to build chain');

    var modN = parseInt(document.getElementById('f-mod-num').value)||49;
    var dir  = parseFloat(document.getElementById('f-dir').value)||1;

    var titleEl = document.getElementById('farey-chain-title');
    if(titleEl) titleEl.textContent = 'CHAIN  ·  ' + _chain.length + ' point' + (_chain.length!==1?'s':'');
    var html = '';

    // Point list with step measurements
    var cumArcDeg = 0, cumChord = 0;
    for(var i=0; i<_chain.length; i++){
      var pt = _chain[i];
      var ang = dir * 2*Math.PI*pt.r/(pt.m||1) + _combinedAngle*Math.PI/180;
      var deg = ((ang*180/Math.PI)%360+360)%360;
      var col = pt.gcd1 ? '#4a90d9' : '#c94040';
      var phi_m = eulerPhi(pt.m);
      html += '<span style="color:'+col+';font-weight:bold;">' + (i+1) + '. ' + pt.r+'/'+pt.m + '</span>';
      html += ' <span style="color:#9a8060;">r='+pt.r+' m='+pt.m+' '+deg.toFixed(2)+'° φ='+phi_m+'</span>';

      if(i > 0){
        var prev = _chain[i-1];
        var pangOrig = dir * 2*Math.PI*prev.r/(prev.m||1) + _combinedAngle*Math.PI/180;
        var cangOrig = dir * 2*Math.PI*pt.r  /(pt.m||1)  + _combinedAngle*Math.PI/180;
        var prevDeg = ((pangOrig*180/Math.PI)%360+360)%360;
        var currDeg = ((cangOrig*180/Math.PI)%360+360)%360;

        // Signed angular step (shortest arc)
        var dAng = currDeg - prevDeg;
        if(dAng >  180) dAng -= 360;
        if(dAng < -180) dAng += 360;
        cumArcDeg += Math.abs(dAng);

        // Chord distance in canvas pixel coords
        var dx = pt.px - prev.px, dy = pt.py - prev.py;
        var chord = Math.sqrt(dx*dx + dy*dy);
        // normalise by canvas half-width to get 0..1 scale
        var W = document.getElementById('fc-combined').width;
        var chordN = chord / (W * 0.5);
        cumChord += chordN;

        // Fraction difference
        var fracDiff = pt.r/pt.m - prev.r/prev.m;

        html += '<br><span style="padding-left:1.5em;color:#e879f9;">'
          + 'Δang = ' + (dAng >= 0 ? '+' : '') + dAng.toFixed(2) + '°'
          + ' &nbsp; chord = ' + chordN.toFixed(4)
          + ' &nbsp; Δfrac = ' + (fracDiff>=0?'+':'') + fracDiff.toFixed(6)
          + '</span>';
      }
      html += '<br>';
    }

    // Totals if 2+ points
    if(_chain.length >= 2){
      html += '<span style="border-top:1px solid rgba(232,121,249,0.3);display:block;margin-top:4px;padding-top:4px;">';
      html += '<span style="color:#e879f9;font-weight:bold;">TOTAL</span>'
        + ' &nbsp; arc = ' + cumArcDeg.toFixed(2) + '°'
        + ' &nbsp; cumulative chord = ' + cumChord.toFixed(4);
      // closing angle: angle from last point back to first
      var p0 = _chain[0], pN = _chain[_chain.length-1];
      var a0 = dir*2*Math.PI*p0.r/(p0.m||1)+_combinedAngle*Math.PI/180;
      var aN = dir*2*Math.PI*pN.r/(pN.m||1)+_combinedAngle*Math.PI/180;
      var closeAng = ((aN-a0)*180/Math.PI % 360 + 360) % 360;
      if(closeAng > 180) closeAng = 360 - closeAng;
      html += ' &nbsp; span = ' + closeAng.toFixed(2) + '° (first→last)';
      html += '</span>';
    }

    info.innerHTML = html;
  }

  // ── Stern-Brocot best rational approx at each ring (memoized) ───────────
  var _ancestorCache = {};
  function fareyAncestors(r0, m0, modN){
    var key = r0+'/'+m0+'@'+modN;
    if(_ancestorCache[key]) return _ancestorCache[key];
    var target = r0 / (m0 || 1);
    var path = [];
    for(var k = 1; k <= modN; k++){
      var bestR = 0, bestM = 1, bestD = 1e9;
      for(var q = 1; q <= k; q++){
        var p = Math.round(target * q);
        if(p < 0) p = 0; if(p > q) p = q;
        var d = Math.abs(p/q - target);
        if(d < bestD){ bestD = d; bestR = p; bestM = q; }
      }
      path.push({r: bestR, m: bestM});
    }
    _ancestorCache[key] = path;
    return path;
  }
  function clearAncestorCache(){ _ancestorCache = {}; }

  function drawChainOverlay(ctx, W){
    if(_chain.length < 1) return;
    ctx.save();

    var modN   = parseInt(document.getElementById('f-mod-num').value) || 49;
    var dir    = parseFloat(document.getElementById('f-dir').value) || 1;
    var invert = document.getElementById('f-invert-order').checked;
    var spacing= (parseInt(document.getElementById('f-spacing').value)||100)/100;
    var zoom   = (parseInt(document.getElementById('f-zoom').value)||100)/100;
    var rinner = (parseInt(document.getElementById('f-rinner').value)||4)/100;
    var cx = W/2, cy = W/2;
    var rBase = W*0.42*spacing; if(rBase > W*0.49) rBase=W*0.49;
    var rMin = W*rinner*zoom, rMax = rBase*zoom;

    function radius(m){
      var t = invert ? (modN-m)/(modN-1||1) : (m-1)/(modN-1||1);
      return rMin + (rMax-rMin)*t;
    }
    function ptXYlocal(r, m){
      var ringOff = (typeof ringOffset==='function') ? ringOffset(m, modN) : 0;
      var a = dir*2*Math.PI*r/(m||1) + _combinedAngle*Math.PI/180 + ringOff*Math.PI/180;
      var rad = radius(m);
      return {x: cx+rad*Math.sin(a), y: cy-rad*Math.cos(a)};
    }

    // ── Inward path for each chain point ─────────────────────────────────
    _chain.forEach(function(pt){
      var ancestors = fareyAncestors(pt.r, pt.m, modN);
      // Build path: from pt.m toward the innermost ring
      // Normal (outer=modN): descend k = pt.m down to 1
      // Inverted (outer=1):  ascend  k = pt.m up to modN
      var pathPts = [];
      if(!invert){
        for(var k = pt.m; k >= 1; k--)
          pathPts.push(ptXYlocal(ancestors[k-1].r, k));
      } else {
        for(var k = pt.m; k <= modN; k++)
          pathPts.push(ptXYlocal(ancestors[k-1].r, k));
      }
      if(pathPts.length < 2) return;

      var col = pt.gcd1 ? '#4a90d9' : '#c94040';
      var steps = pathPts.length - 1;
      for(var i = 0; i < steps; i++){
        var alpha = 0.72 * (1 - i/steps);
        var lw    = Math.max(0.5, (1.6 - i/steps) * W*0.002);
        ctx.beginPath();
        ctx.moveTo(pathPts[i].x, pathPts[i].y);
        ctx.lineTo(pathPts[i+1].x, pathPts[i+1].y);
        ctx.strokeStyle = col;
        ctx.lineWidth   = lw;
        ctx.globalAlpha = alpha;
        ctx.stroke();
        // small tick dot at each ring crossing (skip origin dot at i=0)
        if(i > 0){
          ctx.beginPath();
          ctx.arc(pathPts[i].x, pathPts[i].y, Math.max(1, W*0.0028), 0, 2*Math.PI);
          ctx.fillStyle   = col;
          ctx.globalAlpha = alpha * 0.65;
          ctx.fill();
        }
      }
      // Terminal dot at innermost ring
      var tip = pathPts[pathPts.length-1];
      ctx.beginPath();
      ctx.arc(tip.x, tip.y, Math.max(2, W*0.004), 0, 2*Math.PI);
      ctx.fillStyle = col; ctx.globalAlpha = 0.45; ctx.fill();
    });

    ctx.globalAlpha = 1;

    // ── Chords between consecutive chain points ───────────────────────────
    for(var i = 1; i < _chain.length; i++){
      var a = _chain[i-1], b = _chain[i];
      ctx.beginPath(); ctx.moveTo(a.px, a.py); ctx.lineTo(b.px, b.py);
      ctx.strokeStyle = '#e879f9';
      ctx.lineWidth   = Math.max(1, W*0.002);
      ctx.globalAlpha = 0.7;
      ctx.setLineDash([Math.max(3,W*0.004), Math.max(2,W*0.003)]);
      ctx.stroke(); ctx.setLineDash([]);
      // midpoint label
      var mx=(a.px+b.px)/2, my=(a.py+b.py)/2;
      var chordN = Math.sqrt(Math.pow(b.px-a.px,2)+Math.pow(b.py-a.py,2))/(W*0.5);
      ctx.globalAlpha = 0.9;
      ctx.font = Math.max(8,W*0.012)+'px Cinzel,serif';
      ctx.fillStyle = '#e879f9'; ctx.textAlign = 'center';
      ctx.fillText((i)+'→'+(i+1)+' · '+chordN.toFixed(3), mx, my-W*0.012);
    }

    // ── Chain point rings and index labels ───────────────────────────────
    _chain.forEach(function(pt, i){
      ctx.globalAlpha = 1;
      ctx.beginPath();
      ctx.arc(pt.px, pt.py, Math.max(4, W*0.009), 0, 2*Math.PI);
      ctx.strokeStyle = '#e879f9';
      ctx.lineWidth   = Math.max(1.5, W*0.0025);
      ctx.stroke();
      ctx.fillStyle = '#e879f9';
      ctx.font = 'bold '+Math.max(8,W*0.011)+'px Cinzel,serif';
      ctx.textAlign = 'center';
      ctx.fillText(''+(i+1), pt.px, pt.py - Math.max(6, W*0.013));
    });

    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // ── Keyboard shortcuts ───────────────────────────────────────────────────
  document.addEventListener('keydown', function(e){
    var tag=(document.activeElement||{}).tagName||'';
    if(tag==='INPUT'||tag==='TEXTAREA'||tag==='SELECT') return;
    var modEl=document.getElementById('f-mod-num'), slEl=document.getElementById('f-mod');
    var modN=parseInt((modEl||{}).value)||30;
    switch(e.key){
      case 'i': case 'I':
        if(typeof fareyToggleInspect==='function') fareyToggleInspect(); break;
      case 'Escape':
        if(_chain.length>0) window.fareyClearChain();
        else if(_inspectMode && typeof fareyToggleInspect==='function') fareyToggleInspect();
        break;
      case 'ArrowUp': case '=':
        if(!e.ctrlKey&&!e.metaKey){ e.preventDefault();
          var nv=Math.min(parseInt((modEl||{}).max)||200,modN+1);
          if(modEl) modEl.value=nv; if(slEl) slEl.value=nv; fareyRedraw(); }
        break;
      case 'ArrowDown':
        if(!e.ctrlKey&&!e.metaKey){ e.preventDefault();
          var nv2=Math.max(parseInt((modEl||{}).min)||3,modN-1);
          if(modEl) modEl.value=nv2; if(slEl) slEl.value=nv2; fareyRedraw(); }
        break;
      case 'r': case 'R':
        if(document.getElementById('farey-combined-view').style.display!=='none')
          window.fareyCombinedClick&&window.fareyCombinedClick();
        break;
    }
  });

  // ── Canvas click: rotate or inspect ──────────────────────────────────────
  document.addEventListener('DOMContentLoaded', function(){
    var c = document.getElementById('fc-combined');
    if(!c) return;

    // Right-click removes last chain point
    c.addEventListener('contextmenu', function(e){
      if(_inspectMode && _chain.length > 0){
        e.preventDefault();
        _chain.pop();
        if(_chain.length === 0){
          document.getElementById('fcm-chain-clear').style.display = 'none';
          document.getElementById('farey-chain-panel').style.display = 'none';
        }
        updateChainPanel();
        drawCombined();
      }
    });

    c.addEventListener('click', function(e){
      if(_inspectMode){
        var rect  = c.getBoundingClientRect();
        var scale = c.width / c.offsetWidth;
        var mx    = (e.clientX - rect.left) * scale;
        var my    = (e.clientY - rect.top)  * scale;
        var hitR  = 14 * scale;
        var best  = null, bestD = Infinity;
        _lastCombinedPts.forEach(function(pt){
          var d = Math.sqrt((pt.px-mx)*(pt.px-mx)+(pt.py-my)*(pt.py-my));
          if(d < hitR && d < bestD){ bestD=d; best=pt; }
        });
        if(best){
          // Check if already in chain — if so remove it
          var existing = _chain.findIndex(function(p){ return p.r===best.r && p.m===best.m; });
          if(existing >= 0){
            _chain.splice(existing, 1);
          } else {
            _chain.push({r:best.r, m:best.m, px:best.px, py:best.py, gcd1:best.gcd1});
          }
          _activeTooltipPt = _chain.length > 0 ? _chain[_chain.length-1] : null;
          var clearBtn = document.getElementById('fcm-chain-clear');
          clearBtn.style.display = _chain.length >= 1 ? 'inline-block' : 'none';
          updateChainPanel();
          // Show single-point tooltip only when chain has just 1 point
          if(_chain.length === 1){
            showTooltip(best, mx, my);
          } else {
            document.getElementById('farey-tooltip').style.display = 'none';
          }
          drawCombined();
        } else {
          // Clicked empty space — clear chain if it has points, else do nothing
          if(_chain.length === 0){
            hideTooltip();
            drawCombined();
          }
        }
      } else {
        fareyCombinedClick();
      }
    });
  });

  function syncCombinedSize(){
    var sz = parseInt(document.getElementById('f-size-num').value)||800;
    var c  = document.getElementById('fc-combined');
    c.width=sz; c.height=sz;
    c.style.width=sz+'px'; c.style.height=sz+'px';
  }

  window.fareyCombinedMode = function(mode){
    _combinedMode = mode;
    // update button styles
    ['both','coprime','noncoprime'].forEach(function(m){
      var btn = document.getElementById('fcm-'+m);
      var active = m===mode;
      var colors = {both:['var(--gold)','var(--parchment)'], coprime:['#4a90d9','#4a90d9'], noncoprime:['#c94040','#c94040']};
      btn.style.background = active ? colors[m][0] : 'var(--parchment-dark)';
      btn.style.color       = active ? (m==='both'?'var(--parchment)':'var(--parchment)') : colors[m][1];
    });
    var labels = {both:'Combined · click to rotate 90°', coprime:'gcd(r, m) = 1 · click to rotate 90°', noncoprime:'gcd(r, m) > 1 · click to rotate 90°'};
    var lcolors= {both:'var(--gold)', coprime:'#4a90d9', noncoprime:'#c94040'};
    var lbl = document.getElementById('fc-combined-label');
    lbl.textContent = labels[mode]; lbl.style.color = lcolors[mode];
    // Use fareyRedraw so gap overlay hook fires after canvas switch
    if (typeof window.fareyRedraw === 'function') { window.fareyRedraw(); } else { drawCombined(); }
  };

  window.fareyCombinedClick = function(){
    _combinedAngle = (_combinedAngle + 90) % 360;
    drawCombined();
    highlightNavLink();
  };

  function drawCombined(overrideCanvas){
    var c   = overrideCanvas || document.getElementById('fc-combined');
    if(!c) return;
    var ctx = c.getContext('2d');
    var W=c.width, H=c.height;
    ctx.clearRect(0,0,W,H);
    _lastCombinedPts = []; // reset point cache

    var modN  = parseInt(document.getElementById('f-mod-num').value)||49;
    var col1  = document.getElementById('f-col1').value;
    var col2  = document.getElementById('f-col2').value;
    var labelMode  = document.getElementById('f-label').value;
    var labelStyle = document.getElementById('f-label-style').value;
    var lsize = parseInt(document.getElementById('f-lsize').value)||7;
    var showChords   = document.getElementById('f-chords').checked;
    var showSpokes   = document.getElementById('f-spokes').checked;
    var showSameMod  = document.getElementById('f-samemod').checked;
    var showCrossMod = document.getElementById('f-crossmod').checked;
    var sameModColMode  = document.getElementById('f-samemod-colmode').value;
    var sameModFixedCol = document.getElementById('f-samemod-col').value;
    var sameModThick    = parseInt(document.getElementById('f-samemod-thick').value)/10;
    var crossModThick   = parseInt(document.getElementById('f-crossmod-thick').value)/10;
    var dir  = parseFloat(document.getElementById('f-dir').value)||1;

    var fracs = buildFractions(modN);
    var cx=W/2, cy=H/2;
    var _spacing = (parseInt(document.getElementById('f-spacing').value)||100)/100;
    var _rinner  = (parseInt(document.getElementById('f-rinner').value)||4)/100;
    var _zoom    = (parseInt(document.getElementById('f-zoom').value)||100)/100;
    var _invert  = document.getElementById('f-invert-order').checked;
    var rBase = W*0.42*_spacing; if(rBase > W*0.49) rBase=W*0.49;
    var rMin = W*_rinner*_zoom, rMax = rBase*_zoom;
    var ang = _combinedAngle;

    function radius(m){
      var t = _invert ? (modN-m)/(modN-1||1) : (m-1)/(modN-1||1);
      return rMin+(rMax-rMin)*t;
    }
    function ptXY(r,m){
      var base = dir*2*Math.PI*r/(m||1);
      var rad  = radius(m);
      var a    = base + ang*Math.PI/180 + ringOffset(m, modN)*Math.PI/180;
      return {x:cx+rad*Math.sin(a), y:cy-rad*Math.cos(a)};
    }

    ctx.save();

    // decide which sets to draw
    var sets = [];
    if(_combinedMode==='both'||_combinedMode==='coprime')    sets.push({pts:fracs.cop, color:col1, ringColor:'#2a5a9a'});
    if(_combinedMode==='both'||_combinedMode==='noncoprime') sets.push({pts:fracs.ncp, color:col2, ringColor:'#8a2020'});

    // rings (draw once, shared)
    for(var m=1;m<=modN;m++){
      var rr=radius(m);
      ctx.beginPath(); ctx.arc(cx,cy,rr,0,2*Math.PI);
      ctx.strokeStyle = _combinedMode==='noncoprime'?'#8a2020':(_combinedMode==='coprime'?'#2a5a9a':'#6a6a8a');
      ctx.lineWidth   = m===modN?1.2:0.4;
      ctx.globalAlpha = m===modN?0.7:0.12;
      ctx.stroke();
    }
    ctx.globalAlpha=1;

    sets.forEach(function(s){
      var pts=s.pts, color=brightenColor(s.color, getBrightness());
      var ptMap={};
      pts.forEach(function(p){ ptMap[p.r+'/'+p.m]=p; });

      // chords
      if(showChords){
        var done={};
        pts.forEach(function(p){
          var pr=p.m-p.r, k1=p.r+'/'+p.m, k2=pr+'/'+p.m;
          if(done[k1]||done[k2]) return;
          if(ptMap[k2]&&p.r!==pr){
            done[k1]=done[k2]=1;
            var p1=ptXY(p.r,p.m),p2=ptXY(pr,p.m);
            ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y);
            ctx.strokeStyle=color; ctx.lineWidth=0.4;
            ctx.globalAlpha=0.04+0.14*p.m/modN; ctx.stroke();
          }
        });
        ctx.globalAlpha=1;
      }

      // spokes
      if(showSpokes){
        var byVal={};
        pts.forEach(function(p){ var v=(p.r/p.m).toFixed(10); if(!byVal[v]) byVal[v]=[]; byVal[v].push(p); });
        Object.keys(byVal).forEach(function(v){
          var arr=byVal[v].sort(function(a,b){return a.m-b.m;});
          for(var i=0;i<arr.length-1;i++){
            var pa=ptXY(arr[i].r,arr[i].m),pb=ptXY(arr[i+1].r,arr[i+1].m);
            ctx.beginPath(); ctx.moveTo(pa.x,pa.y); ctx.lineTo(pb.x,pb.y);
            ctx.strokeStyle=color; ctx.lineWidth=0.3; ctx.globalAlpha=0.06; ctx.stroke();
          }
        });
        ctx.globalAlpha=1;
      }

      // ring polygon
      if(showSameMod){
      var polyFilter = (document.getElementById('f-samemod-filter')||{value:'gcd1'}).value;
      var polyRings  = (document.getElementById('f-samemod-rings')||{value:'outer'}).value;
      function gcdLoc(a,b){while(b){var t=b;b=a%b;a=t;}return a;}
      var allF = buildFractions(modN);
      var srcPts2;
      if      (polyFilter==='gcd1') srcPts2 = allF.cop;
      else if (polyFilter==='gcd2') srcPts2 = allF.ncp;
      else                          srcPts2 = allF.cop.concat(allF.ncp);
      var byM2={};
      srcPts2.forEach(function(p){ if(!byM2[p.m]) byM2[p.m]=[]; byM2[p.m].push(p); });
      var mList2=Object.keys(byM2).map(Number).sort(function(a,b){return a-b;});
      var ringsToDraw2;
      if      (polyRings==='outer')  ringsToDraw2=[modN];
      else if (polyRings==='outer5') ringsToDraw2=mList2.slice(-5);
      else                           ringsToDraw2=mList2;
      ringsToDraw2.forEach(function(m){
        var ring=(byM2[m]||[]).slice().sort(function(a,b){return a.r/a.m-b.r/b.m;});
        if(ring.length<2) return;
        var mi=mList2.indexOf(m);
        var lc;
        if(sameModColMode==='permod'){
          var h=Math.round(360*mi/Math.max(mList2.length-1,1));
          lc='hsl('+h+',72%,58%)';
        } else if(sameModColMode==='gradient'){
          var t=(m-1)/(modN-1||1);
          lc='rgb('+Math.round(42+(180-42)*t)+','+Math.round(90+(60-90)*t)+','+Math.round(180+(20-180)*t)+')';
        } else { lc=sameModFixedCol; }
        ctx.strokeStyle=lc; ctx.lineWidth=sameModThick;
        ctx.globalAlpha=0.25+0.75*(m/modN);
        ctx.beginPath();
        var f2=ptXY(ring[0].r,ring[0].m); ctx.moveTo(f2.x,f2.y);
        for(var i=1;i<ring.length;i++){ var pp2=ptXY(ring[i].r,ring[i].m); ctx.lineTo(pp2.x,pp2.y); }
        ctx.lineTo(f2.x,f2.y); ctx.stroke();
      });
      ctx.globalAlpha=1;
      }

      // cross-mod
      if(showCrossMod){
        var ptByRM2={};
        pts.forEach(function(p){ ptByRM2[p.r+','+p.m]=p; });
        var drawnC={};
        pts.forEach(function(p){
          if(p.m>=modN) return;
          if(!ptByRM2[p.r+','+(p.m+1)]) return;
          var ek=p.r+':'+p.m+'-'+(p.m+1);
          if(drawnC[ek]) return; drawnC[ek]=1;
          var lc;
          if(sameModColMode==='permod'){ var h=Math.round(360*(p.r%modN)/modN); lc='hsl('+h+',65%,55%)'; }
          else if(sameModColMode==='gradient'){ var t=(p.m-1)/(modN-1||1); lc='rgb('+Math.round(42+(180-42)*t)+','+Math.round(90+(60-90)*t)+','+Math.round(180+(20-180)*t)+')'; }
          else { lc=sameModFixedCol; }
          var xy1=ptXY(p.r,p.m), xy2=ptXY(p.r,p.m+1);
          ctx.beginPath(); ctx.moveTo(xy1.x,xy1.y); ctx.lineTo(xy2.x,xy2.y);
          ctx.strokeStyle=lc; ctx.lineWidth=crossModThick;
          ctx.globalAlpha=0.15+0.35*(p.m/modN); ctx.stroke();
        });
        ctx.globalAlpha=1;
      }

      // dots / labels
      pts.forEach(function(p){
        var xy=ptXY(p.r,p.m);
        var _ptScale=(parseInt(document.getElementById('f-ptsize')&&document.getElementById('f-ptsize').value)||100)/100;
        var dotR=Math.max(0.3, (1.0*(1-p.m/modN*0.3)) * Math.max(0.4, 2.2 - modN/18) * (W/400) * _ptScale);
        var isActive = _activeTooltipPt && _activeTooltipPt.r===p.r && _activeTooltipPt.m===p.m;

        // cache for hit testing
        _lastCombinedPts.push({px:xy.x, py:xy.y, r:p.r, m:p.m, gcd1: gcd(p.r,p.m)===1});

        ctx.globalAlpha=1;
        var lbl='';
        if(labelMode==='fraction') lbl=p.r+'/'+p.m;
        else if(labelMode==='r')   lbl=''+p.r;
        else if(labelMode==='m')   lbl='m='+p.m;
        else if(labelMode==='angle') lbl=Math.round(360*p.r/p.m)+'°';
        else if(labelMode==='radian') lbl=(2*p.r/p.m).toFixed(2)+'π';
        else if(labelMode==='decimal') lbl=(p.r/p.m).toFixed(2);
        if(labelMode==='none'||labelStyle==='dot+label'){
          ctx.beginPath(); ctx.arc(xy.x,xy.y, isActive ? dotR*2.5 : dotR, 0, 2*Math.PI);
          ctx.fillStyle= isActive ? '#f0d060' : color; ctx.fill();
          if(isActive){
            // ring around active point
            ctx.beginPath(); ctx.arc(xy.x,xy.y,dotR*4,0,2*Math.PI);
            ctx.strokeStyle='rgba(240,208,96,0.5)'; ctx.lineWidth=1; ctx.stroke();
          }
        }
        if(labelMode!=='none'&&lbl){
          ctx.font=lsize+'px Cinzel,serif'; ctx.fillStyle= isActive ? '#f0d060' : color;
          ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.globalAlpha=1;
          ctx.fillText(lbl,xy.x,xy.y-(labelStyle==='label-only'?0:dotR+lsize*0.6));
        }
      });
    });

    // center dot
    ctx.globalAlpha=1;
    ctx.beginPath(); ctx.arc(cx,cy,3*(W/400),0,2*Math.PI);
    ctx.fillStyle='#8a8a6a'; ctx.fill();

    // ── Riemann zeros overlay (on top of everything) ──────────────────────
    if (_showZeros && !overrideCanvas) {
      overlayRiemannZeros(ctx, W, H, rMin, rMax);
    }

    ctx.restore();
  }


  // ── Riemann zeros overlay — Franel-Landau phase method ───────────────────
  // Each zero tₙ maps to angle φₙ = tₙ · log(N) on the outer ring (mod 2π).
  // This is the phase from the explicit formula: ψ(N) = N − Σ N^ρ/ρ − …
  // where each ρ = ½+itₙ contributes N^ρ = N^½ · e^{itₙ log N}.
  // As mod N changes, the phases rotate — constructive interference creates
  // discrepancy spikes at the scales predicted by Franel-Landau.
  var _showZeros = false;
  var RIEMANN_ZEROS = [
    14.134725, 21.022040, 25.010858, 30.424876, 32.935062,
    37.586178, 40.918719, 43.327073, 48.005151, 49.773832,
    52.970321, 56.446248, 59.347044, 60.831779, 65.112544,
    67.079811, 69.546402, 72.067158, 75.704691, 77.144840,
    79.337375, 82.910381, 84.735493, 87.425275, 88.809111,
    92.491899, 94.651344, 95.870634, 98.831194, 101.317851
  ];

  window.fareyToggleZeros = function() {
    _showZeros = !_showZeros;
    var btn = document.getElementById('fcm-zeros');
    if (btn) {
      btn.style.background = _showZeros ? '#a855f7' : 'var(--parchment-dark)';
      btn.style.color = _showZeros ? '#fff' : '#a855f7';
    }
    fareyRedraw();
  };

  function overlayRiemannZeros(ctx, W, H, rMin, rMax) {
    var cx = W/2, cy = H/2;
    var modN = parseInt(document.getElementById('f-mod-num').value) || 49;
    var dir  = parseFloat(document.getElementById('f-dir').value) || 1;
    var angOff = (_combinedAngle || 0) * Math.PI / 180;
    var logN = Math.log(Math.max(modN, 2));

    ctx.save();

    // ── Phase points on outer ring ────────────────────────────────────────
    // φₙ = tₙ · log(N)  (mod 2π) — place on outer ring radius rMax
    // Weight by amplitude: N^½ / |ρ| = N^½ / √(¼+tₙ²) — larger tₙ = fainter
    var nShow = Math.min(RIEMANN_ZEROS.length, 30);
    RIEMANN_ZEROS.slice(0, nShow).forEach(function(t, i) {
      var phase = (t * logN) % (2 * Math.PI);
      var a = dir * phase + angOff;
      var amplitude = Math.sqrt(modN) / Math.sqrt(0.25 + t * t);
      var alpha = Math.min(0.95, 0.3 + amplitude * 0.8);

      // Point on outer ring
      var x = cx + rMax * Math.sin(a);
      var y = cy - rMax * Math.cos(a);

      var dotR = Math.max(2.5, W * 0.007 * (1 - i / nShow * 0.5));
      ctx.beginPath();
      ctx.arc(x, y, dotR, 0, 2 * Math.PI);
      ctx.fillStyle = '#e879f9';
      ctx.globalAlpha = alpha;
      ctx.fill();

      // Spoke from centre — shows which ring the phase lands on
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(x, y);
      ctx.strokeStyle = '#e879f9';
      ctx.lineWidth = 0.6;
      ctx.globalAlpha = alpha * 0.25;
      ctx.stroke();

      // Label first 12
      if (i < 12) {
        var lsize = Math.max(7, W * 0.014);
        ctx.font = lsize + 'px Cinzel, serif';
        ctx.fillStyle = '#ffd700';
        ctx.globalAlpha = Math.min(0.9, alpha);
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        var lx = cx + (rMax + lsize * 1.4) * Math.sin(a);
        var ly = cy - (rMax + lsize * 1.4) * Math.cos(a);
        ctx.fillText('γ' + (i+1), lx, ly);
      }
    });

    ctx.globalAlpha = 1;

    // ── Resultant vector (sum of unit phases) — shows net discrepancy direction
    var sumX = 0, sumY = 0;
    RIEMANN_ZEROS.slice(0, nShow).forEach(function(t) {
      var phase = (t * logN) % (2 * Math.PI);
      var a = dir * phase + angOff;
      var amp = 1 / Math.sqrt(0.25 + t * t);
      sumX += amp * Math.sin(a);
      sumY += -amp * Math.cos(a);
    });
    var sumLen = Math.sqrt(sumX*sumX + sumY*sumY);
    if (sumLen > 0.01) {
      var scale = rMax * 0.6 * Math.min(1, sumLen * 3);
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + sumX/sumLen * scale, cy + sumY/sumLen * scale);
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.7;
      ctx.stroke();
    }

    // ── Legend ────────────────────────────────────────────────────────────
    ctx.font = Math.max(8, W * 0.014) + 'px Cinzel, serif';
    ctx.fillStyle = '#a855f7';
    ctx.globalAlpha = 0.7;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText('Riemann zero phases  φₙ = tₙ · log(' + modN + ')  mod 2π', cx, H - 24);
    ctx.fillStyle = '#ffd700';
    ctx.fillText('Gold arrow = resultant phase vector (proxy for discrepancy)', cx, H - 10);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // (DFT spectrum moved to standalone rz module)

  // ── Composite PNG export ─────────────────────────────────────────────────
  // ── Helper: render a fresh offscreen canvas ─────────────────────────────
  function makeFareyCanvas(mode, size){
    // mode: 'coprime' | 'noncoprime' | 'combined'
    var c = document.createElement('canvas');
    c.width = size; c.height = size;
    if(mode === 'combined'){
      drawCombined(c);
    } else {
      drawFarey(mode, c);
    }

    // ── Gap overlay on export ───────────────────────────────────────────────
    if (mode === 'combined' && window._overlayGap !== null && window._overlayGap !== undefined && window._overlayPairs && window._overlayPairs.length > 0) {
      if (typeof window.drawGapOverlay === 'function') window.drawGapOverlay(c);
    }

    // ── Outer-ring labels ───────────────────────────────────────────────────
    var ctx = c.getContext('2d');
    var modN    = parseInt(document.getElementById('f-mod-num').value) || 49;
    var dir     = parseFloat(document.getElementById('f-dir').value) || 1;
    var spacing = (parseInt(document.getElementById('f-spacing').value) || 100) / 100;
    var zoom    = (parseInt(document.getElementById('f-zoom').value) || 100) / 100;
    var rinner  = (parseInt(document.getElementById('f-rinner').value) || 4) / 100;
    var invert  = document.getElementById('f-invert-order').checked;
    var angBase = (mode === 'combined') ? (window._combinedAngle || 90) : (_angles[mode] || 0);
    var rBase   = size * 0.42 * spacing; if (rBase > size * 0.49) rBase = size * 0.49;
    var rMin    = size * rinner * zoom, rMax = rBase * zoom;
    function _expRadius(m) {
      var t = invert ? (modN-m)/(modN-1||1) : (m-1)/(modN-1||1);
      return rMin + (rMax - rMin) * t;
    }
    var outerR   = _expRadius(modN);
    var lsize    = Math.max(7, size * 0.013);
    var labelPad = lsize * 0.8 + Math.max(3, size * 0.007) + 4;
    var cx = size/2, cy = size/2;

    var fracs = buildFractions(modN);
    var outerPts = [];
    if (mode === 'coprime')    fracs.cop.forEach(function(p){ if(p.m===modN) outerPts.push({r:p.r,m:p.m,gcd1:true}); });
    else if (mode === 'noncoprime') fracs.ncp.forEach(function(p){ if(p.m===modN) outerPts.push({r:p.r,m:p.m,gcd1:false}); });
    else {
      fracs.cop.forEach(function(p){ if(p.m===modN) outerPts.push({r:p.r,m:p.m,gcd1:true}); });
      fracs.ncp.forEach(function(p){ if(p.m===modN) outerPts.push({r:p.r,m:p.m,gcd1:false}); });
    }

    var col1 = document.getElementById('f-col1').value;
    var col2 = document.getElementById('f-col2').value;

    ctx.save();
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

    outerPts.forEach(function(p) {
      var ringOff = (typeof ringOffset === 'function') ? ringOffset(p.m, modN) : 0;
      var a  = dir * 2 * Math.PI * p.r / (p.m || 1) + angBase * Math.PI / 180 + ringOff * Math.PI / 180;
      var lx = cx + (outerR + labelPad) * Math.sin(a);
      var ly = cy - (outerR + labelPad) * Math.cos(a);

      var _og = window._overlayGap, _op = window._overlayPairs || [], _oc = window._overlayColor || '#4a90d9';
      var inOverlay = _og !== null && _og !== undefined && _op.some(function(pair){ return pair.r1===p.r || pair.r2===p.r; });
      ctx.globalAlpha = inOverlay ? 1.0 : 0.7;
      ctx.fillStyle   = inOverlay ? _oc : (p.gcd1 ? col1 : col2);
      ctx.font        = (inOverlay ? 'bold ' : '') + lsize + 'px Cinzel, serif';
      ctx.fillText(p.r + '/' + p.m, lx, ly);
    });

    ctx.globalAlpha = 1;
    ctx.restore();
    return c;
  }

  // ── Shared: draw point detail panel onto ctx ──────────────────────────────
  function drawDetailPanel(ctx, pt, panelX, panelY, panelW, panelH, col1, col2, modN){
    var dir = parseFloat(document.getElementById('f-dir').value)||1;
    var g   = gcd(pt.r, pt.m);
    var ptColor = g===1 ? col1 : col2;
    var ang = dir*2*Math.PI*pt.r/(pt.m||1) + _combinedAngle*Math.PI/180;
    var deg = ((ang*180/Math.PI)%360+360)%360;
    var rad = dir*2*pt.r/(pt.m||1);
    var phi = eulerPhi(pt.m);

    ctx.fillStyle=window.canvasTooltipBg ? window.canvasTooltipBg() : 'rgba(14,11,5,0.97)'; ctx.fillRect(panelX,panelY,panelW,panelH);
    ctx.strokeStyle='rgba(196,155,56,0.55)'; ctx.lineWidth=0.8;
    ctx.strokeRect(panelX,panelY,panelW,panelH);

    var tx=panelX+14, lineH=19, ty=panelY+24;
    ctx.textAlign='left'; ctx.textBaseline='alphabetic';

    ctx.font='bold 13px "Cinzel",Georgia,serif';
    ctx.fillStyle=ptColor; ctx.fillText(pt.r+'/'+pt.m, tx, ty); ty+=lineH+4;

    ctx.strokeStyle='rgba(196,155,56,0.25)'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(panelX+8,ty-4); ctx.lineTo(panelX+panelW-8,ty-4); ctx.stroke();

    ctx.font='10px "Cinzel",Georgia,serif';
    [['r',''+pt.r],['m',''+pt.m],['gcd',''+g]].forEach(function(row){
      ctx.fillStyle='#9a8060'; ctx.fillText(row[0],tx,ty);
      ctx.fillStyle=ptColor;   ctx.fillText(row[1],tx+64,ty); ty+=lineH;
    });

    ty+=4; ctx.strokeStyle='rgba(196,155,56,0.2)'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(panelX+8,ty-4); ctx.lineTo(panelX+panelW-8,ty-4); ctx.stroke();

    [['angle',deg.toFixed(2)+'°'],['radian',rad.toFixed(4)+'π'],['decimal',(pt.r/pt.m).toFixed(6)]].forEach(function(row){
      ctx.fillStyle='#9a8060'; ctx.fillText(row[0],tx,ty);
      ctx.fillStyle=document.body.classList.contains('dark-mode')?'#e8d9b0':'#1e1008'; ctx.fillText(row[1],tx+64,ty); ty+=lineH;
    });

    ty+=4; ctx.beginPath(); ctx.moveTo(panelX+8,ty-4); ctx.lineTo(panelX+panelW-8,ty-4); ctx.stroke();
    ctx.fillStyle='#9a8060'; ctx.fillText('φ('+pt.m+')',tx,ty);
    ctx.fillStyle=document.body.classList.contains('dark-mode')?'#e8d9b0':'#1e1008'; ctx.fillText(''+phi,tx+64,ty); ty+=lineH;
    ctx.fillStyle='#9a8060'; ctx.fillText('type',tx,ty);
    ctx.fillStyle=ptColor;   ctx.fillText(g===1?'gcd = 1':'gcd = '+g,tx+64,ty);
  }

  // ── Composite export ───────────────────────────────────────────────────────
  window.fareyComposite = function(){
    var modN     = parseInt(document.getElementById('f-mod-num').value)||49;
    var col1     = document.getElementById('f-col1').value;
    var col2     = document.getElementById('f-col2').value;
    var diagSize = parseInt(document.getElementById('f-size-num').value)||800;
    var pt       = _activeTooltipPt;

    var PAD=16, GAP=24, FOOT=18;
    var DETAIL_W = pt ? 220 : 0, DETAIL_PAD = pt ? 16 : 0;

    // Render fresh canvases for export
    var combinedOpen = document.getElementById('farey-combined-view').style.display !== 'none';
    var src1 = combinedOpen ? makeFareyCanvas('combined', diagSize)
                            : makeFareyCanvas('coprime',  diagSize);
    var src2 = combinedOpen ? null : makeFareyCanvas('noncoprime', diagSize);

    var W = combinedOpen
      ? PAD + diagSize + DETAIL_PAD + DETAIL_W + PAD
      : PAD + diagSize + GAP + diagSize + DETAIL_PAD + DETAIL_W + PAD;
    var H = PAD + diagSize + FOOT + PAD;

    var off = document.createElement('canvas'); off.width=W; off.height=H;
    var ctx = off.getContext('2d');
    ctx.fillStyle=canvasBg(); ctx.fillRect(0,0,W,H);

    if(combinedOpen){
      ctx.drawImage(src1, PAD, PAD, diagSize, diagSize);
    } else {
      ctx.drawImage(src1, PAD,               PAD, diagSize, diagSize);
      ctx.drawImage(src2, PAD+diagSize+GAP,  PAD, diagSize, diagSize);
    }

    // mod label
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font='9px "Cinzel",Georgia,serif'; ctx.fillStyle='#9a8060';
    var labelX = combinedOpen ? PAD+diagSize/2 : PAD+diagSize+GAP/2+diagSize/2;
    ctx.fillText('mod 1…'+modN, labelX, PAD+diagSize+FOOT/2+2);

    if(pt){
      var dx = W - PAD - DETAIL_W;
      drawDetailPanel(ctx, pt, dx, PAD, DETAIL_W, diagSize, col1, col2, modN);
    }

    var a = document.createElement('a');
    a.download = 'farey_mod'+modN+(pt?'_r'+pt.r+'_m'+pt.m:'')+'_composite.png';
    a.href = off.toDataURL('image/png'); a.click();
  };

  // ── Triangle export ────────────────────────────────────────────────────────
  window.fareyTriangleExport = function(){
    var modN = parseInt(document.getElementById('f-mod-num').value)||49;
    var col1 = document.getElementById('f-col1').value;
    var col2 = document.getElementById('f-col2').value;
    var S    = parseInt(document.getElementById('f-size-num').value)||800;
    var pt   = _activeTooltipPt;

    // Render all three at user size
    var srcCop  = makeFareyCanvas('coprime',    S);
    var srcNcp  = makeFareyCanvas('noncoprime', S);
    var srcComb = makeFareyCanvas('combined',   S);

    // ── Compute stats ─────────────────────────────────────────────────────
    var fracs    = buildFractions(modN);
    var cop = fracs.cop, ncp = fracs.ncp;
    var total    = cop.length + ncp.length;
    var copCount = cop.length, ncpCount = ncp.length;
    var copRatio = total>0 ? copCount/total : 0;
    var ncpRatio = total>0 ? ncpCount/total : 0;
    var gcds = {};
    ncp.forEach(function(p){ var g=gcd(p.r,p.m); gcds[g]=(gcds[g]||0)+1; });
    var gcdList = Object.keys(gcds).map(Number).sort(function(a,b){return a-b;});

    // ── Layout constants ──────────────────────────────────────────────────
    var OUTER    = 28;   // outer padding
    var PLUS     = 40;   // plus-sign zone between top two diagrams
    var SIDE_W   = Math.max(180, Math.round(S * 0.28)); // side legend panel width
    var SIDE_GAP = 16;   // gap between combined and side panels
    var BAR_H    = 14;   // ratio bar height
    var BAR_GAP  = 8;    // gap between bar and combined top
    var BAR_TOP  = 24;   // gap above bar (for "Combined · mod N" label)

    // Top row: two diagrams side by side, centered in totalW
    // Bottom row: [side panel left] [combined] [side panel right]
    // totalW must fit the wider of: (top row) or (side+combined+side)
    var topRowW  = OUTER + S + PLUS + S + OUTER;
    var botRowW  = OUTER + SIDE_W + SIDE_GAP + S + SIDE_GAP + SIDE_W + OUTER;
    var totalW   = Math.max(topRowW, botRowW);

    // Center top diagrams and combined within totalW
    var topRowX  = Math.round((totalW - (S + PLUS + S)) / 2);
    var copX     = topRowX;
    var ncpX     = topRowX + S + PLUS;
    var combX    = Math.round((totalW - S) / 2);

    // Side panel x positions (flanking combined)
    var leftPanX = combX - SIDE_GAP - SIDE_W;
    var rightPanX= combX + S + SIDE_GAP;

    // Row y positions — no stats row between top and bottom
    var diagY    = OUTER + 28;           // diagrams top
    var barY     = diagY + S + BAR_TOP;  // bar sits just below the top diagrams
    var combY    = barY + BAR_H + BAR_GAP;
    var totalH   = combY + S + OUTER;

    var STATS_H  = S;    // side panels fill full height of combined canvas

    var off = document.createElement('canvas');
    off.width = totalW; off.height = totalH;
    var ctx = off.getContext('2d');

    // Background
    ctx.fillStyle = window.canvasBg ? window.canvasBg() : '#0e0b05';
    ctx.fillRect(0, 0, totalW, totalH);

    // ── Draw top diagrams ─────────────────────────────────────────────────
    ctx.drawImage(srcCop, copX, diagY, S, S);
    ctx.drawImage(srcNcp, ncpX, diagY, S, S);

    // Labels above diagrams
    ctx.textAlign='center'; ctx.textBaseline='bottom';
    ctx.font='bold 11px "Cinzel",Georgia,serif';
    ctx.font='bold '+Math.max(9,Math.round(11*fScale))+'px "Cinzel",Georgia,serif';
    ctx.fillStyle=col1; ctx.fillText('GCD(R, M) = 1',  copX+S/2, diagY-5);
    ctx.fillStyle=col2; ctx.fillText('GCD(R, M) > 1', ncpX+S/2, diagY-5);
    // subtitle line
    ctx.font=Math.max(7,Math.round(8*fScale))+'px "Cinzel",Georgia,serif';
    var inkSubtitle = document.body.classList.contains('dark-mode') ? 'rgba(196,155,56,0.7)' : 'rgba(80,50,10,0.7)';
    ctx.fillStyle=inkSubtitle;
    ctx.fillText('r/m, 1 ≤ r ≤ m, 1 ≤ m ≤ '+modN, copX+S/2, diagY-5+14);
    ctx.fillText('r/m, 1 ≤ r ≤ m, 1 ≤ m ≤ '+modN, ncpX+S/2, diagY-5+14);

    // Plus sign between diagrams
    var plusCX = copX + S + PLUS/2;
    var plusCY = diagY + S/2;
    var arm=13, thick=3;
    ctx.fillStyle='#c49b38';
    ctx.fillRect(plusCX-arm, plusCY-thick/2, arm*2, thick);
    ctx.fillRect(plusCX-thick/2, plusCY-arm, thick, arm*2);

    // Corner ticks where diagrams "meet"
    ctx.strokeStyle='rgba(196,155,56,0.5)'; ctx.lineWidth=1.5;
    var tick=16;
    var copIX=copX+S, ncpIX=ncpX;
    [[copIX-tick,diagY,copIX,diagY,copIX,diagY+tick],
     [copIX-tick,diagY+S,copIX,diagY+S,copIX,diagY+S-tick],
     [ncpIX+tick,diagY,ncpIX,diagY,ncpIX,diagY+tick],
     [ncpIX+tick,diagY+S,ncpIX,diagY+S,ncpIX,diagY+S-tick]
    ].forEach(function(c){ ctx.beginPath(); ctx.moveTo(c[0],c[1]); ctx.lineTo(c[2],c[3]); ctx.lineTo(c[4],c[5]); ctx.stroke(); });

    // ── Stats panels ─────────────────────────────────────────────────────
    // Font scale: proportional to canvas size (S=800 is baseline)
    var fScale = S / 800;
    var fTitlePx = Math.round(Math.max(8,  11 * fScale));
    var fRowPx   = Math.round(Math.max(7,  9.5* fScale));
    var fSmallPx = Math.round(Math.max(6,  8  * fScale));
    var lhRow    = Math.round(Math.max(11, 16 * fScale));
    var titleH   = Math.round(Math.max(16, 26 * fScale));
    var indent   = Math.round(Math.max(8,  14 * fScale));
    var darkMode = document.body.classList.contains('dark-mode');
    var inkMain  = darkMode ? '#ffffff' : '#000000';
    var inkLabel = '#9a8060';

    function drawStats(x, y, w, h, title, titleColor, rows){
      ctx.fillStyle=window.canvasTooltipBg2 ? window.canvasTooltipBg2() : 'rgba(14,11,5,0.85)';
      ctx.fillRect(x, y, w, h);
      ctx.strokeStyle='rgba(196,155,56,0.3)'; ctx.lineWidth=Math.max(0.5, 0.7*fScale);
      ctx.strokeRect(x, y, w, h);
      ctx.textAlign='left'; ctx.textBaseline='alphabetic';
      ctx.font='bold '+fTitlePx+'px "Cinzel",Georgia,serif';
      ctx.fillStyle=titleColor;
      ctx.fillText(title, x+indent, y+titleH*0.7);
      ctx.strokeStyle='rgba(196,155,56,0.2)'; ctx.lineWidth=Math.max(0.3, 0.4*fScale);
      ctx.beginPath(); ctx.moveTo(x+indent*0.6, y+titleH); ctx.lineTo(x+w-indent*0.6, y+titleH); ctx.stroke();
      var ty = y + titleH + lhRow, lh = lhRow;
      ctx.font=fRowPx+'px "Cinzel",Georgia,serif';
      rows.forEach(function(row){
        if(row==='---' || (Array.isArray(row) && row[0]==='---')){
          ctx.strokeStyle='rgba(196,155,56,0.12)'; ctx.lineWidth=Math.max(0.2,0.4*fScale);
          ctx.beginPath(); ctx.moveTo(x+indent*0.6,ty-3); ctx.lineTo(x+w-indent*0.6,ty-3); ctx.stroke();
          ty += Math.round(4*fScale); return;
        }
        var inkColor = row[2] || inkMain;
        ctx.fillStyle=inkLabel; ctx.textAlign='left';  ctx.fillText(row[0], x+indent, ty);
        ctx.fillStyle=inkColor; ctx.textAlign='right'; ctx.fillText(row[1], x+w-indent, ty);
        ty += lh;
      });
      return ty; // return end y so caller can know how much space was used
    }

    // Draw an expandable point list section inside a panel
    function drawPointList(x, startY, w, endY, pts, color, sectionTitle){
      var avail = endY - startY - lhRow*2;
      if(avail < lhRow*3) return; // no room
      // Section header
      ctx.font='bold '+fSmallPx+'px "Cinzel",Georgia,serif';
      ctx.fillStyle=color; ctx.textAlign='left';
      ctx.fillText(sectionTitle, x+indent, startY+lhRow*0.85);
      ctx.strokeStyle=color.replace(')',',0.25)').replace('rgb','rgba'); ctx.lineWidth=Math.max(0.2,0.3*fScale);
      ctx.beginPath(); ctx.moveTo(x+indent*0.6, startY+lhRow); ctx.lineTo(x+w-indent*0.6, startY+lhRow); ctx.stroke();

      var ty = startY + lhRow*1.4;
      var ptFontPx = Math.max(5, fSmallPx * 0.92);
      ctx.font = ptFontPx+'px "Cinzel",Georgia,serif';
      var colW = Math.floor(w / Math.max(3, Math.round(w / (ptFontPx * 5.5))));
      var cols = Math.floor(w / colW);
      var col = 0;
      ctx.fillStyle = darkMode ? '#ffffff' : '#000000';
      ctx.textAlign = 'left';

      for(var i = 0; i < pts.length; i++){
        var pt = pts[i];
        var lbl = pt.r + '/' + pt.m;
        var cx = x + indent*0.5 + col * colW;
        if(ty + ptFontPx > endY - 4) {
          // ran out of vertical space
          ctx.fillStyle = '#9a8060';
          ctx.fillText('+'+(pts.length-i)+' more…', cx, ty);
          break;
        }
        ctx.fillStyle = darkMode ? '#ffffff' : '#000000';
        ctx.fillText(lbl, cx, ty);
        col++;
        if(col >= cols){ col=0; ty += Math.round(ptFontPx * 1.35); }
      }
    }

    // ── Side legend panels flanking combined ─────────────────────────────
    var triangleTotal = modN*(modN+1)/2;
    var verified = (copCount+ncpCount === triangleTotal);
    var verifyStr = verified ? '✓ '+triangleTotal : '! '+triangleTotal;
    var tealColor = document.body.classList.contains('dark-mode') ? '#4ecdc4' : '#1a6a4a';

    // Left panel: GCD = 1 (coprime)
    var leftUsedY = drawStats(leftPanX, combY, SIDE_W, STATS_H, 'GCD(R,M) = 1  ·  COPRIME', col1, [
      ['Total points', ''+copCount],
      ['Share of all r/m', (copRatio*100).toFixed(2)+'%'],
      ['Ratio cop / total', copCount+' / '+total],
      ['---'],
      ['Σφ(m),  m=1…'+modN, ''+copCount],
      ['Avg φ(m) / m', copRatio.toFixed(4)],
      ['mod N', ''+modN],
      ['---'],
      ['Total r/m  (N·(N+1)/2)', verifyStr, tealColor],
    ]);
    // List all coprime points grouped by ring m
    var allCop = [];
    for(var mi=1; mi<=modN; mi++){
      for(var ri=1; ri<mi; ri++){
        if(gcd(ri,mi)===1) allCop.push({r:ri,m:mi});
      }
    }
    allCop.push({r:0,m:1}); allCop.push({r:1,m:1});
    drawPointList(leftPanX, leftUsedY, SIDE_W, combY+STATS_H, allCop, col1, 'All GCD = 1 Points  (' + copCount + ')');

    // Right panel: GCD > 1 (non-coprime)
    var ncpRows = [
      ['Total points', ''+ncpCount],
      ['Share of all r/m', (ncpRatio*100).toFixed(2)+'%'],
      ['Ratio ncp / total', ncpCount+' / '+total],
      ['---'],
    ];
    var showN = Math.min(6, gcdList.length);
    gcdList.slice(0, showN).forEach(function(g){
      var cnt=gcds[g];
      ncpRows.push(['gcd = '+g, cnt+' ('+((cnt/ncpCount)*100).toFixed(1)+'%)']);
    });
    if(gcdList.length > showN){
      var remaining = gcdList.length - showN;
      var remainingCount = gcdList.slice(showN).reduce(function(s,g){return s+gcds[g];},0);
      ncpRows.push(['+ '+remaining+' more gcd values', remainingCount+' pts']);
    }
    ncpRows.push(['---']);
    ncpRows.push(['Total r/m  (N·(N+1)/2)', verifyStr, tealColor]);
    var rightUsedY = drawStats(rightPanX, combY, SIDE_W, STATS_H, 'GCD(R,M) > 1  ·  NON-COPRIME', col2, ncpRows);
    // List all non-coprime points
    var allNcp = [];
    for(var mi=1; mi<=modN; mi++){
      for(var ri=1; ri<mi; ri++){
        if(gcd(ri,mi)>1) allNcp.push({r:ri,m:mi});
      }
    }
    drawPointList(rightPanX, rightUsedY, SIDE_W, combY+STATS_H, allNcp, col2, 'All GCD > 1 Points  (' + ncpCount + ')');

    // ── Ratio bar just above combined ─────────────────────────────────────
    // Bar spans same width as combined diagram, centered
    var barX = combX, barW = S;
    ctx.fillStyle='rgba(196,155,56,0.08)'; ctx.fillRect(barX,barY,barW,BAR_H);
    ctx.fillStyle=col1; ctx.fillRect(barX, barY, Math.round(barW*copRatio), BAR_H);
    ctx.fillStyle=col2; ctx.fillRect(barX+Math.round(barW*copRatio), barY, Math.round(barW*ncpRatio), BAR_H);
    // bar labels
    ctx.textBaseline='middle'; ctx.font=Math.max(6,Math.round(7*fScale))+'px "Cinzel",Georgia,serif';
    var midBar = barY + BAR_H/2;
    var barTextColor = document.body.classList.contains('dark-mode') ? '#fff' : '#1e1008';
    if(copRatio > 0.08){
      ctx.textAlign='left'; ctx.fillStyle=barTextColor;
      ctx.fillText('gcd = 1  '+(copRatio*100).toFixed(1)+'%', barX+5, midBar);
    }
    if(ncpRatio > 0.08){
      ctx.textAlign='right'; ctx.fillStyle=barTextColor;
      ctx.fillText((ncpRatio*100).toFixed(1)+'%  gcd > 1', barX+barW-5, midBar);
    }

    // Combined label above bar
    ctx.textAlign='center'; ctx.textBaseline='bottom';
    ctx.font='bold '+Math.max(7,Math.round(9*fScale))+'px "Cinzel",Georgia,serif'; ctx.fillStyle='rgba(196,155,56,0.6)';
    ctx.fillText('Combined  ·  n = 1, …, '+modN+'  (mod '+modN+')', combX+S/2, barY-4);

    // Faint guide lines from inner corners of top diagrams down to combined
    ctx.strokeStyle='rgba(196,155,56,0.1)'; ctx.lineWidth=0.6;
    ctx.beginPath(); ctx.moveTo(copX+S, diagY+S); ctx.lineTo(combX, combY); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(ncpX,   diagY+S); ctx.lineTo(combX+S, combY); ctx.stroke();

    // ── Combined diagram ──────────────────────────────────────────────────
    ctx.drawImage(srcComb, combX, combY, S, S);

    // ── Active point detail (optional footer on combined) ─────────────────
    if(pt){
      var g2  = gcd(pt.r,pt.m);
      var ptC = g2===1?col1:col2;
      var dir = parseFloat(document.getElementById('f-dir').value)||1;
      var ang = dir*2*Math.PI*pt.r/(pt.m||1)+_combinedAngle*Math.PI/180;
      var deg = ((ang*180/Math.PI)%360+360)%360;
      var rad = dir*2*pt.r/(pt.m||1);
      var phi = eulerPhi(pt.m);
      var fh=36, fy=combY+S-fh;
      ctx.fillStyle=window.canvasInspectBg ? window.canvasInspectBg() : 'rgba(10,8,3,0.88)'; ctx.fillRect(combX,fy,S,fh);
      ctx.strokeStyle='rgba(196,155,56,0.3)'; ctx.lineWidth=0.5;
      ctx.beginPath(); ctx.moveTo(combX,fy); ctx.lineTo(combX+S,fy); ctx.stroke();
      var items=[['r',pt.r],['m',pt.m],['gcd',g2],['angle',deg.toFixed(1)+'°'],['rad',rad.toFixed(3)+'π'],['φ(m)',phi]];
      var sp=S/items.length;
      ctx.font='8px "Cinzel",Georgia,serif'; ctx.textBaseline='middle';
      items.forEach(function(item,i){
        var ix=combX+i*sp+sp/2;
        ctx.textAlign='center'; ctx.fillStyle='#9a8060'; ctx.fillText(item[0],ix,fy+10);
        ctx.fillStyle=i<3?ptC:'#e8d9b0'; ctx.fillText(''+item[1],ix,fy+24);
      });
    }

    var a = document.createElement('a');
    a.download='farey_mod'+modN+'_layout'+(pt?'_r'+pt.r+'m'+pt.m:'')+'.png';
    a.href=off.toDataURL('image/png'); a.click();
  };


  // ── Color brightness helper (hue-preserving, no glow) ────────────────────
  function brightenColor(hex, amount){
    // amount: 0-100 extra lightness %
    if(!amount) return hex;
    // parse hex
    var r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
    // to hsl
    r/=255; g/=255; b/=255;
    var max=Math.max(r,g,b), min=Math.min(r,g,b);
    var h,s,l=(max+min)/2;
    if(max===min){ h=s=0; }
    else{
      var d=max-min;
      s = l>0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h=((g-b)/d+(g<b?6:0))/6; break;
        case g: h=((b-r)/d+2)/6; break;
        case b: h=((r-g)/d+4)/6; break;
      }
    }
    // increase lightness, clamp to 0.88 to avoid white-out
    var newL = Math.min(0.88, l + amount/100 * (0.88-l));
    // hsl back to rgb
    function hue2rgb(p,q,t){ if(t<0)t+=1; if(t>1)t-=1; if(t<1/6)return p+(q-p)*6*t; if(t<1/2)return q; if(t<2/3)return p+(q-p)*(2/3-t)*6; return p; }
    var q2 = newL<0.5 ? newL*(1+s) : newL+s-newL*s;
    var p2 = 2*newL-q2;
    var rr=Math.round(hue2rgb(p2,q2,h+1/3)*255);
    var gg=Math.round(hue2rgb(p2,q2,h)*255);
    var bb=Math.round(hue2rgb(p2,q2,h-1/3)*255);
    return '#'+((1<<24)+(rr<<16)+(gg<<8)+bb).toString(16).slice(1);
  }

  function getBrightness(){ return parseInt(document.getElementById('f-bright').value)||0; }

  // ── Per-ring cumulative rotation ─────────────────────────────────────────
  var _ringOffsets   = {};
  var _ringAnimTimer = null;

  function ringOffset(m, modN){
    var a    = parseFloat(document.getElementById('f-ringstep-a').value)||0;
    var b    = parseFloat(document.getElementById('f-ringstep-b').value)||2;
    var rdir = parseFloat(document.getElementById('f-ringdir').value)||1;
    return rdir*(m-1)*(a/b)*360 + (_ringOffsets[m]||0);
  }

  window.fareyToggleRingAnim = function(){
    var btn = document.getElementById('f-ringanim-btn');
    if(_ringAnimTimer){
      clearInterval(_ringAnimTimer); _ringAnimTimer=null;
      btn.style.background='var(--parchment-dark)'; btn.style.color='var(--ink-mid)';
      btn.textContent='▶ Spin';
    } else {
      btn.style.background='var(--gold)'; btn.style.color='var(--parchment)';
      btn.textContent='■ Stop';
      _ringAnimTimer = setInterval(function(){
        var modN  = parseInt(document.getElementById('f-mod-num').value)||49;
        var speed = parseInt(document.getElementById('f-ringspeed').value)||20;
        var rdir  = parseFloat(document.getElementById('f-ringdir').value)||1;
        for(var m=1; m<=modN; m++){
          var t = rdir===1 ? m/modN : (modN-m+1)/modN;
          _ringOffsets[m] = (_ringOffsets[m]||0) + speed*t*0.04;
        }
        fareyRedraw();
      }, 16);
    }
  };

  window.fareyResetRings = function(){
    _ringOffsets = {};
    fareyRedraw();
  };

  // ── Mertens PNG export ────────────────────────────────────────────────────
  window.mertensExportPNG = function(){
    var src = document.getElementById('m_graphCanvas');
    if(!src){ alert('Mertens chart not rendered yet.'); return; }
    var PAD=24, FOOT=32;
    var W=src.width+PAD*2, H=src.height+PAD+FOOT;
    var off=document.createElement('canvas'); off.width=W; off.height=H;
    var ctx=off.getContext('2d');
    ctx.fillStyle=canvasBg(); ctx.fillRect(0,0,W,H);
    ctx.drawImage(src, PAD, PAD, src.width, src.height);
    // border
    ctx.strokeStyle='rgba(90,90,140,0.5)'; ctx.lineWidth=1;
    ctx.strokeRect(PAD,PAD,src.width,src.height);
    // label
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font='10px "Cinzel",Georgia,serif'; ctx.fillStyle='#9a8060';
    var nMax=document.getElementById('m_nMax')?document.getElementById('m_nMax').value:'';
    ctx.fillText('Mertens Function M(n) = Σμ(k)  ·  n = 1…'+(nMax||'N'), W/2, PAD+src.height+FOOT/2);
    var a=document.createElement('a');
    a.download='mertens_'+(nMax||'N')+'.png';
    a.href=off.toDataURL('image/png'); a.click();
  };

})();
</script>

<script>
// ════════════════════════════════════════════════════════════════════════════
// RIEMANN ZEROS SECTION — standalone module (id: riemannZerosSection)
// ════════════════════════════════════════════════════════════════════════════
(function() {
  var RZ_ZEROS = [
     14.134725,  21.022040,  25.010858,  30.424876,  32.935062,
     37.586178,  40.918719,  43.327073,  48.005151,  49.773832,
     52.970321,  56.446248,  59.347044,  60.831779,  65.112544,
     67.079811,  69.546402,  72.067158,  75.704691,  77.144840,
     79.337375,  82.910381,  84.735493,  87.425275,  88.809111,
     92.491899,  94.651344,  95.870634,  98.831194, 101.317851,
    103.725538, 105.446623, 107.168611, 111.029536, 111.874659,
    114.320221, 116.226680, 118.790782, 121.370125, 122.946829,
    124.256819, 127.516683, 129.578704, 131.087688, 133.497737,
    134.756510, 138.116042, 139.736209, 141.123707, 143.111846,
    146.000982, 147.422765, 150.053521, 150.925257, 153.024693,
    156.112909, 157.597591, 158.849989, 161.188964, 163.030709,
    165.537069, 167.184439, 169.094515, 169.911976, 173.411536,
    174.754191, 176.441434, 178.377407, 179.916484, 182.207078,
    184.874467, 185.598783, 187.228922, 189.416158, 192.026656,
    193.079726, 195.265397, 196.876481, 198.015309, 201.264751,
    202.493594, 204.189671, 205.394697, 207.906258, 209.576509,
    211.690862, 213.347919, 214.547044, 216.169538, 219.067596,
    220.714918, 221.430705, 224.007000, 224.983324, 227.421444,
    229.337413, 231.250188, 231.987235, 233.693404, 236.524229
  ];
  var rzAngle = 0; // rotation in degrees

  function gcd(a, b) { while (b) { var t = b; b = a % b; a = t; } return a; }

  function buildCoprime(modN) {
    var pts = [];
    for (var m = 1; m <= modN; m++) {
      for (var r = 1; r < m; r++) {
        if (gcd(r, m) === 1) pts.push({ r: r, m: m });
      }
    }
    // include 0/1 and 1/1
    pts.push({ r: 0, m: 1 }); pts.push({ r: 1, m: 1 });
    return pts;
  }

  // ── Circle canvas ──────────────────────────────────────────────────────────
  function rzDrawCircle() {
    var c = document.getElementById('rz-circle-canvas');
    if (!c) return;
    var ctx = c.getContext('2d');
    var W = c.width, H = c.height, cx = W / 2, cy = H / 2;
    var modN   = parseInt(document.getElementById('rz-mod').value) || 49;
    var nZeros = parseInt(document.getElementById('rz-nzeros').value) || 20;
    var showLbl  = document.getElementById('rz-show-labels').checked;
    var showAxis = document.getElementById('rz-show-axis').checked;

    ctx.clearRect(0, 0, W, H);
    _rzZeroCache = [];  // reset for each draw

    // Start rotated 90° clockwise so critical axis is horizontal (left–right)
    var angOff = (rzAngle + 90) * Math.PI / 180;

    var rMax = W * 0.44, rMin = W * 0.015;

    function radius(m) {
      return rMin + (rMax - rMin) * (m - 1) / Math.max(modN - 1, 1);
    }
    function ptXY(r, m) {
      var a = 2 * Math.PI * r / m + angOff;
      var rad = radius(m);
      return { x: cx + rad * Math.sin(a), y: cy - rad * Math.cos(a) };
    }

    ctx.save();

    // Faint rings
    for (var m = 1; m <= modN; m++) {
      ctx.beginPath(); ctx.arc(cx, cy, radius(m), 0, 2 * Math.PI);
      ctx.strokeStyle = document.body.classList.contains('dark-mode') ? '#2a1a4a' : '#d0c8e8';
      ctx.lineWidth = m === modN ? 1.0 : 0.3;
      ctx.globalAlpha = m === modN ? 0.7 : 0.15;
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // GCD=1 points — cache for inspect hit-test
    _rzPtCache = [];
    var pts = buildCoprime(modN);
    pts.forEach(function(p) {
      var xy = ptXY(p.r, p.m);
      _rzPtCache.push({ x: xy.x, y: xy.y, r: p.r, m: p.m, gcd1: true });
      ctx.beginPath(); ctx.arc(xy.x, xy.y, Math.max(0.8, W * 0.003 * (1 - 0.4 * p.m / modN)), 0, 2 * Math.PI);
      ctx.fillStyle = '#4a90d9'; ctx.globalAlpha = 0.7; ctx.fill();
    });
    ctx.globalAlpha = 1;

    // Critical axis line — now horizontal (0°/180°) after the +90° offset
    if (showAxis) {
      var a0  = angOff,            a180 = Math.PI + angOff;
      var ax1 = cx + rMax * Math.sin(a0),   ay1 = cy - rMax * Math.cos(a0);
      var ax2 = cx + rMax * Math.sin(a180), ay2 = cy - rMax * Math.cos(a180);
      ctx.beginPath(); ctx.moveTo(ax1, ay1); ctx.lineTo(ax2, ay2);
      ctx.strokeStyle = '#a855f7'; ctx.lineWidth = 1.2;
      ctx.globalAlpha = 0.45; ctx.setLineDash([5, 5]); ctx.stroke();
      ctx.setLineDash([]); ctx.globalAlpha = 1;
      ctx.font = Math.max(9, W * 0.015) + 'px Cinzel, serif';
      ctx.fillStyle = '#a855f7'; ctx.globalAlpha = 0.55;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('Re(s) = ½', cx + rMax * 0.72 * Math.sin(a0), cy - rMax * 0.72 * Math.cos(a0) - 11);
      ctx.globalAlpha = 1;
    }

    // ── Riemann zeros: radial by tₙ / modN, auto-capped to fit ───────────────
    // Scale: tₙ = modN lands exactly at outer ring rMax.
    // Auto-cap: compute minimum pixel gap between consecutive zeros and skip
    // any zeros that would be closer than MIN_PX to the previous one.
    var MIN_PX = showLbl ? Math.max(10, W * 0.022) : Math.max(4, W * 0.009);
    var nRequest = Math.min(nZeros, RZ_ZEROS.length);
    // Collect zeros that fit within rMax (tₙ ≤ modN) and that don't overlap
    var shownZeros = [];
    var prevR = -Infinity;
    for (var i = 0; i < nRequest; i++) {
      var t = RZ_ZEROS[i];
      var r = rMin + (rMax - rMin) * (t / modN);
      if (r > rMax) break;                    // beyond outer ring — stop
      if (r - prevR < MIN_PX) continue;       // too close to previous — skip
      shownZeros.push({ t: t, r: r, idx: i });
      prevR = r;
    }

    // Draw ticks + labels on critical axis (0° side = right, and 180° = left)
    shownZeros.forEach(function(z, si) {
      [0, 1].forEach(function(pole) {  // 0 = right side (0°), 1 = left side (180°)
        var a = pole * Math.PI + angOff;
        var x = cx + z.r * Math.sin(a);
        var y = cy - z.r * Math.cos(a);
        // perpendicular tick
        var tk = Math.max(3, W * 0.009);
        var perp = a + Math.PI / 2;
        ctx.beginPath();
        ctx.moveTo(x - tk * Math.sin(perp), y + tk * Math.cos(perp));
        ctx.lineTo(x + tk * Math.sin(perp), y - tk * Math.cos(perp));
        ctx.strokeStyle = '#e879f9'; ctx.lineWidth = 1.4; ctx.globalAlpha = 0.88; ctx.stroke();
        ctx.beginPath(); ctx.arc(x, y, Math.max(1.8, W * 0.003), 0, 2 * Math.PI);
        ctx.fillStyle = '#e879f9'; ctx.globalAlpha = 1; ctx.fill();
      });

      // Labels on right side (pole 0) only
      if (showLbl) {
        var a = angOff;  // 0° direction
        var x = cx + z.r * Math.sin(a);
        var y = cy - z.r * Math.cos(a);
        var lsize = Math.max(7, W * 0.013);
        ctx.font = lsize + 'px monospace';
        ctx.fillStyle = '#ffd700'; ctx.globalAlpha = 0.85;
        ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
        ctx.fillText('γ' + (z.idx + 1) + '=' + z.t.toFixed(2), x + W * 0.014, y - lsize * 0.6);
      }
      // Cache zero tick positions (use right-side pole, a=angOff)
      var zx = cx + z.r * Math.sin(angOff);
      var zy = cy - z.r * Math.cos(angOff);
      _rzZeroCache.push({ x: zx, y: zy, t: z.t, idx: z.idx, r_px: z.r });
    });
    ctx.globalAlpha = 1;

    // Scale legend: outer ring = modN
    ctx.font = Math.max(9, W * 0.014) + 'px Cinzel, serif';
    ctx.fillStyle = canvasText(); ctx.globalAlpha = 0.55; ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';
    ctx.fillText('mod 1…' + modN + '  ·  zeros shown: ' + shownZeros.length + '  ·  outer ring = t = ' + modN, cx, H - 8);
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // ── DFT spectrum canvas ────────────────────────────────────────────────────
  // ── Farey discrepancy vs RH bound ────────────────────────────────────────
  // ── DFT bar chart (original) ──────────────────────────────────────────────
  var _rzDFTHitData = [];   // [{xPx, k, mag, normMag}] for hover inspect
  var _rzDFTZeroHits = [];  // [{xPx, n, t, freq}] zero line positions

  function rzDrawDFT() {
    var c = document.getElementById('rz-dft-canvas');
    if (!c) return;
    var ctx = c.getContext('2d');
    var W = c.width, H = c.height;
    ctx.clearRect(0, 0, W, H);
    var isDark = document.body.classList.contains('dark-mode');

    var modN = parseInt(document.getElementById('rz-mod').value) || 49;
    var pts = buildCoprime(modN);
    if (pts.length < 4) return;

    var N = 512;
    var bins = new Float64Array(N);
    pts.forEach(function(p) {
      var angle = (p.r / p.m) % 1;
      bins[Math.floor(angle * N) % N] += 1;
    });

    var maxFreq = 80;
    var mag = new Float64Array(maxFreq);
    for (var k = 1; k <= maxFreq; k++) {
      var re = 0, im = 0;
      for (var n = 0; n < N; n++) {
        var theta = 2 * Math.PI * k * n / N;
        re += bins[n] * Math.cos(theta);
        im -= bins[n] * Math.sin(theta);
      }
      mag[k - 1] = Math.sqrt(re * re + im * im);
    }
    var maxMag = 0;
    for (var k = 0; k < maxFreq; k++) if (mag[k] > maxMag) maxMag = mag[k];

    var padL = 52, padR = 24, padT = 28, padB = 36;
    var plotW = W - padL - padR, plotH = H - padT - padB;
    var barW = plotW / maxFreq;

    // grid
    ctx.strokeStyle = isDark ? '#1a0828' : '#e0d8f0'; ctx.lineWidth = 0.5;
    for (var g = 0; g <= 4; g++) {
      var gy = padT + plotH * (1 - g / 4);
      ctx.beginPath(); ctx.moveTo(padL, gy); ctx.lineTo(padL + plotW, gy); ctx.stroke();
      ctx.fillStyle = isDark ? '#6a5080' : '#554070'; ctx.font = '9px monospace';
      ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
      var gv = maxMag * g / 4;
      ctx.fillText(gv.toFixed(0), padL - 4, padT + plotH * (1 - g/4));
    }

    // axes
    ctx.strokeStyle = isDark ? '#4a2a6a' : '#b090d0'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padL, padT); ctx.lineTo(padL, padT + plotH);
    ctx.moveTo(padL, padT + plotH); ctx.lineTo(padL + plotW, padT + plotH);
    ctx.stroke();

    // bars — store hit data
    _rzDFTHitData = [];
    for (var k = 0; k < maxFreq; k++) {
      var bh = (mag[k] / maxMag) * plotH;
      var bx = padL + k * barW;
      var by = padT + plotH - bh;
      var intensity = mag[k] / maxMag;
      ctx.fillStyle = 'rgba(' + Math.round(80 + 168*intensity) + ',' + Math.round(10*intensity) + ',' + Math.round(100 + 155*intensity) + ',0.9)';
      ctx.fillRect(bx, by, Math.max(1, barW - 0.8), bh);
      _rzDFTHitData.push({ xPx: bx + barW/2, k: k+1, mag: mag[k], normMag: intensity });
    }

    // Zero prediction lines
    var nShow = Math.min(parseInt(document.getElementById('rz-nzeros').value) || 20, RZ_ZEROS.length);
    _rzDFTZeroHits = [];
    RZ_ZEROS.slice(0, nShow).forEach(function(t, i) {
      var freq = t / (2 * Math.PI);
      var xPos = padL + (freq / maxFreq) * plotW;
      if (xPos < padL || xPos > padL + plotW) return;
      ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 1;
      ctx.globalAlpha = 0.55; ctx.setLineDash([3, 4]);
      ctx.beginPath(); ctx.moveTo(xPos, padT); ctx.lineTo(xPos, padT + plotH); ctx.stroke();
      ctx.setLineDash([]); ctx.globalAlpha = 1;
      ctx.font = '9px monospace'; ctx.fillStyle = '#ffd700';
      ctx.globalAlpha = 0.75; ctx.textAlign = 'center';
      ctx.fillText('γ' + (i+1), xPos, padT + 10);
      ctx.globalAlpha = 1;
      _rzDFTZeroHits.push({ xPx: xPos, n: i+1, t: t, freq: freq });
    });

    // x-axis labels
    ctx.fillStyle = isDark ? '#6a5080' : '#443060'; ctx.font = '9px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    for (var k = 10; k <= maxFreq; k += 10) {
      var tx = padL + (k - 1) * barW + barW/2;
      ctx.fillText(k, tx, padT + plotH + 4);
    }
    ctx.fillStyle = '#9a8060'; ctx.font = '10px Cinzel,serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
    ctx.fillText('DFT frequency k  (γ lines at k = tₙ/2π)', padL + plotW/2, H - 4);
    ctx.textAlign = 'right';
    ctx.fillText('|A_k|', padL - 4, padT + 8);
  }

  // ── Farey discrepancy vs RH bound ─────────────────────────────────────────
  var _rzDiscHitData = []; // [{xPx, N, D, rhB, trivB}]

  function rzDrawSpectrum() {
    var c = document.getElementById('rz-spectrum-canvas');
    if (!c) return;
    var ctx = c.getContext('2d');
    var W = c.width, H = c.height;
    ctx.clearRect(0, 0, W, H);

    var modNMax = parseInt(document.getElementById('rz-mod').value) || 49;
    var nZeros  = Math.min(parseInt(document.getElementById('rz-nzeros').value) || 20, RZ_ZEROS.length);
    var isDark  = document.body.classList.contains('dark-mode');

    // Compute Farey discrepancy D_N for N = 2..modNMax
    // D_N = max_x |#{r/m in F_N : r/m <= x} / |F_N| - x|
    // Approximated by sampling x at each Farey fraction and checking gap uniformity.
    // Classical result: D_N <= 3/(N+2) (trivial) and under RH: O(N^{-1/2} log N / (2pi))
    var Nvals = [], discVals = [], rhBound = [], trivBound = [];
    _rzDiscHitData = [];
    var step = Math.max(1, Math.floor(modNMax / 120));  // ~120 data points max
    for (var N = 2; N <= modNMax; N += step) {
      // Build sorted Farey fractions for F_N (just r/m values as floats)
      var fracs = [];
      for (var m = 1; m <= N; m++) {
        for (var r = 0; r <= m; r++) {
          var g = (r === 0) ? m : gcd(r, m);
          if (g === 1) fracs.push(r / m);
        }
      }
      fracs.sort(function(a,b){ return a-b; });
      var fn = fracs.length;
      // Discrepancy: max |rank/|F_N| - value|
      var D = 0;
      for (var j = 0; j < fn; j++) {
        var dev = Math.abs((j + 1) / fn - fracs[j]);
        if (dev > D) D = dev;
      }
      var logN = Math.log(N);
      var _rh  = logN / (2 * Math.PI * Math.sqrt(N));
      var _triv = 3 / (N + 2);
      Nvals.push(N);
      discVals.push(D);
      rhBound.push(_rh);
      trivBound.push(_triv);
      _rzDiscHitData.push({ N: N, D: D, rhB: _rh, trivB: _triv });
    }

    var padL = 58, padR = 24, padT = 30, padB = 44;
    var plotW = W - padL - padR, plotH = H - padT - padB;

    // y-range: max of all values
    var allVals = discVals.concat(rhBound).concat(trivBound);
    var yMax = 0; allVals.forEach(function(v){ if(v>yMax) yMax=v; });
    yMax *= 1.12;

    function xPx(N)  { return padL + (N - 2) / Math.max(modNMax - 2, 1) * plotW; }
    function yPx(v)  { return padT + plotH * (1 - v / yMax); }
    // Store xPx into hit data
    _rzDiscHitData.forEach(function(d){ d.xPx = xPx(d.N); });

    // Grid
    ctx.strokeStyle = isDark ? '#1a0828' : '#e8e0f0'; ctx.lineWidth = 0.5;
    for (var g = 0; g <= 4; g++) {
      var gy = padT + plotH * g / 4;
      ctx.beginPath(); ctx.moveTo(padL, gy); ctx.lineTo(padL + plotW, gy); ctx.stroke();
      var gv = yMax * (1 - g / 4);
      ctx.fillStyle = isDark ? '#6a5080' : '#554070'; ctx.font = '9px monospace';
      ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
      ctx.fillText(gv.toFixed(4), padL - 4, gy);
    }

    // Axes
    ctx.strokeStyle = isDark ? '#4a2a6a' : '#b090d0'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padL, padT); ctx.lineTo(padL, padT + plotH);
    ctx.moveTo(padL, padT + plotH); ctx.lineTo(padL + plotW, padT + plotH);
    ctx.stroke();

    // Trivial bound (grey dashed)
    ctx.strokeStyle = isDark ? '#4a4060' : '#aaa0c0'; ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    Nvals.forEach(function(N, i){
      var px = xPx(N), py = yPx(trivBound[i]);
      i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
    });
    ctx.stroke(); ctx.setLineDash([]);

    // RH envelope (gold)
    ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 1.5;
    ctx.setLineDash([6, 3]);
    ctx.beginPath();
    Nvals.forEach(function(N, i){
      var px = xPx(N), py = yPx(rhBound[i]);
      i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
    });
    ctx.stroke(); ctx.setLineDash([]);

    // Actual discrepancy (purple filled area)
    ctx.beginPath();
    Nvals.forEach(function(N, i){
      var px = xPx(N), py = yPx(discVals[i]);
      i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
    });
    ctx.lineTo(xPx(Nvals[Nvals.length-1]), padT+plotH);
    ctx.lineTo(xPx(Nvals[0]), padT+plotH);
    ctx.closePath();
    ctx.fillStyle = 'rgba(168,85,247,0.18)'; ctx.fill();

    ctx.strokeStyle = '#a855f7'; ctx.lineWidth = 2;
    ctx.beginPath();
    Nvals.forEach(function(N, i){
      var px = xPx(N), py = yPx(discVals[i]);
      i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
    });
    ctx.stroke();

    // Riemann zero markers on x-axis: mark N = floor(tₙ) where tₙ ≤ modNMax
    var shownPeaks = [];
    for (var zi = 0; zi < nZeros; zi++) {
      var t = RZ_ZEROS[zi];
      if (t > modNMax) break;
      var px = xPx(t);
      ctx.strokeStyle = '#e879f9'; ctx.lineWidth = 1; ctx.globalAlpha = 0.6;
      ctx.setLineDash([2,4]);
      ctx.beginPath(); ctx.moveTo(px, padT); ctx.lineTo(px, padT+plotH); ctx.stroke();
      ctx.setLineDash([]); ctx.globalAlpha = 1;
      // tick on axis
      ctx.beginPath(); ctx.moveTo(px, padT+plotH); ctx.lineTo(px, padT+plotH+5);
      ctx.strokeStyle='#e879f9'; ctx.lineWidth=1.2; ctx.stroke();
      if (zi < 15) {
        ctx.font='8px monospace'; ctx.fillStyle='#e879f9'; ctx.globalAlpha=0.8;
        ctx.textAlign='center'; ctx.textBaseline='top';
        ctx.fillText('γ'+(zi+1), px, padT+plotH+7);
        ctx.globalAlpha=1;
      }
      shownPeaks.push({ n: zi+1, t: t });
    }

    // Legend
    ctx.font = '10px Cinzel, serif'; ctx.textAlign='left'; ctx.textBaseline='alphabetic';
    var ly = padT + 14;
    [['— D_N (Farey discrepancy)','#a855f7'],
     ['-- log N / (2π√N)  RH bound','#ffd700'],
     ['-- 3/(N+2)  trivial bound', isDark?'#4a4060':'#aaa0c0'],
     ['γₙ = Riemann zero heights','#e879f9']].forEach(function(row){
      ctx.fillStyle=row[1]; ctx.globalAlpha=0.85; ctx.fillText(row[0], padL+8, ly); ly+=14;
    });
    ctx.globalAlpha=1;

    // Axis labels
    ctx.fillStyle='#9a8060'; ctx.font='10px Cinzel,serif'; ctx.textAlign='center'; ctx.globalAlpha=0.8;
    ctx.textBaseline='alphabetic';
    ctx.fillText('mod N  (Farey sequence F_N)', padL+plotW/2, H-6);
    ctx.save(); ctx.translate(12, padT+plotH/2); ctx.rotate(-Math.PI/2);
    ctx.textAlign='center'; ctx.fillText('D_N', 0, 0); ctx.restore();
    ctx.globalAlpha=1;

    return shownPeaks;
  }
  // ── DFT legend ─────────────────────────────────────────────────────────────
  function rzUpdateLegend(peakInfo) {
    var el = document.getElementById('rz-dft-legend');
    if (!el || !peakInfo) return;
    var modN = parseInt(document.getElementById('rz-mod').value) || 49;
    var inRange = peakInfo.filter(function(p){ return p.t <= modN; });
    if (inRange.length === 0) {
      el.innerHTML = '<span style="color:#888;">No zero heights ≤ mod N = ' + modN + '.  Increase mod N to see zeros on the discrepancy axis.</span>';
      return;
    }
    var parts = inRange.map(function(p) {
      return '<span style="color:#e879f9;">γ' + p.n + '</span> = ' + p.t.toFixed(3);
    });
    el.innerHTML = '<strong style="color:#ffd700;">Riemann zeros within mod N=' + modN + '</strong>:<br>' + parts.join(' &nbsp;·&nbsp; ')
      + '<br><span style="color:#9a8060;font-size:0.85em;">These are the imaginary parts of the non-trivial zeros of ζ(s) that fall within the current Farey circle. '
      + 'Under RH the discrepancy D_N stays below the gold envelope at each N.</span>';
  }

  // ── Zero heights table ────────────────────────────────────────────────────
  function rzBuildTable() {
    var tbody = document.querySelector('#rz-zeros-table');
    if (!tbody) return;
    var modN   = parseInt(document.getElementById('rz-mod').value) || 49;
    var nZeros = Math.min(parseInt(document.getElementById('rz-nzeros').value) || 20, RZ_ZEROS.length);
    var html = '<thead><tr>'
      + '<th style="text-align:right;">n</th>'
      + '<th style="text-align:right;">t&#8319;</th>'
      + '<th style="text-align:right;">t&#8319; / N &nbsp;<span style="color:#9a8060;font-weight:normal;">(radial depth)</span></th>'
      + '<th style="text-align:right;">&Delta;t</th>'
      + '<th style="text-align:center;">In circle?</th>'
      + '</tr></thead><tbody>';
    for (var i = 0; i < nZeros; i++) {
      var t = RZ_ZEROS[i];
      var delta = i > 0 ? (t - RZ_ZEROS[i-1]).toFixed(4) : '—';
      var frac  = (t / modN).toFixed(4);
      var inCircle = t <= modN;
      html += '<tr>'
        + '<td style="text-align:right;color:#9a8060;">' + (i+1) + '</td>'
        + '<td style="text-align:right;color:#e879f9;">' + t.toFixed(6) + '</td>'
        + '<td style="text-align:right;color:#ffd700;">' + frac + '</td>'
        + '<td style="text-align:right;color:#4ecdc4;">' + delta + '</td>'
        + '<td style="text-align:center;">' + (inCircle ? '<span style="color:#a8e6cf;">&#10003;</span>' : '<span style="color:#888;">—</span>') + '</td>'
        + '</tr>';
    }
    html += '</tbody>';
    tbody.innerHTML = html;
  }

  // ── Inspect state & hit-cache ─────────────────────────────────────────────
  var _rzInspect   = false;
  var _rzPtCache   = [];   // [{x,y,r,m,gcd1}]  — Farey points
  var _rzZeroCache = [];   // [{x,y,t,idx,r_px}] — zero tick positions

  window.rzToggleInspect = function() {
    _rzInspect = !_rzInspect;
    var btn = document.getElementById('rz-inspect-btn');
    var c   = document.getElementById('rz-circle-canvas');
    var lbl = document.getElementById('rz-canvas-label');
    if (_rzInspect) {
      if (btn) { btn.style.background = '#a855f7'; btn.style.color = 'var(--parchment)'; }
      if (c)   c.style.cursor = 'crosshair';
      if (lbl) lbl.innerHTML = 'Inspect mode · click a Farey point or zero tick &nbsp;·&nbsp; <span style="color:#ffd700;">click again to exit</span>';
    } else {
      if (btn) { btn.style.background = 'var(--parchment-dark)'; btn.style.color = '#a855f7'; }
      if (c)   c.style.cursor = 'pointer';
      if (lbl) lbl.innerHTML = 'GCD=1 Farey points (mod N) · Purple = critical axis Re(s)=½ · Pink = zero heights t&#8319; &nbsp;·&nbsp; <span style="color:#888;">Click to rotate · or use Inspect</span>';
      var tt = document.getElementById('rz-tooltip'); if (tt) tt.style.display = 'none';
    }
  };

  // ── Master draw ────────────────────────────────────────────────────────────
  window.rzDraw = function() {
    var showDFT  = document.getElementById('rz-show-dft').checked;
    var showDisc = (document.getElementById('rz-show-disc')||{checked:true}).checked;

    var dftWrap  = document.getElementById('rz-dft-wrap');
    var discWrap = document.getElementById('rz-disc-wrap');
    if (dftWrap)  dftWrap.style.display  = showDFT  ? 'block' : 'none';
    if (discWrap) discWrap.style.display = showDisc ? 'block' : 'none';

    if (showDFT)  rzDrawDFT();
    if (showDisc) {
      var peakInfo = rzDrawSpectrum();
      rzUpdateLegend(peakInfo);
    }
    rzBuildTable();
  };

  // ── Exports ────────────────────────────────────────────────────────────────
  window.rzExportPNG = function() {
    var circle = document.getElementById('rz-circle-canvas');
    var spec   = document.getElementById('rz-spectrum-canvas');
    var modN   = parseInt(document.getElementById('rz-mod').value) || 49;
    var CW = circle.width, CH = circle.height;
    var SW = spec.width,   SH = spec.height;
    var PAD = 20;
    var off = document.createElement('canvas');
    off.width  = Math.max(CW, SW) + PAD * 2;
    off.height = CH + SH + PAD * 3;
    var ctx = off.getContext('2d');
    ctx.fillStyle = window.canvasBg ? window.canvasBg() : '#06040e'; ctx.fillRect(0, 0, off.width, off.height);
    var circleX = (off.width - CW) / 2;
    ctx.drawImage(circle, circleX, PAD, CW, CH);
    var specX  = (off.width - SW) / 2;
    ctx.drawImage(spec, specX, PAD + CH + PAD, SW, SH);
    ctx.font = '13px Cinzel, serif'; ctx.fillStyle = '#a855f7';
    ctx.textAlign = 'center';
    ctx.fillText('Riemann Zero Heights on Critical Axis · mod ' + modN, off.width / 2, off.height - 6);
    var a = document.createElement('a');
    a.download = 'riemann_zeros_mod' + modN + '.png';
    a.href = off.toDataURL('image/png'); a.click();
  };

  window.rzExportDOM = function() {
    var section = document.getElementById('riemannZerosSection');
    if (!section) return;
    if (typeof html2canvas !== 'function') { alert('html2canvas not available'); return; }
    var modN = parseInt(document.getElementById('rz-mod').value) || 49;
    html2canvas(section, {
      scale: 2,
      backgroundColor: document.body.classList.contains('dark-mode') ? '#06040e' : '#f5f0e8',
      useCORS: true,
      logging: false
    }).then(function(canvas) {
      var a = document.createElement('a');
      a.download = 'riemann_zeros_dom_mod' + modN + '.png';
      a.href = canvas.toDataURL('image/png');
      a.click();
    });
  };

  window.rzExportCSV = function() {
    var modN = parseInt(document.getElementById('rz-mod').value) || 49;
    var tMax = RZ_ZEROS[RZ_ZEROS.length - 1];
    var csv = 'Riemann Zero Heights and Farey DFT Analysis\n';
    csv += 'mod N,' + modN + '\n\n';
    csv += 'n,t_n,t_n/t_30,DFT_freq_k,delta_t\n';
    RZ_ZEROS.forEach(function(t, i) {
      var delta = i > 0 ? (t - RZ_ZEROS[i - 1]).toFixed(6) : '';
      csv += (i+1) + ',' + t.toFixed(6) + ',' + (t/tMax).toFixed(8) + ',' + (t/(2*Math.PI)).toFixed(6) + ',' + delta + '\n';
    });
    var a = document.createElement('a');
    a.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);
    a.download = 'riemann_zeros_dft_mod' + modN + '.csv';
    a.click();
  };

  // ── Click to rotate circle ──────────────────────────────────────────────────
  // ── Hover inspect: DFT bar chart ──────────────────────────────────────────
  function rzAttachDFTHover() {
    var c = document.getElementById('rz-dft-canvas');
    var tt = document.getElementById('rz-dft-tooltip');
    if (!c || !tt) return;
    c.addEventListener('mousemove', function(e) {
      var rect = c.getBoundingClientRect();
      var mx = (e.clientX - rect.left) * (c.width / c.offsetWidth);
      // find nearest bar
      var best = null, bestD = Infinity;
      _rzDFTHitData.forEach(function(b) {
        var d = Math.abs(b.xPx - mx);
        if (d < bestD) { bestD = d; best = b; }
      });
      // also check zero lines
      var bestZ = null, bestZD = Infinity;
      _rzDFTZeroHits.forEach(function(z) {
        var d = Math.abs(z.xPx - mx);
        if (d < bestZD) { bestZD = d; bestZ = z; }
      });
      var barW = c.width / 80;
      if (bestD < barW && best) {
        var html = '<span style="color:#a855f7;">k = ' + best.k + '</span>'
          + '  |A<sub>' + best.k + '</sub>| = <span style="color:#e879f9;">' + best.mag.toFixed(1) + '</span>'
          + '  (' + (best.normMag * 100).toFixed(1) + '% of max)';
        if (bestZ && bestZD < barW * 3) {
          html += '<br><span style="color:#ffd700;">Near γ' + bestZ.n + ' = ' + bestZ.t.toFixed(3) + '  (k≈' + bestZ.freq.toFixed(2) + ')</span>';
        }
        tt.innerHTML = html;
        tt.style.left = (e.clientX - c.getBoundingClientRect().left + 12) + 'px';
        tt.style.top  = (e.clientY - c.getBoundingClientRect().top  - 18) + 'px';
        tt.style.display = 'block';
      } else if (bestZD < barW * 2 && bestZ) {
        tt.innerHTML = '<span style="color:#ffd700;">γ' + bestZ.n + ' = t = ' + bestZ.t.toFixed(4) + '</span>'
          + '<br>Predicted DFT peak at k ≈ ' + bestZ.freq.toFixed(3);
        tt.style.left = (e.clientX - c.getBoundingClientRect().left + 12) + 'px';
        tt.style.top  = (e.clientY - c.getBoundingClientRect().top  - 18) + 'px';
        tt.style.display = 'block';
      } else {
        tt.style.display = 'none';
      }
    });
    c.addEventListener('mouseleave', function() { if(tt) tt.style.display='none'; });
  }

  // ── Hover inspect: Discrepancy panel ──────────────────────────────────────
  function rzAttachDiscHover() {
    var c = document.getElementById('rz-spectrum-canvas');
    var tt = document.getElementById('rz-disc-tooltip');
    if (!c || !tt) return;
    c.addEventListener('mousemove', function(e) {
      var rect = c.getBoundingClientRect();
      var mx = (e.clientX - rect.left) * (c.width / c.offsetWidth);
      if (!_rzDiscHitData.length) { tt.style.display='none'; return; }
      var best = null, bestD = Infinity;
      _rzDiscHitData.forEach(function(d) {
        var dd = Math.abs(d.xPx - mx);
        if (dd < bestD) { bestD = dd; best = d; }
      });
      var modNMax = parseInt(document.getElementById('rz-mod').value) || 49;
      var step = c.width / Math.max(modNMax, 1) * 1.2;
      if (best && bestD < Math.max(step, 8)) {
        var underRH = best.D <= best.rhB;
        html = 'N = <span style="color:#a855f7;">' + best.N + '</span>'
          + '  D<sub>N</sub> = <span style="color:#a855f7;">' + best.D.toFixed(5) + '</span>'
          + '<br>RH bound = <span style="color:#ffd700;">' + best.rhB.toFixed(5) + '</span>'
          + '  trivial = <span style="color:#888;">' + best.trivB.toFixed(5) + '</span>'
          + '<br>' + (underRH
            ? '<span style="color:#a8e6cf;">✓ D_N ≤ RH bound</span>'
            : '<span style="color:#ff6b6b;">✗ D_N > RH bound</span>');
        tt.innerHTML = html;
        tt.style.left = (e.clientX - rect.left + 12) + 'px';
        tt.style.top  = (e.clientY - rect.top  - 18) + 'px';
        tt.style.display = 'block';
      } else {
        tt.style.display = 'none';
      }
    });
    c.addEventListener('mouseleave', function() { if(tt) tt.style.display='none'; });
  }

  document.addEventListener('DOMContentLoaded', function() {
    var circ = document.getElementById('rz-circle-canvas');
    if (circ) circ.addEventListener('click', function(e) {
      if (!_rzInspect) {
        // rotate mode
        rzAngle = (rzAngle + 90) % 360; rzDraw(); return;
      }
      // ── Inspect: find nearest cached item ──────────────────────────────────
      var rect  = circ.getBoundingClientRect();
      var scale = circ.width / circ.offsetWidth;
      var mx = (e.clientX - rect.left) * scale;
      var my = (e.clientY - rect.top)  * scale;

      var bestDist = Infinity, bestPt = null, bestType = '';

      // Check Farey points
      _rzPtCache.forEach(function(p) {
        var d = Math.sqrt((p.x-mx)*(p.x-mx)+(p.y-my)*(p.y-my));
        if (d < bestDist) { bestDist = d; bestPt = p; bestType = 'farey'; }
      });
      // Check zero ticks (larger hit radius)
      _rzZeroCache.forEach(function(z) {
        var d = Math.sqrt((z.x-mx)*(z.x-mx)+(z.y-my)*(z.y-my));
        if (d < bestDist - 2) { bestDist = d; bestPt = z; bestType = 'zero'; }
      });

      var HIT_R = circ.width * 0.025;
      if (bestDist > HIT_R || !bestPt) return;

      // Build tooltip content
      var tt = document.getElementById('rz-tooltip');
      if (!tt) return;
      var modN = parseInt(document.getElementById('rz-mod').value) || 49;
      var html = '';

      if (bestType === 'farey') {
        var p = bestPt;
        var g = gcd(p.r, p.m);
        var phi = (function(n){ var r=n,m=n; for(var pp=2;pp*pp<=m;pp++){if(m%pp===0){r-=r/pp;while(m%pp===0)m/=pp;}}if(m>1)r-=r/m;return Math.round(r); })(p.m);
        var ang = (rzAngle+90)*Math.PI/180;
        var a   = 2*Math.PI*p.r/(p.m||1) + ang;
        var deg = ((a*180/Math.PI)%360+360)%360;
        var col = p.gcd1 ? '#4a90d9' : '#c94040';
        html = '<div style="color:'+col+';font-weight:bold;margin-bottom:5px;font-size:0.72rem;">'+p.r+'/'+p.m+'</div>'
          +'<div>r = <span style="color:'+col+'">'+p.r+'</span></div>'
          +'<div>m = <span style="color:'+col+'">'+p.m+'</span></div>'
          +'<div>gcd = <span style="color:'+col+'">'+g+'</span></div>'
          +'<div style="border-top:1px solid rgba(168,85,247,0.2);margin:5px 0;"></div>'
          +'<div>angle = '+deg.toFixed(2)+'°</div>'
          +'<div>decimal = '+(p.r/p.m).toFixed(6)+'</div>'
          +'<div style="color:#9a8060;">φ('+p.m+') = '+phi+'</div>'
          +'<div style="color:#9a8060;">ring '+p.m+' of '+modN+'</div>';
      } else {
        var z = bestPt;
        var rFrac = (z.t / modN).toFixed(4);
        var delta = z.idx > 0 ? (z.t - RZ_ZEROS[z.idx-1]).toFixed(4) : '—';
        var nextT = z.idx+1 < RZ_ZEROS.length ? (RZ_ZEROS[z.idx+1]-z.t).toFixed(4) : '—';
        // nearest Farey fraction to t/modN on outer ring
        var target = z.t / modN;
        var nearestFarey = { r: 0, m: 1, dist: 1 };
        _rzPtCache.forEach(function(fp){
          if(fp.m !== modN) return;
          var fv = fp.r/fp.m;
          // angular position of this Farey point on outer ring
          var a0 = (rzAngle+90)*Math.PI/180;
          var fa = (2*Math.PI*fp.r/fp.m + a0)*180/Math.PI;
          var za = (0 + a0)*180/Math.PI; // zero is at angOff=0 direction
          var df = Math.abs(fp.r/fp.m - target); if(df>0.5)df=1-df;
          if(df < nearestFarey.dist){ nearestFarey={r:fp.r,m:fp.m,dist:df}; }
        });
        html = '<div style="color:#e879f9;font-weight:bold;margin-bottom:5px;font-size:0.72rem;">γ'+(z.idx+1)+'</div>'
          +'<div>t = <span style="color:#e879f9;">'+z.t.toFixed(6)+'</span></div>'
          +'<div>t/modN = <span style="color:#ffd700;">'+rFrac+'</span></div>'
          +'<div style="border-top:1px solid rgba(168,85,247,0.2);margin:5px 0;"></div>'
          +'<div>Δt prev = '+delta+'</div>'
          +'<div>Δt next = '+nextT+'</div>'
          +'<div style="color:#9a8060;">nearest outer: '+nearestFarey.r+'/'+nearestFarey.m+'</div>'
          +'<div style="color:#9a8060;">t/(2π) = '+(z.t/(2*Math.PI)).toFixed(4)+'</div>';
      }

      tt.innerHTML = html;
      // Position tooltip near click, keep in canvas bounds
      var cOffW = circ.offsetWidth, cOffH = circ.offsetHeight;
      var px = (mx / scale), py = (my / scale);
      var tw = 190, th = 175;
      var left = px + 14, top = py - th/2;
      if (left + tw > cOffW)  left = px - tw - 14;
      if (top < 0)            top = 4;
      if (top + th > cOffH)   top = cOffH - th - 4;
      tt.style.left = left+'px'; tt.style.top = top+'px';
      tt.style.display = 'block';
    });
    rzDraw();
    rzAttachDFTHover();
    rzAttachDiscHover();
  });

})();
</script>


<script>
// ════════════════════════════════════════════════════════════════════════════
// GAP → FAREY CANVAS OVERLAY  (fareyShowGapOverlay)
// Connects residue pairs (p mod N, m) <-> ((p+gap) mod N, m) on the
// combined canvas for all primes p in the chosen gap family that are
// ≤ current mod N.  Activates combined view + inspect labels automatically.
// ════════════════════════════════════════════════════════════════════════════
(function () {

  // State
  var _overlayGap    = null;   // currently overlaid gap number
  var _overlayPairs  = [];     // [{r1,r2,m,p}] pairs to draw
  var _overlayColor  = '#4a90d9';
  var _overlayGaps   = [];     // full gap list for multi-gap input
  var MAX_DISPLAY    = 200;    // max chord lines for performance
  // Expose to window so script 3 (makeFareyCanvas export) can read overlay state
  Object.defineProperty(window, '_overlayGap',   { get: function(){ return _overlayGap; } });
  Object.defineProperty(window, '_overlayColor', { get: function(){ return _overlayColor; } });
  Object.defineProperty(window, '_overlayPairs', { get: function(){ return _overlayPairs; } });

  // Gap → colour palette matching decomposition charts
  var GAP_COLORS = {
    1: '#ff6b6b', 2: '#4ecdc4', 4: '#45b7d1', 6: '#96ceb4',
    8: '#ffeaa7', 10: '#dfe6e9', 12: '#fd79a8', 14: '#a29bfe',
    16: '#6c5ce7', 18: '#00b894', 20: '#fdcb6e', 22: '#e17055',
    24: '#74b9ff', 26: '#55efc4', 28: '#fab1a0', 30: '#81ecec'
  };

  // ── Public entry point ───────────────────────────────────────────────────
  window.fareyShowGapOverlay = function (gap) {
    gap = parseInt(gap);
    if (!window.analysisResults) {
      alert('Run analysis first to load prime gap data.');
      return;
    }

    var gapData = window.analysisResults.gapProducts && window.analysisResults.gapProducts[gap];
    if (!gapData || !gapData.primes || !gapData.primes.length) {
      alert('No primes found for gap ' + gap + ' in the current analysis.');
      return;
    }

    _overlayGap   = gap;
    _overlayGaps  = [gap];
    _overlayColor = GAP_COLORS[gap] || '#4a90d9';

    var modN = parseInt(document.getElementById('f-mod-num').value) || 49;

    // Build pairs: p mod modN  <->  (p+gap) mod modN
    // Only include pairs where both residues are coprime to modN
    function gcdLocal(a, b) { while (b) { var t = b; b = a % b; a = t; } return a; }

    _overlayPairs = [];
    var inRange = 0;
    gapData.primes.forEach(function (p) {
      if (p > modN) return; // only primes ≤ modN fit on the outer ring
      inRange++;
      var r1 = ((p % modN) + modN) % modN;
      var r2 = (((p + gap) % modN) + modN) % modN;
      if (r1 === 0 || r2 === 0) return;
      if (gcdLocal(r1, modN) !== 1 || gcdLocal(r2, modN) !== 1) return;
      _overlayPairs.push({ r1: r1, r2: r2, m: modN, p: p });
    });

    // ── Activate combined view + open panel + turn on labels ──────────────
    var panel = document.getElementById('farey-panel');
    var splitV = document.getElementById('farey-split-view');
    var combV  = document.getElementById('farey-combined-view');
    if (panel && panel.style.display === 'none') {
      panel.style.display = 'block';
      if (splitV) splitV.style.display = 'none';
      if (combV)  combV.style.display  = 'block';
    }
    // Ensure combined view is showing
    if (combV) combV.style.display = 'block';
    if (splitV) splitV.style.display = 'none';

    // Turn on label mode = r
    var labelSel = document.getElementById('f-label');
    if (labelSel) labelSel.value = 'r';

    // Turn on inspect mode
    if (typeof window.fareyToggleInspect === 'function' && !window._inspectMode) {
      window.fareyToggleInspect();
    }

    // Redraw — drawCombined will call our overlay hook
    if (typeof window.fareyRedraw === 'function') window.fareyRedraw();

    // Scroll to Farey tool
    var root = document.getElementById('farey-root');
    if (root) root.scrollIntoView({ behavior: 'smooth', block: 'start' });

    // Update stats bar
    updateOverlayBar(gap, gapData, modN, _overlayPairs.length, inRange);
  };

  // ── Clear overlay ─────────────────────────────────────────────────────────
  // ── Gap input quick-apply ────────────────────────────────────────────────
  window.fareyGapInputApply = function() {
    var el     = document.getElementById('f-gap-input');
    var status = document.getElementById('f-gap-input-status');
    if (!el) return;
    var raw = el.value.trim();
    if (!raw) { window.fareyGapOverlayClear(); return; }
    if (!window.analysisResults) {
      if (status) status.textContent = 'Run analysis first.';
      return;
    }
    var gaps = raw.split(/[,\s]+/).map(function(s){ return parseInt(s.trim()); }).filter(function(n){ return !isNaN(n) && n > 0; });
    if (!gaps.length) {
      if (status) status.textContent = 'Enter gap e.g. 2 or 2,4,6';
      return;
    }
    // Single gap — delegate directly to the working handler
    if (gaps.length === 1) {
      window.fareyShowGapOverlay(gaps[0]);
      if (status) status.textContent = '';
      return;
    }
    // Multi-gap — merge pairs from all gaps using same logic as fareyShowGapOverlay
    function gcdL(a,b){ while(b){var t=b;b=a%b;a=t;} return a; }
    var modN   = parseInt(document.getElementById('f-mod-num').value) || 49;
    var allPairs = [];
    var missing  = [];
    var found    = [];
    gaps.forEach(function(gap) {
      var gd = window.analysisResults.gapProducts && window.analysisResults.gapProducts[gap];
      if (!gd || !gd.primes || !gd.primes.length) { missing.push(gap); return; }
      found.push(gap);
      var inRange = 0;
      gd.primes.forEach(function(p) {
        if (p > modN) return;
        inRange++;
        var r1 = ((p % modN) + modN) % modN;
        var r2 = (((p + gap) % modN) + modN) % modN;
        if (r1 === 0 || r2 === 0) return;
        if (gcdL(r1, modN) !== 1 || gcdL(r2, modN) !== 1) return;
        allPairs.push({ r1: r1, r2: r2, m: modN, p: p, gap: gap });
      });
    });
    if (!found.length) {
      if (status) status.textContent = 'Not found: ' + missing.join(', ');
      return;
    }
    _overlayGap   = gaps[0];
    _overlayGaps  = gaps;
    _overlayColor = GAP_COLORS[gaps[0]] || '#4a90d9';
    _overlayPairs = allPairs;
    // Switch to combined view
    var combV = document.getElementById('farey-combined-view');
    var splitV = document.getElementById('farey-split-view');
    if (combV)  combV.style.display  = 'block';
    if (splitV) splitV.style.display = 'none';
    var labelSel = document.getElementById('f-label');
    if (labelSel) labelSel.value = 'r';
    if (typeof window.fareyRedraw === 'function') window.fareyRedraw();
    var root = document.getElementById('farey-root');
    if (root) root.scrollIntoView({ behavior: 'smooth', block: 'start' });
    var gapData = (window.analysisResults.gapProducts && window.analysisResults.gapProducts[gaps[0]]) || { count: 0 };
    updateOverlayBar(gaps[0], gapData, modN, allPairs.length, allPairs.length);
    if (status) {
      status.textContent = missing.length
        ? 'Gaps ' + found.join(',') + ' · missing: ' + missing.join(',')
        : 'Gaps ' + gaps.join(', ') + ' · ' + allPairs.length + ' pairs';
    }
  };

  window.fareyGapOverlayClear = function () {
    _overlayGap   = null;
    _overlayPairs = [];
    _overlayGaps  = [];
    var bar = document.getElementById('farey-gap-overlay-bar');
    if (bar) bar.style.display = 'none';
    var ctrl = document.getElementById('farey-gap-overlay-controls');
    if (ctrl) ctrl.style.display = 'none';
    if (typeof window.fareyRedraw === 'function') window.fareyRedraw();
  };

  // ── Stats bar ─────────────────────────────────────────────────────────────
  function updateOverlayBar(gap, gapData, modN, shownPairs, inRange) {
    var ctrl = document.getElementById('farey-gap-overlay-controls');
    if(ctrl) ctrl.style.display = 'flex';
    var bar  = document.getElementById('farey-gap-overlay-bar');
    var info = document.getElementById('farey-gap-overlay-info');
    if (!bar || !info) return;

    var gapName = {1:'Gap 1',2:'Twin Primes',4:'Cousin Primes',6:'Sexy Primes'}[gap] || 'Gap '+gap;
    var total   = gapData.count;
    var pct     = total > 0 ? ((inRange / total) * 100).toFixed(1) : '0';

    info.innerHTML =
      '<strong style="color:' + _overlayColor + ';">' + gapName + '</strong>'
      + ' &nbsp;·&nbsp; '
      + '<strong style="color:#ffd700;">' + total.toLocaleString() + '</strong> primes in analysis range'
      + ' &nbsp;·&nbsp; '
      + '<strong style="color:#4ecdc4;">' + inRange.toLocaleString() + '</strong> primes ≤ mod ' + modN
      + ' (' + pct + '%)'
      + ' &nbsp;·&nbsp; '
      + '<strong style="color:#e879f9;">' + shownPairs + '</strong> residue pairs shown on canvas'
      + (function(){
          if(window.analysisResults && window.analysisResults.percentageContributions &&
             window.analysisResults.percentageContributions[gap] !== undefined){
            var _p = window.analysisResults.percentageContributions[gap];
            var _g = window.analysisResults.gapProducts[gap];
            return ' &nbsp;·&nbsp; P₂ = <strong style="color:#a8e6cf;">' + (_g?_g.product.toFixed(5):'?') + '</strong>'
                 + ' &nbsp;(<strong style="color:#ffd700;">' + _p.toFixed(2) + '%</strong> of log ζ(2))';
          } return '';
        })();

    bar.style.display = 'block';

    // ── Populate stats dropdown ──────────────────────────────────────────
    var statsPanel = document.getElementById('farey-gap-stats-panel');
    var statsContent = document.getElementById('farey-gap-stats-content');
    if (statsPanel && statsContent) {
      statsPanel.style.display = 'block';
      var lines = [];
      lines.push('<span style="color:#4a90d9;">Gap</span>: <strong>' + gapName + '</strong> &nbsp;·&nbsp; <span style="color:#4a90d9;">Mod N</span>: <strong>' + modN + '</strong>');
      lines.push('<span style="color:#4a90d9;">Primes in analysis</span>: <strong style="color:#ffd700;">' + total.toLocaleString() + '</strong>');
      lines.push('<span style="color:#4a90d9;">Primes ≤ mod N</span>: <strong style="color:#4ecdc4;">' + inRange.toLocaleString() + '</strong> (' + pct + '%)');
      lines.push('<span style="color:#4a90d9;">Residue pairs on canvas</span>: <strong style="color:#e879f9;">' + shownPairs + '</strong>');
      if (window.analysisResults && window.analysisResults.percentageContributions &&
          window.analysisResults.percentageContributions[gap] !== undefined) {
        var _p  = window.analysisResults.percentageContributions[gap];
        var _g  = window.analysisResults.gapProducts[gap];
        if (_g) {
          lines.push('<span style="color:#4a90d9;">Euler product P₂</span>: <strong style="color:#a8e6cf;">' + _g.product.toFixed(8) + '</strong>');
          lines.push('<span style="color:#4a90d9;">log P₂ / log ζ(2)</span>: <strong style="color:#ffd700;">' + _p.toFixed(4) + '%</strong>');
          if (_g.count) lines.push('<span style="color:#4a90d9;">Prime pairs counted</span>: <strong>' + _g.count.toLocaleString() + '</strong>');
        }
      }
      // List residue pairs
      var pairList = _overlayPairs.slice(0, 30).map(function(p){ return p.r1 + '→' + p.r2; }).join(', ');
      if (_overlayPairs.length > 30) pairList += ' … (+' + (_overlayPairs.length - 30) + ' more)';
      lines.push('<span style="color:#4a90d9;">Residue pairs (p mod N → (p+gap) mod N)</span>:<br><span style="color:#9a8060;font-size:0.58rem;line-height:1.6;">' + pairList + '</span>');
      statsContent.innerHTML = lines.join('<br>');
    }
  }

  // ── Hook into drawCombined via postDraw ───────────────────────────────────
  // We wrap the existing drawCombined to append our overlay after it draws.
  // This is safer than patching inside the IIFE.
  document.addEventListener('DOMContentLoaded', function () {
    // Poll until fareyRedraw exists, then patch drawCombined post-hook
    var attempts = 0;
    var poll = setInterval(function () {
      attempts++;
      if (typeof window.fareyRedraw === 'function') {
        clearInterval(poll);
        patchFareyDraw();
      }
      if (attempts > 100) clearInterval(poll);
    }, 50);
  });

  function patchFareyDraw() {
    var origRedraw = window.fareyRedraw;
    window.fareyRedraw = function () {
      origRedraw.apply(this, arguments);
      // After the main draw, overlay gap chords if active
      if (_overlayGap !== null && _overlayPairs.length > 0) {
        drawGapOverlay();
      }
      // After gap overlay, draw chain overlay
      if (window._chain && window._chain.length > 0) {
        var c = document.getElementById('fc-combined');
        if (c) drawChainOverlay(c.getContext('2d'), c.width);
      }
    };
  }

  // ── Core overlay drawing ──────────────────────────────────────────────────
  function drawGapOverlay(overrideCanvas) {
    var c = overrideCanvas || document.getElementById('fc-combined');
    if (!c) return;
    var ctx = c.getContext('2d');
    var W = c.width, H = c.height, cx = W / 2, cy = H / 2;

    var modN    = parseInt(document.getElementById('f-mod-num').value) || 49;
    var dir     = parseFloat(document.getElementById('f-dir').value) || 1;
    var angOff  = (_overlayGap !== null ? window._combinedAngle || 90 : 90) * Math.PI / 180;
    var spacing = (parseInt(document.getElementById('f-spacing').value) || 100) / 100;
    var zoom    = (parseInt(document.getElementById('f-zoom').value) || 100) / 100;
    var rinner  = (parseInt(document.getElementById('f-rinner').value) || 4) / 100;
    var invert  = document.getElementById('f-invert-order').checked;

    var rBase = W * 0.42 * spacing;
    if (rBase > W * 0.49) rBase = W * 0.49;
    var rMin = W * rinner * zoom;
    var rMax = rBase * zoom;

    function radius(m) {
      var t = invert ? (modN - m) / (modN - 1 || 1) : (m - 1) / (modN - 1 || 1);
      return rMin + (rMax - rMin) * t;
    }

    function ptXY(r, m) {
      // ringOffset from the main script — may not be accessible here, so use 0
      var ringOff = 0;
      if (typeof window.ringOffset === 'function') ringOff = window.ringOffset(m, modN);
      var a = dir * 2 * Math.PI * r / (m || 1) + angOff + ringOff * Math.PI / 180;
      var rad = radius(m);
      return { x: cx + rad * Math.sin(a), y: cy - rad * Math.cos(a) };
    }

    var pairs = _overlayPairs.slice(0, MAX_DISPLAY);
    var n = pairs.length;

    var overlayAlpha = (parseInt((document.getElementById('f-overlay-alpha')||{}).value)||80)/100;
    ctx.save();

    // ── Highlighted inward cross-mod paths for each gap pair ─────────────
    // Collect unique residues from all pairs
    var highlightR = {};
    pairs.forEach(function(pair){ highlightR[pair.r1] = true; highlightR[pair.r2] = true; });

    // Draw a glowing cross-mod line for each highlighted r, from modN down to ring 1
    Object.keys(highlightR).forEach(function(rKey){
      var r = parseInt(rKey);
      for(var mk = 1; mk < modN; mk++){
        var xyA = ptXY(r, mk);
        var xyB = ptXY(r, mk + 1);
        var t   = mk / modN; // 0=inner, 1=outer
        ctx.beginPath();
        ctx.moveTo(xyA.x, xyA.y);
        ctx.lineTo(xyB.x, xyB.y);
        ctx.strokeStyle = _overlayColor;
        ctx.lineWidth   = Math.max(0.8, W * 0.003 * t);
        ctx.globalAlpha = (0.25 + 0.55 * t) * overlayAlpha;
        ctx.stroke();
      }
      // Bright dot at the outermost ring (where the gap point lives)
      var xyOuter = ptXY(r, modN);
      ctx.beginPath();
      ctx.arc(xyOuter.x, xyOuter.y, Math.max(3, W * 0.007), 0, 2 * Math.PI);
      ctx.fillStyle   = _overlayColor;
      ctx.globalAlpha = 0.95;
      ctx.fill();
    });

    // ── Chord between r1 and r2 at outer ring (the gap) ──────────────────
    pairs.forEach(function (pair, i) {
      var xy1 = ptXY(pair.r1, pair.m);
      var xy2 = ptXY(pair.r2, pair.m);
      ctx.beginPath();
      ctx.moveTo(xy1.x, xy1.y);
      ctx.lineTo(xy2.x, xy2.y);
      ctx.strokeStyle = _overlayColor;
      ctx.lineWidth   = Math.max(1, W * 0.002);
      ctx.globalAlpha = (0.55 + 0.3 * (i / Math.max(n - 1, 1))) * overlayAlpha;
      ctx.stroke();

      // Label prime value near r1 for first 20
      if (i < 20) {
        ctx.font = Math.max(8, W * 0.016) + 'px Cinzel, serif';
        ctx.fillStyle   = _overlayColor;
        ctx.globalAlpha = 0.8;
        ctx.textAlign   = 'center';
        ctx.fillText(pair.p, xy1.x, xy1.y - W * 0.014);
      }
    });

    // ── Rich legend panel at bottom of canvas ───────────────────────────────
    ctx.save();
    var lsize  = Math.max(9, W * 0.013);
    var lpad   = W * 0.03;
    var lboxH  = lsize * 3.8;
    var ly0    = H - lboxH - 6;

    // Semi-transparent background
    ctx.fillStyle = 'rgba(6,4,14,0.82)';
    ctx.strokeStyle = _overlayColor;
    ctx.lineWidth = 0.8;
    ctx.globalAlpha = 0.92;
    ctx.beginPath();
    ctx.roundRect ? ctx.roundRect(lpad, ly0, W - lpad*2, lboxH, 4) : ctx.rect(lpad, ly0, W - lpad*2, lboxH);
    ctx.fill(); ctx.stroke();
    ctx.globalAlpha = 1;

    ctx.font = 'bold ' + lsize + 'px Cinzel, serif';
    ctx.fillStyle = _overlayColor;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';

    // Line 1: gap name + count + mod
    var gapNames = {1:'Gap 1',2:'Twin Primes',4:'Cousin Primes',6:'Sexy Primes'};
    var displayGaps = _overlayGaps && _overlayGaps.length > 1
      ? 'Gaps ' + _overlayGaps.join(', ')
      : (gapNames[_overlayGap] || 'Gap ' + _overlayGap);
    var line1 = displayGaps + '  ·  ' + pairs.length + ' pairs  ·  mod ' + modN;
    ctx.fillText(line1, lpad + 8, ly0 + 5);

    // Line 2: zeta contributions per gap
    ctx.font = lsize + 'px Cinzel, serif';
    ctx.fillStyle = '#e8d9b0';
    var line2 = '';
    var gapsToShow = (_overlayGaps && _overlayGaps.length) ? _overlayGaps : [_overlayGap];
    if (window.analysisResults && window.analysisResults.percentageContributions) {
      var parts = [];
      gapsToShow.forEach(function(g) {
        var pct  = window.analysisResults.percentageContributions[g];
        var prod = window.analysisResults.gapProducts && window.analysisResults.gapProducts[g];
        if (pct !== undefined && prod) {
          parts.push('P₂(' + g + ')=' + prod.product.toFixed(4) + ' (' + pct.toFixed(2) + '%)');
        }
      });
      line2 = parts.join('  ·  ');
    }
    if (line2) ctx.fillText(line2, lpad + 8, ly0 + 5 + lsize * 1.5);

    // Line 3: residue pairs shown
    ctx.fillStyle = '#9a8060';
    ctx.font = (lsize * 0.88) + 'px Cinzel, serif';
    var r1set = {}, r2set = {};
    pairs.forEach(function(p){ r1set[p.r1]=true; r2set[p.r2]=true; });
    var uniqueR = Object.keys(Object.assign({},r1set,r2set)).sort(function(a,b){return a-b;}).slice(0,16).join(', ');
    ctx.fillText('Residues: ' + uniqueR + (Object.keys(Object.assign({},r1set,r2set)).length > 16 ? ' …' : ''), lpad + 8, ly0 + 5 + lsize * 2.9);

    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // ── Gap spiral animation ──────────────────────────────────────────────────
  // Particles travel each highlighted residue channel from ring 1 → modN,
  // then the gap chord flashes. Drawn on top of the static overlay each frame.

  var _animRAF    = null;   // requestAnimationFrame handle
  var _animPhase  = 0;      // 0=rising 1=chord-flash 2=fade
  var _animT      = 0;      // normalised 0→1 progress within phase
  var _animActive = false;

  // Build a flat array of path points for a residue r: [{x,y}] ring 1..modN
  function buildSpiral(r, modN, cx, cy, rMin, rMax, dir, angOff, invert) {
    var pts = [];
    for (var m = 1; m <= modN; m++) {
      var t   = invert ? (modN - m) / (modN - 1 || 1) : (m - 1) / (modN - 1 || 1);
      var rad = rMin + (rMax - rMin) * t;
      var ringOff = (typeof window.ringOffset === 'function') ? window.ringOffset(m, modN) * Math.PI / 180 : 0;
      var a   = dir * 2 * Math.PI * r / (m || 1) + angOff + ringOff;
      pts.push({ x: cx + rad * Math.sin(a), y: cy - rad * Math.cos(a), m: m });
    }
    return pts;
  }

  // Interpolate position along a spiral given progress 0→1
  function spiralPos(pts, prog) {
    var idx = prog * (pts.length - 1);
    var lo  = Math.floor(idx), hi = Math.min(lo + 1, pts.length - 1);
    var f   = idx - lo;
    return {
      x: pts[lo].x + (pts[hi].x - pts[lo].x) * f,
      y: pts[lo].y + (pts[hi].y - pts[lo].y) * f
    };
  }

  function fareyGapAnimFrame() {
    if (!_animActive) return;

    var c = document.getElementById('fc-combined');
    if (!c) { _animActive = false; return; }
    var ctx = c.getContext('2d');
    var W = c.width, H = c.height, cx = W/2, cy = H/2;

    var modN    = parseInt(document.getElementById('f-mod-num').value) || 49;
    var dir     = parseFloat(document.getElementById('f-dir').value) || 1;
    var angOff  = (window._combinedAngle || 90) * Math.PI / 180;
    var spacing = (parseInt(document.getElementById('f-spacing').value) || 100) / 100;
    var zoom    = (parseInt(document.getElementById('f-zoom').value) || 100) / 100;
    var rinner  = (parseInt(document.getElementById('f-rinner').value) || 4) / 100;
    var invert  = document.getElementById('f-invert-order').checked;
    var rBase   = W * 0.42 * spacing; if (rBase > W * 0.49) rBase = W * 0.49;
    var rMin    = W * rinner * zoom, rMax = rBase * zoom;

    var speed   = parseInt(document.getElementById('f-anim-speed').value) || 5;
    var dt      = speed * 0.004;  // progress increment per frame
    var loop    = document.getElementById('f-anim-loop').checked;
    var color   = _overlayColor || '#e879f9';

    // Collect unique residues
    var pairs = _overlayPairs.slice(0, MAX_DISPLAY);
    var highlightR = {};
    pairs.forEach(function(p){ highlightR[p.r1] = true; highlightR[p.r2] = true; });
    var rKeys = Object.keys(highlightR).map(Number);

    // Redraw base (static overlay) each frame
    window.fareyRedraw();

    // Phase 0: particles rise from ring 1 to ring modN
    if (_animPhase === 0) {
      _animT += dt;
      var prog = Math.min(_animT, 1);

      rKeys.forEach(function(r) {
        var pts = buildSpiral(r, modN, cx, cy, rMin, rMax, dir, angOff, invert);
        var stopIdx = Math.floor(prog * (pts.length - 1));

        // Trail: draw fading line of last ~15% of path
        var trailLen = Math.max(2, Math.floor(pts.length * 0.15));
        var trailStart = Math.max(0, stopIdx - trailLen);
        ctx.save();
        for (var i = trailStart; i < stopIdx; i++) {
          var tf = (i - trailStart) / trailLen;
          ctx.beginPath();
          ctx.moveTo(pts[i].x, pts[i].y);
          ctx.lineTo(pts[i+1].x, pts[i+1].y);
          ctx.strokeStyle = color;
          ctx.lineWidth   = Math.max(1.5, W * 0.004) * (0.3 + 0.7 * tf);
          ctx.globalAlpha = 0.4 + 0.6 * tf;
          ctx.stroke();
        }
        ctx.restore();

        // Bright glowing head particle
        var head = spiralPos(pts, prog);
        var dotR = Math.max(3, W * 0.009);
        // outer glow
        var grad = ctx.createRadialGradient(head.x, head.y, 0, head.x, head.y, dotR * 3);
        grad.addColorStop(0, color);
        grad.addColorStop(0.4, color.replace(')', ',0.6)').replace('rgb','rgba').replace('#','rgba(').replace(/rgba\(([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2}),/, function(_,r,g,b){ return 'rgba('+parseInt(r,16)+','+parseInt(g,16)+','+parseInt(b,16)+','; }) || color);
        grad.addColorStop(1,   'rgba(0,0,0,0)');
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.beginPath(); ctx.arc(head.x, head.y, dotR * 3, 0, 2 * Math.PI);
        ctx.fillStyle = grad; ctx.fill();
        // core dot
        ctx.globalAlpha = 1;
        ctx.beginPath(); ctx.arc(head.x, head.y, dotR, 0, 2 * Math.PI);
        ctx.fillStyle = '#fff'; ctx.fill();
        ctx.restore();
      });

      if (_animT >= 1) { _animPhase = 1; _animT = 0; }

    // Phase 1: chord flash
    } else if (_animPhase === 1) {
      _animT += dt * 1.5;
      var flashProg = Math.min(_animT, 1);

      pairs.forEach(function(pair) {
        var t1 = invert ? (modN - modN) / (modN - 1 || 1) : 1;
        var rad = rMin + (rMax - rMin) * t1;
        var rO1 = (typeof window.ringOffset === 'function') ? window.ringOffset(modN, modN) * Math.PI / 180 : 0;
        var a1  = dir * 2 * Math.PI * pair.r1 / modN + angOff + rO1;
        var a2  = dir * 2 * Math.PI * pair.r2 / modN + angOff + rO1;
        var x1  = cx + rad * Math.sin(a1), y1 = cy - rad * Math.cos(a1);
        var x2  = cx + rad * Math.sin(a2), y2 = cy - rad * Math.cos(a2);
        // Interpolate chord end point for draw-on effect
        var ex  = x1 + (x2 - x1) * flashProg;
        var ey  = y1 + (y2 - y1) * flashProg;
        ctx.save();
        ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(ex, ey);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth   = Math.max(2, W * 0.005);
        ctx.globalAlpha = 0.95;
        ctx.shadowColor = color; ctx.shadowBlur = 12;
        ctx.stroke();
        ctx.restore();
      });

      if (_animT >= 1) {
        _animPhase = 2; _animT = 0;
      }

    // Phase 2: brief pause then loop/stop
    } else if (_animPhase === 2) {
      _animT += dt * 0.5;
      if (_animT >= 1) {
        if (loop) {
          _animPhase = 0; _animT = 0;
        } else {
          _animActive = false;
          var btn = document.getElementById('fcm-gap-play');
          if (btn) { btn.textContent = '▶ Play'; btn.style.background = 'var(--parchment-dark)'; btn.style.color = '#e879f9'; }
          return;
        }
      }
    }

    _animRAF = requestAnimationFrame(fareyGapAnimFrame);
  }

  window.fareyGapAnimToggle = function() {
    if (!_overlayGap || !_overlayPairs.length) {
      alert('Select a gap overlay first (use the gap input or click a gap in the analysis).');
      return;
    }
    var btn = document.getElementById('fcm-gap-play');
    if (_animActive) {
      // Stop
      _animActive = false;
      if (_animRAF) { cancelAnimationFrame(_animRAF); _animRAF = null; }
      if (btn) { btn.textContent = '▶ Play'; btn.style.background = 'var(--parchment-dark)'; btn.style.color = '#e879f9'; }
      // Restore static overlay
      window.fareyRedraw();
    } else {
      // Start
      _animActive = true;
      _animPhase  = 0;
      _animT      = 0;
      if (btn) { btn.textContent = '⏸ Pause'; btn.style.background = '#e879f9'; btn.style.color = '#fff'; }
      fareyGapAnimFrame();
    }
  };

  // Stop animation when overlay is cleared
  var _origClear = window.fareyGapOverlayClear;
  window.fareyGapOverlayClear = function() {
    if (_animActive) {
      _animActive = false;
      if (_animRAF) { cancelAnimationFrame(_animRAF); _animRAF = null; }
      var btn = document.getElementById('fcm-gap-play');
      if (btn) { btn.textContent = '▶ Play'; btn.style.background = 'var(--parchment-dark)'; btn.style.color = '#e879f9'; }
    }
    if (_origClear) _origClear();
  };

  window.drawGapOverlay = drawGapOverlay;

})();
</script>

<script>
(function(){
  var FONTS = [
    { cls: '',              label: 'Aa Cinzel'  },
    { cls: 'font-inter',   label: 'Aa Inter'   },
    { cls: 'font-sourceserif', label: 'Aa Serif' },
    { cls: 'font-mono',    label: 'Aa Mono'    }
  ];
  var _fontIdx = 0;
  window.cycleFontTheme = function(){
    var body = document.body;
    var btn  = document.getElementById('font-toggle');
    // Remove current font class
    FONTS.forEach(function(f){ if(f.cls) body.classList.remove(f.cls); });
    _fontIdx = (_fontIdx + 1) % FONTS.length;
    var next = FONTS[_fontIdx];
    if(next.cls) body.classList.add(next.cls);
    if(btn) btn.textContent = next.label;
  };
})();
</script>
</body>
</html>
