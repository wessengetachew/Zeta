
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Boundary Cancellation Principle - Mathematical Analysis</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=Source+Code+Pro:wght@400;500&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: 'Crimson Pro', Georgia, serif;
    font-size: 18px;
    line-height: 1.7;
    color: #1a1a1a;
    background: #faf9f7;
    padding: 40px 20px;
}

.container {
    max-width: 900px;
    margin: 0 auto;
}

header {
    text-align: center;
    margin-bottom: 50px;
    padding-bottom: 30px;
    border-bottom: 1px solid #ccc;
}

h1 {
    font-size: 2.2rem;
    font-weight: 600;
    margin-bottom: 10px;
    letter-spacing: -0.02em;
}

.subtitle {
    font-size: 1.1rem;
    color: #555;
    font-style: italic;
}

.controls {
    background: #f0eeeb;
    border: 1px solid #ddd;
    padding: 25px 30px;
    margin-bottom: 40px;
}

.controls-title {
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #666;
    margin-bottom: 15px;
}

.controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 20px;
}

.control-item label {
    display: block;
    font-size: 0.85rem;
    color: #555;
    margin-bottom: 5px;
}

.control-item select,
.control-item input {
    width: 100%;
    padding: 8px 12px;
    font-family: 'Source Code Pro', monospace;
    font-size: 0.9rem;
    border: 1px solid #ccc;
    background: #fff;
}

.compute-btn {
    display: block;
    width: 100%;
    padding: 12px;
    background: #2a2a2a;
    color: #fff;
    border: none;
    font-family: 'Crimson Pro', serif;
    font-size: 1rem;
    cursor: pointer;
    transition: background 0.2s;
}

.compute-btn:hover {
    background: #444;
}

section {
    margin-bottom: 45px;
}

h2 {
    font-size: 1.4rem;
    font-weight: 600;
    margin-bottom: 20px;
    padding-bottom: 8px;
    border-bottom: 2px solid #2a2a2a;
}

h3 {
    font-size: 1.15rem;
    font-weight: 600;
    margin: 25px 0 12px 0;
}

p {
    margin-bottom: 15px;
    text-align: justify;
}

.theorem {
    background: #f5f5f0;
    border-left: 4px solid #2a2a2a;
    padding: 20px 25px;
    margin: 25px 0;
}

.theorem-title {
    font-weight: 600;
    margin-bottom: 10px;
}

.definition {
    background: #f0f5f5;
    border-left: 4px solid #4a7a7a;
    padding: 20px 25px;
    margin: 25px 0;
}

.formula {
    background: #fafafa;
    border: 1px solid #e0e0e0;
    padding: 20px;
    margin: 20px 0;
    text-align: center;
    font-family: 'Source Code Pro', monospace;
    font-size: 1.1rem;
    overflow-x: auto;
}

.formula-label {
    font-size: 0.8rem;
    color: #666;
    text-align: right;
    margin-top: 8px;
}

.data-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
    font-size: 0.95rem;
}

.data-table th {
    background: #2a2a2a;
    color: #fff;
    padding: 12px 15px;
    text-align: left;
    font-weight: 500;
}

.data-table td {
    padding: 10px 15px;
    border-bottom: 1px solid #ddd;
}

.data-table tr:nth-child(even) {
    background: #f9f9f7;
}

.data-table .number {
    font-family: 'Source Code Pro', monospace;
    text-align: right;
}

.highlight-row {
    background: #fffde7 !important;
}

.stat-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin: 25px 0;
}

.stat-card {
    background: #fff;
    border: 1px solid #ddd;
    padding: 20px;
}

.stat-label {
    font-size: 0.85rem;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.stat-value {
    font-family: 'Source Code Pro', monospace;
    font-size: 1.8rem;
    font-weight: 500;
    color: #2a2a2a;
    margin: 5px 0;
}

.stat-note {
    font-size: 0.85rem;
    color: #888;
    font-style: italic;
}

.proof {
    margin: 20px 0;
    padding-left: 20px;
    border-left: 2px solid #ccc;
}

.proof-title {
    font-style: italic;
    color: #555;
    margin-bottom: 10px;
}

.qed {
    text-align: right;
    font-size: 1.2rem;
}

.code {
    font-family: 'Source Code Pro', monospace;
    font-size: 0.9rem;
    background: #f5f5f5;
    padding: 2px 6px;
    border-radius: 3px;
}

.export-section {
    background: #f0eeeb;
    border: 1px solid #ddd;
    padding: 20px 25px;
    margin-top: 40px;
}

.export-title {
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #666;
    margin-bottom: 15px;
}

.export-buttons {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}

.export-btn {
    padding: 10px 20px;
    background: #fff;
    border: 1px solid #ccc;
    font-family: 'Crimson Pro', serif;
    font-size: 0.95rem;
    cursor: pointer;
    transition: all 0.2s;
}

.export-btn:hover {
    background: #2a2a2a;
    color: #fff;
    border-color: #2a2a2a;
}

.error-series {
    margin: 20px 0;
    max-height: 400px;
    overflow-y: auto;
}

.point-list {
    max-height: 300px;
    overflow-y: auto;
    font-family: 'Source Code Pro', monospace;
    font-size: 0.8rem;
    background: #fafafa;
    padding: 15px;
    border: 1px solid #e0e0e0;
}

.loading {
    text-align: center;
    padding: 40px;
    color: #666;
    font-style: italic;
}

footer {
    margin-top: 60px;
    padding-top: 20px;
    border-top: 1px solid #ccc;
    text-align: center;
    font-size: 0.85rem;
    color: #888;
}

@media print {
    .controls, .export-section { display: none; }
    body { padding: 20px; }
}
</style>
</head>
<body>

<div class="container">
    <header>
        <h1>The Boundary Cancellation Principle</h1>
        <p class="subtitle">Computational Analysis of Error Terms in Arithmetic Lattices</p>
    </header>

    <div class="controls">
        <div class="controls-title">Parameters</div>
        <div class="controls-grid">
            <div class="control-item">
                <label>Structure Type</label>
                <select id="structureType">
                    <option value="coprime">Coprime Lattice Points</option>
                    <option value="squarefree">Squarefree Integers</option>
                    <option value="kfree">k-Free Integers</option>
                    <option value="coprime-tuple">Coprime m-Tuples</option>
                </select>
            </div>
            <div class="control-item">
                <label>Dimension (k)</label>
                <select id="dimension">
                    <option value="2" selected>2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                </select>
            </div>
            <div class="control-item">
                <label>Radius / Bound (R)</label>
                <input type="number" id="radius" value="50" min="10" max="200">
            </div>
            <div class="control-item">
                <label>k-free parameter</label>
                <input type="number" id="kfreeK" value="2" min="2" max="10">
            </div>
        </div>
        <button class="compute-btn" onclick="compute()">Compute Full Analysis</button>
    </div>

    <section id="principleSection">
        <h2>1. Statement of the Principle</h2>
        
        <div class="theorem">
            <div class="theorem-title">Boundary Cancellation Principle</div>
            <p>Let an arithmetic counting problem be defined on a <em>k</em>-dimensional lattice with arithmetic constraints imposed via Möbius-type inclusion-exclusion. If the main term scales with the volume of the supporting region, then the dominant error term scales with the boundary measure of that region.</p>
        </div>

        <p>The critical consequence is that the error exponent depends solely on dimension:</p>

        <div class="formula">
            Error exponent = (k - 1) / k
            <div class="formula-label">where k is the lattice dimension</div>
        </div>

        <p>For squarefree counting (k = 2), this yields the classical O(x<sup>1/2</sup>) error. For cubefree counting (k = 3), we obtain O(x<sup>1/3</sup>), and so forth.</p>
    </section>

    <section id="configSection">
        <h2>2. Current Configuration</h2>
        
        <div class="stat-grid">
            <div class="stat-card">
                <div class="stat-label">Structure</div>
                <div class="stat-value" id="displayStructure">Coprime Lattice</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Dimension k</div>
                <div class="stat-value" id="displayDimension">2</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Radius R</div>
                <div class="stat-value" id="displayRadius">50</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Critical Exponent</div>
                <div class="stat-value" id="displayExponent">1/2</div>
            </div>
        </div>
    </section>

    <section id="definitionsSection">
        <h2>3. Definitions</h2>

        <div class="definition">
            <div class="theorem-title" id="defTitle">Definition (Coprime Lattice Points)</div>
            <p id="defContent">A point (a₁, a₂, ..., aₖ) ∈ ℤᵏ is coprime (or primitive) if gcd(a₁, a₂, ..., aₖ) = 1. Such points are precisely those visible from the origin.</p>
        </div>

        <h3>The Möbius Function</h3>
        <p>The Möbius function μ(n) is defined by:</p>
        <div class="formula">
            μ(n) = 1 if n = 1<br>
            μ(n) = (−1)ʳ if n is squarefree with r prime factors<br>
            μ(n) = 0 if n has a squared prime factor
        </div>

        <p>This function serves as the fundamental arithmetic filter in the inclusion-exclusion sieve.</p>
    </section>

    <section id="mainTermSection">
        <h2>4. Main Term Analysis</h2>

        <div class="theorem">
            <div class="theorem-title" id="mainTermTitle">Theorem (Main Term for Coprime Lattice Points)</div>
            <p id="mainTermStatement">The number of coprime lattice points in the ball of radius R in ℤᵏ satisfies:</p>
            <div class="formula" id="mainTermFormula">
                #{(a₁,...,aₖ) : |a|≤R, gcd=1} = Rᵏ / ζ(k) + O(Rᵏ⁻¹)
            </div>
        </div>

        <div class="stat-grid">
            <div class="stat-card">
                <div class="stat-label">Predicted Count (Main Term)</div>
                <div class="stat-value" id="predictedCount">—</div>
                <div class="stat-note" id="predictedFormula">Rᵏ / ζ(k)</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Density Constant</div>
                <div class="stat-value" id="densityConstant">—</div>
                <div class="stat-note" id="densityFormula">1 / ζ(k)</div>
            </div>
        </div>

        <h3>Zeta Values</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>k</th>
                    <th>ζ(k)</th>
                    <th>1/ζ(k) (density)</th>
                    <th>Closed Form</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="number">2</td>
                    <td class="number">1.6449340668</td>
                    <td class="number">0.6079271019</td>
                    <td>π²/6</td>
                </tr>
                <tr>
                    <td class="number">3</td>
                    <td class="number">1.2020569032</td>
                    <td class="number">0.8319073725</td>
                    <td>Apéry's constant</td>
                </tr>
                <tr>
                    <td class="number">4</td>
                    <td class="number">1.0823232337</td>
                    <td class="number">0.9239384669</td>
                    <td>π⁴/90</td>
                </tr>
                <tr>
                    <td class="number">5</td>
                    <td class="number">1.0369277551</td>
                    <td class="number">0.9643895748</td>
                    <td>—</td>
                </tr>
                <tr>
                    <td class="number">6</td>
                    <td class="number">1.0173430620</td>
                    <td class="number">0.9829523809</td>
                    <td>π⁶/945</td>
                </tr>
            </tbody>
        </table>
    </section>

    <section id="countingSection">
        <h2>5. Exact Counting Results</h2>

        <div class="stat-grid">
            <div class="stat-card">
                <div class="stat-label">Total Lattice Points</div>
                <div class="stat-value" id="totalPoints">—</div>
                <div class="stat-note">Points in ball of radius R</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Surviving Points</div>
                <div class="stat-value" id="survivingPoints">—</div>
                <div class="stat-note">Satisfying arithmetic constraint</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Removed Points</div>
                <div class="stat-value" id="removedPoints">—</div>
                <div class="stat-note">Filtered by Möbius sieve</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Empirical Density</div>
                <div class="stat-value" id="empiricalDensity">—</div>
                <div class="stat-note">Surviving / Total</div>
            </div>
        </div>

        <h3>Comparison with Prediction</h3>
        <table class="data-table">
            <thead>
                <tr>
                    <th>Quantity</th>
                    <th>Value</th>
                    <th>Notes</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Predicted (Main Term)</td>
                    <td class="number" id="tablePredicted">—</td>
                    <td id="tablePredictedNote">—</td>
                </tr>
                <tr>
                    <td>Actual Count</td>
                    <td class="number" id="tableActual">—</td>
                    <td>Exact enumeration</td>
                </tr>
                <tr class="highlight-row">
                    <td>Error (Actual − Predicted)</td>
                    <td class="number" id="tableError">—</td>
                    <td>Deviation from main term</td>
                </tr>
                <tr>
                    <td>Theoretical Error Bound</td>
                    <td class="number" id="tableErrorBound">—</td>
                    <td id="tableErrorBoundNote">—</td>
                </tr>
                <tr>
                    <td>Relative Error</td>
                    <td class="number" id="tableRelError">—</td>
                    <td>|Error| / Predicted</td>
                </tr>
            </tbody>
        </table>
    </section>

    <section id="boundarySection">
        <h2>6. Boundary Analysis</h2>

        <p>The Boundary Cancellation Principle asserts that error accumulates at the geometric boundary. We verify this by examining point distribution across radial shells.</p>

        <div class="stat-grid">
            <div class="stat-card">
                <div class="stat-label">Boundary Shell Points</div>
                <div class="stat-value" id="boundaryPoints">—</div>
                <div class="stat-note" id="boundaryNote">Shell: R − δ ≤ |x| ≤ R</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Interior Points</div>
                <div class="stat-value" id="interiorPoints">—</div>
                <div class="stat-note">|x| < R − δ</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Boundary Ratio</div>
                <div class="stat-value" id="boundaryRatio">—</div>
                <div class="stat-note">Boundary / Total Surviving</div>
            </div>
        </div>

        <h3>Radial Density Distribution</h3>
        <p>Density of surviving points as a function of distance from origin:</p>
        
        <div class="error-series" id="radialDensityTable">
            <table class="data-table">
                <thead>
                    <tr>
                        <th>Radius Range</th>
                        <th>Total Points</th>
                        <th>Surviving</th>
                        <th>Density</th>
                    </tr>
                </thead>
                <tbody id="radialDensityBody">
                </tbody>
            </table>
        </div>
    </section>

    <section id="errorSection">
        <h2>7. Error Term Scaling</h2>

        <div class="theorem">
            <div class="theorem-title">Verification of Error Scaling</div>
            <p>If the Boundary Cancellation Principle holds, then |Error(R)| should be bounded by C · R<sup id="errorExpDisplay">k−1</sup> for some constant C.</p>
        </div>

        <p>We compute the error for increasing values of R and verify the predicted scaling:</p>

        <div class="error-series" id="errorSeriesTable">
            <table class="data-table">
                <thead>
                    <tr>
                        <th>R</th>
                        <th>Actual</th>
                        <th>Predicted</th>
                        <th>Error</th>
                        <th>Bound (R<sup id="errorExpHeader">k−1</sup>)</th>
                        <th>|Error|/Bound</th>
                    </tr>
                </thead>
                <tbody id="errorSeriesBody">
                </tbody>
            </table>
        </div>

        <div class="stat-grid">
            <div class="stat-card">
                <div class="stat-label">Max |Error|/Bound Ratio</div>
                <div class="stat-value" id="maxErrorRatio">—</div>
                <div class="stat-note">Should remain bounded</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Average |Error|/Bound</div>
                <div class="stat-value" id="avgErrorRatio">—</div>
                <div class="stat-note">Typical deviation</div>
            </div>
        </div>
    </section>

    <section id="proofSection">
        <h2>8. Sketch of Proof</h2>

        <div class="proof">
            <div class="proof-title">Proof sketch (Coprime lattice case)</div>
            
            <p><strong>Step 1.</strong> Express the count via Möbius inversion:</p>
            <div class="formula">
                #{coprime points in B(R)} = Σ_{d=1}^{R} μ(d) · #{lattice points in B(R/d)}
            </div>

            <p><strong>Step 2.</strong> The inner count satisfies:</p>
            <div class="formula">
                #{lattice points in B(r)} = Vol(B(r)) + O(r<sup>k−1</sup>)
            </div>
            <p>where the error arises from the boundary of the ball.</p>

            <p><strong>Step 3.</strong> Summing with Möbius weights:</p>
            <div class="formula">
                Σ_{d=1}^{R} μ(d) · Vol(B(R/d)) = R<sup>k</sup> · Σ_{d=1}^{∞} μ(d)/d<sup>k</sup> + O(R<sup>k−1</sup>)
            </div>

            <p><strong>Step 4.</strong> Recognize the Euler product:</p>
            <div class="formula">
                Σ_{d=1}^{∞} μ(d)/d<sup>k</sup> = 1/ζ(k)
            </div>

            <p><strong>Step 5.</strong> The error terms from Step 2 do not cancel beyond the boundary measure, yielding total error O(R<sup>k−1</sup>).</p>

            <p class="qed">∎</p>
        </div>
    </section>

    <section id="dataSection">
        <h2>9. Sample Point Data</h2>

        <p>First 100 surviving points (sorted by norm):</p>
        <div class="point-list" id="pointList">
            Computing...
        </div>
    </section>

    <div class="export-section">
        <div class="export-title">Export Data</div>
        <div class="export-buttons">
            <button class="export-btn" onclick="exportCSV('points')">All Points (CSV)</button>
            <button class="export-btn" onclick="exportCSV('error')">Error Series (CSV)</button>
            <button class="export-btn" onclick="exportCSV('density')">Density Data (CSV)</button>
            <button class="export-btn" onclick="exportCSV('summary')">Summary (CSV)</button>
            <button class="export-btn" onclick="exportLaTeX()">LaTeX Table</button>
            <button class="export-btn" onclick="window.print()">Print / PDF</button>
        </div>
    </div>

    <footer>
        Boundary Cancellation Principle Analysis Tool<br>
        Computed: <span id="computeTime">—</span>
    </footer>
</div>

<script>
const State = {
    structure: 'coprime',
    dimension: 2,
    radius: 50,
    kfreeK: 2,
    points: [],
    classified: [],
    errorSeries: [],
    densityData: [],
    primes: [],
    maxPrime: 0
};

function sievePrimes(max) {
    if (max <= State.maxPrime) return;
    const sieve = new Array(max + 1).fill(true);
    sieve[0] = sieve[1] = false;
    for (let i = 2; i * i <= max; i++) {
        if (sieve[i]) {
            for (let j = i * i; j <= max; j += i) sieve[j] = false;
        }
    }
    State.primes = [];
    for (let i = 2; i <= max; i++) {
        if (sieve[i]) State.primes.push(i);
    }
    State.maxPrime = max;
}

function gcd(a, b) {
    a = Math.abs(a); b = Math.abs(b);
    while (b) [a, b] = [b, a % b];
    return a;
}

function gcdArr(arr) {
    return arr.reduce((a, b) => gcd(a, b));
}

function isKFree(n, k) {
    if (n <= 0) return false;
    sievePrimes(Math.ceil(Math.pow(n, 1/k)) + 10);
    for (const p of State.primes) {
        const pk = Math.pow(p, k);
        if (pk > n) break;
        if (n % pk === 0) return false;
    }
    return true;
}

function generatePoints(R, k) {
    const points = [];
    const R2 = R * R;
    
    if (k === 2) {
        for (let x = 1; x <= R; x++) {
            const maxY = Math.floor(Math.sqrt(R2 - x * x));
            for (let y = -maxY; y <= maxY; y++) {
                points.push([x, y]);
            }
        }
    } else if (k === 3) {
        for (let x = 1; x <= R; x++) {
            const rem1 = R2 - x * x;
            const maxY = Math.floor(Math.sqrt(rem1));
            for (let y = -maxY; y <= maxY; y++) {
                const rem2 = rem1 - y * y;
                if (rem2 < 0) continue;
                const maxZ = Math.floor(Math.sqrt(rem2));
                for (let z = -maxZ; z <= maxZ; z++) {
                    points.push([x, y, z]);
                }
            }
        }
    } else {
        const generate = (current, depth, remaining) => {
            if (depth === k) {
                points.push([...current]);
                return;
            }
            const max = Math.floor(Math.sqrt(remaining));
            const start = depth === 0 ? 1 : -max;
            for (let v = start; v <= max; v++) {
                const newRem = remaining - v * v;
                if (newRem >= 0) {
                    current.push(v);
                    generate(current, depth + 1, newRem);
                    current.pop();
                }
            }
        };
        generate([], 0, R2);
    }
    
    return points;
}

function classifyPoint(p, structure, kfreeK) {
    let survives = false;
    
    switch (structure) {
        case 'coprime':
        case 'coprime-tuple':
            survives = gcdArr(p.map(Math.abs)) === 1;
            break;
        case 'squarefree':
            const n2 = p.reduce((s, x) => s + x * x, 0);
            survives = isKFree(Math.round(Math.sqrt(n2)), 2);
            break;
        case 'kfree':
            const nk = p.reduce((s, x) => s + x * x, 0);
            survives = isKFree(Math.round(Math.sqrt(nk)), kfreeK);
            break;
        default:
            survives = gcdArr(p.map(Math.abs)) === 1;
    }
    
    const norm = Math.sqrt(p.reduce((s, x) => s + x * x, 0));
    return { point: p, survives, norm };
}

function zeta(s) {
    const vals = { 
        2: Math.PI * Math.PI / 6, 
        3: 1.2020569031595942, 
        4: Math.pow(Math.PI, 4) / 90, 
        5: 1.0369277551433699, 
        6: Math.pow(Math.PI, 6) / 945 
    };
    if (vals[s]) return vals[s];
    let sum = 0;
    for (let n = 1; n < 10000; n++) sum += 1 / Math.pow(n, s);
    return sum;
}

function mainTerm(R, k, structure, kfreeK) {
    switch (structure) {
        case 'coprime':
        case 'coprime-tuple':
            return Math.pow(R, k) / zeta(k);
        case 'squarefree':
            return R / zeta(2);
        case 'kfree':
            return R / zeta(kfreeK);
        default:
            return Math.pow(R, k) / zeta(k);
    }
}

function errorBound(R, k, structure, kfreeK) {
    switch (structure) {
        case 'squarefree':
            return Math.pow(R, 0.5);
        case 'kfree':
            return Math.pow(R, 1 / kfreeK);
        default:
            return Math.pow(R, k - 1);
    }
}

function compute() {
    const startTime = performance.now();
    
    State.structure = document.getElementById('structureType').value;
    State.dimension = parseInt(document.getElementById('dimension').value);
    State.radius = parseInt(document.getElementById('radius').value);
    State.kfreeK = parseInt(document.getElementById('kfreeK').value);
    
    const k = State.dimension;
    const R = State.radius;
    
    // Generate and classify points
    State.points = generatePoints(R, k);
    State.classified = State.points.map(p => classifyPoint(p, State.structure, State.kfreeK));
    
    const surviving = State.classified.filter(p => p.survives);
    const total = State.classified.length;
    const survCount = surviving.length;
    
    // Compute main term and error
    const predicted = mainTerm(R, k, State.structure, State.kfreeK);
    const error = survCount - predicted;
    const bound = errorBound(R, k, State.structure, State.kfreeK);
    
    // Boundary analysis
    const delta = Math.max(1, Math.floor(R * 0.1));
    const boundaryThreshold = R - delta;
    const boundary = surviving.filter(p => p.norm >= boundaryThreshold);
    const interior = surviving.filter(p => p.norm < boundaryThreshold);
    
    // Update display
    updateConfigDisplay();
    updateDefinitions();
    updateMainTermDisplay(predicted);
    updateCountingDisplay(total, survCount, predicted, error, bound);
    updateBoundaryDisplay(boundary.length, interior.length, survCount, delta);
    computeRadialDensity();
    computeErrorSeries();
    updatePointList(surviving);
    
    const elapsed = (performance.now() - startTime).toFixed(0);
    document.getElementById('computeTime').textContent = new Date().toLocaleString() + ` (${elapsed}ms)`;
}

function updateConfigDisplay() {
    const k = State.dimension;
    const R = State.radius;
    
    const names = {
        'coprime': 'Coprime Lattice',
        'squarefree': 'Squarefree Integers',
        'kfree': `${State.kfreeK}-Free Integers`,
        'coprime-tuple': 'Coprime m-Tuples'
    };
    
    document.getElementById('displayStructure').textContent = names[State.structure];
    document.getElementById('displayDimension').textContent = k;
    document.getElementById('displayRadius').textContent = R;
    document.getElementById('displayExponent').textContent = `${k-1}/${k} = ${((k-1)/k).toFixed(4)}`;
    
    document.getElementById('errorExpDisplay').textContent = k - 1;
    document.getElementById('errorExpHeader').textContent = k - 1;
}

function updateDefinitions() {
    const titles = {
        'coprime': 'Definition (Coprime Lattice Points)',
        'squarefree': 'Definition (Squarefree Integers)',
        'kfree': `Definition (${State.kfreeK}-Free Integers)`,
        'coprime-tuple': 'Definition (Coprime m-Tuples)'
    };
    
    const contents = {
        'coprime': `A point (a₁, a₂, ..., a${State.dimension}) ∈ ℤ${State.dimension} is coprime if gcd(a₁, a₂, ..., a${State.dimension}) = 1. Such points are visible from the origin.`,
        'squarefree': 'An integer n is squarefree if it is not divisible by p² for any prime p. Equivalently, μ(n) ≠ 0.',
        'kfree': `An integer n is ${State.kfreeK}-free if it is not divisible by p${State.kfreeK} for any prime p.`,
        'coprime-tuple': `An m-tuple (a₁, ..., a${State.dimension}) is coprime if gcd(a₁, ..., a${State.dimension}) = 1.`
    };
    
    document.getElementById('defTitle').textContent = titles[State.structure];
    document.getElementById('defContent').textContent = contents[State.structure];
}

function updateMainTermDisplay(predicted) {
    const k = State.dimension;
    const z = zeta(k);
    
    document.getElementById('predictedCount').textContent = predicted.toFixed(2);
    document.getElementById('densityConstant').textContent = (1/z).toFixed(10);
    
    const formulas = {
        'coprime': [`R${k} / ζ(${k})`, `1 / ζ(${k})`],
        'squarefree': ['R / ζ(2) = 6R/π²', '6/π²'],
        'kfree': [`R / ζ(${State.kfreeK})`, `1 / ζ(${State.kfreeK})`],
        'coprime-tuple': [`R${k} / ζ(${k})`, `1 / ζ(${k})`]
    };
    
    document.getElementById('predictedFormula').textContent = formulas[State.structure][0];
    document.getElementById('densityFormula').textContent = formulas[State.structure][1];
    
    // Update theorem
    const theorems = {
        'coprime': `The number of coprime lattice points in the ball of radius R in ℤ${k} satisfies:`,
        'squarefree': 'The count of squarefree integers up to x satisfies:',
        'kfree': `The count of ${State.kfreeK}-free integers up to x satisfies:`,
        'coprime-tuple': `The number of coprime ${k}-tuples in [1,R]${k} satisfies:`
    };
    
    document.getElementById('mainTermTitle').textContent = `Theorem (Main Term for ${document.getElementById('displayStructure').textContent})`;
    document.getElementById('mainTermStatement').textContent = theorems[State.structure];
}

function updateCountingDisplay(total, survCount, predicted, error, bound) {
    document.getElementById('totalPoints').textContent = total.toLocaleString();
    document.getElementById('survivingPoints').textContent = survCount.toLocaleString();
    document.getElementById('removedPoints').textContent = (total - survCount).toLocaleString();
    document.getElementById('empiricalDensity').textContent = (survCount / total * 100).toFixed(4) + '%';
    
    document.getElementById('tablePredicted').textContent = predicted.toFixed(4);
    document.getElementById('tablePredictedNote').textContent = `Using ζ(${State.dimension}) = ${zeta(State.dimension).toFixed(10)}`;
    document.getElementById('tableActual').textContent = survCount.toLocaleString();
    document.getElementById('tableError').textContent = error.toFixed(4);
    document.getElementById('tableErrorBound').textContent = bound.toFixed(4);
    document.getElementById('tableErrorBoundNote').textContent = `O(R${State.dimension - 1}) bound`;
    document.getElementById('tableRelError').textContent = (Math.abs(error) / predicted * 100).toFixed(6) + '%';
}

function updateBoundaryDisplay(boundaryCount, interiorCount, totalSurv, delta) {
    document.getElementById('boundaryPoints').textContent = boundaryCount.toLocaleString();
    document.getElementById('boundaryNote').textContent = `Shell width δ = ${delta}`;
    document.getElementById('interiorPoints').textContent = interiorCount.toLocaleString();
    document.getElementById('boundaryRatio').textContent = (boundaryCount / totalSurv * 100).toFixed(2) + '%';
}

function computeRadialDensity() {
    const R = State.radius;
    const bins = 10;
    const binWidth = R / bins;
    
    State.densityData = [];
    
    for (let i = 0; i < bins; i++) {
        const rMin = i * binWidth;
        const rMax = (i + 1) * binWidth;
        
        const inBin = State.classified.filter(p => p.norm >= rMin && p.norm < rMax);
        const surviving = inBin.filter(p => p.survives).length;
        const total = inBin.length;
        const density = total > 0 ? surviving / total : 0;
        
        State.densityData.push({ rMin, rMax, total, surviving, density });
    }
    
    const tbody = document.getElementById('radialDensityBody');
    tbody.innerHTML = State.densityData.map(d => `
        <tr>
            <td>[${d.rMin.toFixed(1)}, ${d.rMax.toFixed(1)})</td>
            <td class="number">${d.total.toLocaleString()}</td>
            <td class="number">${d.surviving.toLocaleString()}</td>
            <td class="number">${(d.density * 100).toFixed(4)}%</td>
        </tr>
    `).join('');
}

function computeErrorSeries() {
    const R = State.radius;
    const k = State.dimension;
    const step = Math.max(1, Math.floor(R / 20));
    
    State.errorSeries = [];
    
    for (let r = 5; r <= R; r += step) {
        const pts = generatePoints(r, k);
        const classified = pts.map(p => classifyPoint(p, State.structure, State.kfreeK));
        const survCount = classified.filter(p => p.survives).length;
        const pred = mainTerm(r, k, State.structure, State.kfreeK);
        const err = survCount - pred;
        const bnd = errorBound(r, k, State.structure, State.kfreeK);
        
        State.errorSeries.push({
            r, actual: survCount, predicted: pred, error: err, bound: bnd,
            ratio: Math.abs(err) / bnd
        });
    }
    
    const tbody = document.getElementById('errorSeriesBody');
    tbody.innerHTML = State.errorSeries.map(d => `
        <tr>
            <td class="number">${d.r}</td>
            <td class="number">${d.actual.toLocaleString()}</td>
            <td class="number">${d.predicted.toFixed(2)}</td>
            <td class="number">${d.error.toFixed(2)}</td>
            <td class="number">${d.bound.toFixed(2)}</td>
            <td class="number">${d.ratio.toFixed(4)}</td>
        </tr>
    `).join('');
    
    const ratios = State.errorSeries.map(d => d.ratio);
    document.getElementById('maxErrorRatio').textContent = Math.max(...ratios).toFixed(4);
    document.getElementById('avgErrorRatio').textContent = (ratios.reduce((a,b) => a+b, 0) / ratios.length).toFixed(4);
}

function updatePointList(surviving) {
    const sorted = surviving.sort((a, b) => a.norm - b.norm).slice(0, 100);
    const list = sorted.map((p, i) => 
        `${(i+1).toString().padStart(3)}. (${p.point.join(', ')})  |x| = ${p.norm.toFixed(4)}`
    ).join('\n');
    
    document.getElementById('pointList').textContent = list || 'No points';
}

function exportCSV(type) {
    let csv = '', filename = '';
    
    switch (type) {
        case 'points':
            csv = 'index,' + Array.from({length: State.dimension}, (_, i) => `x${i+1}`).join(',') + ',survives,norm\n';
            State.classified.forEach((item, i) => {
                csv += `${i},${item.point.join(',')},${item.survives?1:0},${item.norm.toFixed(6)}\n`;
            });
            filename = 'lattice-points';
            break;
            
        case 'error':
            csv = 'radius,actual,predicted,error,bound,ratio\n';
            State.errorSeries.forEach(d => {
                csv += `${d.r},${d.actual},${d.predicted.toFixed(6)},${d.error.toFixed(6)},${d.bound.toFixed(6)},${d.ratio.toFixed(6)}\n`;
            });
            filename = 'error-series';
            break;
            
        case 'density':
            csv = 'r_min,r_max,total,surviving,density\n';
            State.densityData.forEach(d => {
                csv += `${d.rMin.toFixed(2)},${d.rMax.toFixed(2)},${d.total},${d.surviving},${d.density.toFixed(6)}\n`;
            });
            filename = 'radial-density';
            break;
            
        case 'summary':
            const surv = State.classified.filter(p => p.survives).length;
            const pred = mainTerm(State.radius, State.dimension, State.structure, State.kfreeK);
            csv = 'parameter,value\n';
            csv += `structure,${State.structure}\n`;
            csv += `dimension,${State.dimension}\n`;
            csv += `radius,${State.radius}\n`;
            csv += `total_points,${State.classified.length}\n`;
            csv += `surviving_points,${surv}\n`;
            csv += `predicted,${pred.toFixed(6)}\n`;
            csv += `error,${(surv - pred).toFixed(6)}\n`;
            csv += `error_bound,${errorBound(State.radius, State.dimension, State.structure, State.kfreeK).toFixed(6)}\n`;
            csv += `critical_exponent,${((State.dimension-1)/State.dimension).toFixed(6)}\n`;
            csv += `zeta_k,${zeta(State.dimension).toFixed(10)}\n`;
            filename = 'summary';
            break;
    }
    
    const blob = new Blob([csv], { type: 'text/csv' });
    const link = document.createElement('a');
    link.download = `bcp-${filename}-${Date.now()}.csv`;
    link.href = URL.createObjectURL(blob);
    link.click();
}

function exportLaTeX() {
    const k = State.dimension;
    const surv = State.classified.filter(p => p.survives).length;
    const pred = mainTerm(State.radius, k, State.structure, State.kfreeK);
    const err = surv - pred;
    const bnd = errorBound(State.radius, k, State.structure, State.kfreeK);
    
    let latex = `% Boundary Cancellation Principle - Computed Results
% Structure: ${State.structure}, k = ${k}, R = ${State.radius}

\\begin{table}[h]
\\centering
\\begin{tabular}{lrr}
\\toprule
Quantity & Value & Notes \\\\
\\midrule
Dimension $k$ & ${k} & \\\\
Radius $R$ & ${State.radius} & \\\\
Total points & ${State.classified.length.toLocaleString()} & In ball $B(R)$ \\\\
Surviving points & ${surv.toLocaleString()} & Exact count \\\\
Predicted & ${pred.toFixed(4)} & $R^k/\\zeta(k)$ \\\\
Error & ${err.toFixed(4)} & Actual $-$ Predicted \\\\
Error bound & ${bnd.toFixed(4)} & $O(R^{${k-1}})$ \\\\
Relative error & ${(Math.abs(err)/pred*100).toFixed(4)}\\% & \\\\
\\bottomrule
\\end{tabular}
\\caption{Boundary Cancellation Principle verification for ${State.structure} with $k=${k}$, $R=${State.radius}$.}
\\end{table}

% Error series
\\begin{table}[h]
\\centering
\\begin{tabular}{rrrrrr}
\\toprule
$R$ & Actual & Predicted & Error & Bound & Ratio \\\\
\\midrule
`;

    State.errorSeries.forEach(d => {
        latex += `${d.r} & ${d.actual} & ${d.predicted.toFixed(2)} & ${d.error.toFixed(2)} & ${d.bound.toFixed(2)} & ${d.ratio.toFixed(4)} \\\\\n`;
    });

    latex += `\\bottomrule
\\end{tabular}
\\caption{Error scaling verification.}
\\end{table}
`;

    const blob = new Blob([latex], { type: 'text/plain' });
    const link = document.createElement('a');
    link.download = `bcp-latex-${Date.now()}.tex`;
    link.href = URL.createObjectURL(blob);
    link.click();
}

// Initialize
document.addEventListener('DOMContentLoaded', compute);
</script>

</body>
    </html>
