
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Primitive Lattice Directions & Modular Circles - Enhanced</title>
    <style>
        :root {
            --bg-deep: #0a0e1a;
            --bg-card: #141829;
            --bg-panel: #1a1f35;
            --gold: #FFD700;
            --gold-dim: #B8960A;
            --cyan: #00FFFF;
            --cyan-dim: #008B8B;
            --text-primary: #E8E8E8;
            --text-secondary: #A0A0A0;
            --border: #2a3150;
            --accent-purple: #9F7AEA;
            --accent-green: #48BB78;
            --accent-red: #e74c3c;
        }

        [data-theme="light"] {
            --bg-deep: #f7fafc;
            --bg-card: #ffffff;
            --bg-panel: #edf2f7;
            --gold: #d69e00;
            --gold-dim: #b8860b;
            --cyan: #0891b2;
            --cyan-dim: #0e7490;
            --text-primary: #1a202c;
            --text-secondary: #4a5568;
            --border: #cbd5e0;
            --accent-purple: #7c3aed;
            --accent-green: #059669;
            --accent-red: #dc2626;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
            transition: background 0.3s, color 0.3s;
        }

        .container { max-width: 2200px; margin: 0 auto; }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 30px;
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--gold), var(--cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle { color: var(--text-secondary); font-size: 1.2em; font-style: italic; }

        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--bg-card);
            border: 2px solid var(--border);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
        }

        .theme-toggle:hover { border-color: var(--gold); transform: translateY(-2px); }

        .fullscreen-toggle {
            position: fixed;
            top: 20px;
            right: 160px;
            background: var(--bg-card);
            border: 2px solid var(--border);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s;
        }

        .fullscreen-toggle:hover { border-color: var(--cyan); transform: translateY(-2px); }

        .fullscreen-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--bg-deep);
            z-index: 999;
            display: none;
            padding: 20px;
        }

        .fullscreen-mode.active { display: block; }

        .fullscreen-content {
            width: 100%;
            height: 100%;
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
        }

        .fullscreen-canvas {
            max-width: calc(50% - 10px);
            max-height: 100%;
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border);
        }

        .fullscreen-canvas canvas {
            width: 100%;
            height: auto;
            max-height: calc(100vh - 100px);
        }

        .controls-panel {
            background: var(--bg-panel);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 30px;
            border: 1px solid var(--border);
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 450px;
            gap: 25px;
            margin-bottom: 30px;
        }

        .canvas-section {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .canvas-panel {
            background: var(--bg-card);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .legend-sidebar {
            background: var(--bg-card);
            padding: 25px;
            border-radius: 12px;
            border: 1px solid var(--border);
            position: sticky;
            top: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        .section-title {
            font-size: 1.2em;
            font-weight: 600;
            color: var(--gold);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .subsection-title {
            font-size: 1em;
            font-weight: 600;
            color: var(--cyan);
            margin: 20px 0 10px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--border);
        }

        .control-group { margin-bottom: 20px; }

        label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-primary);
            font-weight: 600;
            font-size: 0.95em;
        }

        input[type="number"], select {
            width: 100%;
            padding: 10px;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--cyan);
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--gold);
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--gold);
            cursor: pointer;
            border-radius: 50%;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            padding: 8px;
            background: var(--bg-card);
            border-radius: 6px;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--cyan);
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            font-weight: normal;
        }

        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .canvas-title {
            font-size: 1.4em;
            font-weight: 600;
            color: var(--gold);
        }

        .independent-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .canvas-controls {
            background: var(--bg-panel);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid var(--border);
        }

        canvas {
            display: block;
            margin: 0 auto;
            background: var(--bg-deep);
            border-radius: 8px;
            border: 2px solid var(--border);
            cursor: crosshair;
        }

        .legend-item-detailed {
            background: var(--bg-panel);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid var(--cyan);
        }

        .legend-color-box {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }

        .color-swatch {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            border: 2px solid var(--border);
        }

        .legend-label {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--text-primary);
        }

        .legend-description {
            color: var(--text-secondary);
            font-size: 0.9em;
            line-height: 1.5;
            margin-top: 8px;
        }

        .legend-formula {
            background: var(--bg-deep);
            padding: 10px;
            border-radius: 6px;
            margin-top: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--gold);
        }

        .legend-stats {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 0.9em;
        }

        .stat-label {
            color: var(--text-secondary);
        }

        .stat-value {
            color: var(--cyan);
            font-weight: 600;
            font-family: monospace;
        }

        .inspection-panel {
            background: var(--bg-panel);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 2px solid var(--gold);
        }

        .inspection-title {
            font-weight: 600;
            color: var(--gold);
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .property-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 8px 15px;
            margin-top: 10px;
        }

        .property-label {
            color: var(--text-secondary);
            font-weight: 600;
        }

        .property-value {
            color: var(--text-primary);
            font-family: monospace;
        }

        .animation-controls {
            background: var(--bg-panel);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid var(--border);
        }

        .play-button {
            background: linear-gradient(135deg, var(--accent-green), #059669);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-right: 10px;
        }

        .play-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(72, 187, 120, 0.4);
        }

        button {
            background: linear-gradient(135deg, var(--gold), var(--gold-dim));
            color: var(--bg-deep);
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
        }

        button.secondary {
            background: linear-gradient(135deg, var(--cyan), var(--cyan-dim));
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .slider-value {
            margin-left: 10px;
            color: var(--gold);
            font-weight: 600;
            font-family: monospace;
        }

        .control-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .analysis-section {
            background: var(--bg-panel);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .analysis-title {
            font-weight: 600;
            color: var(--accent-purple);
            margin-bottom: 10px;
        }

        .gap-visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .gap-bar {
            height: 20px;
            background: var(--cyan);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            color: var(--bg-deep);
            font-weight: 600;
        }

        .tooltip {
            position: absolute;
            background: var(--bg-card);
            border: 2px solid var(--gold);
            padding: 10px;
            border-radius: 6px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 250px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .tooltip-title {
            font-weight: 600;
            color: var(--gold);
            margin-bottom: 5px;
        }

        .tooltip-content {
            font-size: 0.9em;
            color: var(--text-primary);
        }

        @media (max-width: 1400px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            .legend-sidebar {
                position: relative;
                top: 0;
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="toggleTheme()">Toggle Theme</button>
    <button class="fullscreen-toggle" onclick="toggleFullscreen()">Fullscreen</button>

    <div class="fullscreen-mode" id="fullscreenMode">
        <div class="fullscreen-content">
            <div class="fullscreen-canvas">
                <canvas id="fullscreenCanvas1" width="700" height="700"></canvas>
            </div>
            <div class="fullscreen-canvas">
                <canvas id="fullscreenCanvas2" width="700" height="700"></canvas>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip">
        <div class="tooltip-title" id="tooltipTitle"></div>
        <div class="tooltip-content" id="tooltipContent"></div>
    </div>

    <div class="container">
        <div class="header">
            <h1>Primitive Lattice Directions & Modular Circles</h1>
            <div class="subtitle">Enhanced Interactive Framework for GCD-Visibility and Gaussian Integers</div>
        </div>

        <div class="controls-panel">
            <div class="section-title">‚öô Global Controls & Filters</div>
            
            <div class="control-row">
                <div class="control-group">
                    <label>Modulus m: <span class="slider-value" id="modulusValue">8</span></label>
                    <input type="range" id="modulus" min="2" max="100" value="8" oninput="updateModulus()">
                    <div class="preset-buttons">
                        <button onclick="setMod(6)">m=6</button>
                        <button onclick="setMod(12)">m=12</button>
                        <button onclick="setMod(17)">m=17</button>
                        <button onclick="setMod(60)">m=60</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Lattice Range: <span class="slider-value" id="rangeValue">15</span></label>
                    <input type="range" id="latticeRange" min="5" max="50" value="15" oninput="updateRange()">
                </div>
            </div>

            <div class="control-row">
                <div class="control-group">
                    <label>Filter by Norm Range:</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="number" id="normMin" value="0" min="0" onchange="draw2()" style="width: 48%;" placeholder="Min">
                        <input type="number" id="normMax" value="1000" min="1" onchange="draw2()" style="width: 48%;" placeholder="Max">
                    </div>
                </div>

                <div class="control-group">
                    <label>Highlight Symmetries:</label>
                    <select id="symmetryMode" onchange="draw2()">
                        <option value="none">None</option>
                        <option value="rotational">Rotational (4-fold)</option>
                        <option value="reflection">Reflection Axes</option>
                        <option value="both">Both</option>
                    </select>
                </div>
            </div>

            <div class="animation-controls">
                <div class="subsection-title">üé¨ Animation Controls</div>
                <button class="play-button" onclick="toggleAnimation()">‚ñ∂ Start Animation</button>
                <button onclick="stepModulus(1)">Step +1</button>
                <button onclick="stepModulus(-1)">Step -1</button>
                <span style="margin-left: 15px; color: var(--text-secondary);">Speed:</span>
                <input type="range" id="animSpeed" min="100" max="2000" value="500" style="width: 150px; display: inline-block; margin-left: 10px;">
            </div>

            <!-- Gap Analysis System -->
            <div class="control-section" style="margin-top: 25px; padding: 20px; background: var(--bg-card); border-radius: 8px; border: 1px solid var(--border);">
                <div class="subsection-title">üìä Gap Analysis</div>
                
                <div id="gapControls" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 15px;">
                    <!-- Dynamically generated gap checkboxes -->
                </div>
                
                <div style="padding: 15px; background: rgba(255, 215, 0, 0.05); border-radius: 6px; border: 1px solid rgba(255, 215, 0, 0.2);">
                    <label style="font-weight: 600; color: var(--gold);">Dynamic Gap Generation</label>
                    
                    <div style="margin-top: 10px; display: flex; align-items: center; gap: 10px;">
                        <label style="font-size: 0.9em;">Max Gap:</label>
                        <input type="number" id="maxGap" min="2" step="2" value="12" style="width: 70px; padding: 5px;">
                        <button onclick="generateGaps()" style="padding: 5px 12px; font-size: 0.9em;">Generate</button>
                    </div>
                    
                    <div style="margin-top: 10px;">
                        <label style="font-size: 0.9em; font-weight: 600;">Add Consecutive Range:</label>
                        <div style="display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                            <span style="font-size: 0.85em;">From:</span>
                            <input type="number" id="gapStart" min="2" value="14" style="width: 60px; padding: 5px;">
                            <span style="font-size: 0.85em;">To:</span>
                            <input type="number" id="gapEnd" min="3" value="20" style="width: 60px; padding: 5px;">
                            <button onclick="addConsecutiveGaps()" style="padding: 5px 10px; font-size: 0.85em;">Add Range</button>
                        </div>
                    </div>
                    
                    <div style="margin-top: 10px;">
                        <button onclick="clearAllGaps()" style="padding: 5px 15px; font-size: 0.9em; background: var(--accent-red);">Clear All Gaps</button>
                    </div>
                </div>
            </div>

            <!-- Smith Chart Transform -->
            <div class="control-section" style="margin-top: 25px; padding: 20px; background: var(--bg-card); border-radius: 8px; border: 1px solid var(--border);">
                <div class="subsection-title">üîÑ Smith Chart Transform (Cayley Map)</div>
                
                <div class="checkbox-group" style="margin-bottom: 15px;">
                    <input type="checkbox" id="enableSmithChart" onchange="toggleSmithChart()">
                    <label for="enableSmithChart">Enable Smith Chart Transform</label>
                </div>
                
                <div id="smithChartControls" style="display: none;">
                    <div class="control-group" style="margin-bottom: 12px;">
                        <label>Global Phase Shift Œ±: <span id="smithAlphaValue" class="slider-value">90</span>¬∞</label>
                        <input type="range" id="smithAlpha" min="0" max="360" value="90" oninput="updateSmithChart()">
                    </div>
                    
                    <div class="control-group" style="margin-bottom: 12px;">
                        <label>Radius Mode:</label>
                        <select id="smithRadiusMode" onchange="updateSmithChart()">
                            <option value="unit">Unit (R=1)</option>
                            <option value="scaled" selected>Scaled (0.5-2.0)</option>
                            <option value="modulus">By Modulus</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                    
                    <div id="smithCustomScaleGroup" class="control-group" style="display: none; margin-bottom: 12px;">
                        <label>Custom Scale: <span id="smithScaleValue" class="slider-value">1.0</span></label>
                        <input type="range" id="smithScale" min="0.1" max="5" step="0.1" value="1.0" oninput="updateSmithScale()">
                    </div>
                    
                    <div class="checkbox-group" style="margin-bottom: 10px;">
                        <input type="checkbox" id="smithShowGrid" checked onchange="draw1()">
                        <label for="smithShowGrid">Show Smith Grid</label>
                    </div>
                    
                    <div style="margin-top: 12px; font-size: 0.85em; padding: 12px; background: rgba(0, 255, 255, 0.05); border-radius: 6px; border: 1px solid rgba(0, 255, 255, 0.2); line-height: 1.6;">
                        <strong style="color: var(--cyan);">Cayley/Smith Transform:</strong><br>
                        Œì = (z - 1)/(z + 1)<br>
                        <span style="opacity: 0.8;">
                        ‚Ä¢ R=1: Points map to vertical line<br>
                        ‚Ä¢ R&lt;1: Interior of circle<br>
                        ‚Ä¢ R&gt;1: Smith chart arcs
                        </span>
                    </div>
                </div>
            </div>

            <!-- Lift Dynamics -->
            <div class="control-section" style="margin-top: 25px; padding: 20px; background: var(--bg-card); border-radius: 8px; border: 1px solid var(--border);">
                <div class="subsection-title">‚¨ÜÔ∏è Lift Dynamics</div>
                
                <div class="checkbox-group" style="margin-bottom: 10px;">
                    <input type="checkbox" id="showDirectLifts" checked onchange="draw1()">
                    <label for="showDirectLifts">Direct Lifts (r ‚Üí r, consecutive m)</label>
                </div>
                
                <div class="checkbox-group" style="margin-bottom: 15px;">
                    <input type="checkbox" id="showModularLifts" onchange="draw1()">
                    <label for="showModularLifts">Modular Lifts (r ‚Üí r + m, consecutive m)</label>
                </div>
                
                <div class="control-group" style="margin-bottom: 12px;">
                    <label>Lift Line Thickness: <span id="liftThicknessValue" class="slider-value">2.0</span></label>
                    <input type="range" id="liftThickness" min="0.5" max="5" step="0.5" value="2" oninput="updateLiftThickness()">
                </div>
                
                <div style="margin-top: 12px; font-size: 0.85em; padding: 12px; background: rgba(72, 187, 120, 0.05); border-radius: 6px; border: 1px solid rgba(72, 187, 120, 0.2); line-height: 1.6;">
                    <strong style="color: var(--accent-green);">Lift Types:</strong><br>
                    <span style="opacity: 0.8;">
                    <strong style="color: var(--gold);">Direct Lifts:</strong> How residues r connect between m and m+1<br>
                    <strong style="color: #FF6384;">Modular Lifts:</strong> r ‚Üí (r + m) mod (m+1) transformations
                    </span>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="canvas-section">
                <!-- Canvas 1 -->
                <div class="canvas-panel">
                    <div class="canvas-header">
                        <div class="canvas-title">Canvas 1: Modular Circle</div>
                        <div class="independent-toggle">
                            <input type="checkbox" id="c1Ind" onchange="toggleC1Ind()">
                            <label for="c1Ind">Independent</label>
                        </div>
                    </div>

                    <div id="c1IndControls" style="display:none;">
                        <div class="canvas-controls">
                            <label>Canvas 1 Modulus: <span class="slider-value" id="c1ModVal">8</span></label>
                            <input type="range" id="c1Mod" min="2" max="100" value="8" oninput="updateC1()">
                        </div>
                    </div>

                    <div class="canvas-controls">
                        <div class="subsection-title">Display Options</div>
                        
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                            <div class="checkbox-group">
                                <input type="checkbox" id="c1ShowCircle" checked onchange="draw1()">
                                <label for="c1ShowCircle">Circle</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="c1ShowPoints" checked onchange="draw1()">
                                <label for="c1ShowPoints">Points</label>
                            </div>
                        </div>

                        <div class="control-group" style="margin-top: 10px;">
                            <label>Label Format:</label>
                            <select id="c1LabelFormat" onchange="draw1()">
                                <option value="none">None</option>
                                <option value="r" selected>r (residue)</option>
                                <option value="gcd">gcd(r,m)</option>
                                <option value="theta">Œ∏ (radians)</option>
                                <option value="ratio">r/m</option>
                                <option value="deg">Œ∏ (degrees)</option>
                            </select>
                        </div>

                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 10px;">
                            <div class="checkbox-group">
                                <input type="checkbox" id="c1ShowPoly" checked onchange="draw1()">
                                <label for="c1ShowPoly">Polygon</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="c1ShowGrid" onchange="draw1()">
                                <label for="c1ShowGrid">Grid</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="c1ShowAxes" checked onchange="draw1()">
                                <label for="c1ShowAxes">Axes</label>
                            </div>
                        </div>

                        <div class="control-group" style="margin-top: 15px;">
                            <label>Color Scheme:</label>
                            <select id="c1Color" onchange="draw1()">
                                <option value="default">Default (Cyan/Red)</option>
                                <option value="rainbow">Rainbow Spectrum</option>
                                <option value="heatmap">Heatmap</option>
                                <option value="monochrome">Monochrome Gold</option>
                            </select>
                        </div>

                        <div class="control-group">
                            <label>Point Size: <span class="slider-value" id="c1PSizeVal">5</span>px</label>
                            <input type="range" id="c1PSize" min="2" max="15" value="5" oninput="updateC1PSize()">
                        </div>
                    </div>

                    <canvas id="canvas1" width="700" height="700"></canvas>
                </div>

                <!-- Canvas 2 -->
                <div class="canvas-panel">
                    <div class="canvas-header">
                        <div class="canvas-title">Canvas 2: Lattice Directions</div>
                        <div class="independent-toggle">
                            <input type="checkbox" id="c2Ind" onchange="toggleC2Ind()">
                            <label for="c2Ind">Independent</label>
                        </div>
                    </div>

                    <div id="c2IndControls" style="display:none;">
                        <div class="canvas-controls">
                            <div class="control-row">
                                <div>
                                    <label>Canvas 2 Modulus: <span class="slider-value" id="c2ModVal">8</span></label>
                                    <input type="range" id="c2Mod" min="2" max="100" value="8" oninput="updateC2()">
                                </div>
                                <div>
                                    <label>Canvas 2 Range: <span class="slider-value" id="c2RangeVal">15</span></label>
                                    <input type="range" id="c2Range" min="5" max="50" value="15" oninput="updateC2()">
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="canvas-controls">
                        <div class="subsection-title">View Mode</div>
                        
                        <div class="checkbox-group">
                            <input type="checkbox" id="c2Invert" onchange="toggleInvert()">
                            <label for="c2Invert">Invert to Concentric Rings</label>
                        </div>

                        <div id="invertOptions" style="display:none;">
                            <div class="control-group">
                                <label>Ring Mode:</label>
                                <select id="ringMode" onchange="draw2()">
                                    <option value="standard">Standard (small inner)</option>
                                    <option value="inverse">Inverse (small outer)</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Max Modulus: <span class="slider-value" id="maxModVal">20</span></label>
                                <input type="range" id="maxMod" min="5" max="100" value="20" oninput="updateMaxMod()">
                            </div>
                        </div>

                        <div class="subsection-title">Display Options</div>
                        
                        <div class="control-group">
                            <label>Display Mode:</label>
                            <select id="c2Display" onchange="draw2()">
                                <option value="all">All Primitive</option>
                                <option value="primes">Prime Norms</option>
                                <option value="specific">Specific Norm</option>
                            </select>
                        </div>

                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 15px;">
                            <div class="checkbox-group">
                                <input type="checkbox" id="c2ShowLattice" checked onchange="draw2()">
                                <label for="c2ShowLattice">Points</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="c2ShowLines" checked onchange="draw2()">
                                <label for="c2ShowLines">Lines</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="c2ShowCircle" checked onchange="draw2()">
                                <label for="c2ShowCircle">Circle</label>
                            </div>
                        </div>

                        <div class="control-group" style="margin-top: 10px;">
                            <label>Label Format:</label>
                            <select id="c2LabelFormat" onchange="draw2()">
                                <option value="none">None</option>
                                <option value="coords" selected>(a,b) coords</option>
                                <option value="norm">Norm (a¬≤+b¬≤)</option>
                                <option value="gcd">gcd(a,b)</option>
                                <option value="theta">Œ∏ (radians)</option>
                                <option value="deg">Œ∏ (degrees)</option>
                            </select>
                        </div>

                        <div class="control-group" style="margin-top: 15px;">
                            <label>Color Scheme:</label>
                            <select id="c2Color" onchange="draw2()">
                                <option value="default">Default</option>
                                <option value="rainbow">Rainbow</option>
                                <option value="normBased">Norm-Based</option>
                                <option value="gcdBased">GCD-Based</option>
                            </select>
                        </div>

                        <div class="control-row">
                            <div>
                                <label>Point: <span class="slider-value" id="c2PSizeVal">5</span>px</label>
                                <input type="range" id="c2PSize" min="2" max="15" value="5" oninput="updateC2PSize()">
                            </div>
                            <div>
                                <label>Zoom: <span class="slider-value" id="zoomVal">100</span>%</label>
                                <input type="range" id="zoom" min="50" max="300" value="100" oninput="updateZoom()">
                            </div>
                        </div>
                    </div>

                    <canvas id="canvas2" width="700" height="700"></canvas>
                </div>
            </div>

            <!-- Right Sidebar - Detailed Legend & Analysis -->
            <div class="legend-sidebar">
                <div class="section-title">üìä Detailed Analysis & Legend</div>

                <div id="inspectionPanel" class="inspection-panel" style="display:none;">
                    <div class="inspection-title">üîç Inspected Point</div>
                    <div class="property-grid" id="inspectionDetails"></div>
                </div>

                <div class="subsection-title">Canvas 1: Modular Circle</div>
                <div id="legend1Details"></div>

                <div class="subsection-title">Canvas 2: Lattice Directions</div>
                <div id="legend2Details"></div>

                <div class="analysis-section">
                    <div class="analysis-title">Gap Analysis</div>
                    <div id="gapAnalysis"></div>
                </div>

                <div class="analysis-section">
                    <div class="analysis-title">Symmetry Properties</div>
                    <div id="symmetryAnalysis"></div>
                </div>

                <div class="analysis-section">
                    <div class="analysis-title">Distribution Statistics</div>
                    <div id="distributionStats"></div>
                </div>
            </div>
        </div>

        <div class="stats-panel" style="background: var(--bg-card); padding: 25px; border-radius: 12px; margin-bottom: 30px; border-left: 4px solid var(--gold);">
            <div class="section-title">üìä Global Statistics</div>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                <div style="background: var(--bg-panel); padding: 15px; border-radius: 8px; border: 1px solid var(--border);">
                    <div style="font-size: 0.9em; color: var(--text-secondary); margin-bottom: 5px;">Canvas 1 Modulus</div>
                    <div style="font-size: 1.3em; font-weight: 600; color: var(--cyan); font-family: monospace;" id="statMod1">8</div>
                </div>
                <div style="background: var(--bg-panel); padding: 15px; border-radius: 8px; border: 1px solid var(--border);">
                    <div style="font-size: 0.9em; color: var(--text-secondary); margin-bottom: 5px;">Canvas 2 Modulus</div>
                    <div style="font-size: 1.3em; font-weight: 600; color: var(--cyan); font-family: monospace;" id="statMod2">8</div>
                </div>
                <div style="background: var(--bg-panel); padding: 15px; border-radius: 8px; border: 1px solid var(--border);">
                    <div style="font-size: 0.9em; color: var(--text-secondary); margin-bottom: 5px;">œÜ(m) - Euler's Totient</div>
                    <div style="font-size: 1.3em; font-weight: 600; color: var(--cyan); font-family: monospace;" id="statTotient">4</div>
                </div>
                <div style="background: var(--bg-panel); padding: 15px; border-radius: 8px; border: 1px solid var(--border);">
                    <div style="font-size: 0.9em; color: var(--text-secondary); margin-bottom: 5px;">Coprime Density</div>
                    <div style="font-size: 1.3em; font-weight: 600; color: var(--cyan); font-family: monospace;" id="statDensity">0.5000</div>
                </div>
            </div>
        </div>

        <div class="theory-panel" style="background: var(--bg-card); padding: 25px; border-radius: 12px; margin-bottom: 30px; border-left: 4px solid var(--accent-purple);">
            <div class="section-title" style="color: var(--accent-purple);">üìê Theoretical Foundation</div>
            
            <p style="margin-bottom: 15px; color: var(--text-primary);"><strong>Visibility Indicator:</strong> For any lattice point (a,b), we define:</p>
            <div style="background: var(--bg-panel); padding: 15px; border-radius: 8px; margin: 15px 0; text-align: center; font-family: 'Courier New', monospace; font-size: 1.1em; color: var(--cyan); border: 1px solid var(--border);">
                vis(a,b) = 1 if gcd(a,b) = 1, else 0
            </div>
            <p style="margin-bottom: 15px; color: var(--text-primary);">Primitive lattice vectors with vis(a,b) = 1 determine rays from the origin that hit no other lattice point before reaching (a,b).</p>
            
            <p style="margin-bottom: 15px; color: var(--text-primary);"><strong>Modular Embedding:</strong> Each reduced residue r with gcd(r,m) = 1 maps to the unit circle:</p>
            <div style="background: var(--bg-panel); padding: 15px; border-radius: 8px; margin: 15px 0; text-align: center; font-family: 'Courier New', monospace; font-size: 1.1em; color: var(--cyan); border: 1px solid var(--border);">
                r ‚Üí e<sup>2œÄir/m</sup>
            </div>
            
            <p style="margin-bottom: 15px; color: var(--text-primary);"><strong>Norm and Gaussian Integers:</strong> A primitive vector (a,b) with norm n = a¬≤ + b¬≤ corresponds to the Gaussian integer a + bi with |a + bi|¬≤ = n.</p>
            
            <p style="margin-bottom: 15px; color: var(--text-primary);"><strong>Prime Norm Uniqueness:</strong> If a¬≤ + b¬≤ = p where p is prime and p ‚â° 1 (mod 4), the representation is unique up to signs and coordinate swap.</p>
            
            <p style="color: var(--text-primary);"><strong>Basel Problem Connection:</strong> The limiting density of coprime pairs approaches 6/œÄ¬≤ ‚âà 0.6079, known as the Basel constant.</p>
        </div>

        <div class="export-panel" style="background: var(--bg-card); padding: 25px; border-radius: 12px; margin-bottom: 30px;">
            <div class="section-title">üíæ Export Visualizations</div>
            
            <div class="resolution-selector">
                <button class="resolution-btn" onclick="setRes('2k')">2K (2048px)</button>
                <button class="resolution-btn active" onclick="setRes('4k')">4K (3840px)</button>
                <button class="resolution-btn" onclick="setRes('8k')">8K (7680px)</button>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 20px;">
                <button onclick="exportPNG('canvas1')">Export Canvas 1 PNG</button>
                <button onclick="exportPNG('canvas2')">Export Canvas 2 PNG</button>
                <button class="secondary" onclick="exportBoth()">Export Both PNG</button>
                <button onclick="exportCSV('canvas1')">Export Canvas 1 CSV</button>
                <button onclick="exportCSV('canvas2')">Export Canvas 2 CSV</button>
                <button class="secondary" onclick="exportAllCSV()">Export Complete CSV</button>
            </div>
        </div>

        <div style="text-align: center; padding: 25px; background: var(--bg-card); border-radius: 12px; border: 1px solid var(--border); color: var(--text-secondary);">
            <p><strong>Primitive Lattice Directions & Modular Circles</strong></p>
            <p>A geometric framework unifying GCD-visibility, reduced residues, and Gaussian integers</p>
            <p style="margin-top: 15px;">Created by <a href="https://twitter.com/7dview" target="_blank" style="color: var(--cyan); text-decoration: none;">Wessen Getachew (@7dview)</a> | 
            <a href="https://github.com/wessengetachew" target="_blank" style="color: var(--cyan); text-decoration: none;">GitHub</a></p>
        </div>
    </div>

    <script>
        let theme = 'dark';
        let c2Inverted = false;
        let c2Zoom = 1.0;
        let animating = false;
        let animInterval = null;
        let selectedPoint = null;

        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b) {
                let t = b;
                b = a % b;
                a = t;
            }
            return a;
        }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        function eulerTotient(n) {
            let result = 0;
            for (let i = 1; i < n; i++) {
                if (gcd(i, n) === 1) result++;
            }
            return result;
        }

        function getResidues(m) {
            return Array.from({length: m}, (_, i) => i).filter(r => r > 0 && gcd(r, m) === 1);
        }

        function getLatticePoints(range) {
            const pts = [];
            for (let a = -range; a <= range; a++) {
                for (let b = -range; b <= range; b++) {
                    if (a === 0 && b === 0) continue;
                    if (gcd(a, b) === 1) {
                        const norm = a * a + b * b;
                        pts.push({a, b, norm, gcdVal: 1, isPrime: isPrime(norm)});
                    }
                }
            }
            return pts;
        }

        function factorize(n) {
            const factors = [];
            let d = 2;
            while (d * d <= n) {
                while (n % d === 0) {
                    factors.push(d);
                    n /= d;
                }
                d++;
            }
            if (n > 1) factors.push(n);
            return factors;
        }

        function getColor(scheme, val, max, isReduced, isPrime) {
            if (scheme === 'rainbow') {
                const h = (val / max) * 360;
                return `hsl(${h}, 80%, 60%)`;
            } else if (scheme === 'heatmap') {
                const r = Math.floor((val / max) * 255);
                const b = 255 - r;
                return `rgb(${r}, 0, ${b})`;
            } else if (scheme === 'monochrome') {
                return theme === 'dark' ? '#FFD700' : '#d69e00';
            } else {
                if (isPrime) return theme === 'dark' ? '#FFD700' : '#d69e00';
                return isReduced ? 
                    (theme === 'dark' ? '#00FFFF' : '#0891b2') : 
                    (theme === 'dark' ? '#e74c3c' : '#dc2626');
            }
        }

        function toggleTheme() {
            theme = theme === 'dark' ? 'light' : 'dark';
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            draw1();
            draw2();
        }

        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            theme = savedTheme;
            document.body.setAttribute('data-theme', theme);
        }

        function updateModulus() {
            const m = document.getElementById('modulus').value;
            document.getElementById('modulusValue').textContent = m;
            if (!document.getElementById('c1Ind').checked) {
                document.getElementById('c1Mod').value = m;
                document.getElementById('c1ModVal').textContent = m;
            }
            if (!document.getElementById('c2Ind').checked) {
                document.getElementById('c2Mod').value = m;
                document.getElementById('c2ModVal').textContent = m;
            }
            draw1();
            draw2();
        }

        function updateRange() {
            const r = document.getElementById('latticeRange').value;
            document.getElementById('rangeValue').textContent = r;
            if (!document.getElementById('c2Ind').checked) {
                document.getElementById('c2Range').value = r;
                document.getElementById('c2RangeVal').textContent = r;
            }
            draw2();
        }

        function setMod(m) {
            document.getElementById('modulus').value = m;
            updateModulus();
        }

        function toggleC1Ind() {
            const isInd = document.getElementById('c1Ind').checked;
            document.getElementById('c1IndControls').style.display = isInd ? 'block' : 'none';
            draw1();
        }

        function toggleC2Ind() {
            const isInd = document.getElementById('c2Ind').checked;
            document.getElementById('c2IndControls').style.display = isInd ? 'block' : 'none';
            draw2();
        }

        function toggleInvert() {
            c2Inverted = document.getElementById('c2Invert').checked;
            document.getElementById('invertOptions').style.display = c2Inverted ? 'block' : 'none';
            draw2();
        }

        function updateC1() {
            const m = document.getElementById('c1Mod').value;
            document.getElementById('c1ModVal').textContent = m;
            draw1();
        }

        function updateC2() {
            const m = document.getElementById('c2Mod').value;
            const r = document.getElementById('c2Range').value;
            document.getElementById('c2ModVal').textContent = m;
            document.getElementById('c2RangeVal').textContent = r;
            draw2();
        }

        function updateMaxMod() {
            const m = document.getElementById('maxMod').value;
            document.getElementById('maxModVal').textContent = m;
            draw2();
        }

        function updateZoom() {
            c2Zoom = document.getElementById('zoom').value / 100;
            document.getElementById('zoomVal').textContent = Math.round(c2Zoom * 100);
            draw2();
        }

        function updateC1PSize() {
            document.getElementById('c1PSizeVal').textContent = document.getElementById('c1PSize').value;
            draw1();
        }

        function updateC2PSize() {
            document.getElementById('c2PSizeVal').textContent = document.getElementById('c2PSize').value;
            draw2();
        }

        function toggleAnimation() {
            animating = !animating;
            const btn = event.target;
            if (animating) {
                btn.textContent = '‚è∏ Pause';
                const speed = parseInt(document.getElementById('animSpeed').value);
                animInterval = setInterval(() => {
                    stepModulus(1);
                }, speed);
            } else {
                btn.textContent = '‚ñ∂ Start';
                clearInterval(animInterval);
            }
        }

        function stepModulus(delta) {
            const modInput = document.getElementById('modulus');
            let val = parseInt(modInput.value) + delta;
            if (val < 2) val = 100;
            if (val > 100) val = 2;
            modInput.value = val;
            updateModulus();
        }

        function draw1() {
            const isInd = document.getElementById('c1Ind').checked;
            const m = isInd ? 
                parseInt(document.getElementById('c1Mod').value) :
                parseInt(document.getElementById('modulus').value);
            
            const canvas = document.getElementById('canvas1');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const cx = w/2, cy = h/2;
            const r = Math.min(w, h) * 0.35;
            
            const showCircle = document.getElementById('c1ShowCircle').checked;
            const showPoints = document.getElementById('c1ShowPoints').checked;
            const labelFormat = document.getElementById('c1LabelFormat').value;
            const showPoly = document.getElementById('c1ShowPoly').checked;
            const showGrid = document.getElementById('c1ShowGrid').checked;
            const showAxes = document.getElementById('c1ShowAxes').checked;
            const colorScheme = document.getElementById('c1Color').value;
            const pSize = parseFloat(document.getElementById('c1PSize').value);
            
            ctx.clearRect(0, 0, w, h);
            
            if (showGrid) {
                ctx.strokeStyle = theme === 'dark' ? '#2a3150' : '#cbd5e0';
                ctx.lineWidth = 0.5;
                for (let i = -1; i <= 1; i += 0.2) {
                    ctx.beginPath();
                    ctx.moveTo(cx + i * r, cy - r);
                    ctx.lineTo(cx + i * r, cy + r);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(cx - r, cy + i * r);
                    ctx.lineTo(cx + r, cy + i * r);
                    ctx.stroke();
                }
            }
            
            if (showCircle) {
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                ctx.strokeStyle = theme === 'dark' ? '#FFD700' : '#d69e00';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            if (showAxes) {
                ctx.strokeStyle = theme === 'dark' ? '#00FFFF' : '#0891b2';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx - r, cy);
                ctx.lineTo(cx + r, cy);
                ctx.moveTo(cx, cy - r);
                ctx.lineTo(cx, cy + r);
                ctx.stroke();
            }
            
            const residues = getResidues(m);
            
            if (showPoints) {
                for (let i = 0; i < m; i++) {
                    const isRed = residues.includes(i);
                    const ang = (2 * Math.PI * i / m) - Math.PI / 2;
                    const x = cx + r * Math.cos(ang);
                    const y = cy + r * Math.sin(ang);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, isRed ? pSize + 2 : pSize, 0, 2 * Math.PI);
                    const col = getColor(colorScheme, i, m, isRed, false);
                    ctx.fillStyle = col;
                    ctx.fill();
                    ctx.strokeStyle = theme === 'dark' ? '#E8E8E8' : '#1a202c';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    if (labelFormat !== 'none') {
                        ctx.fillStyle = theme === 'dark' ? '#E8E8E8' : '#1a202c';
                        ctx.font = 'bold 12px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        let labelText = '';
                        switch(labelFormat) {
                            case 'r':
                                labelText = i.toString();
                                break;
                            case 'gcd':
                                labelText = `gcd=${gcd(i, m)}`;
                                break;
                            case 'theta':
                                labelText = (ang + Math.PI/2).toFixed(2);
                                break;
                            case 'ratio':
                                labelText = `${i}/${m}`;
                                break;
                            case 'deg':
                                labelText = Math.round((ang + Math.PI/2) * 180 / Math.PI) + '¬∞';
                                break;
                        }
                        
                        ctx.fillText(labelText, cx + (r + 30) * Math.cos(ang), cy + (r + 30) * Math.sin(ang));
                    }
                }
            }
            
            if (showPoly && residues.length > 0) {
                ctx.strokeStyle = theme === 'dark' ? '#9F7AEA' : '#7c3aed';
                ctx.lineWidth = 3;
                ctx.beginPath();
                residues.forEach((ri, i) => {
                    const ang = (2 * Math.PI * ri / m) - Math.PI / 2;
                    const x = cx + r * Math.cos(ang);
                    const y = cy + r * Math.sin(ang);
                    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                });
                ctx.closePath();
                ctx.stroke();
            }
            
            // Draw Gap Analysis (after polygon, before Smith)
            drawGapAnalysis(ctx, m, cx, cy, r, residues, currentTheme);
            
            // Draw Lift Dynamics (shows connections to m+1)
            drawLifts(ctx, m, cx, cy, r, residues, currentTheme);
            
            // Draw Smith Chart Transform (last, so it's on top)
            drawSmithTransform(ctx, m, cx, cy, r, residues, pSize, currentTheme);
            
            updateLegend1(m, residues);
        }

        function draw2() {
            if (c2Inverted) {
                drawRings();
            } else {
                drawLattice();
            }
        }

        function drawLattice() {
            const isInd = document.getElementById('c2Ind').checked;
            const m = isInd ? 
                parseInt(document.getElementById('c2Mod').value) :
                parseInt(document.getElementById('modulus').value);
            
            const range = isInd ?
                parseInt(document.getElementById('c2Range').value) :
                parseInt(document.getElementById('latticeRange').value);
            
            const canvas = document.getElementById('canvas2');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const cx = w/2, cy = h/2;
            const scale = (Math.min(w, h) / (2 * range + 4)) * c2Zoom;
            
            const showLattice = document.getElementById('c2ShowLattice').checked;
            const showLines = document.getElementById('c2ShowLines').checked;
            const showCircle = document.getElementById('c2ShowCircle').checked;
            const labelFormat = document.getElementById('c2LabelFormat').value;
            const displayMode = document.getElementById('c2Display').value;
            const colorScheme = document.getElementById('c2Color').value;
            const pSize = parseFloat(document.getElementById('c2PSize').value);
            const normMin = parseInt(document.getElementById('normMin').value) || 0;
            const normMax = parseInt(document.getElementById('normMax').value) || 1000;
            const symmetryMode = document.getElementById('symmetryMode').value;
            
            ctx.clearRect(0, 0, w, h);
            
            ctx.strokeStyle = theme === 'dark' ? '#00FFFF' : '#0891b2';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(w, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, h);
            ctx.stroke();
            
            // Symmetry axes
            if (symmetryMode === 'reflection' || symmetryMode === 'both') {
                ctx.strokeStyle = theme === 'dark' ? '#9F7AEA' : '#7c3aed';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([5, 5]);
                // Diagonal axes
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(w, h);
                ctx.moveTo(0, h);
                ctx.lineTo(w, 0);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            if (showCircle) {
                ctx.beginPath();
                ctx.arc(cx, cy, scale, 0, 2 * Math.PI);
                ctx.strokeStyle = theme === 'dark' ? '#FFD700' : '#d69e00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            let pts = getLatticePoints(range);
            pts = pts.filter(p => p.norm >= normMin && p.norm <= normMax);
            
            if (displayMode === 'primes') pts = pts.filter(p => p.isPrime);
            if (displayMode === 'specific') pts = pts.filter(p => p.norm === m);
            
            let visCount = 0, primeCount = 0;
            
            pts.forEach(p => {
                const x = cx + p.a * scale;
                const y = cy - p.b * scale;
                
                if (showLines) {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(x, y);
                    
                    let lineColor;
                    if (colorScheme === 'rainbow') {
                        const idx = pts.indexOf(p);
                        lineColor = getColor('rainbow', idx, pts.length, false, false);
                    } else if (colorScheme === 'normBased') {
                        lineColor = getColor('heatmap', p.norm, 500, false, false);
                    } else if (colorScheme === 'gcdBased') {
                        lineColor = getColor('rainbow', p.gcdVal, 10, false, false);
                    } else if (p.isPrime) {
                        lineColor = theme === 'dark' ? '#FFD700' : '#d69e00';
                    } else {
                        lineColor = theme === 'dark' ? '#48BB78' : '#059669';
                    }
                    
                    ctx.strokeStyle = lineColor;
                    ctx.lineWidth = 1.5;
                    ctx.globalAlpha = 0.4;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                if (showLattice) {
                    ctx.beginPath();
                    ctx.arc(x, y, pSize, 0, 2 * Math.PI);
                    
                    let pointColor;
                    if (colorScheme === 'normBased') {
                        pointColor = getColor('heatmap', p.norm, 500, false, false);
                    } else if (colorScheme === 'rainbow') {
                        const idx = pts.indexOf(p);
                        pointColor = getColor('rainbow', idx, pts.length, false, false);
                    } else if (p.isPrime) {
                        pointColor = theme === 'dark' ? '#FFD700' : '#d69e00';
                    } else {
                        pointColor = theme === 'dark' ? '#48BB78' : '#059669';
                    }
                    
                    ctx.fillStyle = pointColor;
                    ctx.fill();
                    ctx.strokeStyle = theme === 'dark' ? '#E8E8E8' : '#1a202c';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    if (labelFormat !== 'none') {
                        ctx.fillStyle = theme === 'dark' ? '#E8E8E8' : '#1a202c';
                        ctx.font = 'bold 10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom';
                        
                        let labelText = '';
                        const angle = Math.atan2(p.b, p.a);
                        
                        switch(labelFormat) {
                            case 'coords':
                                labelText = `(${p.a},${p.b})`;
                                break;
                            case 'norm':
                                labelText = `${p.norm}`;
                                break;
                            case 'gcd':
                                labelText = `gcd=${gcd(p.a, p.b)}`;
                                break;
                            case 'theta':
                                labelText = angle.toFixed(2);
                                break;
                            case 'deg':
                                labelText = Math.round(angle * 180 / Math.PI) + '¬∞';
                                break;
                        }
                        
                        // Only label if not too crowded (optional spacing filter)
                        if (Math.abs(p.a) <= 8 && Math.abs(p.b) <= 8) {
                            ctx.fillText(labelText, x, y - 8);
                        }
                    }
                }
                
                const ang = Math.atan2(p.b, p.a);
                const ux = cx + scale * Math.cos(ang);
                const uy = cy - scale * Math.sin(ang);
                ctx.beginPath();
                ctx.arc(ux, uy, pSize + 1, 0, 2 * Math.PI);
                ctx.fillStyle = theme === 'dark' ? '#00FFFF' : '#0891b2';
                ctx.fill();
                ctx.strokeStyle = theme === 'dark' ? '#E8E8E8' : '#1a202c';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                visCount++;
                if (p.isPrime) primeCount++;
            });
            
            updateLegend2(pts, visCount, primeCount);
        }

        function drawRings() {
            const maxMod = parseInt(document.getElementById('maxMod').value);
            const ringMode = document.getElementById('ringMode').value;
            const labelFormat = document.getElementById('c2LabelFormat').value;
            const colorScheme = document.getElementById('c2Color').value;
            const pSize = parseFloat(document.getElementById('c2PSize').value);
            
            const canvas = document.getElementById('canvas2');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const cx = w/2, cy = h/2;
            const maxR = Math.min(w, h) * 0.4 * c2Zoom;
            const spacing = maxR / maxMod;
            
            ctx.clearRect(0, 0, w, h);
            
            ctx.strokeStyle = theme === 'dark' ? '#00FFFF' : '#0891b2';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(w, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, h);
            ctx.stroke();
            
            let totalPoints = 0;
            let coprimeCount = 0;
            
            for (let m = 2; m <= maxMod; m++) {
                const r = ringMode === 'standard' ? m * spacing : (maxMod - m + 2) * spacing;
                
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                ctx.strokeStyle = theme === 'dark' ? '#2a3150' : '#cbd5e0';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 2]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                const residues = getResidues(m);
                
                for (let ri = 0; ri < m; ri++) {
                    const isRed = residues.includes(ri);
                    const ang = (2 * Math.PI * ri / m) - Math.PI / 2;
                    const x = cx + r * Math.cos(ang);
                    const y = cy + r * Math.sin(ang);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, isRed ? pSize + 1 : pSize - 1, 0, 2 * Math.PI);
                    
                    let pointColor;
                    if (colorScheme === 'rainbow') {
                        pointColor = getColor('rainbow', ri, m, false, false);
                    } else if (colorScheme === 'normBased') {
                        pointColor = getColor('heatmap', ri, m, false, false);
                    } else {
                        pointColor = isRed ? 
                            (theme === 'dark' ? '#00FFFF' : '#0891b2') :
                            (theme === 'dark' ? '#e74c3c' : '#dc2626');
                    }
                    
                    ctx.fillStyle = pointColor;
                    ctx.fill();
                    ctx.strokeStyle = theme === 'dark' ? '#E8E8E8' : '#1a202c';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                    
                    if (showLabels && m <= 20) {
                        ctx.fillStyle = theme === 'dark' ? '#E8E8E8' : '#1a202c';
                        ctx.font = '9px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${ri}/${m}`, x, y - 8);
                    }
                    
                    totalPoints++;
                    if (isRed) coprimeCount++;
                }
                
                if (m <= 20) {
                    ctx.fillStyle = theme === 'dark' ? '#FFD700' : '#d69e00';
                    ctx.font = 'bold 11px sans-serif';
                    ctx.fillText(`m=${m}`, cx + r + 5, cy);
                }
            }
            
            updateLegend2Rings(maxMod, totalPoints, coprimeCount);
        }

        function updateLegend1(m, residues) {
            const container = document.getElementById('legend1Details');
            const totient = residues.length;
            const density = (totient / m).toFixed(4);
            const gaps = [];
            
            for (let i = 0; i < residues.length; i++) {
                const next = residues[(i + 1) % residues.length];
                const gap = (next > residues[i]) ? (next - residues[i]) : (m - residues[i] + next);
                gaps.push(gap);
            }
            
            const maxGap = Math.max(...gaps);
            const avgGap = (gaps.reduce((a, b) => a + b, 0) / gaps.length).toFixed(2);
            
            // Update global stats
            const isInd = document.getElementById('c1Ind').checked;
            const m1 = isInd ? 
                parseInt(document.getElementById('c1Mod').value) :
                parseInt(document.getElementById('modulus').value);
            document.getElementById('statMod1').textContent = m1;
            document.getElementById('statTotient').textContent = totient;
            document.getElementById('statDensity').textContent = density;
            
            container.innerHTML = `
                <div class="legend-item-detailed">
                    <div class="legend-color-box">
                        <div class="color-swatch" style="background: ${theme === 'dark' ? '#00FFFF' : '#0891b2'};"></div>
                        <div class="legend-label">Reduced Residues (Coprime)</div>
                    </div>
                    <div class="legend-description">
                        Points r where gcd(r, m) = 1. These are integers less than m that share no common factors with m. 
                        They form the group of units ‚Ñ§/m‚Ñ§* under multiplication.
                    </div>
                    <div class="legend-formula">œÜ(${m}) = ${totient}</div>
                    <div class="legend-stats">
                        <div class="stat-row">
                            <span class="stat-label">Density:</span>
                            <span class="stat-value">${density} ‚âà 6/œÄ¬≤ = 0.6079</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Residues:</span>
                            <span class="stat-value">${residues.join(', ')}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Max Gap:</span>
                            <span class="stat-value">${maxGap}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Avg Gap:</span>
                            <span class="stat-value">${avgGap}</span>
                        </div>
                    </div>
                </div>

                <div class="legend-item-detailed">
                    <div class="legend-color-box">
                        <div class="color-swatch" style="background: ${theme === 'dark' ? '#e74c3c' : '#dc2626'};"></div>
                        <div class="legend-label">Non-coprime Residues</div>
                    </div>
                    <div class="legend-description">
                        Points r where gcd(r, m) > 1. These share a common divisor with m and are not units in ‚Ñ§/m‚Ñ§.
                        Count: ${m - totient - 1} (excluding 0)
                    </div>
                </div>

                <div class="legend-item-detailed">
                    <div class="legend-color-box">
                        <div class="color-swatch" style="background: ${theme === 'dark' ? '#9F7AEA' : '#7c3aed'};"></div>
                        <div class="legend-label">Inscribed Polygon</div>
                    </div>
                    <div class="legend-description">
                        Connects all reduced residues sequentially. For prime m, forms a regular (m-1)-gon.
                        For m = 2^k, forms a regular polygon with œÜ(m) = 2^(k-1) sides.
                    </div>
                    <div class="legend-stats">
                        <div class="stat-row">
                            <span class="stat-label">Vertices:</span>
                            <span class="stat-value">${totient}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Symmetry:</span>
                            <span class="stat-value">${isPrime(m) ? 'Cyclic' : 'Varies'}</span>
                        </div>
                    </div>
                </div>
            `;
            
            updateGapAnalysis(gaps);
        }

        function updateLegend2(pts, visCount, primeCount) {
            const container = document.getElementById('legend2Details');
            const avgNorm = (pts.reduce((sum, p) => sum + p.norm, 0) / pts.length).toFixed(2);
            const primePercent = ((primeCount / visCount) * 100).toFixed(1);
            
            // Update global stats
            const isInd = document.getElementById('c2Ind').checked;
            const m2 = isInd ? 
                parseInt(document.getElementById('c2Mod').value) :
                parseInt(document.getElementById('modulus').value);
            document.getElementById('statMod2').textContent = m2;
            
            container.innerHTML = `
                <div class="legend-item-detailed">
                    <div class="legend-color-box">
                        <div class="color-swatch" style="background: ${theme === 'dark' ? '#48BB78' : '#059669'};"></div>
                        <div class="legend-label">Primitive Vectors</div>
                    </div>
                    <div class="legend-description">
                        Lattice vectors (a, b) where gcd(a, b) = 1. These are "visible" from the origin‚Äîno other 
                        lattice point lies on the segment from (0,0) to (a,b).
                    </div>
                    <div class="legend-formula">vis(a,b) = 1 ‚ü∫ gcd(a,b) = 1</div>
                    <div class="legend-stats">
                        <div class="stat-row">
                            <span class="stat-label">Count:</span>
                            <span class="stat-value">${visCount}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Average Norm:</span>
                            <span class="stat-value">${avgNorm}</span>
                        </div>
                    </div>
                </div>

                <div class="legend-item-detailed">
                    <div class="legend-color-box">
                        <div class="color-swatch" style="background: ${theme === 'dark' ? '#FFD700' : '#d69e00'};"></div>
                        <div class="legend-label">Prime Norm Vectors</div>
                    </div>
                    <div class="legend-description">
                        Primitive vectors where a¬≤ + b¬≤ = p (prime). By Fermat's theorem, primes p ‚â° 1 (mod 4) 
                        can be uniquely expressed as a sum of two squares (up to order and signs).
                    </div>
                    <div class="legend-formula">|a + bi|¬≤ = a¬≤ + b¬≤ = p (prime)</div>
                    <div class="legend-stats">
                        <div class="stat-row">
                            <span class="stat-label">Prime Norms:</span>
                            <span class="stat-value">${primeCount}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Percentage:</span>
                            <span class="stat-value">${primePercent}%</span>
                        </div>
                    </div>
                </div>

                <div class="legend-item-detailed">
                    <div class="legend-color-box">
                        <div class="color-swatch" style="background: ${theme === 'dark' ? '#00FFFF' : '#0891b2'};"></div>
                        <div class="legend-label">Unit Circle Projection</div>
                    </div>
                    <div class="legend-description">
                        Each primitive vector normalized to the unit circle at angle Œ∏ = atan2(b, a).
                        Shows the directional distribution of visible lattice rays.
                    </div>
                    <div class="legend-formula">(a,b) ‚Üí (cos Œ∏, sin Œ∏) where Œ∏ = atan2(b,a)</div>
                </div>
            `;
            
            updateSymmetryAnalysis(pts);
            updateDistributionStats(pts);
        }

        function updateLegend2Rings(maxMod, totalPoints, coprimeCount) {
            const container = document.getElementById('legend2Details');
            const density = (coprimeCount / totalPoints).toFixed(4);
            
            container.innerHTML = `
                <div class="legend-item-detailed">
                    <div class="legend-color-box">
                        <div class="color-swatch" style="background: ${theme === 'dark' ? '#00FFFF' : '#0891b2'};"></div>
                        <div class="legend-label">Concentric Ring Structure</div>
                    </div>
                    <div class="legend-description">
                        Displays all moduli from m=2 to m=${maxMod}. Each ring represents a different modulus, 
                        with points at positions r‚ãÖe^(2œÄik/m) for k = 0, 1, ..., m-1.
                    </div>
                    <div class="legend-stats">
                        <div class="stat-row">
                            <span class="stat-label">Total Rings:</span>
                            <span class="stat-value">${maxMod - 1}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Total Points:</span>
                            <span class="stat-value">${totalPoints}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Coprime Points:</span>
                            <span class="stat-value">${coprimeCount}</span>
                        </div>
                        <div class="stat-row">
                            <span class="stat-label">Overall Density:</span>
                            <span class="stat-value">${density}</span>
                        </div>
                    </div>
                </div>
            `;
        }

        function updateGapAnalysis(gaps) {
            const container = document.getElementById('gapAnalysis');
            const gapCounts = {};
            gaps.forEach(g => {
                gapCounts[g] = (gapCounts[g] || 0) + 1;
            });
            
            let html = '<div class="gap-visualization">';
            for (const [gap, count] of Object.entries(gapCounts).sort((a, b) => a[0] - b[0])) {
                const width = (count / gaps.length) * 100;
                html += `<div class="gap-bar" style="width: ${Math.max(width, 15)}%; background: hsl(${180 + gap * 30}, 70%, 60%)">${gap}: ${count}</div>`;
            }
            html += '</div>';
            
            html += `<div class="legend-description" style="margin-top: 10px;">
                Gap distribution between consecutive reduced residues. Gaps reveal arithmetic structure of the modulus.
            </div>`;
            
            container.innerHTML = html;
        }

        function updateSymmetryAnalysis(pts) {
            const container = document.getElementById('symmetryAnalysis');
            
            // Count quadrants
            const quadrants = [0, 0, 0, 0];
            pts.forEach(p => {
                if (p.a >= 0 && p.b >= 0) quadrants[0]++;
                else if (p.a < 0 && p.b >= 0) quadrants[1]++;
                else if (p.a < 0 && p.b < 0) quadrants[2]++;
                else quadrants[3]++;
            });
            
            const isSymmetric = quadrants.every(q => q === quadrants[0]);
            
            container.innerHTML = `
                <div class="stat-row">
                    <span class="stat-label">4-fold Symmetry:</span>
                    <span class="stat-value">${isSymmetric ? 'Yes' : 'Approximate'}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Q1 (++):</span>
                    <span class="stat-value">${quadrants[0]}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Q2 (-+):</span>
                    <span class="stat-value">${quadrants[1]}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Q3 (--):</span>
                    <span class="stat-value">${quadrants[2]}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Q4 (+-):</span>
                    <span class="stat-value">${quadrants[3]}</span>
                </div>
                <div class="legend-description" style="margin-top: 10px;">
                    Primitive lattice points exhibit natural 4-fold rotational symmetry: if (a,b) is primitive, 
                    so are (-b,a), (-a,-b), and (b,-a).
                </div>
            `;
        }

        function updateDistributionStats(pts) {
            const container = document.getElementById('distributionStats');
            
            const norms = pts.map(p => p.norm);
            const minNorm = Math.min(...norms);
            const maxNorm = Math.max(...norms);
            const medianNorm = norms.sort((a, b) => a - b)[Math.floor(norms.length / 2)];
            
            // Norm distribution by ranges
            const ranges = [
                {label: '0-50', count: norms.filter(n => n <= 50).length},
                {label: '51-100', count: norms.filter(n => n > 50 && n <= 100).length},
                {label: '101-200', count: norms.filter(n => n > 100 && n <= 200).length},
                {label: '200+', count: norms.filter(n => n > 200).length}
            ];
            
            container.innerHTML = `
                <div class="stat-row">
                    <span class="stat-label">Min Norm:</span>
                    <span class="stat-value">${minNorm}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Median Norm:</span>
                    <span class="stat-value">${medianNorm}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Max Norm:</span>
                    <span class="stat-value">${maxNorm}</span>
                </div>
                ${ranges.map(r => `
                    <div class="stat-row">
                        <span class="stat-label">Norm ${r.label}:</span>
                        <span class="stat-value">${r.count}</span>
                    </div>
                `).join('')}
                <div class="legend-description" style="margin-top: 10px;">
                    Norm distribution shows how primitive vectors spread across distance ranges from origin.
                </div>
            `;
        }

        // Click inspection
        document.getElementById('canvas1').addEventListener('click', function(e) {
            const rect = this.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const isInd = document.getElementById('c1Ind').checked;
            const m = isInd ? 
                parseInt(document.getElementById('c1Mod').value) :
                parseInt(document.getElementById('modulus').value);
            
            const cx = this.width / 2;
            const cy = this.height / 2;
            const r = Math.min(this.width, this.height) * 0.35;
            
            // Find clicked point
            for (let i = 0; i < m; i++) {
                const ang = (2 * Math.PI * i / m) - Math.PI / 2;
                const px = cx + r * Math.cos(ang);
                const py = cy + r * Math.sin(ang);
                
                if (Math.abs(x - px) < 15 && Math.abs(y - py) < 15) {
                    showInspection1(i, m);
                    return;
                }
            }
        });

        function showInspection1(r, m) {
            const panel = document.getElementById('inspectionPanel');
            const details = document.getElementById('inspectionDetails');
            const g = gcd(r, m);
            const isCoprime = g === 1;
            const angle = (2 * Math.PI * r / m);
            
            details.innerHTML = `
                <span class="property-label">Residue:</span>
                <span class="property-value">${r}</span>
                <span class="property-label">Modulus:</span>
                <span class="property-value">${m}</span>
                <span class="property-label">GCD(r, m):</span>
                <span class="property-value">${g}</span>
                <span class="property-label">Coprime:</span>
                <span class="property-value">${isCoprime ? 'Yes' : 'No'}</span>
                <span class="property-label">Angle:</span>
                <span class="property-value">${(angle * 180 / Math.PI).toFixed(2)}¬∞</span>
                <span class="property-label">e^(2œÄir/m):</span>
                <span class="property-value">${Math.cos(angle).toFixed(3)} + ${Math.sin(angle).toFixed(3)}i</span>
            `;
            
            panel.style.display = 'block';
        }

        draw1();
        draw2();

        // Export functions
        let exportRes = 3840;

        function setRes(res) {
            const buttons = document.querySelectorAll('.resolution-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            switch(res) {
                case '2k': exportRes = 2048; break;
                case '4k': exportRes = 3840; break;
                case '8k': exportRes = 7680; break;
            }
        }

        function exportPNG(canvasId) {
            const canvas = document.getElementById(canvasId);
            const num = canvasId === 'canvas1' ? 1 : 2;
            const title = num === 1 ? 'Canvas 1: Modular Circle' : 'Canvas 2: Lattice Directions';
            
            // Get legend data
            const legendContainer = document.getElementById(num === 1 ? 'legend1Details' : 'legend2Details');
            const legendItems = legendContainer.querySelectorAll('.legend-item-detailed');
            
            const temp = document.createElement('canvas');
            const pad = 200;
            const legH = 150 + legendItems.length * 120;
            temp.width = exportRes + pad * 2;
            temp.height = exportRes + pad + legH;
            
            const ctx = temp.getContext('2d');
            ctx.fillStyle = theme === 'dark' ? '#0a0e1a' : '#ffffff';
            ctx.fillRect(0, 0, temp.width, temp.height);
            
            ctx.fillStyle = theme === 'dark' ? '#FFD700' : '#d69e00';
            ctx.font = 'bold 70px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(title, temp.width / 2, pad / 2 + 30);
            
            const scale = exportRes / canvas.width;
            ctx.save();
            ctx.translate(pad, pad);
            ctx.scale(scale, scale);
            ctx.drawImage(canvas, 0, 0);
            ctx.restore();
            
            const legY = exportRes + pad + 80;
            ctx.fillStyle = theme === 'dark' ? '#E8E8E8' : '#1a202c';
            ctx.font = 'bold 50px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Legend & Analysis:', pad, legY);
            
            let yOff = legY + 80;
            legendItems.forEach(item => {
                const label = item.querySelector('.legend-label').textContent;
                const desc = item.querySelector('.legend-description').textContent;
                const colorBox = item.querySelector('.color-swatch');
                const color = colorBox ? colorBox.style.background : (theme === 'dark' ? '#FFD700' : '#d69e00');
                
                ctx.fillStyle = color;
                ctx.fillRect(pad + 20, yOff - 30, 50, 50);
                ctx.strokeStyle = theme === 'dark' ? '#E8E8E8' : '#1a202c';
                ctx.lineWidth = 3;
                ctx.strokeRect(pad + 20, yOff - 30, 50, 50);
                
                ctx.fillStyle = theme === 'dark' ? '#FFD700' : '#d69e00';
                ctx.font = 'bold 40px sans-serif';
                ctx.fillText(label, pad + 90, yOff);
                
                ctx.fillStyle = theme === 'dark' ? '#A0A0A0' : '#4a5568';
                ctx.font = '28px sans-serif';
                const words = desc.split(' ');
                let line = '';
                let lineY = yOff + 40;
                words.forEach((word, i) => {
                    const testLine = line + word + ' ';
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > temp.width - pad * 2 - 120 && i > 0) {
                        ctx.fillText(line, pad + 90, lineY);
                        line = word + ' ';
                        lineY += 35;
                    } else {
                        line = testLine;
                    }
                });
                ctx.fillText(line, pad + 90, lineY);
                
                yOff += 120;
            });
            
            ctx.fillStyle = theme === 'dark' ? '#A0A0A0' : '#4a5568';
            ctx.font = '30px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Created by Wessen Getachew (@7dview)', temp.width / 2, temp.height - 50);
            
            const link = document.createElement('a');
            link.download = `${title.replace(/[^a-z0-9]/gi, '_')}_${exportRes}px.png`;
            link.href = temp.toDataURL('image/png');
            link.click();
        }

        function exportBoth() {
            // Create combined canvas with both views, titles, and legends
            const canvas1 = document.getElementById('canvas1');
            const canvas2 = document.getElementById('canvas2');
            
            const canvasWidth = exportRes;
            const canvasHeight = exportRes;
            const titleHeight = 100;
            const legendHeight = 300;
            const padding = 40;
            
            // Total dimensions: 2 canvases side by side + titles + legends
            const totalWidth = (canvasWidth * 2) + (padding * 3);
            const totalHeight = titleHeight + canvasHeight + legendHeight + (padding * 3);
            
            const combined = document.createElement('canvas');
            combined.width = totalWidth;
            combined.height = totalHeight;
            const ctx = combined.getContext('2d');
            
            // Background
            ctx.fillStyle = currentTheme === 'dark' ? '#0a0e1a' : '#ffffff';
            ctx.fillRect(0, 0, totalWidth, totalHeight);
            
            const textColor = currentTheme === 'dark' ? '#E8E8E8' : '#1a202c';
            const bgCard = currentTheme === 'dark' ? '#141829' : '#ffffff';
            const borderColor = currentTheme === 'dark' ? '#2a3150' : '#cbd5e0';
            const goldColor = currentTheme === 'dark' ? '#FFD700' : '#d69e00';
            const cyanColor = currentTheme === 'dark' ? '#00FFFF' : '#0891b2';
            
            // Helper function to draw rounded rect
            function roundRect(x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
                ctx.closePath();
            }
            
            // CANVAS 1 Section
            const x1 = padding;
            const yTitle = padding;
            
            // Canvas 1 Title
            ctx.fillStyle = textColor;
            ctx.font = `bold ${Math.floor(exportRes/25)}px sans-serif`;
            ctx.textAlign = 'center';
            const title1 = document.getElementById('c1Ind').checked ? 
                `Canvas 1: m=${document.getElementById('c1Mod').value}` :
                `Canvas 1: m=${document.getElementById('modulus').value}`;
            ctx.fillText(title1, x1 + canvasWidth/2, yTitle + 50);
            
            // Draw Canvas 1
            const yCanvas = yTitle + titleHeight;
            const scale1 = canvasWidth / canvas1.width;
            ctx.save();
            ctx.translate(x1, yCanvas);
            ctx.scale(scale1, scale1);
            ctx.drawImage(canvas1, 0, 0);
            ctx.restore();
            
            // Canvas 1 Legend
            const yLegend = yCanvas + canvasHeight + padding;
            ctx.fillStyle = bgCard;
            roundRect(x1, yLegend, canvasWidth, legendHeight, 12);
            ctx.fill();
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = cyanColor;
            ctx.font = `bold ${Math.floor(exportRes/40)}px sans-serif`;
            ctx.textAlign = 'left';
            ctx.fillText('Legend', x1 + 20, yLegend + 40);
            
            const legendItems1 = [
                { color: cyanColor, text: 'Reduced Residues (gcd(r,m)=1)' },
                { color: '#e74c3c', text: 'Non-coprime Residues' },
                { color: '#9F7AEA', text: 'Inscribed Polygon' }
            ];
            
            const fontSize = Math.floor(exportRes/50);
            ctx.font = `${fontSize}px sans-serif`;
            legendItems1.forEach((item, i) => {
                const y = yLegend + 80 + (i * 60);
                // Color box
                ctx.fillStyle = item.color;
                ctx.fillRect(x1 + 20, y, 40, 40);
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(x1 + 20, y, 40, 40);
                // Text
                ctx.fillStyle = textColor;
                ctx.textAlign = 'left';
                ctx.fillText(item.text, x1 + 75, y + 28);
            });
            
            // CANVAS 2 Section
            const x2 = padding + canvasWidth + padding;
            
            // Canvas 2 Title
            ctx.fillStyle = textColor;
            ctx.font = `bold ${Math.floor(exportRes/25)}px sans-serif`;
            ctx.textAlign = 'center';
            const title2 = document.getElementById('c2Ind').checked ?
                `Canvas 2: m=${document.getElementById('c2Mod').value}` :
                `Canvas 2: m=${document.getElementById('modulus').value}`;
            ctx.fillText(title2, x2 + canvasWidth/2, yTitle + 50);
            
            // Draw Canvas 2
            const scale2 = canvasWidth / canvas2.width;
            ctx.save();
            ctx.translate(x2, yCanvas);
            ctx.scale(scale2, scale2);
            ctx.drawImage(canvas2, 0, 0);
            ctx.restore();
            
            // Canvas 2 Legend
            ctx.fillStyle = bgCard;
            roundRect(x2, yLegend, canvasWidth, legendHeight, 12);
            ctx.fill();
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = cyanColor;
            ctx.font = `bold ${Math.floor(exportRes/40)}px sans-serif`;
            ctx.textAlign = 'left';
            ctx.fillText('Legend', x2 + 20, yLegend + 40);
            
            const legendItems2 = [
                { color: '#48BB78', text: 'Primitive Vectors (gcd=1)' },
                { color: goldColor, text: 'Prime Norm Vectors' },
                { color: cyanColor, text: 'Normalized on Unit Circle' }
            ];
            
            ctx.font = `${fontSize}px sans-serif`;
            legendItems2.forEach((item, i) => {
                const y = yLegend + 80 + (i * 60);
                // Color box
                ctx.fillStyle = item.color;
                ctx.fillRect(x2 + 20, y, 40, 40);
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(x2 + 20, y, 40, 40);
                // Text
                ctx.fillStyle = textColor;
                ctx.textAlign = 'left';
                ctx.fillText(item.text, x2 + 75, y + 28);
            });
            
            // Download combined image
            const link = document.createElement('a');
            link.download = `lattice_combined_${exportRes}px.png`;
            link.href = combined.toDataURL('image/png');
            link.click();
        }

        function exportCSV(canvasId) {
            const num = canvasId === 'canvas1' ? 1 : 2;
            let csv = '';
            
            if (num === 1) {
                const isInd = document.getElementById('c1Ind').checked;
                const m = isInd ? 
                    parseInt(document.getElementById('c1Mod').value) :
                    parseInt(document.getElementById('modulus').value);
                
                csv = 'Modulus,Residue,IsReduced,GCD,Angle_rad,Angle_deg\n';
                for (let r = 0; r < m; r++) {
                    const isRed = gcd(r, m) === 1;
                    const ang = (2 * Math.PI * r / m);
                    csv += `${m},${r},${isRed},${gcd(r, m)},${ang.toFixed(10)},${(ang * 180 / Math.PI).toFixed(6)}\n`;
                }
            } else {
                const isInd = document.getElementById('c2Ind').checked;
                const range = isInd ?
                    parseInt(document.getElementById('c2Range').value) :
                    parseInt(document.getElementById('latticeRange').value);
                
                csv = 'a,b,Norm,GCD,IsPrime,Angle_rad,Angle_deg\n';
                const pts = getLatticePoints(range);
                pts.forEach(p => {
                    const ang = Math.atan2(p.b, p.a);
                    csv += `${p.a},${p.b},${p.norm},${p.gcdVal},${p.isPrime},${ang.toFixed(10)},${(ang * 180 / Math.PI).toFixed(6)}\n`;
                });
            }
            
            const blob = new Blob([csv], {type: 'text/csv'});
            const link = document.createElement('a');
            link.download = `${canvasId}_data.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function exportAllCSV() {
            const isInd1 = document.getElementById('c1Ind').checked;
            const m1 = isInd1 ? 
                parseInt(document.getElementById('c1Mod').value) :
                parseInt(document.getElementById('modulus').value);
            
            const isInd2 = document.getElementById('c2Ind').checked;
            const range = isInd2 ?
                parseInt(document.getElementById('c2Range').value) :
                parseInt(document.getElementById('latticeRange').value);
            
            let csv = '=== CANVAS 1: MODULAR CIRCLE ===\n';
            csv += `Modulus: ${m1}\n`;
            csv += `Euler Totient: ${eulerTotient(m1)}\n\n`;
            csv += 'Residue,IsReduced,GCD,Angle_rad,Angle_deg\n';
            
            for (let r = 0; r < m1; r++) {
                const isRed = gcd(r, m1) === 1;
                const ang = (2 * Math.PI * r / m1);
                csv += `${r},${isRed},${gcd(r, m1)},${ang.toFixed(10)},${(ang * 180 / Math.PI).toFixed(6)}\n`;
            }
            
            csv += '\n\n=== CANVAS 2: LATTICE DIRECTIONS ===\n';
            csv += `Range: ${range}\n\n`;
            csv += 'a,b,Norm,GCD,IsPrime,Angle_rad,Angle_deg\n';
            
            const pts = getLatticePoints(range);
            pts.forEach(p => {
                const ang = Math.atan2(p.b, p.a);
                csv += `${p.a},${p.b},${p.norm},${p.gcdVal},${p.isPrime},${ang.toFixed(10)},${(ang * 180 / Math.PI).toFixed(6)}\n`;
            });
            
            const blob = new Blob([csv], {type: 'text/csv'});
            const link = document.createElement('a');
            link.download = 'complete_data.csv';
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        // ==================== GAP ANALYSIS SYSTEM ====================
        let selectedGaps = [2, 4, 6];

        function generateGaps() {
            const maxGap = parseInt(document.getElementById('maxGap').value) || 12;
            const gapsContainer = document.getElementById('gapControls');
            gapsContainer.innerHTML = '';
            
            for (let g = 2; g <= maxGap; g += 2) {
                const div = document.createElement('div');
                div.className = 'checkbox-group';
                div.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 6px; background: var(--bg-panel); border-radius: 4px;';
                div.innerHTML = `
                    <input type="checkbox" id="gap${g}" ${selectedGaps.includes(g) ? 'checked' : ''} 
                           onchange="toggleGap(${g})" style="width: 18px; height: 18px;">
                    <label for="gap${g}" style="margin: 0; cursor: pointer; font-size: 0.9em;">Gap ${g}</label>
                `;
                gapsContainer.appendChild(div);
            }
        }

        function toggleGap(g) {
            const idx = selectedGaps.indexOf(g);
            if (idx === -1) {
                selectedGaps.push(g);
            } else {
                selectedGaps.splice(idx, 1);
            }
            selectedGaps.sort((a, b) => a - b);
            draw1();
        }

        function addConsecutiveGaps() {
            const start = parseInt(document.getElementById('gapStart').value);
            const end = parseInt(document.getElementById('gapEnd').value);
            if (start && end && end >= start) {
                for (let g = start; g <= end; g++) {
                    if (!selectedGaps.includes(g)) selectedGaps.push(g);
                }
                selectedGaps.sort((a, b) => a - b);
                generateGaps();
                draw1();
            }
        }

        function clearAllGaps() {
            selectedGaps = [];
            generateGaps();
            draw1();
        }

        function drawGapAnalysis(ctx, m, cx, cy, r, residues, theme) {
            if (selectedGaps.length === 0 || residues.length === 0) return;
            
            ctx.save();
            
            for (let i = 0; i < residues.length; i++) {
                const r1 = residues[i];
                const r2 = residues[(i + 1) % residues.length];
                const gap = (r2 - r1 + m) % m;
                
                if (selectedGaps.includes(gap)) {
                    const ang1 = (2 * Math.PI * r1 / m) - Math.PI / 2;
                    const ang2 = (2 * Math.PI * r2 / m) - Math.PI / 2;
                    
                    // Draw thick arc for this gap
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, ang1, ang2, false);
                    
                    const hue = (gap / 20) * 360;
                    ctx.strokeStyle = `hsla(${hue}, 70%, 50%, 0.6)`;
                    ctx.lineWidth = 5;
                    ctx.stroke();
                    
                    // Label the gap at midpoint
                    const midAng = ang1 + (ang2 - ang1) / 2;
                    const labelR = r + 18;
                    const labelX = cx + labelR * Math.cos(midAng);
                    const labelY = cy + labelR * Math.sin(midAng);
                    
                    ctx.fillStyle = theme === 'dark' ? '#FFD700' : '#d69e00';
                    ctx.font = 'bold 13px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(gap.toString(), labelX, labelY);
                }
            }
            
            ctx.restore();
        }

        // ==================== SMITH CHART TRANSFORM ====================
        let smithChartEnabled = false;
        let smithAlpha = Math.PI / 2;
        let smithRadiusMode = 'scaled';
        let smithCustomScale = 1.0;

        function toggleSmithChart() {
            smithChartEnabled = document.getElementById('enableSmithChart').checked;
            const controls = document.getElementById('smithChartControls');
            controls.style.display = smithChartEnabled ? 'block' : 'none';
            draw1();
        }

        function updateSmithChart() {
            const alpha = parseFloat(document.getElementById('smithAlpha').value);
            smithAlpha = alpha * Math.PI / 180;
            document.getElementById('smithAlphaValue').textContent = alpha;
            
            smithRadiusMode = document.getElementById('smithRadiusMode').value;
            const customScaleGroup = document.getElementById('smithCustomScaleGroup');
            customScaleGroup.style.display = smithRadiusMode === 'custom' ? 'block' : 'none';
            
            draw1();
        }

        function updateSmithScale() {
            smithCustomScale = parseFloat(document.getElementById('smithScale').value);
            document.getElementById('smithScaleValue').textContent = smithCustomScale.toFixed(1);
            draw1();
        }

        function cayleyTransform(z) {
            // Cayley/M√∂bius transform: Œì = (z - 1)/(z + 1)
            const numeratorRe = z.re - 1;
            const numeratorIm = z.im;
            const denominatorRe = z.re + 1;
            const denominatorIm = z.im;
            
            const denomMagSq = denominatorRe * denominatorRe + denominatorIm * denominatorIm;
            
            if (denomMagSq < 1e-10) {
                return {re: 0, im: 0};
            }
            
            const gammaRe = (numeratorRe * denominatorRe + numeratorIm * denominatorIm) / denomMagSq;
            const gammaIm = (numeratorIm * denominatorRe - numeratorRe * denominatorIm) / denomMagSq;
            
            return {re: gammaRe, im: gammaIm};
        }

        function getSmithRadius(modulus) {
            switch(smithRadiusMode) {
                case 'unit':
                    return 1.0;
                case 'scaled':
                    return 0.5 + (modulus / 100) * 1.5;
                case 'modulus':
                    return Math.min(3.0, Math.log(modulus + 1) / Math.log(10));
                case 'custom':
                    return smithCustomScale;
                default:
                    return 1.0;
            }
        }

        function drawSmithChartGrid(ctx, cx, cy, r, theme) {
            if (!document.getElementById('smithShowGrid')?.checked) return;
            
            ctx.save();
            ctx.strokeStyle = theme === 'dark' ? 'rgba(100, 150, 200, 0.3)' : 'rgba(50, 100, 150, 0.3)';
            ctx.lineWidth = 1;
            
            // Unit circle boundary
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Vertical line (R=1 image)
            ctx.strokeStyle = theme === 'dark' ? 'rgba(0, 255, 255, 0.5)' : 'rgba(0, 145, 178, 0.5)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(cx, cy - r);
            ctx.lineTo(cx, cy + r);
            ctx.stroke();
            
            ctx.restore();
        }

        function drawSmithTransform(ctx, m, cx, cy, r, residues, pSize, theme) {
            if (!smithChartEnabled || residues.length === 0) return;
            
            ctx.save();
            
            // Draw Smith grid
            drawSmithChartGrid(ctx, cx, cy, r, theme);
            
            const R = getSmithRadius(m);
            
            residues.forEach(res => {
                const theta = (2 * Math.PI * res / m) + smithAlpha;
                const z = {
                    re: R * Math.cos(theta),
                    im: R * Math.sin(theta)
                };
                
                const gamma = cayleyTransform(z);
                
                // Map to screen coordinates (scale to fit in radius)
                const scale = r * 0.8;
                const screenX = cx + gamma.re * scale;
                const screenY = cy - gamma.im * scale;
                
                // Draw transformed point
                ctx.beginPath();
                ctx.arc(screenX, screenY, pSize + 3, 0, 2 * Math.PI);
                ctx.fillStyle = theme === 'dark' ? 'rgba(0, 255, 255, 0.7)' : 'rgba(0, 145, 178, 0.7)';
                ctx.fill();
                ctx.strokeStyle = theme === 'dark' ? '#FFD700' : '#d69e00';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw line from original to transformed
                const origAng = (2 * Math.PI * res / m) - Math.PI / 2;
                const origX = cx + r * Math.cos(origAng);
                const origY = cy + r * Math.sin(origAng);
                
                ctx.beginPath();
                ctx.moveTo(origX, origY);
                ctx.lineTo(screenX, screenY);
                ctx.strokeStyle = theme === 'dark' ? 'rgba(255, 215, 0, 0.2)' : 'rgba(217, 158, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
            
            ctx.restore();
        }

        // ==================== LIFT DYNAMICS ====================
        function updateLiftThickness() {
            const val = parseFloat(document.getElementById('liftThickness').value);
            document.getElementById('liftThicknessValue').textContent = val.toFixed(1);
            draw1();
        }

        function drawLifts(ctx, m, cx, cy, r, residues, theme) {
            const showDirect = document.getElementById('showDirectLifts')?.checked;
            const showModular = document.getElementById('showModularLifts')?.checked;
            
            if (!showDirect && !showModular) return;
            if (m >= 100) return; // Skip for very large m to avoid clutter
            
            const thickness = parseFloat(document.getElementById('liftThickness')?.value || 2);
            const residues1 = residues;
            const residues2 = getResidues(m + 1);
            
            // Use slightly different radii to show lift
            const r1 = r * 0.92;
            const r2 = r * 1.08;
            
            ctx.save();
            ctx.globalAlpha = 0.4;
            
            // Direct lifts: r ‚Üí r
            if (showDirect) {
                ctx.strokeStyle = theme === 'dark' ? '#FFD700' : '#d69e00';
                ctx.lineWidth = thickness;
                
                residues1.forEach(res => {
                    if (residues2.includes(res)) {
                        const ang1 = (2 * Math.PI * res / m) - Math.PI / 2;
                        const ang2 = (2 * Math.PI * res / (m + 1)) - Math.PI / 2;
                        
                        const x1 = cx + r1 * Math.cos(ang1);
                        const y1 = cy + r1 * Math.sin(ang1);
                        const x2 = cx + r2 * Math.cos(ang2);
                        const y2 = cy + r2 * Math.sin(ang2);
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                });
            }
            
            // Modular lifts: r ‚Üí (r + m) mod (m+1)
            if (showModular) {
                ctx.strokeStyle = theme === 'dark' ? '#FF6384' : '#dc2626';
                ctx.lineWidth = thickness * 0.8;
                
                residues1.forEach(res => {
                    const liftedR = (res + m) % (m + 1);
                    if (residues2.includes(liftedR)) {
                        const ang1 = (2 * Math.PI * res / m) - Math.PI / 2;
                        const ang2 = (2 * Math.PI * liftedR / (m + 1)) - Math.PI / 2;
                        
                        const x1 = cx + r1 * Math.cos(ang1);
                        const y1 = cy + r1 * Math.sin(ang1);
                        const x2 = cx + r2 * Math.cos(ang2);
                        const y2 = cy + r2 * Math.sin(ang2);
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                });
            }
            
            ctx.restore();
        }

        // Initialize gap controls on load
        document.addEventListener('DOMContentLoaded', () => {
            generateGaps();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            const modInput = document.getElementById('modulus');
            const val = parseInt(modInput.value);
            
            switch(e.key) {
                case 'ArrowRight':
                    modInput.value = Math.min(100, val + 1);
                    updateModulus();
                    break;
                case 'ArrowLeft':
                    modInput.value = Math.max(2, val - 1);
                    updateModulus();
                    break;
                case 'ArrowUp':
                    modInput.value = Math.min(100, val + 10);
                    updateModulus();
                    break;
                case 'ArrowDown':
                    modInput.value = Math.max(2, val - 10);
                    updateModulus();
                    break;
                case 'r':
                case 'R':
                    modInput.value = 8;
                    updateModulus();
                    break;
                case 'f':
                case 'F':
                    toggleFullscreen();
                    break;
                case 'Escape':
                    if (document.getElementById('fullscreenMode').classList.contains('active')) {
                        toggleFullscreen();
                    }
                    break;
            }
        });

        // Fullscreen mode
        function toggleFullscreen() {
            const fsMode = document.getElementById('fullscreenMode');
            const isActive = fsMode.classList.contains('active');
            
            if (isActive) {
                fsMode.classList.remove('active');
            } else {
                fsMode.classList.add('active');
                
                // Copy current canvases to fullscreen canvases
                const fs1 = document.getElementById('fullscreenCanvas1');
                const fs2 = document.getElementById('fullscreenCanvas2');
                const c1 = document.getElementById('canvas1');
                const c2 = document.getElementById('canvas2');
                
                const ctx1 = fs1.getContext('2d');
                const ctx2 = fs2.getContext('2d');
                
                ctx1.clearRect(0, 0, fs1.width, fs1.height);
                ctx2.clearRect(0, 0, fs2.width, fs2.height);
                
                ctx1.drawImage(c1, 0, 0);
                ctx2.drawImage(c2, 0, 0);
            }
        }
    </script>
</body>
    </html>
