<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Polar vs Cartesian ¬∑ Gap Analysis</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@300;400;700&family=DM+Sans:wght@300;400;500&display=swap');

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   DESIGN SYSTEM
   Mathematical clarity ¬∑ Educational depth
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
:root {
  /* Core palette */
  --bg:        #0e1119;
  --bg2:       #121722;
  --surface:   rgba(255,255,255,0.028);
  --surface2:  rgba(255,255,255,0.045);

  /* Blue ‚Äî primary */
  --blue:      #5b9cf6;
  --blue-dim:  rgba(91,156,246,0.18);
  --blue-faint:rgba(91,156,246,0.07);
  --border:    rgba(91,156,246,0.18);

  /* Gold ‚Äî secondary */
  --gold:      #e8c547;
  --gold-dim:  rgba(232,197,71,0.18);
  --gold-faint:rgba(232,197,71,0.06);
  --gold-border:rgba(232,197,71,0.2);

  /* Semantic */
  --green:     #5ebd78;
  --teal:      #4ecdc4;
  --violet:    #b48eff;
  --red:       #f87171;
  --orange:    #fb923c;

  /* Text */
  --text:      #dde5f4;
  --text-dim:  rgba(180,200,235,0.5);
  --text-faint:rgba(150,175,215,0.35);

  /* Pink kept for legacy JS color references but softened */
  --pink: #5b9cf6;
}

* { margin:0; padding:0; box-sizing:border-box; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'DM Sans', sans-serif;
  min-height: 100vh;
  overflow-x: hidden;
  /* Subtle grid-paper background */
  background-image:
    linear-gradient(rgba(91,156,246,0.025) 1px, transparent 1px),
    linear-gradient(90deg, rgba(91,156,246,0.025) 1px, transparent 1px);
  background-size: 32px 32px;
  background-position: center center;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   DESKTOP LAYOUT ‚Äî 3-column dashboard
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
.page-shell {
  display: grid;
  grid-template-columns: 320px 1fr;
  grid-template-rows: auto 1fr;
  grid-template-areas:
    "topbar topbar"
    "left   center";
  min-height: 100vh;
  max-width: 1920px;
  margin: 0 auto;
}

/* Top bar */
.topbar {
  grid-area: topbar;
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 10px 24px;
  border-bottom: 1px solid rgba(91,156,246,0.12);
  background: rgba(14,17,25,0.96);
  backdrop-filter: blur(16px);
  position: sticky; top: 0; z-index: 100;
}
.topbar-title {
  font-family: 'Lora', serif;
  font-size: clamp(1rem, 2vw, 1.4rem);
  color: var(--blue);
  letter-spacing: -0.01em;
  white-space: nowrap;
}
.topbar-author {
  font-size: .56rem; text-transform: uppercase; letter-spacing: .22em;
  color: rgba(232,197,71,.4); white-space: nowrap; font-family:'JetBrains Mono',monospace;
}
.topbar-actions { display: flex; gap: 8px; align-items: center; flex-shrink: 0; }
.topbar-kb {
  font-size: .5rem; color: rgba(91,156,246,.3);
  letter-spacing: .1em; white-space: nowrap; font-family:'JetBrains Mono',monospace;
}

/* Left sidebar */
.col-left {
  grid-area: left;
  border-right: 1px solid rgba(91,156,246,.08);
  overflow-y: auto;
  padding: 16px 14px 40px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  background: rgba(14,17,25,.7);
}

/* Center ‚Äî main visualization */
.col-center {
  grid-area: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px 40px 40px;
  gap: 14px;
  overflow-y: auto;
  min-width: 0;
}

/* Center all direct children with consistent max-width */
.col-center > * {
  width: 100%;
  max-width: 900px;
}
.col-center > .sphere-wrap,
.col-center > .dual-wave-row,
.col-center > #liveStats {
  max-width: 900px;
}

/* Right sidebar ‚Äî collapsed (content moved to center) */
.col-right { display: none; }

/* Sidebar section headers */
.sidebar-section {
  font-size: .48rem; text-transform: uppercase; letter-spacing: .24em;
  color: rgba(91,156,246,.35); padding: 0 2px; margin-top: 4px;
  font-family:'JetBrains Mono',monospace;
}
.sidebar-section.gold { color: rgba(232,197,71,.35); }

/* Remove old max-width constraints from panels inside sidebars */
.col-left .panel,
.col-left .harm-panel,
.col-left .coord-panel,
.col-right .panel,
.col-right .gap-panel,
.col-right .harm-panel {
  max-width: none;
  width: 100%;
  margin-top: 0;
}

/* Preset dropdown in topbar context */
.topbar .preset-drop-wrap {
  max-width: 260px;
  margin: 0;
  flex-shrink: 0;
}
.topbar .preset-drop-header {
  padding: 7px 12px;
}

/* Intro block in left col */
.col-left .intro {
  max-width: none;
  width: 100%;
  margin-bottom: 0;
  border-left: 2px solid rgba(91,156,246,.2);
  padding-left: 12px;
}
.col-left .intro h1 { display: none; }

/* Stats in center */
.col-center .live-stats {
  grid-template-columns: repeat(4, 1fr);
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   MOBILE ‚Äî single column
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
@media (max-width: 900px) {
  .page-shell {
    grid-template-columns: 1fr;
    grid-template-areas:
      "topbar"
      "center"
      "left";
  }
  .topbar {
    grid-template-columns: 1fr auto;
    padding: 8px 14px;
    gap: 10px;
  }
  .col-left {
    border: none;
    border-top: 1px solid rgba(91,156,246,.08);
    padding: 14px 12px 28px;
  }
  .col-center { padding: 14px 12px 20px; }
  .col-center .live-stats { grid-template-columns: repeat(2,1fr); }
  .dual-wave-row { flex-direction: column !important; }
  .dual-wave-row > * { max-width: 100% !important; }
}

@media (max-width: 1200px) and (min-width: 901px) {
  .page-shell {
    grid-template-columns: 280px 1fr;
  }
}

/* ‚îÄ‚îÄ Presets ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.presets-wrap { max-width: 580px; width: 100%; margin-bottom: 16px; }
.pg-label {
  font-size:.52rem; text-transform:uppercase; letter-spacing:.18em;
  color:rgba(91,156,246,.5); margin-bottom:5px; margin-top:8px; margin-left:2px;
  font-family:'JetBrains Mono',monospace;
}
.pg-label.gold { color:rgba(232,197,71,.6); }
.presets { display:flex; flex-wrap:wrap; gap:5px; }
.preset-btn {
  font-family:'JetBrains Mono',monospace; font-size:.6rem;
  letter-spacing:.07em; text-transform:uppercase;
  padding:4px 10px; border-radius:4px; cursor:pointer;
  border:1px solid rgba(91,156,246,.2); background:rgba(255,255,255,.02);
  color:rgba(180,200,235,.55); transition:all .15s;
}
.preset-btn:hover { border-color:var(--blue); color:var(--blue); }
.preset-btn.active { background:var(--blue); border-color:var(--blue); color:#000; }
.preset-btn.gap-active { background:var(--gold); border-color:var(--gold); color:#000; }

/* ‚îÄ‚îÄ Sphere canvas ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.sphere-wrap {
  width:100%;
  display:flex; flex-direction:column; align-items:center; gap:10px;
}
#polarCanvas {
  display:block; border-radius:50%;
  box-shadow: 0 0 80px rgba(91,156,246,.1), 0 0 200px rgba(91,156,246,.04),
              0 4px 32px rgba(0,0,0,.5);
  cursor:grab;
}
#polarCanvas:active { cursor:grabbing; }

.formula-box {
  border:1px solid var(--gold); border-radius:6px;
  padding:8px 18px; background:rgba(232,197,71,.05);
  font-family:'JetBrains Mono',monospace;
  font-size:clamp(.72rem,2.3vw,.92rem); color:var(--text);
  text-align:center;
}
.formula-box em { color:var(--gold); font-style:normal; font-weight:700; }
#cartCanvas { display:block; border-radius:4px; }

/* ‚îÄ‚îÄ Live Stats Bar ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.live-stats {
  width:100%;
  background:rgba(232,197,71,.03); border:1px solid rgba(232,197,71,.12);
  border-radius:8px; padding:8px 14px;
  display:grid; grid-template-columns:repeat(4,1fr); gap:6px 10px;
}
.stat-cell { display:flex; flex-direction:column; gap:2px; }
.stat-lbl { font-size:.46rem; text-transform:uppercase; letter-spacing:.12em; color:rgba(232,197,71,.4); font-family:'JetBrains Mono',monospace; }
.stat-val { font-size:.68rem; color:var(--gold); font-weight:700; font-family:'JetBrains Mono',monospace; }

/* ‚îÄ‚îÄ Rotation controls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.rot-controls {
  display:flex; align-items:center; gap:12px;
  flex-wrap:wrap; justify-content:center; margin-top:2px;
}
.rot-hint { font-size:.58rem; color:rgba(91,156,246,.45); letter-spacing:.07em; font-family:'JetBrains Mono',monospace; }

/* ‚îÄ‚îÄ Panels ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.panels { display:flex; flex-direction:column; gap:10px; width:100%; }
.panel { background:var(--surface); border:1px solid var(--border); border-radius:8px; padding:14px 16px; }
.panel.gold-panel { border-color:var(--gold-border); }
.panel-title {
  font-size:.52rem; text-transform:uppercase; letter-spacing:.2em;
  color:var(--blue); margin-bottom:12px;
  display:flex; align-items:center; gap:8px;
  font-family:'JetBrains Mono',monospace;
}
.panel-title.gold { color:var(--gold); }
.panel-title::after { content:''; flex:1; height:1px; background:var(--border); }
.panel-title.gold::after { background:var(--gold-border); }
.grid-2 { display:grid; grid-template-columns:1fr 1fr; gap:10px 18px; }
.cg { display:flex; flex-direction:column; gap:4px; }
label { font-size:.58rem; color:rgba(180,200,235,.65); text-transform:uppercase; letter-spacing:.1em; font-family:'JetBrains Mono',monospace; }
input[type=range] {
  -webkit-appearance:none; width:100%; height:2px;
  background:rgba(91,156,246,.2); border-radius:2px; outline:none; cursor:pointer;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none; width:12px; height:12px; border-radius:50%;
  background:var(--blue); cursor:pointer;
}
.vd { font-size:.68rem; color:var(--gold); text-align:right; font-family:'JetBrains Mono',monospace; }

/* ‚îÄ‚îÄ Playback ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.pb-row { display:grid; grid-template-columns:1fr auto; gap:14px; align-items:end; }
.btn-row { display:flex; gap:8px; flex-wrap:wrap; }
button.ctrl {
  font-family:'JetBrains Mono',monospace; font-size:.65rem;
  letter-spacing:.08em; text-transform:uppercase;
  padding:7px 14px; border-radius:4px; cursor:pointer;
  transition:all .15s; border:1px solid rgba(91,156,246,.35);
  background:transparent; color:var(--blue); white-space:nowrap;
}
button.ctrl:hover, button.ctrl.on { background:var(--blue); color:#000; }
button.ctrl.gold-ctrl { border-color:rgba(232,197,71,.4); color:var(--gold); }
button.ctrl.gold-ctrl:hover, button.ctrl.gold-ctrl.on { background:var(--gold); color:#000; }
.speed-sub { font-size:.54rem; color:rgba(232,197,71,.45); margin-top:-2px; font-family:'JetBrains Mono',monospace; }
.qrow { display:flex; gap:5px; flex-wrap:wrap; margin-top:10px; align-items:center; }
.qlabel { font-size:.55rem; color:rgba(150,175,215,.5); text-transform:uppercase; letter-spacing:.1em; font-family:'JetBrains Mono',monospace; }

/* loop toggle */
.loop-row {
  display:flex; align-items:center; gap:10px; margin-top:8px;
  padding-top:8px; border-top:1px solid rgba(91,156,246,.08);
}
.loop-check {
  -webkit-appearance:none; width:30px; height:16px; border-radius:8px;
  background:rgba(91,156,246,.12); border:1px solid rgba(91,156,246,.25);
  cursor:pointer; position:relative; transition:background .2s; flex-shrink:0;
}
.loop-check:checked { background:var(--blue); border-color:var(--blue); }
.loop-check::after {
  content:''; position:absolute; top:2px; left:2px;
  width:10px; height:10px; border-radius:50%; background:#fff;
  transition:transform .2s; box-shadow:0 1px 4px rgba(0,0,0,.4);
}
.loop-check:checked::after { transform:translateX(14px); }
.loop-lbl { font-size:.58rem; color:rgba(180,200,235,.65); text-transform:uppercase; letter-spacing:.1em; font-family:'JetBrains Mono',monospace; }
.loop-state { font-size:.54rem; color:rgba(232,197,71,.4); font-family:'JetBrains Mono',monospace; }

/* ‚îÄ‚îÄ Gap Decomposition Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.gap-panel {
  width:100%; margin-top:0;
  background:var(--surface); border:1px solid var(--gold-border);
  border-radius:8px; overflow:hidden;
}
.gap-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 16px; cursor:pointer; user-select:none;
  border-bottom:1px solid transparent; transition:border-color .2s;
}
.gap-header.open { border-bottom-color:var(--gold-border); }
.gap-header-title {
  font-size:.54rem; text-transform:uppercase; letter-spacing:.2em; color:var(--gold);
  font-family:'JetBrains Mono',monospace;
}
.gap-chevron { font-size:.7rem; color:var(--gold); transition:transform .25s; }
.gap-chevron.open { transform:rotate(180deg); }
.gap-body { display:none; padding:14px 16px 16px; }
.gap-body.open { display:block; }

/* Gap controls grid */
.gap-ctrl-grid { display:grid; grid-template-columns:1fr 1fr; gap:10px 18px; margin-bottom:12px; }
.gap-ctrl-grid label { color:rgba(180,200,235,.6); }
.gap-ctrl-grid input[type=range] { background:rgba(232,197,71,.15); }
.gap-ctrl-grid input[type=range]::-webkit-slider-thumb { background:var(--gold); }
.gap-vd { font-size:.68rem; color:var(--gold); text-align:right; font-family:'JetBrains Mono',monospace; }

.gap-filter-row { display:flex; gap:7px; flex-wrap:wrap; align-items:center; margin-bottom:10px; }
.gap-filter-lbl { font-size:.54rem; color:rgba(232,197,71,.45); text-transform:uppercase; letter-spacing:.12em; font-family:'JetBrains Mono',monospace; }
.gap-filter-btn {
  font-family:'JetBrains Mono',monospace; font-size:.54rem; letter-spacing:.06em;
  text-transform:uppercase; padding:3px 8px; border-radius:4px; cursor:pointer;
  border:1px solid rgba(232,197,71,.2); background:transparent; color:rgba(150,175,100,.7); transition:all .12s;
}
.gap-filter-btn:hover { border-color:var(--gold); color:var(--gold); }
.gap-filter-btn.active { background:var(--gold); color:#000; border-color:var(--gold); }

.gap-run-row { display:flex; gap:7px; margin-bottom:12px; flex-wrap:wrap; }

/* Status */
.gap-status {
  font-size:.58rem; color:rgba(150,200,150,.8); min-height:1.4em;
  border-left:2px solid var(--gold); padding-left:8px;
  margin-bottom:10px; line-height:1.7; font-family:'JetBrains Mono',monospace;
}

/* Progress bar */
.gap-progress { height:2px; background:rgba(232,197,71,.1); border-radius:2px; margin-bottom:10px; overflow:hidden; display:none; }
.gap-progress-fill { height:100%; background:var(--gold); border-radius:2px; width:0%; transition:width .1s; }

/* Live stats grid for gap */
.gap-live-stats {
  display:grid; grid-template-columns:repeat(3,1fr); gap:5px; margin-bottom:12px;
}
.gap-stat {
  background:rgba(232,197,71,.03); border:1px solid rgba(232,197,71,.08);
  border-radius:5px; padding:5px 7px;
}
.gap-stat-lbl { font-size:.44rem; text-transform:uppercase; letter-spacing:.1em; color:rgba(232,197,71,.38); margin-bottom:2px; font-family:'JetBrains Mono',monospace; }
.gap-stat-val { font-size:.64rem; color:var(--gold); font-weight:700; word-break:break-all; font-family:'JetBrains Mono',monospace; }

/* Chart tabs */
.gap-tabs { display:flex; gap:4px; margin-bottom:10px; flex-wrap:wrap; }
.gap-tab {
  font-family:'JetBrains Mono',monospace; font-size:.54rem; letter-spacing:.06em;
  text-transform:uppercase; padding:4px 9px; border-radius:4px; cursor:pointer;
  border:1px solid rgba(232,197,71,.2); background:transparent; color:rgba(150,175,100,.7); transition:all .12s;
}
.gap-tab:hover { border-color:var(--gold); color:var(--gold); }
.gap-tab.active { background:var(--gold); color:#000; border-color:var(--gold); }

#gapCanvas { display:block; border-radius:4px; width:100%; background:#0e1119; }

.gap-legend { display:flex; flex-wrap:wrap; gap:5px; margin-top:7px; }
.gap-leg { display:flex; align-items:center; gap:4px; font-size:.52rem; color:rgba(150,175,115,.7); font-family:'JetBrains Mono',monospace; }
.gap-leg-sw { width:8px; height:8px; border-radius:2px; flex-shrink:0; }

/* Export row */
.export-row { display:flex; gap:7px; flex-wrap:wrap; margin-top:12px; padding-top:12px; border-top:1px solid rgba(232,197,71,.08); }

/* Gap presets inside the gap panel */
.gap-wave-presets { margin-bottom:12px; }
.gap-wave-presets .pg-label { font-size:.5rem; margin-top:0; margin-bottom:5px; color:rgba(232,197,71,.45); }
.gap-wave-row { display:flex; flex-wrap:wrap; gap:4px; }
.gap-wave-btn {
  font-family:'JetBrains Mono',monospace; font-size:.54rem; letter-spacing:.06em;
  text-transform:uppercase; padding:3px 8px; border-radius:4px; cursor:pointer;
  border:1px solid rgba(232,197,71,.18); background:rgba(232,197,71,.02);
  color:rgba(150,175,100,.7); transition:all .15s;
}
.gap-wave-btn:hover { border-color:var(--gold); color:var(--gold); }
.gap-wave-btn.active { background:var(--gold); border-color:var(--gold); color:#000; }
.gap-wave-btn .n-badge { font-size:.45rem; opacity:.65; margin-left:3px; }

/* ‚îÄ‚îÄ Multi-gap selector ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.gap-selector-wrap { margin-bottom:12px; }
.gap-selector-label {
  font-size:.52rem; text-transform:uppercase; letter-spacing:.14em;
  color:rgba(232,197,71,.5); margin-bottom:5px;
  display:flex; align-items:center; gap:10px; flex-wrap:wrap;
  font-family:'JetBrains Mono',monospace;
}
.gap-selector-label span { opacity:.6; font-size:.48rem; }
.gap-chips { display:flex; flex-wrap:wrap; gap:4px; }
.gap-chip {
  font-family:'JetBrains Mono',monospace; font-size:.58rem;
  letter-spacing:.06em; padding:3px 8px; border-radius:4px;
  cursor:pointer; border:1px solid transparent;
  background:rgba(255,255,255,.03); color:rgba(130,150,120,.7);
  transition:all .12s; position:relative; user-select:none;
}
.gap-chip:hover { color:rgba(200,220,160,.9); border-color:rgba(255,255,255,.12); }
.gap-chip.selected { color:#000 !important; font-weight:700; }
.gap-chip .chip-dot {
  display:inline-block; width:5px; height:5px; border-radius:50%;
  margin-right:4px; vertical-align:middle; background:currentColor;
}

/* ‚îÄ‚îÄ Thickness slider ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.thick-row {
  display:flex; align-items:center; gap:10px; margin-bottom:10px;
  padding:7px 9px; background:rgba(232,197,71,.02);
  border:1px solid rgba(232,197,71,.08); border-radius:6px;
}
.thick-row label { color:rgba(180,200,135,.7); font-size:.58rem; white-space:nowrap; flex-shrink:0; }
.thick-row input[type=range] { flex:1; background:rgba(232,197,71,.15); }
.thick-row input[type=range]::-webkit-slider-thumb { background:var(--gold); }
.thick-val { font-size:.66rem; color:var(--gold); min-width:28px; text-align:right; font-family:'JetBrains Mono',monospace; }

/* ‚îÄ‚îÄ All-gaps stats table ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.gap-table-wrap {
  margin-top:12px; overflow-x:auto;
  border:1px solid rgba(232,197,71,.1); border-radius:6px;
}
.gap-table-controls {
  display:flex; gap:8px; flex-wrap:wrap; align-items:center;
  padding:7px 10px; background:rgba(232,197,71,.02);
  border-bottom:1px solid rgba(232,197,71,.08);
}
.gap-table-controls label { font-size:.52rem; color:rgba(150,175,135,.8); white-space:nowrap; font-family:'JetBrains Mono',monospace; }
.gap-table-controls select, .gap-table-controls input {
  font-family:'JetBrains Mono',monospace; font-size:.58rem;
  background:#0e1119; border:1px solid rgba(232,197,71,.2); color:var(--gold);
  padding:2px 5px; border-radius:3px; cursor:pointer;
}
#gdTableWrap table {
  width:100%; border-collapse:collapse; font-size:.58rem;
  font-family:'JetBrains Mono',monospace;
}
#gdTableWrap th {
  position:sticky; top:0; background:#0e1119;
  color:rgba(232,197,71,.65); font-size:.48rem; text-transform:uppercase;
  letter-spacing:.1em; padding:5px 8px; text-align:right;
  border-bottom:1px solid rgba(232,197,71,.15); white-space:nowrap;
}
#gdTableWrap th:first-child { text-align:left; }
#gdTableWrap td {
  padding:4px 8px; text-align:right; border-bottom:1px solid rgba(232,197,71,.04);
  white-space:nowrap; color:rgba(150,180,140,.8);
}
#gdTableWrap td:first-child { text-align:left; }
#gdTableWrap tr:hover td { background:rgba(232,197,71,.04); }
#gdTableWrap tr.gap-row-selected td { background:rgba(232,197,71,.05); }
#gdTableWrap td.gap-id { font-weight:700; }
#gdTableWrap { max-height:340px; overflow-y:auto; }

/* ‚îÄ‚îÄ Convergence dropdown table ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.conv-dropdown-wrap {
  margin-top:12px;
  border:1px solid rgba(232,197,71,.12); border-radius:6px; overflow:hidden;
}
.conv-dropdown-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:8px 12px; background:rgba(232,197,71,.03); cursor:pointer;
  user-select:none;
}
.conv-dropdown-title { font-size:.54rem; text-transform:uppercase; letter-spacing:.15em; color:var(--gold); font-family:'JetBrains Mono',monospace; }
.conv-dropdown-chevron { font-size:.7rem; color:var(--gold); transition:transform .2s; }
.conv-dropdown-chevron.open { transform:rotate(180deg); }
.conv-dropdown-body { display:none; }
.conv-dropdown-body.open { display:block; }
.conv-table-controls {
  display:flex; gap:10px; flex-wrap:wrap; align-items:center;
  padding:7px 10px; background:rgba(232,197,71,.02);
  border-bottom:1px solid rgba(232,197,71,.07);
}
.conv-table-controls label { font-size:.52rem; color:rgba(150,175,135,.8); white-space:nowrap; font-family:'JetBrains Mono',monospace; }
.conv-table-controls select, .conv-table-controls input[type=number] {
  font-family:'JetBrains Mono',monospace; font-size:.58rem;
  background:#0e1119; border:1px solid rgba(232,197,71,.2); color:var(--gold);
  padding:2px 5px; border-radius:3px; width:56px;
}
.conv-table-controls select { width:auto; }
#gdConvTableWrap { max-height:400px; overflow-y:auto; }
#gdConvTableWrap table { width:100%; border-collapse:collapse; font-size:.56rem; font-family:'JetBrains Mono',monospace; }
#gdConvTableWrap th {
  position:sticky; top:0; background:#0e1119;
  color:rgba(232,197,71,.6); font-size:.47rem; text-transform:uppercase;
  letter-spacing:.1em; padding:5px 7px; text-align:right;
  border-bottom:1px solid rgba(232,197,71,.15); white-space:nowrap;
}
#gdConvTableWrap th:first-child, #gdConvTableWrap th:nth-child(2) { text-align:left; }
#gdConvTableWrap td {
  padding:3px 7px; text-align:right; border-bottom:1px solid rgba(232,197,71,.04);
  white-space:nowrap;
}
#gdConvTableWrap td:first-child, #gdConvTableWrap td:nth-child(2) { text-align:left; }
#gdConvTableWrap tr:hover td { background:rgba(232,197,71,.04); }
.conv-row-improving td { color:#5ebd78; }
.conv-row-worsening td { color:#f87171; }
.conv-row-best td { color:var(--gold) !important; font-weight:700; }
.conv-cell-product { color:#4ecdc4; }
.conv-cell-pi { color:#5b9cf6; }
.conv-cell-err { color:#fb923c; }
.conv-cell-logerr { color:#b48eff; }
.conv-cell-gap { color:var(--gold); font-weight:700; }

/* ‚îÄ‚îÄ Harmonics Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.harm-panel {
  max-width:560px; width:100%; margin-top:0;
  background:var(--surface); border:1px solid rgba(91,156,246,.16);
  border-radius:8px; overflow:hidden;
}
.harm-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 16px; cursor:pointer; user-select:none;
  border-bottom:1px solid transparent; transition:border-color .2s;
}
.harm-header.open { border-bottom-color:rgba(91,156,246,.16); }
.harm-header-title { font-size:.54rem; text-transform:uppercase; letter-spacing:.2em; color:var(--blue); font-family:'JetBrains Mono',monospace; }
.harm-chevron { font-size:.7rem; color:var(--blue); transition:transform .25s; }
.harm-chevron.open { transform:rotate(180deg); }
.harm-body { display:none; padding:12px 16px 16px; }
.harm-body.open { display:block; }

.harm-section-title {
  font-size:.48rem; text-transform:uppercase; letter-spacing:.15em;
  color:rgba(91,156,246,.5); margin-bottom:7px; margin-top:10px;
  font-family:'JetBrains Mono',monospace;
}
.harm-section-title:first-child { margin-top:0; }

/* Interval grid */
.harm-interval-grid { display:flex; flex-wrap:wrap; gap:4px; margin-bottom:8px; }
.harm-interval-btn {
  font-family:'JetBrains Mono',monospace; font-size:.57rem;
  letter-spacing:.06em; padding:3px 9px; border-radius:4px;
  cursor:pointer; border:1px solid rgba(91,156,246,.2);
  background:rgba(91,156,246,.03); color:rgba(91,156,246,.45);
  transition:all .12s;
}
.harm-interval-btn:hover { border-color:var(--blue); color:var(--blue); }
.harm-interval-btn.active {
  background:var(--blue); border-color:var(--blue); color:#000; font-weight:700;
}
.harm-interval-btn .ratio-badge { font-size:.45rem; opacity:.65; margin-left:3px; }

/* Consonance color key */
.harm-consonance-key { display:flex; gap:7px; flex-wrap:wrap; margin-bottom:8px; }
.harm-cons-pill { font-size:.5rem; padding:2px 7px; border-radius:4px; display:flex; align-items:center; gap:4px; }
.harm-cons-dot { width:6px; height:6px; border-radius:50%; flex-shrink:0; }

/* Audio row */
.harm-audio-row { display:grid; grid-template-columns:1fr 1fr; gap:9px; margin-bottom:8px; }
.harm-freq-display {
  font-size:.85rem; color:var(--blue); font-weight:700; text-align:center;
  padding:7px; background:rgba(91,156,246,.06); border:1px solid rgba(91,156,246,.15);
  border-radius:5px; letter-spacing:.05em; font-family:'JetBrains Mono',monospace;
}
.harm-note-display {
  font-size:.65rem; color:var(--green); text-align:center;
  padding:7px; background:rgba(94,189,120,.05); border:1px solid rgba(94,189,120,.12);
  border-radius:5px; font-family:'JetBrains Mono',monospace;
}

.harm-btn-row { display:flex; gap:7px; flex-wrap:wrap; margin-bottom:7px; }
.harm-btn {
  font-family:'JetBrains Mono',monospace; font-size:.6rem;
  letter-spacing:.07em; text-transform:uppercase; padding:6px 12px;
  border-radius:4px; cursor:pointer; border:1px solid rgba(91,156,246,.3);
  background:transparent; color:var(--blue); transition:all .15s;
}
.harm-btn:hover, .harm-btn.on { background:var(--blue); color:#000; }

/* Harmonic mode toggle */
.harm-mode-row {
  display:flex; align-items:center; gap:9px; margin-top:7px;
  padding-top:7px; border-top:1px solid rgba(91,156,246,.08);
}
.harm-toggle {
  -webkit-appearance:none; width:30px; height:16px; border-radius:8px;
  background:rgba(91,156,246,.12); border:1px solid rgba(91,156,246,.25);
  cursor:pointer; position:relative; transition:background .2s; flex-shrink:0;
}
.harm-toggle:checked { background:var(--blue); border-color:var(--blue); }
.harm-toggle::after {
  content:''; position:absolute; top:2px; left:2px;
  width:10px; height:10px; border-radius:50%; background:#fff;
  transition:transform .2s; box-shadow:0 1px 4px rgba(0,0,0,.4);
}
.harm-toggle:checked::after { transform:translateX(14px); }
.harm-lbl { font-size:.58rem; color:rgba(150,180,180,.7); text-transform:uppercase; letter-spacing:.1em; font-family:'JetBrains Mono',monospace; }
.harm-state { font-size:.54rem; color:rgba(91,156,246,.4); font-family:'JetBrains Mono',monospace; }

/* Arnold tongue */
.arnold-row { display:flex; gap:9px; align-items:center; margin-bottom:7px; }
.arnold-val { font-size:.62rem; color:#e879f9; min-width:30px; text-align:right; font-family:'JetBrains Mono',monospace; }

/* ‚îÄ‚îÄ Zoom & Pan overlay controls ‚îÄ‚îÄ‚îÄ */
.zoom-bar {
  display:flex; align-items:center; gap:7px; margin-top:5px;
  justify-content:center; flex-wrap:wrap;
}
.zoom-btn {
  font-family:'JetBrains Mono',monospace; font-size:.7rem;
  width:28px; height:28px; border-radius:50%; cursor:pointer;
  border:1px solid rgba(91,156,246,.3); background:rgba(91,156,246,.06);
  color:var(--blue); display:flex; align-items:center; justify-content:center;
  transition:all .15s; flex-shrink:0; font-weight:700;
}
.zoom-btn:hover { background:var(--blue); color:#000; }
.zoom-level-lbl {
  font-size:.58rem; color:rgba(232,197,71,.65); min-width:40px; text-align:center;
  letter-spacing:.08em; font-family:'JetBrains Mono',monospace;
}
.zoom-reset-btn {
  font-family:'JetBrains Mono',monospace; font-size:.55rem;
  padding:3px 9px; border-radius:4px; cursor:pointer;
  border:1px solid rgba(232,197,71,.25); background:transparent;
  color:rgba(232,197,71,.65); transition:all .15s;
}
.zoom-reset-btn:hover { background:var(--gold); color:#000; }

/* canvas pan cursor */
#polarCanvas.panning { cursor:move !important; }


/* ‚îÄ‚îÄ Coord Mode panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.coord-panel {
  max-width:560px; width:100%; margin-top:0;
  background:var(--surface); border:1px solid rgba(94,189,120,.15);
  border-radius:8px; overflow:hidden;
}
.coord-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 16px; cursor:pointer; user-select:none;
  border-bottom:1px solid transparent; transition:border-color .2s;
}
.coord-header.open { border-bottom-color:rgba(94,189,120,.15); }
.coord-header-title { font-size:.54rem; text-transform:uppercase; letter-spacing:.2em; color:var(--green); font-family:'JetBrains Mono',monospace; }
.coord-chevron { font-size:.7rem; color:var(--green); transition:transform .25s; }
.coord-chevron.open { transform:rotate(180deg); }
.coord-body { display:none; padding:12px 16px 16px; }
.coord-body.open { display:block; }
.coord-mode-grid { display:flex; flex-wrap:wrap; gap:5px; margin-bottom:10px; }
.coord-mode-btn {
  font-family:'JetBrains Mono',monospace; font-size:.58rem; letter-spacing:.06em;
  text-transform:uppercase; padding:4px 10px; border-radius:4px; cursor:pointer;
  border:1px solid rgba(94,189,120,.2); background:rgba(94,189,120,.03);
  color:rgba(94,189,120,.6); transition:all .14s;
}
.coord-mode-btn:hover { border-color:var(--green); color:var(--green); }
.coord-mode-btn.active { background:var(--green); color:#000; border-color:var(--green); }

/* ‚îÄ‚îÄ Keyboard shortcuts hint ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.kb-hint {
  font-size:.5rem; color:rgba(91,156,246,.3); text-align:center;
  letter-spacing:.1em; margin-top:4px; font-family:'JetBrains Mono',monospace;
}

/* ‚îÄ‚îÄ Fullscreen mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
:fullscreen .page-shell,
:-webkit-full-screen .page-shell,
:-moz-full-screen .page-shell {
  max-width: 100vw;
  width: 100vw;
  height: 100vh;
}
:fullscreen body,
:-webkit-full-screen body,
:-moz-full-screen body {
  overflow: hidden;
}
/* In fullscreen: sidebar stays, center gets all remaining space */
:fullscreen .col-left,
:-webkit-full-screen .col-left,
:-moz-full-screen .col-left {
  height: 100vh;
  overflow-y: auto;
}
:fullscreen .col-center,
:-webkit-full-screen .col-center,
:-moz-full-screen .col-center {
  height: 100vh;
  overflow-y: auto;
}
#btnFullscreen.active { background: var(--blue); color: #000; }

.intro-body {
  font-size:.62rem; line-height:1.8; color:rgba(180,200,235,.45);
  font-family:'JetBrains Mono',monospace;
}
.intro-body p { margin-bottom:.5em; }
.intro-body p:last-child { margin-bottom:0; }

/* ‚îÄ‚îÄ Side cards & labels ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.sidebar-label {
  font-size:.46rem; text-transform:uppercase; letter-spacing:.26em;
  color:rgba(91,156,246,.38); padding:0 2px; margin-top:6px;
  font-family:'JetBrains Mono',monospace;
}
.sidebar-label.gold { color:rgba(232,197,71,.38); }
.sidebar-label:first-child { margin-top:0; }

.side-card {
  background:var(--surface); border:1px solid var(--border);
  border-radius:8px; padding:12px 13px; width:100%;
}
.side-card.gap-card { border-color:var(--gold-border); padding:0; overflow:hidden; }
.side-card.gap-card .gap-panel { border:none; border-radius:0; }
.intro-card { border-color:rgba(91,156,246,.1); }

/* Topbar brand */
.topbar-brand { display:flex; flex-direction:column; gap:2px; flex-shrink:0; }

/* Center canvas sizing */
.col-center .sphere-wrap {
  width:100%; max-width:900px;
  display:flex; flex-direction:column; align-items:center; gap:10px;
}
.col-center #polarCanvas { width:100% !important; height:auto !important; }
.col-center #cartCanvas  { width:100% !important; height:auto !important; max-width:900px; border-radius:4px; }
.col-center .live-stats  { max-width:900px; width:100%; grid-template-columns:repeat(4,1fr); }

/* ‚îÄ‚îÄ Preset dropdown ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.preset-drop-wrap { width:100%; margin-bottom:0; }
.preset-drop-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:8px 11px; cursor:pointer; user-select:none;
  background:rgba(91,156,246,.03); border:1px solid rgba(91,156,246,.14);
  border-radius:6px; transition:border-color .2s;
}
.preset-drop-header.open { border-radius:6px 6px 0 0; border-color:rgba(91,156,246,.28); }
.preset-drop-title { font-size:.52rem; text-transform:uppercase; letter-spacing:.2em; color:var(--blue); font-family:'JetBrains Mono',monospace; }
.preset-active-name { font-size:.52rem; color:rgba(232,197,71,.65); letter-spacing:.06em; font-family:'JetBrains Mono',monospace; }
.preset-drop-chevron { font-size:.65rem; color:var(--blue); transition:transform .22s; }
.preset-drop-chevron.open { transform:rotate(180deg); }
.preset-drop-body {
  display:none; padding:11px 11px 13px;
  background:rgba(91,156,246,.015); border:1px solid rgba(91,156,246,.14);
  border-top:none; border-radius:0 0 6px 6px;
}
.preset-drop-body.open { display:block; }


/* ‚îÄ‚îÄ Dual wave row (cart + gap side by side) ‚îÄ‚îÄ */
.dual-wave-row {
  display: flex;
  gap: 12px;
  width: 100%;
  max-width: 900px;
  align-items: flex-start;
}
.wave-panel {
  display: flex;
  flex-direction: column;
  gap: 6px;
  flex: 1;
  min-width: 0;
}
.wave-label {
  font-size: .5rem; text-transform: uppercase; letter-spacing: .2em;
  color: rgba(91,156,246,.4); font-family: 'JetBrains Mono', monospace;
  padding: 0 2px;
}
.wave-label.gold { color: rgba(232,197,71,.45); }
.wave-panel.gap-hidden { display: none; }

/* ‚îÄ‚îÄ Stacked accordion panels ‚îÄ‚îÄ */
.center-bottom {
  width: 100%;
  max-width: 900px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

/* Shared accordion shell */
.accordion {
  width: 100%;
  border-radius: 8px;
  overflow: hidden;
}
.accordion-header {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  cursor: pointer;
  user-select: none;
  border-bottom: 1px solid transparent;
  transition: border-color .2s, background .2s;
}
.accordion-header:hover { background: rgba(255,255,255,.02); }
.accordion-header.open { border-bottom-color: var(--accordion-border, rgba(91,156,246,.15)); }
.accordion-title {
  font-size: .56rem; text-transform: uppercase; letter-spacing: .2em;
  font-family: 'JetBrains Mono', monospace;
  flex: 1;
}
.accordion-chevron {
  font-size: .65rem;
  transition: transform .22s;
  flex-shrink: 0;
}
.accordion-chevron.open { transform: rotate(180deg); }
.accordion-body {
  display: none;
  padding: 14px 16px 16px;
}
.accordion-body.open { display: block; }

/* Harmonics accordion ‚Äî blue */
.accordion.harm-accordion {
  background: var(--surface);
  border: 1px solid rgba(91,156,246,.18);
  --accordion-border: rgba(91,156,246,.18);
}
.accordion.harm-accordion .accordion-title { color: var(--blue); }
.accordion.harm-accordion .accordion-chevron { color: var(--blue); }

/* Gap accordion ‚Äî gold */
.accordion.gap-accordion {
  background: var(--surface);
  border: 1px solid rgba(232,197,71,.2);
  --accordion-border: rgba(232,197,71,.2);
}
.accordion.gap-accordion .accordion-title { color: var(--gold); }
.accordion.gap-accordion .accordion-chevron { color: var(--gold); }

/* On/Off toggle inside accordion header */
.acc-onoff-wrap {
  display: flex; align-items: center; gap: 8px; flex-shrink: 0;
  padding: 2px 0;
}
.acc-onoff-lbl {
  font-size: .5rem; text-transform: uppercase; letter-spacing: .12em;
  font-family: 'JetBrains Mono', monospace;
}
.acc-onoff-state {
  font-size: .48rem; font-family: 'JetBrains Mono', monospace;
  min-width: 24px;
}
/* prevent toggle click from bubbling to accordion open/close */
.acc-onoff-wrap * { pointer-events: auto; }

/* Gold toggle variant for gap channel */
#gapChannelOn {
  background: rgba(232,197,71,.12);
  border-color: rgba(232,197,71,.3);
}
#gapChannelOn:checked {
  background: var(--gold);
  border-color: var(--gold);
}
/* Scrollbar styling ‚Äî mathematical dark theme */
::-webkit-scrollbar { width:4px; height:4px; }
::-webkit-scrollbar-track { background:rgba(255,255,255,.02); }
::-webkit-scrollbar-thumb { background:rgba(91,156,246,.2); border-radius:2px; }
::-webkit-scrollbar-thumb:hover { background:rgba(91,156,246,.4); }

/* Select / input theming */
select {
  font-family:'JetBrains Mono',monospace; font-size:.58rem;
  background:#0e1119; border:1px solid rgba(91,156,246,.2);
  color:var(--blue); padding:3px 5px; border-radius:4px;
}

</style>
</head>
<body>
<div class="page-shell">

  <!-- ‚ïê‚ïê TOP BAR ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <header class="topbar">
    <div class="topbar-brand">
      <div class="topbar-title">Polar vs Cartesian</div>
      <div class="topbar-author">Wessen Getachew</div>
    </div>

    <div class="topbar-actions">
      <button class="ctrl" id="btnPlay">‚ñ∂ Play</button>
      <button class="ctrl" id="btnReset">‚Ü∫ Reset</button>
      <button class="ctrl" id="btnSkipComplete" title="Skip drawing ‚Äî show completed state instantly">‚è≠ Complete</button>
      <button class="ctrl gold-ctrl" id="btnExport4K" title="Export 4K PNG">‚¨á 4K</button>
      <button class="ctrl gold-ctrl" id="btnExportMulti" title="Export Multiple Angles">‚¨á Multi</button>
      <button class="ctrl" id="btnAutoRot">‚ü≥ Rotate</button>
      <button class="ctrl" id="btnFullscreen" title="Toggle fullscreen">‚õ∂ Full</button>
    </div>
  </header>

  <!-- ‚ïê‚ïê LEFT SIDEBAR ‚Äî Controls ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <aside class="col-left">

    <!-- Formula Parameters -->
    <div class="sidebar-label">Formula Parameters</div>
    <div class="side-card">
      <div class="grid-2">
        <div class="cg"><label>A ‚Äî offset</label><input type="range" id="sA" min="0.1" max="4" step="0.05" value="2"><div class="vd" id="dA">2</div></div>
        <div class="cg"><label>B ‚Äî outer freq</label><input type="range" id="sB" min="1" max="12" step="0.5" value="1"><div class="vd" id="dB">1</div></div>
        <div class="cg"><label>C ‚Äî inner freq</label><input type="range" id="sC" min="1" max="12" step="0.5" value="3"><div class="vd" id="dC">3</div></div>
        <div class="cg"><label>D ‚Äî modulation</label><input type="range" id="sD" min="4" max="128" step="1" value="32"><div class="vd" id="dD">32</div></div>
        <div class="cg"><label>Œ∏ range (√ó œÄ)</label><input type="range" id="sTheta" min="2" max="300" step="1" value="64"><div class="vd" id="dTheta">64œÄ</div></div>
      </div>
    </div>

    <!-- Playback Speed -->
    <div class="sidebar-label" style="margin-top:10px">Playback Speed</div>
    <div class="side-card">
      <div class="cg" style="margin-bottom:10px">
        <label>Draw speed</label>
        <input type="range" id="sSpeed" min="0.05" max="40" step="0.05" value="8">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="speed-sub" id="speedDesc">normal</div>
          <div class="vd" id="dSpeed">8.0</div>
        </div>
      </div>
      <div class="loop-row">
        <input type="checkbox" class="loop-check" id="cbLoop">
        <span class="loop-lbl">Loop</span>
        <span class="loop-state" id="loopState">off ‚Äî stops at end</span>
      </div>
      <div class="qrow" style="margin-top:10px">
        <span class="qlabel">Quick:</span>
        <button class="ctrl" style="font-size:.55rem;padding:3px 6px" onclick="setSpeed(0.1)">√ó0.1</button>
        <button class="ctrl" style="font-size:.55rem;padding:3px 6px" onclick="setSpeed(2)">Slow</button>
        <button class="ctrl" style="font-size:.55rem;padding:3px 6px" onclick="setSpeed(8)">Normal</button>
        <button class="ctrl" style="font-size:.55rem;padding:3px 6px" onclick="setSpeed(20)">Fast</button>
        <button class="ctrl" style="font-size:.55rem;padding:3px 6px" onclick="setSpeed(40)">Max</button>
      </div>
    </div>

    <!-- Coordinate Mode -->
    <div class="sidebar-label" style="margin-top:10px">Coordinate Mode</div>
    <div class="side-card" id="coordPanel">
      <div class="coord-mode-grid" id="coordModeGrid">
        <button class="coord-mode-btn active" data-mode="polar">‚äô Polar</button>
        <button class="coord-mode-btn" data-mode="logcylinder">‚åá Log-Cyl</button>
        <button class="coord-mode-btn" data-mode="logspiral">üåÄ Spiral</button>
        <button class="coord-mode-btn" data-mode="poincare">‚¨§ Poincar√©</button>
      </div>
      <div style="font-size:.56rem;color:rgba(94,189,120,.45);line-height:1.6;margin:7px 0;font-family:'JetBrains Mono',monospace" id="coordModeDesc">Polar/spherical ‚Äî default.</div>
      <div class="cg">
        <label style="color:rgba(150,180,150,.7)">Blend</label>
        <input type="range" id="coordBlend" min="0" max="1" step="0.01" value="1" style="background:rgba(94,189,120,.18)">
        <div style="font-size:.62rem;color:var(--green);text-align:right;font-family:'JetBrains Mono',monospace" id="coordBlendVal">100%</div>
      </div>
    </div>

    <!-- Presets -->
    <div class="sidebar-label" style="margin-top:10px">Presets</div>
    <div class="side-card">
      <div class="preset-drop-wrap" style="max-width:none;margin:0">
        <div class="preset-drop-header" id="presetDropHeader">
          <div class="preset-drop-title">Select Preset</div>
          <span class="preset-active-name" id="presetActiveName">Original</span>
          <span class="preset-drop-chevron" id="presetDropChev">‚ñº</span>
        </div>
        <div class="preset-drop-body" id="presetDropBody">
          <div class="pg-label">Classics</div><div class="presets" id="pgClassic"></div>
          <div class="pg-label">Complex</div><div class="presets" id="pgComplex"></div>
          <div class="pg-label">Organic</div><div class="presets" id="pgOrganic"></div>
          <div class="pg-label">Geometric</div><div class="presets" id="pgGeo"></div>
          <div class="pg-label">Ethereal</div><div class="presets" id="pgEth"></div>
        </div>
      </div>
    </div>

    <!-- Gap Decomposition ‚Äî controls only in sidebar, output below harmonics in center -->
    <div class="sidebar-label" style="margin-top:10px;color:rgba(232,197,71,.38)">Gap Decomposition ¬∑ Œ∂(s)</div>
    <div class="side-card">

      <!-- Channel toggle -->
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:10px;padding-bottom:10px;border-bottom:1px solid rgba(232,197,71,.1)">
        <input type="checkbox" class="harm-toggle" id="gapChannelOn"
          style="background:rgba(232,197,71,.12);border-color:rgba(232,197,71,.3);"
          onchange="toggleGapChannel(this.checked)">
        <span class="acc-onoff-lbl" style="color:var(--gold)">Channel</span>
        <span class="acc-onoff-state" style="color:rgba(232,197,71,.45)" id="gapChannelState">off</span>
      </div>

      <div class="gap-ctrl-grid">
        <div class="cg">
          <label>Max N (primes up to)</label>
          <input type="range" id="gdN" min="1" max="300000000" step="1" value="10000000">
          <div class="gap-vd" id="gdND">10,000,000</div>
        </div>
        <div class="cg">
          <label>Œ∂ exponent s</label>
          <input type="range" id="gdS" min="1.01" max="10" step="0.01" value="2">
          <div class="gap-vd" id="gdSD" style="color:var(--gold)">s = 2.00</div>
        </div>
      </div>

      <div class="gap-filter-row">
        <span class="gap-filter-lbl">Gap filter:</span>
        <button class="gap-filter-btn active" data-filter="all" onclick="setGapFilter(this,'all')">All</button>
        <button class="gap-filter-btn" data-filter="tiny" onclick="setGapFilter(this,'tiny')">2‚Äì10</button>
        <button class="gap-filter-btn" data-filter="small" onclick="setGapFilter(this,'small')">2‚Äì30</button>
        <button class="gap-filter-btn" data-filter="medium" onclick="setGapFilter(this,'medium')">20‚Äì80</button>
        <button class="gap-filter-btn" data-filter="large" onclick="setGapFilter(this,'large')">50‚Äì200</button>
      </div>

      <div class="gap-run-row" style="margin-top:8px">
        <button class="ctrl gold-ctrl" id="gdRunBtn" onclick="gdRun()">‚ñ∂ Compute</button>
        <button class="ctrl gold-ctrl" onclick="gdClear()" style="font-size:.6rem;padding:6px 10px">‚úï Clear</button>
      </div>

      <div class="thick-row">
        <label>Trace Thickness</label>
        <input type="range" id="gdThick" min="0.5" max="8" step="0.5" value="1.35">
        <span class="thick-val" id="gdThickVal">1.35px</span>
      </div>

      <div class="gap-progress" id="gdProgress" style="margin-top:8px"><div class="gap-progress-fill" id="gdProgressFill"></div></div>
      <div class="gap-status" id="gdStatus" style="margin-top:4px;font-size:.54rem;color:rgba(232,197,71,.45);font-family:'JetBrains Mono',monospace;line-height:1.5">Run to analyze prime gap contributions to Œ∂(s).</div>

    </div><!-- /.side-card -->

  </aside>

  <!-- ‚ïê‚ïê CENTER ‚Äî Visualization ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <main class="col-center">

    <!-- Featured Formula Box -->
    <div style="width:100%;margin-bottom:16px;">
      <div style="background:rgba(232,197,71,0.06);border:2px solid rgba(232,197,71,0.3);border-radius:10px;padding:16px 20px;text-align:center;">
        <div style="font-family:'JetBrains Mono',monospace;font-size:clamp(1.1rem,2.2vw,1.6rem);color:var(--gold);font-weight:bold;">
          f(Œ∏) = <span id="fA">2</span> + sin(<span id="fB">1</span>Œ∏) ¬∑ sin(<span id="fC">3</span>Œ∏ / <span id="fD">32</span>)
        </div>
      </div>
    </div>

    <!-- Sphere canvas -->
    <div class="sphere-wrap">
      <canvas id="polarCanvas"></canvas>

      <div class="rot-controls">
        <span class="rot-hint">drag to rotate ¬∑ shift+drag to pan</span>
        <button class="ctrl" id="btnResetRot" style="font-size:.58rem;padding:4px 9px">‚Ü∫ Reset View</button>
      </div>

      <div class="zoom-bar">
        <button class="zoom-btn" id="btnZoomOut">‚àí</button>
        <span class="zoom-level-lbl" id="zoomLbl">1.0√ó</span>
        <button class="zoom-btn" id="btnZoomIn">+</button>
        <button class="zoom-reset-btn" id="btnZoomReset">Reset Zoom</button>
      </div>

      <!-- Manual Rotation Controls -->
      <div style="margin-top:12px;margin-bottom:8px;">
        <div class="pg-label" style="margin-bottom:6px;">rotation (degrees)</div>
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;">
          <div>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:3px;">
              <label style="font-size:.48rem;color:var(--text-dim);font-family:'JetBrains Mono',monospace;text-transform:uppercase;letter-spacing:.1em;">X¬∞</label>
              <input type="number" class="rotation-input-small" id="rotX" value="90" min="0" max="360" step="1" style="width:50px;padding:3px 5px;background:var(--surface);border:1px solid var(--border);border-radius:3px;color:var(--text);font-family:'JetBrains Mono',monospace;font-size:.65rem;text-align:center;">
            </div>
            <input type="range" class="slider" id="rotXSlider" min="0" max="360" step="1" value="90" style="width:100%;">
          </div>
          <div>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:3px;">
              <label style="font-size:.48rem;color:var(--text-dim);font-family:'JetBrains Mono',monospace;text-transform:uppercase;letter-spacing:.1em;">Y¬∞</label>
              <input type="number" class="rotation-input-small" id="rotY" value="0" min="0" max="360" step="1" style="width:50px;padding:3px 5px;background:var(--surface);border:1px solid var(--border);border-radius:3px;color:var(--text);font-family:'JetBrains Mono',monospace;font-size:.65rem;text-align:center;">
            </div>
            <input type="range" class="slider" id="rotYSlider" min="0" max="360" step="1" value="0" style="width:100%;">
          </div>
          <div>
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:3px;">
              <label style="font-size:.48rem;color:var(--text-dim);font-family:'JetBrains Mono',monospace;text-transform:uppercase;letter-spacing:.1em;">Z¬∞</label>
              <input type="number" class="rotation-input-small" id="rotZ" value="0" min="0" max="360" step="1" style="width:50px;padding:3px 5px;background:var(--surface);border:1px solid var(--border);border-radius:3px;color:var(--text);font-family:'JetBrains Mono',monospace;font-size:.65rem;text-align:center;">
            </div>
            <input type="range" class="slider" id="rotZSlider" min="0" max="360" step="1" value="0" style="width:100%;">
          </div>
        </div>
      </div>

      <div class="kb-hint">Space=Play ¬∑ R=Rotate ¬∑ F=Fullscreen ¬∑ S=Screenshot ¬∑ ‚Üë‚Üì=Zoom ¬∑ ‚Üê‚Üí=Spin</div>
    </div>

    <!-- Dual wave row: Cartesian + Gap side by side -->
    <div class="dual-wave-row" id="dualWaveRow">
      <!-- Left: Cartesian wave -->
      <div class="wave-panel" id="cartWavePanel">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:4px;">
          <div class="wave-label">f(Œ∏) ‚Äî Cartesian</div>
          <div style="display:flex;align-items:center;gap:10px;">
            <span style="font-size:.44rem;color:rgba(91,156,246,.35);font-family:'JetBrains Mono',monospace;letter-spacing:.08em">click to probe</span>
            <label style="font-size:.48rem;color:rgba(91,156,246,.5);text-transform:uppercase;letter-spacing:.1em;font-family:'JetBrains Mono',monospace;">Extend ‚àía</label>
            <input type="checkbox" class="loop-check" id="cbNegA" title="Show negative extent below zero">
          </div>
        </div>
        <canvas id="cartCanvas" style="cursor:crosshair"></canvas>

        <!-- Probe detail panel ‚Äî shown after click -->
        <div id="cartProbePanel" style="display:none;margin-top:8px;background:rgba(6,6,8,.85);border:1px solid rgba(91,156,246,.18);border-radius:6px;padding:10px 14px;">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
            <span style="font-size:.5rem;text-transform:uppercase;letter-spacing:.2em;color:rgba(91,156,246,.5);font-family:'JetBrains Mono',monospace">Point Probe</span>
            <button onclick="clearCartProbe()" style="background:none;border:none;color:rgba(91,156,246,.4);font-size:.65rem;cursor:pointer;padding:0 2px">‚úï</button>
          </div>
          <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px 12px;" id="cartProbeGrid">
            <!-- filled by JS -->
          </div>
          <!-- Connection to gap decomp -->
          <div id="cartProbeGap" style="display:none;margin-top:8px;padding-top:8px;border-top:1px solid rgba(232,197,71,.12);">
            <div style="font-size:.44rem;text-transform:uppercase;letter-spacing:.18em;color:rgba(232,197,71,.4);font-family:'JetBrains Mono',monospace;margin-bottom:4px">Prime Gap at this Œ∏</div>
            <div id="cartProbeGapDetail" style="font-family:'JetBrains Mono',monospace;font-size:.62rem;color:rgba(232,197,71,.85);line-height:1.9"></div>
          </div>
          <!-- Sphere highlight indicator -->
          <div id="cartProbeSphereHint" style="margin-top:8px;padding:5px 9px;background:rgba(91,156,246,.06);border-radius:4px;font-size:.48rem;color:rgba(91,156,246,.55);font-family:'JetBrains Mono',monospace;text-align:center;display:none">
            Point highlighted on sphere above
          </div>
        </div>

        <!-- Connection explainer ‚Äî always shown once gap data loaded -->
        <div id="cartGapRelation" style="display:none;margin-top:8px;padding:9px 13px;background:rgba(232,197,71,.04);border:1px solid rgba(232,197,71,.1);border-radius:6px;">
          <div style="font-size:.44rem;text-transform:uppercase;letter-spacing:.18em;color:rgba(232,197,71,.35);font-family:'JetBrains Mono',monospace;margin-bottom:5px">How f(Œ∏) and Gap Families Connect</div>
          <div id="cartGapRelationText" style="font-size:.54rem;color:rgba(200,185,150,.6);font-family:'JetBrains Mono',monospace;line-height:1.8"></div>
        </div>
      </div>
      <!-- Right: Gap Œ∂(s) chart ‚Äî hidden until data loaded -->
      <div class="wave-panel gap-hidden" id="gapWavePanel">
        <div class="wave-label gold">Gap Families ‚Äî Œ∂(s)</div>
        <canvas id="gapCanvas" height="300"></canvas>
        <div class="gap-legend" id="gdLegend"></div>
      </div>
    </div>

    <!-- Live stats bar -->
    <div class="live-stats" id="liveStats" style="max-width:900px">
      <div class="stat-cell"><div class="stat-lbl">Progress</div><div class="stat-val" id="stProg">0%</div></div>
      <div class="stat-cell"><div class="stat-lbl">Œ∏ current</div><div class="stat-val" id="stTheta">0</div></div>
      <div class="stat-cell"><div class="stat-lbl">f(Œ∏) now</div><div class="stat-val" id="stFTheta">‚Äî</div></div>
      <div class="stat-cell"><div class="stat-lbl">f(Œ∏) min</div><div class="stat-val" id="stFMin">‚Äî</div></div>
      <div class="stat-cell"><div class="stat-lbl">f(Œ∏) max</div><div class="stat-val" id="stFMax">‚Äî</div></div>
      <div class="stat-cell"><div class="stat-lbl">f(Œ∏) mean</div><div class="stat-val" id="stFMean">‚Äî</div></div>
      <div class="stat-cell"><div class="stat-lbl">Pts drawn</div><div class="stat-val" id="stPts">0</div></div>
      <div class="stat-cell"><div class="stat-lbl">Œ∏ total</div><div class="stat-val" id="stThetaMax">64œÄ</div></div>
    </div>

    <!-- Harmonics accordion (center only) -->
    <div class="center-bottom">
      <div class="accordion harm-accordion" id="harmPanelWrap">
        <div class="accordion-header" id="harmAccHeader" onclick="toggleHarmAccordion(event)">
          <span class="accordion-title">‚ô© Harmonics ¬∑ Farey Intervals</span>
          <div class="acc-onoff-wrap" onclick="event.stopPropagation()">
            <input type="checkbox" class="harm-toggle" id="harmSyncOn"
              style="background:rgba(91,156,246,.12);border-color:rgba(91,156,246,.3);"
              onchange="toggleHarmSync(this.checked)">
            <span class="acc-onoff-lbl" style="color:var(--blue)">Sound</span>
            <span class="acc-onoff-state" style="color:rgba(91,156,246,.45)" id="harmSyncState">off</span>
          </div>
          <span class="accordion-chevron" id="harmAccChev">‚ñº</span>
        </div>
        <div class="accordion-body" id="harmAccBody">
          <div class="harm-mode-row" style="margin-top:0;padding-top:0;border-top:none;margin-bottom:10px">
            <input type="checkbox" class="harm-toggle" id="harmColorMode">
            <span class="harm-lbl">Sphere Color Mode</span>
            <span class="harm-state" id="harmModeState">off</span>
          </div>
          <div class="harm-section-title">Farey Intervals</div>
          <div class="harm-interval-grid" id="harmIntervalGrid"></div>
          <div class="harm-consonance-key" style="margin-top:5px">
            <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#5ebd78"></div><span style="color:#5ebd78;font-size:.48rem">1:1</span></div>
            <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#5b9cf6"></div><span style="color:#5b9cf6;font-size:.48rem">q‚â§4</span></div>
            <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#e8c547"></div><span style="color:#e8c547;font-size:.48rem">q‚â§16</span></div>
            <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#fb923c"></div><span style="color:#fb923c;font-size:.48rem">q‚â§64</span></div>
            <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#b48eff"></div><span style="color:#b48eff;font-size:.48rem">q>64</span></div>
          </div>
          <div class="harm-audio-row" style="margin-top:10px">
            <div class="harm-freq-display" id="harmFreqDisplay">‚Äî Hz</div>
            <div class="harm-note-display" id="harmNoteDisplay">‚Äî ¬∑ ‚Äî</div>
          </div>
          <div class="harm-section-title" style="margin-top:12px">Audio
            <span id="harmModeIndicator" style="margin-left:8px;font-size:.48rem;color:rgba(91,156,246,.5);text-transform:none;letter-spacing:.04em;font-family:'DM Sans',sans-serif">¬∑ sound is off</span>
          </div>
          <div class="harm-btn-row">
            <button class="harm-btn" id="harmPlayBtn" onclick="harmPlay()">‚ñ∂ Play once</button>
            <button class="harm-btn" id="harmChordBtn" onclick="harmChord()">‚ô™ Chord</button>
            <button class="harm-btn" id="harmArpBtn" onclick="harmArp()">‚àø Arp</button>
            <button class="harm-btn" onclick="harmStop()">‚ñ† Stop</button>
          </div>
          <div style="display:flex;gap:9px;margin-top:8px">
            <div class="cg" style="flex:1">
              <label style="font-size:.52rem;color:rgba(150,175,200,.6)">Base Hz</label>
              <input type="range" id="harmBaseHz" min="110" max="880" step="1" value="220" style="background:rgba(91,156,246,.18)">
              <div class="vd" id="harmBaseHzVal" style="color:var(--blue);font-size:.58rem">220 Hz</div>
            </div>
            <div class="cg" style="flex:1">
              <label style="font-size:.52rem;color:rgba(150,175,200,.6)">Volume</label>
              <input type="range" id="harmVol" min="0" max="5" step="0.05" value="0.35" style="background:rgba(91,156,246,.18)">
              <div class="vd" id="harmVolVal" style="color:var(--blue);font-size:.58rem">35%</div>
            </div>
            <div class="cg" style="flex:1">
              <label style="font-size:.52rem;color:rgba(150,175,200,.6)">Wave</label>
              <select id="harmWave" style="font-family:'JetBrains Mono',monospace;font-size:.55rem;background:#0e1119;border:1px solid rgba(91,156,246,.2);color:var(--blue);padding:2px 3px;border-radius:4px;width:100%">
                <option value="sine">Sine</option>
                <option value="triangle">Triangle</option>
                <option value="square">Square</option>
                <option value="sawtooth">Saw</option>
              </select>
            </div>
          </div>
          <div class="harm-section-title" style="margin-top:12px">Arnold Tongue ¬∑ Warp</div>
          <div class="arnold-row">
            <label style="font-size:.52rem;color:rgba(150,175,200,.6);flex-shrink:0">K</label>
            <input type="range" id="harmArnold" min="0" max="2" step="0.01" value="0" style="flex:1;background:rgba(232,121,249,.18)">
            <span class="arnold-val" id="harmArnoldVal">0.00</span>
            <button class="harm-btn" style="font-size:.5rem;padding:3px 6px" onclick="applyArnoldWarp()">Apply</button>
            <button class="harm-btn" style="font-size:.5rem;padding:3px 6px" onclick="resetArnold()">Reset</button>
          </div>
        </div><!-- /.accordion-body -->
      </div><!-- /.harm-accordion -->

      <!-- ‚îÄ‚îÄ Gap Decomposition Results Accordion ‚îÄ‚îÄ -->
      <div class="accordion gap-accordion" id="gapDecompWrap">
        <div class="accordion-header" id="gapAccHeader" onclick="toggleGapAccordion(event)">
          <span class="accordion-title">‚ö° Gap Decomposition ¬∑ Œ∂(s)</span>
          <div class="acc-onoff-wrap" style="display:flex;gap:8px;align-items:center">
            <button class="ctrl gold-ctrl" id="gdExportPNG" onclick="gdExport4K();event.stopPropagation()" style="display:none;font-size:.5rem;padding:3px 8px">‚¨á 4K PNG</button>
            <button class="ctrl gold-ctrl" id="gdExportCSV" onclick="gdExportCSV();event.stopPropagation()" style="display:none;font-size:.5rem;padding:3px 8px">‚¨á CSV</button>
            <button class="ctrl gold-ctrl" id="gdExportTXT" onclick="gdExportTXT();event.stopPropagation()" style="display:none;font-size:.5rem;padding:3px 8px">‚¨á Report</button>
          </div>
          <span class="accordion-chevron" id="gapAccChev">‚ñº</span>
        </div>
        <div class="accordion-body" id="gapAccBody">

          <!-- Gap selector chips -->
          <div class="gap-selector-wrap" id="gdSelectorWrap" style="display:none">
            <div class="gap-selector-label">
              Click gaps to highlight on sphere &amp; cart
              <span>‚Äî each gets its own color; deselect to remove</span>
              <button class="gap-filter-btn" onclick="gdClearSelection()" style="margin-left:auto">‚úï Clear all</button>
            </div>
            <div class="gap-chips" id="gdChips"></div>
          </div>

          <!-- Stats grid with screenshot -->
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;margin-top:2px">
            <span style="font-size:.48rem;text-transform:uppercase;letter-spacing:.18em;color:rgba(232,197,71,.4);font-family:'JetBrains Mono',monospace">Statistics</span>
            <button class="ctrl gold-ctrl" onclick="screenshotSection('gdStatsGrid','gap_stats')" style="font-size:.48rem;padding:2px 7px;opacity:.7">‚¨á Stats PNG</button>
          </div>
          <div class="gap-live-stats" id="gdStatsGrid" style="display:none">
            <div class="gap-stat"><div class="gap-stat-lbl">Total primes</div><div class="gap-stat-val" id="gst0">‚Äî</div></div>
            <div class="gap-stat"><div class="gap-stat-lbl">Gap families</div><div class="gap-stat-val" id="gst1">‚Äî</div></div>
            <div class="gap-stat"><div class="gap-stat-lbl">Max gap</div><div class="gap-stat-val" id="gst2">‚Äî</div></div>
            <div class="gap-stat"><div class="gap-stat-lbl">Target Œ∂(s)</div><div class="gap-stat-val" id="gst3">‚Äî</div></div>
            <div class="gap-stat"><div class="gap-stat-lbl">Computed product</div><div class="gap-stat-val" id="gst4">‚Äî</div></div>
            <div class="gap-stat"><div class="gap-stat-lbl">Rel. error</div><div class="gap-stat-val" id="gst5">‚Äî</div></div>
            <div class="gap-stat"><div class="gap-stat-lbl">Twin primes (g=2)</div><div class="gap-stat-val" id="gst6">‚Äî</div></div>
            <div class="gap-stat"><div class="gap-stat-lbl">Cousin primes (g=4)</div><div class="gap-stat-val" id="gst7">‚Äî</div></div>
            <div class="gap-stat"><div class="gap-stat-lbl">Sexy primes (g=6)</div><div class="gap-stat-val" id="gst8">‚Äî</div></div>
            <div class="gap-stat"><div class="gap-stat-lbl">Most common gap</div><div class="gap-stat-val" id="gst9">‚Äî</div></div>
            <div class="gap-stat"><div class="gap-stat-lbl">Twin ratio (g2/g4)</div><div class="gap-stat-val" id="gst10">‚Äî</div></div>
            <div class="gap-stat"><div class="gap-stat-lbl">Calculated œÄ</div><div class="gap-stat-val" id="gst11">‚Äî</div></div>
          </div>

          <!-- Chart canvas with screenshot -->
          <div style="display:flex;align-items:center;justify-content:space-between;margin-top:12px;margin-bottom:6px">
            <div class="gap-tabs" id="gdTabs" style="display:none;flex:1">
              <button class="gap-tab active" onclick="gdSwitchTab(this,'contrib')">Contributions</button>
              <button class="gap-tab" onclick="gdSwitchTab(this,'dist')">Distribution</button>
              <button class="gap-tab" onclick="gdSwitchTab(this,'conv')">Convergence</button>
              <button class="gap-tab" onclick="gdSwitchTab(this,'ratio')">Gap Ratios</button>
              <button class="gap-tab" onclick="gdSwitchTab(this,'pct')">% Share</button>
            </div>
            <button class="ctrl gold-ctrl" id="gdChartScreenshot" onclick="screenshotCanvas(gdCanvas,'gap_chart')" style="font-size:.48rem;padding:2px 7px;opacity:.7;display:none;margin-left:8px;flex-shrink:0">‚¨á Chart PNG</button>
          </div>
          <!-- Chart canvas (re-rendered here from the center wave panel, shown large) -->
          <div id="gdChartArea" style="width:100%;display:none">
            <canvas id="gdChartBig" style="width:100%;border-radius:4px;background:#060608;display:block"></canvas>
          </div>

          <!-- Contributions table with screenshot -->
          <div class="gap-table-wrap" id="gdTableSection" style="display:none">
            <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px">
              <div class="gap-table-controls" style="flex:1">
                <label>Sort by:
                  <select id="gdTableSort" onchange="gdBuildTable()">
                    <option value="gap">Gap ‚Üë</option>
                    <option value="count_desc">Count ‚Üì</option>
                    <option value="logshare_desc">Log-Œ∂ share ‚Üì</option>
                    <option value="product_desc">Product ‚Üì</option>
                    <option value="cumulative">Cumulative ‚Üë</option>
                  </select>
                </label>
                <label>Decimals:
                  <input type="number" id="gdTableDec" min="2" max="20" value="8" style="width:46px" onchange="gdBuildTable()">
                </label>
                <label>Show top:
                  <select id="gdTableTop" onchange="gdBuildTable()">
                    <option value="0">All</option>
                    <option value="10">10</option>
                    <option value="25">25</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                  </select>
                </label>
                <label><input type="checkbox" id="gdTableHighlight" checked onchange="gdBuildTable()"> Highlight selected</label>
              </div>
              <button class="ctrl gold-ctrl" onclick="screenshotSection('gdTableWrap','gap_table')" style="font-size:.48rem;padding:2px 7px;opacity:.7;margin-left:8px;flex-shrink:0">‚¨á Table PNG</button>
            </div>
            <div id="gdTableWrap"></div>
          </div>

          <!-- Convergence table with screenshot -->
          <div class="conv-dropdown-wrap" id="gdConvSection" style="display:none">
            <div class="conv-dropdown-header" id="convDropHeader">
              <div class="conv-dropdown-title">‚ü∂ Step-by-step convergence to œÄ¬≤/6 = Œ∂(2)</div>
              <button class="ctrl gold-ctrl" onclick="screenshotSection('gdConvTableWrap','gap_convergence');event.stopPropagation()" style="font-size:.48rem;padding:2px 7px;opacity:.7;margin-right:8px">‚¨á Conv PNG</button>
              <span class="conv-dropdown-chevron" id="convDropChev">‚ñº</span>
            </div>
            <div class="conv-dropdown-body" id="convDropBody">
              <div class="conv-table-controls">
                <label>Sort:
                  <select id="convSort" onchange="gdBuildConvTable()">
                    <option value="gap_asc">Gap ‚Üë (natural order)</option>
                    <option value="logshare_desc">Log-share ‚Üì</option>
                    <option value="cumulative_asc">Cumulative product ‚Üë</option>
                    <option value="relerr_asc">Rel. error ‚Üë (best first)</option>
                  </select>
                </label>
                <label>Decimals:
                  <input type="number" id="convDec" min="2" max="20" value="12" onchange="gdBuildConvTable()">
                </label>
                <label>Show top:
                  <select id="convTop" onchange="gdBuildConvTable()">
                    <option value="0">All steps</option>
                    <option value="10">10</option>
                    <option value="25">25</option>
                    <option value="50">50</option>
                  </select>
                </label>
                <label><input type="checkbox" id="convShowPi" checked onchange="gdBuildConvTable()"> Show œÄ estimate</label>
                <label><input type="checkbox" id="convShowLog" checked onchange="gdBuildConvTable()"> log‚ÇÅ‚ÇÄ error</label>
                <label><input type="checkbox" id="convShowDelta" checked onchange="gdBuildConvTable()"> Œî product</label>
              </div>
              <div id="gdConvTableWrap"></div>
            </div>
          </div>

        </div><!-- /.accordion-body #gapAccBody -->
      </div><!-- /.gap-accordion -->

    </div><!-- /.center-bottom -->

  </main>

  <!-- right col removed ‚Äî content in sidebar and center -->

</div><!-- /.page-shell -->

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PRESETS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const PRESET_GROUPS = {
  pgClassic: [
    { name:'Original',   A:1.9, B:3,  C:3,  D:32,  theta:64,  trail:6  },
    { name:'Halo',       A:2,   B:1,  C:1,  D:128, theta:4,   trail:1  },
    { name:'Daisy',      A:1.0, B:5,  C:5,  D:20,  theta:40,  trail:6  },
    { name:'Sunflower',  A:1.0, B:5,  C:5,  D:21,  theta:42,  trail:5  },
    { name:'Rose',       A:2.0, B:4,  C:4,  D:16,  theta:32,  trail:6  },
    { name:'Lily',       A:1.5, B:6,  C:6,  D:18,  theta:36,  trail:6  },
  ],
  pgComplex: [
    { name:'Hypnotic',   A:0.5, B:7,  C:7,  D:16,  theta:64,  trail:8  },
    { name:'Galaxy',     A:1.5, B:9,  C:1,  D:64,  theta:128, trail:4  },
    { name:'Fractal',    A:0.8, B:11, C:11, D:43,  theta:86,  trail:8  },
    { name:'Mandala',    A:1.2, B:8,  C:8,  D:40,  theta:80,  trail:6  },
    { name:'Deep Space', A:0.6, B:12, C:3,  D:96,  theta:128, trail:3  },
    { name:'Cosmos',     A:1.0, B:10, C:2,  D:80,  theta:128, trail:4  },
    { name:'Nebula',     A:1.3, B:9,  C:4,  D:72,  theta:108, trail:5  },
    { name:'Quasar',     A:0.7, B:11, C:7,  D:55,  theta:110, trail:3  },
  ],
  pgOrganic: [
    { name:'Butterfly',  A:2.0, B:2,  C:4,  D:8,   theta:32,  trail:10 },
    { name:'Jellyfish',  A:1.8, B:3,  C:2,  D:12,  theta:48,  trail:8  },
    { name:'Fern',       A:1.1, B:2,  C:5,  D:10,  theta:40,  trail:7  },
    { name:'Coral',      A:1.4, B:4,  C:2,  D:28,  theta:56,  trail:6  },
    { name:'Anemone',    A:1.6, B:5,  C:3,  D:15,  theta:60,  trail:6  },
    { name:'Seashell',   A:2.2, B:3,  C:1,  D:24,  theta:48,  trail:5  },
    { name:'Vine',       A:1.0, B:3,  C:7,  D:14,  theta:56,  trail:6  },
    { name:'Mycelium',   A:0.9, B:6,  C:2,  D:36,  theta:72,  trail:4  },
  ],
  pgGeo: [
    { name:'Crystal',    A:2.5, B:4,  C:4,  D:24,  theta:48,  trail:6  },
    { name:'Spiral',     A:1.2, B:1,  C:6,  D:12,  theta:96,  trail:5  },
    { name:'Hexagon',    A:2.0, B:6,  C:6,  D:36,  theta:72,  trail:6  },
    { name:'Star-12',    A:1.8, B:12, C:12, D:48,  theta:96,  trail:7  },
    { name:'Diamond',    A:2.1, B:4,  C:8,  D:20,  theta:40,  trail:6  },
    { name:'Pinwheel',   A:1.3, B:3,  C:9,  D:18,  theta:54,  trail:6  },
    { name:'Web',        A:0.9, B:7,  C:3,  D:42,  theta:84,  trail:5  },
    { name:'Lattice',    A:1.7, B:5,  C:7,  D:35,  theta:70,  trail:5  },
  ],
  pgEth: [
    { name:'Whisper',    A:3.5, B:2,  C:1,  D:16,  theta:8,   trail:2  },
    { name:'Phantom',    A:0.3, B:8,  C:8,  D:32,  theta:64,  trail:2  },
    { name:'Aurora',     A:1.9, B:4,  C:1,  D:48,  theta:96,  trail:3  },
    { name:'Mirage',     A:2.3, B:5,  C:2,  D:30,  theta:60,  trail:4  },
    { name:'Specter',    A:1.5, B:7,  C:2,  D:56,  theta:112, trail:2  },
    { name:'Wraith',     A:0.5, B:10, C:5,  D:100, theta:100, trail:1  },
    { name:'Solstice',   A:2.8, B:3,  C:3,  D:64,  theta:64,  trail:5  },
    { name:'Eclipse',    A:1.9, B:2,  C:6,  D:12,  theta:24,  trail:3  },
  ],
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  GAP COLOR PALETTE (shared everywhere)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const GAP_PALETTE = {
  2:'#ffd700', 4:'#4ecdc4', 6:'#a855f7', 8:'#f97316',
  10:'#22c55e', 12:'#38bdf8', 14:'#fb7185', 18:'#e879f9',
  24:'#facc15', 30:'#34d399', 36:'#60a5fa', 42:'#f87171',
  48:'#a3e635', 72:'#fb923c', 86:'#c084fc',
};
const FALLBACK_COLORS = [
  '#ffd700','#4ecdc4','#a855f7','#f97316','#22c55e','#38bdf8',
  '#fb7185','#e879f9','#facc15','#34d399','#60a5fa','#f87171',
  '#a3e635','#fb923c','#c084fc','#ff6b9d','#00d2ff','#7fff00',
];
function gapColor(g, idx){ return GAP_PALETTE[g] || FALLBACK_COLORS[idx % FALLBACK_COLORS.length]; }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MULTI-GAP SELECTION STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Map: gapValue ‚Üí color string (when selected)
let selectedGaps = new Map();
// Lookup: gapValue ‚Üí index in allGaps array (for color assignment)
let gapIndexMap = {};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  VISUALIZATION STATE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let A=2, B=1, C=3, D=32, thetaTotal=64*Math.PI, trailFade=6;
let speed=8, paused=true, looping=false;
let traceThickness = 1.35;

const TOTAL_PTS = 8000;
let precomputed = [];
let drawProgress = 0;
let lastCartProg = 0;

// Precomputed stats
let fMin=Infinity, fMax=-Infinity, fSum=0;

// 3D rotation
let rotMat = [1,0,0, 0,1,0, 0,0,1];
let autoRotate = false;
let seqRotateOnComplete = false; // true when preset triggers auto-rotate on finish
let isDrag=false, lastMX=0, lastMY=0;

// Manual rotation angles (in degrees)
let manualRotX = 90;
let manualRotY = 0;
let manualRotZ = 0;

// Wrap angle to 0-360 range
function wrapAngle(angle) {
  angle = angle % 360;
  if (angle < 0) angle += 360;
  return angle;
}

// Function to build rotation matrix from manual angles
function updateManualRotation() {
  const rx = manualRotX * Math.PI / 180;
  const ry = manualRotY * Math.PI / 180;
  const rz = manualRotZ * Math.PI / 180;
  // Apply rotations in order: Z, Y, X
  rotMat = mmul(mrotX(rx), mmul(mrotY(ry), mrotZ(rz)));
}

// Function to extract Euler angles from rotation matrix (XYZ order)
function extractEulerAngles() {
  // Extract angles from rotation matrix
  // Assuming rotation order: Z, Y, X
  const sy = Math.sqrt(rotMat[0] * rotMat[0] + rotMat[3] * rotMat[3]);
  
  let x, y, z;
  
  if (sy > 1e-6) {
    x = Math.atan2(rotMat[7], rotMat[8]);
    y = Math.atan2(-rotMat[6], sy);
    z = Math.atan2(rotMat[3], rotMat[0]);
  } else {
    x = Math.atan2(-rotMat[5], rotMat[4]);
    y = Math.atan2(-rotMat[6], sy);
    z = 0;
  }
  
  return {
    x: wrapAngle(x * 180 / Math.PI),
    y: wrapAngle(y * 180 / Math.PI),
    z: wrapAngle(z * 180 / Math.PI)
  };
}

// Function to update input fields and sliders from rotation matrix
function updateRotationInputs() {
  const angles = extractEulerAngles();
  manualRotX = angles.x;
  manualRotY = angles.y;
  manualRotZ = angles.z;
  
  const roundedX = Math.round(angles.x);
  const roundedY = Math.round(angles.y);
  const roundedZ = Math.round(angles.z);
  
  document.getElementById('rotX').value = roundedX;
  document.getElementById('rotY').value = roundedY;
  document.getElementById('rotZ').value = roundedZ;
  
  document.getElementById('rotXSlider').value = roundedX;
  document.getElementById('rotYSlider').value = roundedY;
  document.getElementById('rotZSlider').value = roundedZ;
}

// Initialize rotation matrix with default angles
updateManualRotation();

const PAD = {l:38,r:14,t:12,b:26};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CANVASES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const pCv = document.getElementById('polarCanvas');
const pCtx = pCv.getContext('2d');
const cCv = document.getElementById('cartCanvas');
const cCtx = cCv.getContext('2d');
let cBuf;

function setSize() {
  const leftSidebar = window.innerWidth > 900 ? 320 : 0;
  const sphereW = Math.min(window.innerWidth - leftSidebar - 80, 900);
  pCv.width = pCv.height = sphereW;
  const gapVisible = document.getElementById('gapWavePanel') &&
    !document.getElementById('gapWavePanel').classList.contains('gap-hidden');
  const cartW = gapVisible ? Math.floor((sphereW - 12) / 2) : sphereW;

  // Base height + extra per selected gap lane (each lane needs ~52px min to be readable)
  const baseH = Math.round(cartW * 0.42);
  const nGaps = selectedGaps ? selectedGaps.size : 0;
  const LANE_PX = 52; // min px per lane
  const neededH = nGaps > 0 ? Math.max(baseH, baseH * 0.55 + nGaps * LANE_PX) : baseH;
  cCv.width = cartW;
  cCv.height = Math.round(neededH);
}
setSize();
// ‚îÄ‚îÄ Robust resize handling ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Mobile browsers fire 'resize' when the address bar hides/shows during scroll.
// We use visualViewport.width (stable during scroll) and only reset when the
// LAYOUT width actually changes by more than 8px.
let _lastLayoutW = 0;

function onLayoutResize() {
  const vvw = (window.visualViewport ? window.visualViewport.width : window.innerWidth);
  const newW = Math.round(vvw);
  if (Math.abs(newW - _lastLayoutW) < 8) return;
  _lastLayoutW = newW;

  const prevW = pCv.width;
  setSize();
  if (pCv.width !== prevW) {
    hardReset();
  }
  gdResizeCanvas();
}

if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', onLayoutResize);
}
window.addEventListener('resize', onLayoutResize);

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  3D MATH
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function mmul(a, b) {
  return [
    a[0]*b[0]+a[1]*b[3]+a[2]*b[6], a[0]*b[1]+a[1]*b[4]+a[2]*b[7], a[0]*b[2]+a[1]*b[5]+a[2]*b[8],
    a[3]*b[0]+a[4]*b[3]+a[5]*b[6], a[3]*b[1]+a[4]*b[4]+a[5]*b[7], a[3]*b[2]+a[4]*b[5]+a[5]*b[8],
    a[6]*b[0]+a[7]*b[3]+a[8]*b[6], a[6]*b[1]+a[7]*b[4]+a[8]*b[7], a[6]*b[2]+a[7]*b[5]+a[8]*b[8]
  ];
}
function mrotX(a) { const c=Math.cos(a),s=Math.sin(a); return [1,0,0, 0,c,-s, 0,s,c]; }
function mrotY(a) { const c=Math.cos(a),s=Math.sin(a); return [c,0,s, 0,1,0, -s,0,c]; }
function mrotZ(a) { const c=Math.cos(a),s=Math.sin(a); return [c,-s,0, s,c,0, 0,0,1]; }
function applyM(m, x, y, z) {
  return [m[0]*x+m[1]*y+m[2]*z, m[3]*x+m[4]*y+m[5]*z, m[6]*x+m[7]*y+m[8]*z];
}
function proj(rx, ry, rz) {
  const fov = 2.8, scale = fov / (fov - rz);
  const R = pCv.width * 0.37;
  return [pCv.width/2 + rx*R*scale, pCv.height/2 - ry*R*scale];
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FORMULA & SPHERE MAPPING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function f(t) { return A + Math.sin(B*t) * Math.sin(C*t/D); }

function toSphere(t, r) {
  const lon = t;
  const polar = (t / thetaTotal) * Math.PI;
  const rn = r / (A + 1.2);
  const x = rn * Math.sin(polar) * Math.cos(lon);
  const y = rn * Math.cos(polar);
  const z = rn * Math.sin(polar) * Math.sin(lon);
  return [x, y, z];
}

function updateFormula() {
  document.getElementById('fA').textContent = A;
  document.getElementById('fB').textContent = B;
  document.getElementById('fC').textContent = C;
  document.getElementById('fD').textContent = D;
  // Sync topbar formula
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  PRECOMPUTE ‚Äî now stores gap-class identity per point
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function precompute() {
  precomputed = new Array(TOTAL_PTS);
  fMin=Infinity; fMax=-Infinity; fSum=0;

  // Build a fast lookup: for each point index ‚Üí which gap class does it visually correspond to
  // We derive this from the gdData if available: primes falling inside [t, t+dt] map to gap families.
  // For the sphere rendering, gap assignment is computed from visualization parameters (B, C, D)
  // We use a simpler approach: tag each point by the nearest gap class from gapFamilies if data exists.
  // Without data, gap = null (no coloring).
  let gapAtPoint = null;
  if (gdData) {
    gapAtPoint = buildGapAtPoint();
  }

  for (let i = 0; i < TOTAL_PTS; i++) {
    const t = (i / TOTAL_PTS) * thetaTotal;
    const r = f(t);
    if (r < fMin) fMin = r;
    if (r > fMax) fMax = r;
    fSum += r;
    const [x,y,z] = harmArnoldK > 0 ? toSphereWarped(t, r) : toSphere(t, r);
    const hue = harmColorMode
      ? null  // will be set to harmonic color below
      : 295 + (i/TOTAL_PTS)*40;
    const gap = gapAtPoint ? gapAtPoint[i] : null;
    const harmCol = harmColorMode ? harmColorForProgress(i/TOTAL_PTS) : null;
    precomputed[i] = [x, y, z, hue, gap, harmCol];
  }
  document.getElementById('stFMin').textContent = fMin.toFixed(4);
  document.getElementById('stFMax').textContent = fMax.toFixed(4);
  document.getElementById('stFMean').textContent = (fSum/TOTAL_PTS).toFixed(4);
  document.getElementById('stThetaMax').textContent = Math.round(thetaTotal/Math.PI);
}

// Map each point index to a gap class by finding which prime gap the Œ∏ value falls within.
// Œ∏ at point i ‚Üí t = (i/TOTAL_PTS)*thetaTotal. We scale t into [0, maxPrime] range and find
// the surrounding prime pair. The gap between that prime pair gives the gap class.
function buildGapAtPoint() {
  const { primes, gapFamilies } = gdData;
  if (!primes || primes.length < 2) return null;
  const maxP = primes[primes.length-1];

  // Build sorted list of [prime, gap] pairs for binary search
  // gap[i] = primes[i+1] - primes[i], associated with primes[i]
  const pArr = primes; // already sorted
  const result = new Array(TOTAL_PTS).fill(null);

  for (let i = 0; i < TOTAL_PTS; i++) {
    const t = (i / TOTAL_PTS) * thetaTotal;
    // Map t (0..thetaTotal) ‚Üí prime index using t/thetaTotal * primes.length
    const pIdx = Math.min(pArr.length - 2, Math.floor((t / thetaTotal) * (pArr.length - 1)));
    if (pIdx >= 0 && pIdx < pArr.length - 1) {
      result[i] = pArr[pIdx+1] - pArr[pIdx];
    }
  }
  return result;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CARTESIAN BUFFER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function makeCartBuf() {
  cBuf = document.createElement('canvas');
  cBuf.width = cCv.width; cBuf.height = cCv.height;
  drawCartGrid(cBuf.getContext('2d'));
  lastCartProg = 0;
}

// Whether to show negative extent (toggled by #cbNegA)
let cartNegA = true;

function getCartYRange() {
  const yMax = Math.ceil(A + 1.2);
  // When A is near 0, the wave f(Œ∏)=A+sin*sin can dip below 0 ‚Äî always show negative if A<0.5
  const showNeg = cartNegA || A < 0.5;
  // yMin: if negative shown, extend downward by same amplitude (sin amplitude ‚â§ 1)
  const yMin = showNeg ? -(Math.min(A, 1) + 0.2) : 0;
  return { yMin, yMax };
}

function drawCartGrid(ctx) {
  const w=ctx.canvas.width, h=ctx.canvas.height;
  const {l,r:pr,t,b}=PAD, pw=w-l-pr, ph=h-t-b;
  const { yMin, yMax } = getCartYRange();
  const yRange = yMax - yMin;
  // Y-axis origin pixel position
  const yZeroPy = h - b - ((-yMin) / yRange) * ph;

  ctx.fillStyle='#060608'; ctx.fillRect(0,0,w,h);
  ctx.font=`${Math.max(8,w*.021)}px JetBrains Mono,monospace`;

  // Horizontal grid lines (integer ticks in range)
  const yStep = yRange > 4 ? 2 : 1;
  for(let yv = Math.ceil(yMin); yv <= Math.floor(yMax); yv += yStep){
    const py = h - b - ((yv - yMin) / yRange) * ph;
    ctx.strokeStyle = yv === 0 ? 'rgba(91,156,246,0.18)' : '#182018';
    ctx.lineWidth = yv === 0 ? 1 : 0.7;
    ctx.beginPath(); ctx.moveTo(l,py); ctx.lineTo(w-pr,py); ctx.stroke();
    ctx.fillStyle = yv < 0 ? '#7040a0' : '#3a7040';
    ctx.textAlign='right'; ctx.textBaseline='middle';
    ctx.fillText(yv, l-5, py);
  }

  // Vertical grid (theta)
  const tmPi=Math.round(thetaTotal/Math.PI);
  [4,8,16,32,48,64,96,128,160,192,240,300].filter(v=>v<=tmPi).forEach(tv=>{
    const px=l+(tv/tmPi)*pw;
    if(px<w-pr){
      ctx.strokeStyle='#182018'; ctx.lineWidth=0.7;
      ctx.beginPath(); ctx.moveTo(px,t); ctx.lineTo(px,h-b); ctx.stroke();
      ctx.fillStyle='#3a7040'; ctx.textAlign='center'; ctx.textBaseline='top';
      ctx.fillText(tv+'œÄ',px,h-b+4);
    }
  });

  // Axes
  ctx.strokeStyle='var(--blue,#5b9cf6)'; ctx.fillStyle='var(--blue,#5b9cf6)'; ctx.lineWidth=1.5;
  // Y axis
  ctx.beginPath(); ctx.moveTo(l,t); ctx.lineTo(l,h-b+6); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(l-4,t+4); ctx.lineTo(l,t-5); ctx.lineTo(l+4,t+4); ctx.fill();
  // X axis at y=0 line
  ctx.beginPath(); ctx.moveTo(l-6,yZeroPy); ctx.lineTo(w-pr+6,yZeroPy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(w-pr+2,yZeroPy-4); ctx.lineTo(w-pr+7,yZeroPy); ctx.lineTo(w-pr+2,yZeroPy+4); ctx.fill();
}

function cartXY(t, rv) {
  const {l,r:pr,t:pt,b}=PAD, pw=cCv.width-l-pr, ph=cCv.height-pt-b;
  const { yMin, yMax } = getCartYRange();
  const yRange = yMax - yMin;
  return [l+(t/thetaTotal)*pw, cCv.height-b-((rv - yMin)/yRange)*ph];
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SPHERE WIREFRAME
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function drawSphereGrid(ctx) {
  ctx.lineWidth=0.55;
  for(let li=-2; li<=2; li++){
    const lat=(li/3)*Math.PI/2;
    const cosLat=Math.cos(lat), sinLat=Math.sin(lat);
    ctx.beginPath(); let first=true;
    for(let lo=0; lo<=Math.PI*2+0.05; lo+=0.08){
      const x=cosLat*Math.cos(lo), y=sinLat, z=cosLat*Math.sin(lo);
      const [rx,ry,rz]=applyM(rotMat,x,y,z);
      const [px,py]=proj(rx,ry,rz);
      ctx.globalAlpha=Math.max(0.05, 0.06+(rz+1)*0.12);
      ctx.strokeStyle='#3a7040';
      if(first){ctx.moveTo(px,py);first=false;}else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }
  for(let lo=0; lo<8; lo++){
    const lon=(lo/8)*Math.PI*2;
    const cosLon=Math.cos(lon), sinLon=Math.sin(lon);
    ctx.beginPath(); let first=true;
    for(let la=-Math.PI/2; la<=Math.PI/2+0.05; la+=0.08){
      const x=Math.cos(la)*cosLon, y=Math.sin(la), z=Math.cos(la)*sinLon;
      const [rx,ry,rz]=applyM(rotMat,x,y,z);
      const [px,py]=proj(rx,ry,rz);
      ctx.globalAlpha=Math.max(0.05, 0.06+(rz+1)*0.12);
      ctx.strokeStyle='#3a7040';
      if(first){ctx.moveTo(px,py);first=false;}else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }
  ctx.globalAlpha=1;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  RENDER ‚Äî sphere base + per-gap isolated paths
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const HUE_BANDS = 24;

function renderSphere() {
  pCtx.fillStyle='#060608';
  pCtx.fillRect(0,0,pCv.width,pCv.height);
  drawSphereGrid(pCtx);

  const end = Math.floor(drawProgress);
  if (end < 2) return;

  // Always draw from the beginning (index 1) to keep full trail visible
  const startIdx = 1;
  const hasGapSel = selectedGaps.size > 0;
  const dimBase = hasGapSel;

  // ‚îÄ‚îÄ Base continuous curve with Catmull-Rom smoothing ‚îÄ‚îÄ
  // Sub-divide each segment to preserve smoothness at high speed
  const N_SUB = Math.max(1, Math.min(8, Math.ceil(speed / 4)));
  const bands = [];
  for(let b=0; b<HUE_BANDS; b++) bands.push({segs:[], bright:0, n:0});

  // Catmull-Rom interpolation in 3D sphere-space (before projection)
  function crPoint(p0, p1, p2, p3, t) {
    // p0..p3 are [x,y,z,...] arrays; t in [0,1]
    const t2=t*t, t3=t2*t;
    return [
      0.5*((-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3+(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2+(-p0[0]+p2[0])*t+2*p1[0]),
      0.5*((-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3+(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2+(-p0[1]+p2[1])*t+2*p1[1]),
      0.5*((-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t3+(2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t2+(-p0[2]+p2[2])*t+2*p1[2]),
    ];
  }

  for(let i=startIdx; i<end; i++){
    const p0=precomputed[Math.max(0,i-1)];
    const p1=precomputed[i];
    const p2=precomputed[Math.min(TOTAL_PTS-1,i+1)];
    const p3=precomputed[Math.min(TOTAL_PTS-1,i+2)];
    if(!p0||!p1||!p2||!p3) continue;
    // Color bands based on position in the full drawn range
    const bi=Math.min(HUE_BANDS-1, Math.floor((i-startIdx)/(end-startIdx)*HUE_BANDS));
    // Walk N_SUB sub-intervals
    for(let s=0; s<N_SUB; s++){
      const ta=s/N_SUB, tb=(s+1)/N_SUB;
      const [ax,ay,az]=crPoint(p0,p1,p2,p3,ta);
      const [bx,by,bz]=crPoint(p0,p1,p2,p3,tb);
      const [rxa,rya,rza]=applyM(rotMat,ax,ay,az);
      const [rxb,ryb,rzb]=applyM(rotMat,bx,by,bz);
      const [pxa,pya]=proj(rxa,rya,rza);
      const [pxb,pyb]=proj(rxb,ryb,rzb);
      const depth=(rza+rzb)*0.5;
      bands[bi].segs.push(pxa,pya,pxb,pyb);
      bands[bi].bright+=depth; bands[bi].n++;
    }
  }

  if(dimBase){
    for(let bi=0; bi<HUE_BANDS; bi++){
      const bd=bands[bi]; if(!bd.segs.length) continue;
      const avgZ=bd.n>0?bd.bright/bd.n:0;
      pCtx.strokeStyle=`rgba(55,75,55,${Math.max(0.04,0.08+avgZ*0.06)})`;
      pCtx.lineWidth=traceThickness*0.5; pCtx.globalAlpha=1; pCtx.shadowBlur=0;
      pCtx.beginPath();
      for(let j=0;j<bd.segs.length;j+=4){ pCtx.moveTo(bd.segs[j],bd.segs[j+1]); pCtx.lineTo(bd.segs[j+2],bd.segs[j+3]); }
      pCtx.stroke();
    }
  } else {
    pCtx.lineWidth=traceThickness; pCtx.shadowColor='var(--blue,#5b9cf6)'; pCtx.shadowBlur=4;
    for(let bi=0; bi<HUE_BANDS; bi++){
      const bd=bands[bi]; if(!bd.segs.length) continue;
      const hue=295+(bi/HUE_BANDS)*40;
      const avgZ=bd.n>0?bd.bright/bd.n:0;
      const bright=48+avgZ*22;
      // Use harmonic color if mode active, else standard hue
      const harmBandCol = harmColorMode ? (harmColorForProgress(bi/HUE_BANDS)||`hsl(${hue},100%,${bright}%)`) : `hsl(${hue},100%,${bright}%)`;
      pCtx.strokeStyle = harmBandCol;
      pCtx.globalAlpha=Math.max(0.2, 0.4+avgZ*0.55);
      pCtx.beginPath();
      for(let j=0;j<bd.segs.length;j+=4){ pCtx.moveTo(bd.segs[j],bd.segs[j+1]); pCtx.lineTo(bd.segs[j+2],bd.segs[j+3]); }
      pCtx.stroke();
    }
    pCtx.globalAlpha=1; pCtx.shadowBlur=0;
  }

  // ‚îÄ‚îÄ Per-gap smooth Catmull-Rom arcs on sphere ‚îÄ‚îÄ
  if(hasGapSel){
    selectedGaps.forEach((col, gv) => {
      const pts = [];
      for(let i=startIdx; i<end; i++){
        if(precomputed[i] && precomputed[i][4]===gv) pts.push(i);
      }
      if(!pts.length) return;

      // Glowing dots at each occurrence
      pCtx.shadowColor=col; pCtx.shadowBlur=10; pCtx.globalAlpha=0.9;
      pCtx.fillStyle=col;
      pts.forEach(i=>{
        const p=precomputed[i];
        const [rx,ry,rz]=applyM(rotMat,p[0],p[1],p[2]);
        if(rz < -0.5) return;
        const [px,py]=proj(rx,ry,rz);
        pCtx.beginPath(); pCtx.arc(px,py,Math.max(2,traceThickness),0,Math.PI*2); pCtx.fill();
      });
      pCtx.shadowBlur=0; pCtx.globalAlpha=1;

      // Catmull-Rom smooth arc connecting occurrences
      if(pts.length >= 2){
        pCtx.strokeStyle=col; pCtx.lineWidth=traceThickness*1.3;
        pCtx.shadowColor=col; pCtx.shadowBlur=7; pCtx.globalAlpha=0.75;
        pCtx.beginPath();
        let penDown=false;
        const GAP_THRESH=60; // max index gap to connect
        for(let k=0; k<pts.length-1; k++){
          const i=pts[k], j=pts[k+1];
          if(j-i > GAP_THRESH){ penDown=false; continue; }
          // Use 4 control points for Catmull-Rom
          const pi0=precomputed[Math.max(0,k>0?pts[k-1]:i)];
          const pi1=precomputed[i];
          const pi2=precomputed[j];
          const pi3=precomputed[Math.min(TOTAL_PTS-1,k+2<pts.length?pts[k+2]:j)];
          const CR_STEPS=8;
          for(let s=0; s<=CR_STEPS; s++){
            const t=s/CR_STEPS;
            const t2=t*t, t3=t2*t;
            const x=0.5*((-pi0[0]+3*pi1[0]-3*pi2[0]+pi3[0])*t3+(2*pi0[0]-5*pi1[0]+4*pi2[0]-pi3[0])*t2+(-pi0[0]+pi2[0])*t+2*pi1[0]);
            const y=0.5*((-pi0[1]+3*pi1[1]-3*pi2[1]+pi3[1])*t3+(2*pi0[1]-5*pi1[1]+4*pi2[1]-pi3[1])*t2+(-pi0[1]+pi2[1])*t+2*pi1[1]);
            const z=0.5*((-pi0[2]+3*pi1[2]-3*pi2[2]+pi3[2])*t3+(2*pi0[2]-5*pi1[2]+4*pi2[2]-pi3[2])*t2+(-pi0[2]+pi2[2])*t+2*pi1[2]);
            const [rx,ry,rz]=applyM(rotMat,x,y,z);
            if(rz<-0.6){ penDown=false; continue; }
            const [px,py]=proj(rx,ry,rz);
            if(!penDown){ pCtx.moveTo(px,py); penDown=true; } else pCtx.lineTo(px,py);
          }
        }
        pCtx.stroke();
        pCtx.globalAlpha=1; pCtx.shadowBlur=0;
      }
    });
  }

  // Moving dot
  const cur=precomputed[Math.max(0,end-1)];
  if(cur){
    const [cx,cy,cz]=cur;
    const [rx,ry,rz]=applyM(rotMat,cx,cy,cz);
    const [px,py]=proj(rx,ry,rz);
    pCtx.globalAlpha=Math.max(0.5, 0.5+(rz+1)*0.4);
    pCtx.beginPath(); pCtx.arc(px,py,3.5,0,Math.PI*2);
    pCtx.fillStyle='#fff'; pCtx.shadowColor='#fff'; pCtx.shadowBlur=14;
    pCtx.fill(); pCtx.shadowBlur=0; pCtx.globalAlpha=1;
  }

  // Center glow
  const [crx,cry,crz]=applyM(rotMat,0,0,0);
  const [cpx,cpy]=proj(crx,cry,crz);
  pCtx.beginPath(); pCtx.arc(cpx,cpy,3,0,Math.PI*2);
  pCtx.fillStyle='#ffd700'; pCtx.shadowColor='#ffd700'; pCtx.shadowBlur=16;
  pCtx.fill(); pCtx.shadowBlur=0;

  // Probe flash ‚Äî highlighted point from cart click
  drawProbeFlash(pCtx, pCv.width);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  RENDER CART ‚Äî smooth base + FFT-style per-gap stacked lanes
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// FFT canvas: drawn on top of main cart, shows gap waveform lanes
let fftCanvas = null;

function ensureFftCanvas(){
  if(!fftCanvas || fftCanvas.width !== cCv.width || fftCanvas.height !== cCv.height){
    fftCanvas = document.createElement('canvas');
    fftCanvas.width = cCv.width; fftCanvas.height = cCv.height;
  }
}

// Build FFT lane display: for each selected gap, show a local density
// waveform in a horizontal lane. Lane height = cartCanvas.height / nGaps.
// X axis = Œ∏ (same as cart), Y axis = local occurrence density in that lane.
function drawFftLanes(end){
  if(!selectedGaps.size || !precomputed.length) return;
  ensureFftCanvas();
  const ctx = fftCanvas.getContext('2d');
  const w=fftCanvas.width, h=fftCanvas.height;
  ctx.clearRect(0,0,w,h);

  const {l,r:pr,t:pt,b}=PAD;
  const pw=w-l-pr, ph=h-pt-b;
  const gapList=[...selectedGaps.entries()]; // [[gv,col],...]
  const nGaps=gapList.length;
  const laneH=Math.floor(ph/nGaps);
  const BINS=Math.min(pw, 256); // FFT-style resolution bins

  // For each gap, count occurrences per Œ∏-bin up to current progress
  const maxIdx=Math.min(end, TOTAL_PTS-1);

  gapList.forEach(([gv,col],li)=>{
    const laneTop=pt + li*laneH;
    const laneMid=laneTop+laneH/2;
    const laneAmp=laneH*0.42;

    // Count density in each bin
    const bins=new Float32Array(BINS).fill(0);
    for(let i=1; i<=maxIdx; i++){
      if(precomputed[i]&&precomputed[i][4]===gv){
        const binIdx=Math.floor((i/maxIdx)*BINS);
        if(binIdx<BINS) bins[binIdx]++;
      }
    }

    // Smooth bins with 3-tap gaussian
    const smooth=new Float32Array(BINS);
    for(let b=0;b<BINS;b++){
      smooth[b]=(bins[Math.max(0,b-1)]*0.25+bins[b]*0.5+bins[Math.min(BINS-1,b+1)]*0.25);
    }
    const maxBin=Math.max(1,...smooth);

    // Draw lane background
    ctx.fillStyle=`${col}0d`;
    ctx.fillRect(l,laneTop,pw,laneH);
    // Lane label
    ctx.fillStyle=col+'aa';
    ctx.font=`${Math.max(8,w*0.018)}px JetBrains Mono,monospace`;
    ctx.textAlign='left'; ctx.textBaseline='middle';
    ctx.fillText(`g=${gv}`,l+4,laneMid);
    // Baseline
    ctx.strokeStyle=col+'22'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(l,laneMid); ctx.lineTo(l+pw,laneMid); ctx.stroke();

    // Draw FFT-style waveform using Catmull-Rom smooth path
    ctx.strokeStyle=col; ctx.lineWidth=traceThickness;
    ctx.shadowColor=col; ctx.shadowBlur=6; ctx.globalAlpha=0.9;
    ctx.beginPath();
    let first=true;
    for(let b=0;b<BINS;b++){
      const x=l+(b/BINS)*pw;
      const amp=(smooth[b]/maxBin)*laneAmp;
      const y=laneMid-amp;
      if(first){ ctx.moveTo(x,y); first=false; } else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Mirror (filled area below baseline = symmetric FFT look)
    ctx.globalAlpha=0.35;
    ctx.fillStyle=col;
    ctx.beginPath();
    ctx.moveTo(l,laneMid);
    for(let b=0;b<BINS;b++){
      const x=l+(b/BINS)*pw;
      const amp=(smooth[b]/maxBin)*laneAmp;
      ctx.lineTo(x,laneMid-amp);
    }
    for(let b=BINS-1;b>=0;b--){
      const x=l+(b/BINS)*pw;
      const amp=(smooth[b]/maxBin)*laneAmp;
      ctx.lineTo(x,laneMid+amp);
    }
    ctx.closePath(); ctx.fill();
    ctx.globalAlpha=1; ctx.shadowBlur=0;

    // Vertical cursor at drawProgress
    if(end<TOTAL_PTS){
      const cx2=l+(end/TOTAL_PTS)*pw;
      ctx.strokeStyle=col; ctx.lineWidth=1; ctx.globalAlpha=0.6;
      ctx.setLineDash([3,3]);
      ctx.beginPath(); ctx.moveTo(cx2,laneTop); ctx.lineTo(cx2,laneTop+laneH); ctx.stroke();
      ctx.setLineDash([]); ctx.globalAlpha=1;
    }

    // Lane separator
    ctx.strokeStyle='rgba(255,255,255,0.04)'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(l,laneTop+laneH); ctx.lineTo(l+pw,laneTop+laneH); ctx.stroke();
  });
}

function renderCart() {
  const newEnd=Math.floor(drawProgress);
  const hasGapSel = selectedGaps.size > 0;

  if(newEnd===0 && lastCartProg>0){ makeCartBuf(); }

  // Draw base f(Œ∏) curve with sub-step smoothing
  if(newEnd > lastCartProg){
    const cbCtx=cBuf.getContext('2d');
    const C_SUB=Math.max(1,Math.min(8,Math.ceil(speed/4)));

    for(let i=lastCartProg; i<newEnd; i++){
      for(let s=0; s<C_SUB; s++){
        const ta=((i+s/C_SUB)/TOTAL_PTS)*thetaTotal;
        const tb=((i+(s+1)/C_SUB)/TOTAL_PTS)*thetaTotal;
        const ra=f(ta), rb=f(tb);
        const [cxa,cya]=cartXY(ta,ra);
        const [cxb,cyb]=cartXY(tb,rb);
        const fracA=(i+s/C_SUB)/TOTAL_PTS;
        const hue=295+fracA*40;
        // Dim if gaps selected so FFT lanes read clearly
        if(hasGapSel){
          cbCtx.strokeStyle='rgba(40,60,40,0.12)'; cbCtx.lineWidth=traceThickness*0.35;
        } else {
          cbCtx.strokeStyle=`hsl(${hue},100%,62%)`; cbCtx.lineWidth=traceThickness;
          cbCtx.shadowColor='var(--blue,#5b9cf6)'; cbCtx.shadowBlur=3;
        }
        cbCtx.beginPath(); cbCtx.moveTo(cxa,cya); cbCtx.lineTo(cxb,cyb); cbCtx.stroke();
        cbCtx.shadowBlur=0;
      }
    }
    lastCartProg=newEnd;
  }

  cCtx.clearRect(0,0,cCv.width,cCv.height);
  cCtx.drawImage(cBuf,0,0);

  // Overlay FFT gap lanes (always redrawn since they show full history up to cursor)
  if(hasGapSel){ drawFftLanes(newEnd); cCtx.drawImage(fftCanvas,0,0); }
}

// When gap selection changes, we need to redraw the cart buffer from scratch
function invalidateCartBuf(){
  makeCartBuf();
  lastCartProg = 0;
  fftCanvas = null; // force FFT redraw
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  LIVE STATS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function updateLiveStats() {
  const end = Math.floor(drawProgress);
  const pct = TOTAL_PTS > 0 ? ((end / TOTAL_PTS) * 100).toFixed(1) : '0.0';
  const t = (end / TOTAL_PTS) * thetaTotal;
  const tPi = (t / Math.PI).toFixed(2);
  const fv = end > 0 ? f(t).toFixed(4) : '‚Äî';
  document.getElementById('stProg').textContent = pct + '%';
  document.getElementById('stTheta').textContent = tPi + 'œÄ';
  document.getElementById('stFTheta').textContent = fv;
  document.getElementById('stPts').textContent = end.toLocaleString();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SEQUENTIAL ROTATION STATE  (X‚ÜíY‚ÜíZ each 360¬∞, then stop)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// autoRotate = true ‚Üí continuous Y-spin (manual button / legacy)
// seqRotate  = true ‚Üí sequential X/Y/Z sweep triggered at wave end
let seqRotate = false;
let seqAxis   = 0;           // 0=X, 1=Y, 2=Z
let seqAngle  = 0;           // radians accumulated for current axis
const SEQ_SPEED = 0.012;     // radians per frame (~60fps ‚Üí ~30s per axis)

function startSeqRotate() {
  seqRotate = true;
  seqAxis   = 0;
  seqAngle  = 0;
  // seqRotate and autoRotate are independent ‚Äî seqRotate pauses when autoRotate is on
  // Show active state on Complete button
  const cBtn = document.getElementById('btnSkipComplete');
  if (cBtn) cBtn.classList.add('on');
  // Sync autoRotate button label if it's on
  const rBtn = document.getElementById('btnAutoRot');
  if (rBtn) {
    rBtn.classList.toggle('on', autoRotate);
    rBtn.textContent = autoRotate ? '‚ü≥ Rotating...' : '‚ü≥ Rotate';
  }
}

function stopSeqRotate() {
  seqRotate = false;
  const cBtn = document.getElementById('btnSkipComplete');
  if (cBtn) cBtn.classList.remove('on');
  // Restore Auto-Rotate button to reflect actual autoRotate state
  const rBtn = document.getElementById('btnAutoRot');
  if (rBtn) {
    rBtn.classList.toggle('on', autoRotate);
    rBtn.textContent = autoRotate ? '‚ü≥ Rotating...' : '‚ü≥ Rotate';
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ANIMATION LOOP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function loop() {
  requestAnimationFrame(loop);

  if (seqRotate) {
    const step = SEQ_SPEED;
    if (seqAxis === 0)      rotMat = mmul(mrotX(step), rotMat);
    else if (seqAxis === 1) rotMat = mmul(mrotY(step), rotMat);
    else                    rotMat = mmul(mrotZ(step), rotMat);
    seqAngle += step;
    if (seqAngle >= Math.PI * 2) {
      seqAngle = 0;
      seqAxis++;
      if (seqAxis > 2) stopSeqRotate(); // done with Z
    }
    if (Math.random() < 0.08) updateRotationInputs();
  } else if (autoRotate) {
    rotMat = mmul(mrotY(0.008), rotMat);
    if (Math.random() < 0.1) updateRotationInputs();
  }

  if(!paused){
    drawProgress += speed;
    if(drawProgress >= TOTAL_PTS){
      if(looping){
        drawProgress = 0;
        harmSyncScheduledUntil = 0;
        harmSyncLastPtIdx = -1;
      } else {
        drawProgress = TOTAL_PTS; paused = true;
        const btn = document.getElementById('btnPlay');
        btn.textContent = '‚ñ∂ Play'; btn.classList.remove('on');
        harmSyncStop();
        // Start sequential X‚ÜíY‚ÜíZ rotation after preset finishes drawing
        if (seqRotateOnComplete) { startSeqRotate(); }
      }
    }
    harmSyncTick();
  }
  renderSphere();
  renderCart();
  updateLiveStats();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  HARD RESET
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function hardReset() {
  drawProgress=0; lastCartProg=0;
  seqRotateOnComplete=false;
  harmSyncStop();
  seqRotate = false; seqAxis = 0; seqAngle = 0;
  // Clear Complete button active state
  const cBtn=document.getElementById('btnSkipComplete');
  if(cBtn) cBtn.classList.remove('on');
  // Preserve autoRotate ‚Äî it's a persistent toggle
  precompute(); makeCartBuf(); updateFormula();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  DRAG ROTATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let _autoRotateBeforeDrag = false;
let _seqRotateBeforeDrag  = false;
function onDragStart(ex,ey){ 
  isDrag=true; 
  lastMX=ex; 
  lastMY=ey; 
  // Pause rotation during drag ‚Äî resume on drag end
  _autoRotateBeforeDrag = autoRotate;
  _seqRotateBeforeDrag  = seqRotate;
  autoRotate = false;
  seqRotate  = false;
}
function onDragMove(ex,ey){
  if(!isDrag) return;
  const dx=ex-lastMX, dy=ey-lastMY;
  lastMX=ex; lastMY=ey;
  const s=0.012;
  rotMat=mmul(mrotY(dx*s), rotMat);
  rotMat=mmul(mrotX(dy*s), rotMat);
  updateRotationInputs();
}
function onDragEnd(){ 
  isDrag=false; 
  // Restore rotation state after drag
  autoRotate = _autoRotateBeforeDrag;
  seqRotate  = _seqRotateBeforeDrag;
  updateRotationInputs();
}

pCv.addEventListener('mousedown', e=>{ e.preventDefault(); onDragStart(e.clientX,e.clientY); });
window.addEventListener('mousemove', e=>onDragMove(e.clientX,e.clientY));
window.addEventListener('mouseup', onDragEnd);
pCv.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.touches[0]; onDragStart(t.clientX,t.clientY); },{passive:false});
pCv.addEventListener('touchmove',  e=>{ e.preventDefault(); const t=e.touches[0]; onDragMove(t.clientX,t.clientY); },{passive:false});
pCv.addEventListener('touchend',   onDragEnd);

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ROTATION BUTTONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
document.getElementById('btnAutoRot').addEventListener('click',function(){
  // If seqRotate is running, stop it ‚Äî user is taking control
  if (seqRotate) stopSeqRotate();
  autoRotate=!autoRotate;
  this.classList.toggle('on',autoRotate);
  this.textContent=autoRotate?'‚ü≥ Rotating...':'‚ü≥ Rotate';
});
document.getElementById('btnResetRot').addEventListener('click',()=>{
  manualRotX = 90;
  manualRotY = 0;
  manualRotZ = 0;
  document.getElementById('rotX').value = 90;
  document.getElementById('rotY').value = 0;
  document.getElementById('rotZ').value = 0;
  document.getElementById('rotXSlider').value = 90;
  document.getElementById('rotYSlider').value = 0;
  document.getElementById('rotZSlider').value = 0;
  updateManualRotation();
  autoRotate=false; seqRotate=false; seqAxis=0; seqAngle=0;
  const rBtn=document.getElementById('btnAutoRot');
  rBtn.classList.remove('on'); rBtn.textContent='‚ü≥ Rotate';
  const cBtn=document.getElementById('btnSkipComplete');
  cBtn.classList.remove('on');
});

// Manual rotation X - slider
document.getElementById('rotXSlider').addEventListener('input', function() {
  const val = wrapAngle(parseFloat(this.value) || 0);
  manualRotX = val;
  document.getElementById('rotX').value = Math.round(val);
  updateManualRotation();
});

// Manual rotation X - input (with wrapping)
document.getElementById('rotX').addEventListener('input', function() {
  const val = wrapAngle(parseFloat(this.value) || 0);
  manualRotX = val;
  this.value = Math.round(val);
  document.getElementById('rotXSlider').value = Math.round(val);
  updateManualRotation();
});

// Manual rotation Y - slider
document.getElementById('rotYSlider').addEventListener('input', function() {
  const val = wrapAngle(parseFloat(this.value) || 0);
  manualRotY = val;
  document.getElementById('rotY').value = Math.round(val);
  updateManualRotation();
});

// Manual rotation Y - input (with wrapping)
document.getElementById('rotY').addEventListener('input', function() {
  const val = wrapAngle(parseFloat(this.value) || 0);
  manualRotY = val;
  this.value = Math.round(val);
  document.getElementById('rotYSlider').value = Math.round(val);
  updateManualRotation();
});

// Manual rotation Z - slider
document.getElementById('rotZSlider').addEventListener('input', function() {
  const val = wrapAngle(parseFloat(this.value) || 0);
  manualRotZ = val;
  document.getElementById('rotZ').value = Math.round(val);
  updateManualRotation();
});

// Manual rotation Z - input (with wrapping)
document.getElementById('rotZ').addEventListener('input', function() {
  const val = wrapAngle(parseFloat(this.value) || 0);
  manualRotZ = val;
  this.value = Math.round(val);
  document.getElementById('rotZSlider').value = Math.round(val);
  updateManualRotation();
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SPEED & THICKNESS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function setSpeed(v){
  speed=v;
  document.getElementById('sSpeed').value=v;
  document.getElementById('dSpeed').textContent=v.toFixed(2);
  updateSpeedDesc(v);
}
function updateSpeedDesc(v){
  const el=document.getElementById('speedDesc');
  if(v<0.2) el.textContent='ultra slow';
  else if(v<1) el.textContent='crawl';
  else if(v<4) el.textContent='slow';
  else if(v<12) el.textContent='normal';
  else if(v<25) el.textContent='fast';
  else el.textContent='maximum';
}

// Thickness slider
document.getElementById('gdThick').addEventListener('input', function(){
  traceThickness = parseFloat(this.value);
  document.getElementById('gdThickVal').textContent = traceThickness.toFixed(2)+'px';
  // Invalidate cart buf so it redraws with new thickness
  invalidateCartBuf();
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  LOOP TOGGLE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
document.getElementById('cbLoop').addEventListener('change', function(){
  looping = this.checked;
  document.getElementById('loopState').textContent = looping ? 'on ‚Äî loops forever' : 'off ‚Äî stops at end';
});

// Negative-A extension toggle ‚Äî default ON
document.getElementById('cbNegA').checked = true;
document.getElementById('cbNegA').addEventListener('change', function(){
  cartNegA = this.checked;
  invalidateCartBuf();
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SLIDER BINDINGS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function bind(id,dId,setter,fmt,noReset){
  document.getElementById(id).addEventListener('input',function(){
    const v=parseFloat(this.value);
    setter(v);
    document.getElementById(dId).textContent=fmt?fmt(v):v;
    if(!noReset) hardReset();
  });
}
bind('sA','dA',v=>{
  A=v;
  // When A < 0.5, the wave can dip below zero ‚Äî auto-check the Extend -a toggle
  const cbNeg = document.getElementById('cbNegA');
  if (cbNeg && v < 0.5 && !cbNeg.checked) {
    cbNeg.checked = true; cartNegA = true;
  }
});
bind('sB','dB',v=>B=v);
bind('sC','dC',v=>C=v);
bind('sD','dD',v=>D=v);
bind('sTheta','dTheta',v=>thetaTotal=v*Math.PI,v=>v+'œÄ');
bind('sSpeed','dSpeed',v=>{speed=v;updateSpeedDesc(v); if(!paused && harmSyncEnabled) harmSyncStart(); },v=>v.toFixed(2),true);

document.getElementById('btnPlay').addEventListener('click',function(){
  onUserInteraction(); // switches to loop mode after intro
  paused=!paused;
  this.textContent=paused?'‚ñ∂ Play':'‚è∏ Pause';
  this.classList.toggle('on',!paused);
  if(!paused){ if(harmSyncEnabled) harmSyncStart(); }
  else { harmSyncPause(); }
});
document.getElementById('btnReset').addEventListener('click',()=>{ harmSyncStop(); hardReset(); });

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FULLSCREEN
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function toggleFullscreen() {
  const btn = document.getElementById('btnFullscreen');
  const el = document.documentElement; // fullscreen the whole page

  if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement) {
    // Enter fullscreen
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen;
    if (req) req.call(el);
  } else {
    // Exit fullscreen
    const ex = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen;
    if (ex) ex.call(document);
  }
}

function onFullscreenChange() {
  const btn = document.getElementById('btnFullscreen');
  const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement);
  btn.textContent = isFs ? '‚õ∂ Exit' : '‚õ∂ Full';
  btn.classList.toggle('active', isFs);
  // Resize canvases to fit new dimensions
  setTimeout(() => { setSize(); hardReset(); }, 120);
}

document.getElementById('btnFullscreen').addEventListener('click', toggleFullscreen);
document.addEventListener('fullscreenchange', onFullscreenChange);
document.addEventListener('webkitfullscreenchange', onFullscreenChange);
document.addEventListener('mozfullscreenchange', onFullscreenChange);

// Skip to completed state ‚Äî instantly draw everything, then start seq rotation
document.getElementById('btnSkipComplete').addEventListener('click', () => {
  // Ensure precomputed is up to date
  if (!precomputed.length) precompute();
  // Draw entire cart buffer at once
  drawProgress = TOTAL_PTS;
  lastCartProg = 0;
  makeCartBuf();
  // Fill the buffer with all points
  const cbCtx = cBuf.getContext('2d');
  for (let i = 1; i < TOTAL_PTS; i++) {
    const ta = ((i - 1) / TOTAL_PTS) * thetaTotal;
    const tb = (i / TOTAL_PTS) * thetaTotal;
    const ra = f(ta), rb = f(tb);
    const [cxa, cya] = cartXY(ta, ra);
    const [cxb, cyb] = cartXY(tb, rb);
    const frac = (i - 1) / TOTAL_PTS;
    const hue = 295 + frac * 40;
    cbCtx.strokeStyle = `hsl(${hue},100%,62%)`;
    cbCtx.lineWidth = traceThickness;
    cbCtx.beginPath(); cbCtx.moveTo(cxa, cya); cbCtx.lineTo(cxb, cyb); cbCtx.stroke();
  }
  lastCartProg = TOTAL_PTS;
  paused = true;
  const btn = document.getElementById('btnPlay');
  btn.textContent = '‚ñ∂ Play'; btn.classList.remove('on');
  harmSyncStop();
  startSeqRotate();
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  4K SPHERE EXPORT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
document.getElementById('btnExport4K').addEventListener('click', exportSphere4K);
document.getElementById('btnExportMulti').addEventListener('click', exportMultiAngle);

function exportSphere4K() {
  // ‚îÄ‚îÄ Composite 4K export: sphere + formula + cart canvas + stats bar ‚îÄ‚îÄ
  // Target output: 3840 √ó 2160 (16:9)
  const W = 3840, H = 2160;
  const cv = document.createElement('canvas');
  cv.width = W; cv.height = H;
  const ctx = cv.getContext('2d');

  // Background
  ctx.fillStyle = '#060608';
  ctx.fillRect(0, 0, W, H);

  // ‚îÄ‚îÄ Layout constants (scaled to 4K) ‚îÄ‚îÄ
  const SCALE   = W / pCv.width;       // how much bigger 4K is vs live canvas
  const PADDING = 80;                   // outer padding px at 4K
  const SPHERE_W = Math.round(W * 0.54);
  const SPHERE_H = SPHERE_W;           // sphere is square
  const RIGHT_X  = SPHERE_W + PADDING * 2;
  const RIGHT_W  = W - RIGHT_X - PADDING;

  // ‚ïê‚ïê LEFT COLUMN: sphere (scaled up from live canvas) ‚ïê‚ïê
  // Draw sphere at 4K res using the same geometry
  const sphereOff = document.createElement('canvas');
  sphereOff.width = sphereOff.height = SPHERE_W;
  const sc = sphereOff.getContext('2d');
  sc.fillStyle = '#060608';
  sc.fillRect(0, 0, SPHERE_W, SPHERE_W);

  // Wireframe grid scaled to SPHERE_W
  const sphereR4K = SPHERE_W * 0.37;
  function proj4K(rx, ry, rz){
    const fov=2.8, scale=fov/(fov-rz);
    return [SPHERE_W/2 + rx*sphereR4K*scale*zoomLevel + panX*SCALE*0.5,
            SPHERE_W/2 - ry*sphereR4K*scale*zoomLevel + panY*SCALE*0.5];
  }
  sc.lineWidth = 1.2;
  for(let li=-2; li<=2; li++){
    const lat=(li/3)*Math.PI/2, cosLat=Math.cos(lat), sinLat=Math.sin(lat);
    sc.beginPath(); let first=true;
    for(let lo=0; lo<=Math.PI*2+0.05; lo+=0.04){
      const x=cosLat*Math.cos(lo), y=sinLat, z=cosLat*Math.sin(lo);
      const [rx,ry,rz]=applyM(rotMat,x,y,z);
      const [px,py]=proj4K(rx,ry,rz);
      sc.globalAlpha=Math.max(0.05,0.06+(rz+1)*0.12); sc.strokeStyle='#3a7040';
      if(first){sc.moveTo(px,py);first=false;}else sc.lineTo(px,py);
    } sc.stroke();
  }
  for(let lo=0; lo<8; lo++){
    const lon=(lo/8)*Math.PI*2, cosLon=Math.cos(lon), sinLon=Math.sin(lon);
    sc.beginPath(); let first=true;
    for(let la=-Math.PI/2; la<=Math.PI/2+0.05; la+=0.04){
      const x=Math.cos(la)*cosLon, y=Math.sin(la), z=Math.cos(la)*sinLon;
      const [rx,ry,rz]=applyM(rotMat,x,y,z);
      const [px,py]=proj4K(rx,ry,rz);
      sc.globalAlpha=Math.max(0.05,0.06+(rz+1)*0.12); sc.strokeStyle='#3a7040';
      if(first){sc.moveTo(px,py);first=false;}else sc.lineTo(px,py);
    } sc.stroke();
  }
  sc.globalAlpha=1;

  // Curve trace on sphere
  const end=Math.floor(drawProgress);
  if(end>=2){
    // Always draw from beginning to keep full trail visible
    const startIdx=1;
    sc.lineWidth=traceThickness*2.2;
    for(let i=startIdx;i<end;i++){
      const p0=precomputed[i-1],p1=precomputed[i];
      if(!p0||!p1) continue;
      const [rx1,ry1,rz1]=applyM(rotMat,p0[0],p0[1],p0[2]);
      const [rx2,ry2,rz2]=applyM(rotMat,p1[0],p1[1],p1[2]);
      const [px1,py1]=proj4K(rx1,ry1,rz1);
      const [px2,py2]=proj4K(rx2,ry2,rz2);
      const gap=p1[4];
      const selCol=gap!==null?selectedGaps.get(gap):undefined;
      const frac=i/TOTAL_PTS;
      if(selCol){
        sc.strokeStyle=selCol; sc.shadowColor=selCol; sc.shadowBlur=14;
      } else if(harmColorMode){
        const hc=harmColorForProgress(frac);
        sc.strokeStyle=hc||`hsl(${295+frac*40},100%,55%)`;
        sc.shadowColor=sc.strokeStyle; sc.shadowBlur=6;
      } else {
        const bi=Math.min(HUE_BANDS-1,Math.floor((i-startIdx)/histLen*HUE_BANDS));
        const hue=295+(bi/HUE_BANDS)*40;
        const avgZ=(rz1+rz2)*0.5, bright=48+avgZ*22;
        sc.strokeStyle=`hsl(${hue},100%,${bright}%)`;
        sc.shadowColor='var(--blue,#5b9cf6)'; sc.shadowBlur=8;
      }
      sc.globalAlpha=Math.max(0.2,0.5);
      sc.beginPath(); sc.moveTo(px1,py1); sc.lineTo(px2,py2); sc.stroke();
    }
    sc.shadowBlur=0; sc.globalAlpha=1;

    // Center glow
    const [crx,cry,crz]=applyM(rotMat,0,0,0);
    const [cpx,cpy]=proj4K(crx,cry,crz);
    sc.beginPath(); sc.arc(cpx,cpy,5,0,Math.PI*2);
    sc.fillStyle='#ffd700'; sc.shadowColor='#ffd700'; sc.shadowBlur=20;
    sc.fill(); sc.shadowBlur=0;
  }

  // Blit sphere onto main 4K canvas (vertically centered in left col)
  const SPHERE_TOP = Math.round((H - SPHERE_H) / 2);
  ctx.drawImage(sphereOff, PADDING, SPHERE_TOP, SPHERE_W, SPHERE_H);

  // ‚ïê‚ïê RIGHT COLUMN ‚ïê‚ïê
  const COL_Y = PADDING;
  let ry = COL_Y;

  // ‚îÄ‚îÄ Formula box ‚îÄ‚îÄ
  const FORMULA_H = 160;
  // Box
  ctx.save();
  ctx.fillStyle='rgba(255,215,0,0.05)';
  ctx.strokeStyle='#ffd700'; ctx.lineWidth=3;
  ctx.shadowColor='rgba(255,215,0,0.35)'; ctx.shadowBlur=28;
  ctx.beginPath(); ctx.roundRect(RIGHT_X, ry, RIGHT_W, FORMULA_H, 16);
  ctx.fill(); ctx.stroke(); ctx.restore();

  // Draw formula with gold numbers, white text
  ctx.textBaseline='middle';
  ctx.font=`bold 54px 'JetBrains Mono', monospace`;
  const FY = ry + FORMULA_H / 2;
  // Measure total width so we can centre it
  const parts = [
    { text:'f(Œ∏) = ',      color:'#d8f0d8' },
    { text:`${A}`,         color:'#ffd700' },
    { text:' + sin(',      color:'#d8f0d8' },
    { text:`${B}`,         color:'#ffd700' },
    { text:'Œ∏) ¬∑ sin(',    color:'#d8f0d8' },
    { text:`${C}`,         color:'#ffd700' },
    { text:'Œ∏ / ',         color:'#d8f0d8' },
    { text:`${D}`,         color:'#ffd700' },
    { text:')',             color:'#d8f0d8' },
  ];
  const totalW = parts.reduce((s,p)=>s+ctx.measureText(p.text).width,0);
  let fx = RIGHT_X + (RIGHT_W - totalW) / 2;
  ctx.textAlign='left';
  parts.forEach(p=>{ ctx.fillStyle=p.color; ctx.fillText(p.text,fx,FY); fx+=ctx.measureText(p.text).width; });
  ry += FORMULA_H + 48;

  // ‚îÄ‚îÄ Cartesian canvas (scaled up) ‚îÄ‚îÄ
  const CART_H = Math.round(RIGHT_W * (cCv.height / cCv.width));
  ctx.save();
  ctx.shadowColor='rgba(91,156,246,0.15)'; ctx.shadowBlur=30;
  ctx.drawImage(cCv, RIGHT_X, ry, RIGHT_W, CART_H);
  ctx.restore();
  // Border around cart
  ctx.strokeStyle='rgba(91,156,246,0.25)'; ctx.lineWidth=2;
  ctx.strokeRect(RIGHT_X, ry, RIGHT_W, CART_H);
  ry += CART_H + 48;

  // ‚îÄ‚îÄ Live stats bar ‚îÄ‚îÄ
  const STATS = [
    { lbl:'PROGRESS',      val: `${((drawProgress/TOTAL_PTS)*100).toFixed(1)}%` },
    { lbl:'Œ∏ CURRENT',     val: `${((drawProgress/TOTAL_PTS)*thetaTotal/Math.PI).toFixed(2)}œÄ` },
    { lbl:'F(Œ∏) CURRENT',  val: end>0 ? f((drawProgress/TOTAL_PTS)*thetaTotal).toFixed(4) : '‚Äî' },
    { lbl:'F(Œ∏) MIN',      val: fMin.toFixed(4) },
    { lbl:'F(Œ∏) MAX',      val: fMax.toFixed(4) },
    { lbl:'F(Œ∏) MEAN',     val: (fSum/TOTAL_PTS).toFixed(4) },
    { lbl:'PTS DRAWN',     val: Math.floor(drawProgress).toLocaleString() },
    { lbl:'Œ∏ TOTAL (√óŒ†)',  val: Math.round(thetaTotal/Math.PI).toString() },
  ];
  const STATS_H = 220;
  const cellW   = RIGHT_W / 4;
  const cellH   = STATS_H / 2;

  ctx.fillStyle='rgba(255,215,0,0.04)';
  ctx.strokeStyle='rgba(255,215,0,0.18)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(RIGHT_X, ry, RIGHT_W, STATS_H, 12); ctx.fill(); ctx.stroke();

  STATS.forEach((s,i)=>{
    const col=i%4, row=Math.floor(i/4);
    const cx=RIGHT_X+col*cellW, cy=ry+row*cellH;
    ctx.textAlign='left'; ctx.textBaseline='top';
    ctx.fillStyle='rgba(255,215,0,0.45)';
    ctx.font=`500 22px 'JetBrains Mono', monospace`;
    ctx.fillText(s.lbl, cx+18, cy+18);
    ctx.fillStyle='#ffd700';
    ctx.font=`bold 40px 'JetBrains Mono', monospace`;
    ctx.fillText(s.val, cx+18, cy+52);
  });
  ry += STATS_H + 48;

  // ‚îÄ‚îÄ Parameter Legend (Bottom-Right) ‚îÄ‚îÄ
  const LEGEND_X = RIGHT_X;
  const LEGEND_Y = H - 580;  // Position from bottom
  const LEGEND_W = RIGHT_W;
  const LEGEND_H = 500;
  
  // Background panel
  ctx.fillStyle='rgba(91,156,246,0.04)';
  ctx.strokeStyle='rgba(91,156,246,0.18)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(LEGEND_X, LEGEND_Y, LEGEND_W, LEGEND_H, 12); ctx.fill(); ctx.stroke();
  
  // Title
  ctx.textAlign='left'; ctx.textBaseline='top';
  ctx.fillStyle='rgba(91,156,246,0.7)';
  ctx.font=`bold 32px 'JetBrains Mono', monospace`;
  ctx.fillText('PARAMETERS', LEGEND_X + 24, LEGEND_Y + 20);
  
  let py = LEGEND_Y + 70;
  const lineH = 36;
  const indent = LEGEND_X + 24;
  
  // Parameter details
  const params = [
    { label: 'Formula Parameters:', value: '', color: 'rgba(255,215,0,0.6)' },
    { label: '  A (Offset):', value: A.toString(), color: '#ffd700' },
    { label: '  B (Amplitude):', value: B.toString(), color: '#ffd700' },
    { label: '  C (Frequency):', value: C.toString(), color: '#ffd700' },
    { label: '  D (Phase):', value: D.toString(), color: '#ffd700' },
    { label: '', value: '', color: '' },
    { label: 'Visualization:', value: '', color: 'rgba(91,156,246,0.6)' },
    { label: '  Color Mode:', value: harmColorMode ? 'Harmonic Consonance' : 'Hue Gradient', color: harmColorMode ? '#5ebd78' : '#5b9cf6' },
    { label: '  Rotation X:', value: `${Math.round(manualRotX)}¬∞`, color: '#5b9cf6' },
    { label: '  Rotation Y:', value: `${Math.round(manualRotY)}¬∞`, color: '#5b9cf6' },
    { label: '  Rotation Z:', value: `${Math.round(manualRotZ)}¬∞`, color: '#5b9cf6' },
    { label: '  Zoom Level:', value: `${zoomLevel.toFixed(2)}√ó`, color: '#5b9cf6' },
    { label: '  Trace Thickness:', value: traceThickness.toString(), color: '#5b9cf6' },
    { label: '  Speed:', value: speed.toString(), color: '#5b9cf6' },
  ];
  
  ctx.font=`500 24px 'JetBrains Mono', monospace`;
  params.forEach(p => {
    if (p.label === '' && p.value === '') {
      py += lineH * 0.3; // Small gap
    } else if (p.value === '') {
      // Section header
      ctx.fillStyle = p.color;
      ctx.font=`bold 26px 'JetBrains Mono', monospace`;
      ctx.fillText(p.label, indent, py);
      ctx.font=`500 24px 'JetBrains Mono', monospace`;
      py += lineH;
    } else {
      // Parameter line
      ctx.fillStyle = 'rgba(180,200,235,0.5)';
      ctx.fillText(p.label, indent, py);
      ctx.fillStyle = p.color;
      const labelW = ctx.measureText(p.label).width;
      ctx.fillText(p.value, indent + labelW + 12, py);
      py += lineH;
    }
  });

  // Add harmonic intervals if color mode is on
  if (harmColorMode && harmSelectedIntervals.size > 0) {
    py += lineH * 0.3; // Small gap
    ctx.fillStyle = 'rgba(94,189,120,0.6)';
    ctx.font=`bold 26px 'JetBrains Mono', monospace`;
    ctx.fillText('Harmonic Intervals:', indent, py);
    ctx.font=`500 22px 'JetBrains Mono', monospace`;
    py += lineH;
    
    const sel = [...harmSelectedIntervals].sort((a,b) => a-b);
    const intervalStr = sel.map(i => HARM_INTERVALS[i].name).join(', ');
    ctx.fillStyle = '#5ebd78';
    ctx.fillText(`  ${intervalStr}`, indent, py);
    py += lineH;
  }

  // ‚îÄ‚îÄ Watermark ‚îÄ‚îÄ
  ctx.textAlign='left'; ctx.textBaseline='bottom';
  ctx.fillStyle='rgba(91,156,246,0.35)';
  ctx.font=`500 28px 'JetBrains Mono', monospace`;
  ctx.fillText('Polar vs Cartesian ¬∑ Wessen Getachew ¬∑ @7dview', PADDING, H - PADDING);

  // ‚îÄ‚îÄ Œ∏ range label top-right ‚îÄ‚îÄ
  ctx.textAlign='right'; ctx.textBaseline='top';
  ctx.fillStyle='rgba(255,215,0,0.4)';
  ctx.font=`500 26px 'JetBrains Mono', monospace`;
  ctx.fillText(`Œ∏ ‚àà [0, ${Math.round(thetaTotal/Math.PI)}œÄ]`, W - PADDING, PADDING);

  // ‚îÄ‚îÄ Download ‚îÄ‚îÄ
  const link = document.createElement('a');
  link.download = `polar_cart_4K_A${A}_B${B}_C${C}_D${D}.png`;
  link.href = cv.toDataURL('image/png');
  link.click();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MULTI-ANGLE EXPORT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function exportMultiAngle() {
  // Prompt user for number of angles
  const countStr = prompt('How many angle views do you want? (2-12)', '4');
  const count = parseInt(countStr);
  
  if (!count || count < 2 || count > 12) {
    alert('Please enter a number between 2 and 12');
    return;
  }
  
  // Ask if user wants individual files or combined
  const exportMode = confirm('Click OK for COMBINED image\nClick Cancel for INDIVIDUAL images');
  
  // Generate evenly distributed rotation angles
  // Always start with X=0, Y=0, Z=0, then rotate Y axis
  const angles = [];
  for (let i = 0; i < count; i++) {
    const yAngle = Math.round((360 / count) * i);
    angles.push({ x: 0, y: yAngle, z: 0 });
  }
  
  // Size for each canvas (high quality)
  const SIZE = 2048; // 2K per image
  const cvTemp = document.createElement('canvas');
  cvTemp.width = cvTemp.height = SIZE;
  const ctx = cvTemp.getContext('2d');
  
  // Save current rotation
  const savedRotX = manualRotX;
  const savedRotY = manualRotY;
  const savedRotZ = manualRotZ;
  const savedRotMat = [...rotMat];
  
  // Generate each angle
  const images = [];
  angles.forEach((angle, idx) => {
    // Set rotation
    manualRotX = angle.x;
    manualRotY = angle.y;
    manualRotZ = angle.z;
    const rx = manualRotX * Math.PI / 180;
    const ry = manualRotY * Math.PI / 180;
    const rz = manualRotZ * Math.PI / 180;
    rotMat = mmul(mrotX(rx), mmul(mrotY(ry), mrotZ(rz)));
    
    // Clear canvas
    ctx.fillStyle = '#060608';
    ctx.fillRect(0, 0, SIZE, SIZE);
    
    // Draw grid
    const R = SIZE * 0.37;
    function proj2K(rx, ry, rz) {
      const fov = 2.8, scale = fov / (fov - rz);
      return [SIZE / 2 + rx * R * scale * zoomLevel, SIZE / 2 - ry * R * scale * zoomLevel];
    }
    
    ctx.lineWidth = 1.5;
    // Latitude lines
    for (let li = -2; li <= 2; li++) {
      const lat = (li / 3) * Math.PI / 2, cosLat = Math.cos(lat), sinLat = Math.sin(lat);
      ctx.beginPath();
      let first = true;
      for (let lo = 0; lo <= Math.PI * 2 + 0.05; lo += 0.04) {
        const x = cosLat * Math.cos(lo), y = sinLat, z = cosLat * Math.sin(lo);
        const [rx, ry, rz] = applyM(rotMat, x, y, z);
        const [px, py] = proj2K(rx, ry, rz);
        ctx.globalAlpha = Math.max(0.05, 0.06 + (rz + 1) * 0.12);
        ctx.strokeStyle = '#3a7040';
        if (first) { ctx.moveTo(px, py); first = false; } else ctx.lineTo(px, py);
      }
      ctx.stroke();
    }
    // Longitude lines
    for (let lo = 0; lo < 8; lo++) {
      const lon = (lo / 8) * Math.PI * 2, cosLon = Math.cos(lon), sinLon = Math.sin(lon);
      ctx.beginPath();
      let first = true;
      for (let la = -Math.PI / 2; la <= Math.PI / 2 + 0.05; la += 0.04) {
        const x = Math.cos(la) * cosLon, y = Math.sin(la), z = Math.cos(la) * sinLon;
        const [rx, ry, rz] = applyM(rotMat, x, y, z);
        const [px, py] = proj2K(rx, ry, rz);
        ctx.globalAlpha = Math.max(0.05, 0.06 + (rz + 1) * 0.12);
        ctx.strokeStyle = '#3a7040';
        if (first) { ctx.moveTo(px, py); first = false; } else ctx.lineTo(px, py);
      }
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    
    // Draw curve
    const end = Math.floor(drawProgress);
    if (end >= 2) {
      ctx.lineWidth = traceThickness * 2.5;
      for (let i = 1; i < end; i++) {
        const p1 = precomputed[i], p0 = precomputed[i - 1];
        if (!p0 || !p1) continue;
        const [rx1, ry1, rz1] = applyM(rotMat, p0[0], p0[1], p0[2]);
        const [rx2, ry2, rz2] = applyM(rotMat, p1[0], p1[1], p1[2]);
        const [px1, py1] = proj2K(rx1, ry1, rz1);
        const [px2, py2] = proj2K(rx2, ry2, rz2);
        const frac = i / TOTAL_PTS;
        ctx.strokeStyle = harmColorMode ? (harmColorForProgress(frac) || `hsl(${200 + frac * 80},90%,60%)`) : `hsl(${200 + frac * 80},90%,60%)`;
        ctx.globalAlpha = 0.9;
        ctx.beginPath();
        ctx.moveTo(px1, py1);
        ctx.lineTo(px2, py2);
        ctx.stroke();
      }
    }
    
    // Add title
    ctx.globalAlpha = 1;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#ffd700';
    ctx.font = `bold 48px 'JetBrains Mono', monospace`;
    ctx.fillText(`f(Œ∏) = ${A} + sin(${B}Œ∏) ¬∑ sin(${C}Œ∏ / ${D})`, SIZE / 2, 40);
    
    // Add rotation angles at bottom
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = '#5b9cf6';
    ctx.font = `500 36px 'JetBrains Mono', monospace`;
    ctx.fillText(`X: ${angle.x}¬∞  Y: ${angle.y}¬∞  Z: ${angle.z}¬∞`, SIZE / 2, SIZE - 40);
    
    // Store image
    images.push({
      dataUrl: cvTemp.toDataURL('image/png'),
      canvas: cvTemp.toDataURL('image/png'),
      angle: angle
    });
  });
  
  // Restore rotation
  manualRotX = savedRotX;
  manualRotY = savedRotY;
  manualRotZ = savedRotZ;
  rotMat = savedRotMat;
  
  if (exportMode) {
    // COMBINED MODE ‚Äî balanced grid: find most-square layout
    // For n items, find cols√órows where cols*rows >= n and |cols-rows| is minimized
    function bestGrid(n) {
      let bestCols = n, bestRows = 1, bestDiff = n - 1;
      for (let c = 1; c <= n; c++) {
        const r = Math.ceil(n / c);
        if (c * r >= n) {
          const diff = Math.abs(c - r);
          if (diff < bestDiff || (diff === bestDiff && c <= r)) {
            bestDiff = diff;
            bestCols = c;
            bestRows = r;
          }
        }
      }
      return { cols: bestCols, rows: bestRows };
    }
    const { cols, rows } = bestGrid(count);

    const CELL_PAD = 32;    // padding between cells
    const MARGIN = 60;      // outer margin
    const LABEL_H = 100;    // title area at top
    const FOOT_H = 60;      // footer
    const AXIS_L = 48;      // left axis label area per cell
    const AXIS_B = 32;      // bottom axis label area per cell

    // Each cell is square: SIZE x SIZE, plus axis areas
    const CELL_W = SIZE + AXIS_L;
    const CELL_H = SIZE + AXIS_B;

    const gridW = MARGIN * 2 + cols * CELL_W + (cols - 1) * CELL_PAD;
    const gridH = MARGIN + LABEL_H + rows * CELL_H + (rows - 1) * CELL_PAD + FOOT_H;

    const gridCanvas = document.createElement('canvas');
    gridCanvas.width = gridW;
    gridCanvas.height = gridH;
    const gCtx = gridCanvas.getContext('2d');

    // Background
    gCtx.fillStyle = '#060608';
    gCtx.fillRect(0, 0, gridW, gridH);

    // Subtle grid paper
    gCtx.strokeStyle = 'rgba(91,156,246,0.04)';
    gCtx.lineWidth = 1;
    for (let x = 0; x < gridW; x += 32) { gCtx.beginPath(); gCtx.moveTo(x,0); gCtx.lineTo(x,gridH); gCtx.stroke(); }
    for (let y = 0; y < gridH; y += 32) { gCtx.beginPath(); gCtx.moveTo(0,y); gCtx.lineTo(gridW,y); gCtx.stroke(); }

    // Title
    gCtx.textAlign = 'center'; gCtx.textBaseline = 'middle';
    gCtx.fillStyle = '#e8c547';
    gCtx.font = `bold 52px 'JetBrains Mono', monospace`;
    gCtx.fillText(`f(Œ∏) = ${A} + sin(${B}Œ∏) ¬∑ sin(${C}Œ∏ / ${D})`, gridW / 2, MARGIN + LABEL_H * 0.38);
    // Grid descriptor
    gCtx.fillStyle = 'rgba(91,156,246,0.6)';
    gCtx.font = `400 28px 'JetBrains Mono', monospace`;
    gCtx.fillText(`${cols}√ó${rows} view array ¬∑ ${count} rotation angles`, gridW / 2, MARGIN + LABEL_H * 0.72);

    // Footer
    gCtx.textAlign = 'right'; gCtx.textBaseline = 'bottom';
    gCtx.fillStyle = 'rgba(232,197,71,0.3)';
    gCtx.font = `300 22px 'JetBrains Mono', monospace`;
    gCtx.fillText(`Œ∏ ‚àà [0, ${Math.round(thetaTotal/Math.PI)}œÄ]   A=${A}  B=${B}  C=${C}  D=${D}`, gridW - MARGIN, gridH - 20);

    // Draw each image in grid
    let loadedCount = 0;
    const imageElements = [];

    images.forEach((img, idx) => {
      const imgEl = new Image();
      imageElements.push(imgEl);

      imgEl.onload = () => {
        loadedCount++;

        const col = idx % cols;
        const row = Math.floor(idx / cols);
        const cellX = MARGIN + col * (CELL_W + CELL_PAD) + AXIS_L;
        const cellY = MARGIN + LABEL_H + row * (CELL_H + CELL_PAD);

        // Cell background border
        gCtx.strokeStyle = 'rgba(91,156,246,0.15)';
        gCtx.lineWidth = 1;
        gCtx.strokeRect(cellX - 1, cellY - 1, SIZE + 2, SIZE + 2);

        // Draw sphere image
        gCtx.drawImage(imgEl, cellX, cellY, SIZE, SIZE);

        // ‚îÄ‚îÄ Y-axis label (left of cell) ‚îÄ‚îÄ
        gCtx.save();
        gCtx.translate(cellX - AXIS_L + 12, cellY + SIZE / 2);
        gCtx.rotate(-Math.PI / 2);
        gCtx.textAlign = 'center'; gCtx.textBaseline = 'middle';
        gCtx.fillStyle = 'rgba(94,189,120,0.7)';
        gCtx.font = `400 20px 'JetBrains Mono', monospace`;
        gCtx.fillText('Y (Œ∏)', 0, 0);
        gCtx.restore();

        // ‚îÄ‚îÄ X-axis label (below cell) ‚îÄ‚îÄ
        gCtx.textAlign = 'center'; gCtx.textBaseline = 'top';
        gCtx.fillStyle = 'rgba(94,189,120,0.7)';
        gCtx.font = `400 20px 'JetBrains Mono', monospace`;
        gCtx.fillText('X (œÜ)', cellX + SIZE / 2, cellY + SIZE + 6);

        // ‚îÄ‚îÄ View label inside image (top-center) ‚îÄ‚îÄ
        gCtx.textAlign = 'center'; gCtx.textBaseline = 'top';
        gCtx.fillStyle = 'rgba(232,197,71,0.85)';
        gCtx.font = `bold 28px 'JetBrains Mono', monospace`;
        gCtx.fillText(`X:${images[idx].angle.x}¬∞ Y:${images[idx].angle.y}¬∞ Z:${images[idx].angle.z}¬∞`, cellX + SIZE / 2, cellY + 12);

        // ‚îÄ‚îÄ View number badge ‚îÄ‚îÄ
        gCtx.textAlign = 'left'; gCtx.textBaseline = 'top';
        gCtx.fillStyle = 'rgba(91,156,246,0.5)';
        gCtx.font = `500 22px 'JetBrains Mono', monospace`;
        gCtx.fillText(`#${idx + 1}`, cellX + 10, cellY + 10);

        if (loadedCount === count) {
          const link = document.createElement('a');
          link.download = `polar_${cols}x${rows}grid_${count}views_A${A}_B${B}_C${C}_D${D}.png`;
          link.href = gridCanvas.toDataURL('image/png');
          link.click();
        }
      };

      imgEl.src = img.canvas;
    });
    
  } else {
    // INDIVIDUAL MODE - Download separately
    images.forEach((img, idx) => {
      const link = document.createElement('a');
      link.download = `polar_A${A}_B${B}_C${C}_D${D}_angle${idx + 1}_X${img.angle.x}_Y${img.angle.y}_Z${img.angle.z}.png`;
      link.href = img.dataUrl;
      link.click();
    });
    alert(`Exported ${count} individual angle views!`);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  BUILD PRESETS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let activePresetBtn = null;

// Preset dropdown toggle
document.getElementById('presetDropHeader').addEventListener('click',()=>{
  document.getElementById('presetDropBody').classList.toggle('open');
  document.getElementById('presetDropChev').classList.toggle('open');
  document.getElementById('presetDropHeader').classList.toggle('open');
});

function buildPresets(){
  Object.entries(PRESET_GROUPS).forEach(([gid, list])=>{
    const row = document.getElementById(gid);
    if(!row) return;
    list.forEach((p,i)=>{
      const btn = document.createElement('button');
      btn.className = 'preset-btn';
      btn.textContent = p.name;
      if(gid==='pgClassic'&&i===0){ btn.classList.add('active'); activePresetBtn=btn; }
      btn.onclick = ()=> applyPreset(p, btn, gid==='pgGapWave');
      row.appendChild(btn);
    });
  });
}

function applyPreset(p, btn, isGap){
  onUserInteraction(); // first preset click switches to loop mode
  A=p.A; B=p.B; C=p.C; D=p.D; thetaTotal=p.theta*Math.PI; trailFade=p.trail||6;
  const sl=(id,v,fmt)=>{ document.getElementById(id).value=v; document.getElementById('d'+id.slice(1)).textContent=fmt?fmt(v):v; };
  sl('sA',A); sl('sB',B); sl('sC',C); sl('sD',D);
  sl('sTheta',p.theta,v=>v+'œÄ');
  if(activePresetBtn) activePresetBtn.classList.remove('active','gap-active');
  if(btn){ btn.classList.add(isGap?'gap-active':'active'); activePresetBtn=btn; }

  // Update active name in dropdown header
  const nameEl=document.getElementById('presetActiveName');
  if(nameEl) nameEl.textContent=p.name;

  // Loop OFF (as requested)
  looping=false;
  const cbLoop=document.getElementById('cbLoop');
  if(cbLoop){ cbLoop.checked=false; }
  document.getElementById('loopState').textContent='off ‚Äî stops at end';

  // Fast speed
  setSpeed(20);

  // Auto-rotate: preserve user's current toggle state; seqRotate fires when wave ends
  seqRotateOnComplete = true;

  // Reset then play
  hardReset();
  paused=false;
  const playBtn=document.getElementById('btnPlay');
  if(playBtn){ playBtn.textContent='‚è∏ Pause'; playBtn.classList.add('on'); }
  // Sync harmonics with wave
  harmSyncStart();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  GAP DECOMPOSITION MODULE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

document.getElementById('gdN').addEventListener('input', function(){
  document.getElementById('gdND').textContent = parseInt(this.value).toLocaleString();
});
document.getElementById('gdS').addEventListener('input', function(){
  document.getElementById('gdSD').textContent = `s = ${parseFloat(this.value).toFixed(2)}`;
});

let gdData = null;
let gdTab = 'contrib';
let gdFilter = 'all';
const gdCanvas = document.getElementById('gapCanvas');
const gdCtx = gdCanvas.getContext('2d');
let gdActiveWaveBtn = null;

function gdResizeCanvas(){
  const gapPanel = document.getElementById('gapWavePanel');
  const leftSidebar = window.innerWidth > 900 ? 320 : 0;
  const sphereW = Math.min(window.innerWidth - leftSidebar - 80, 900);

  if(!gapPanel || gapPanel.classList.contains('gap-hidden')){
    gdCanvas.width = Math.max(280, 400);
  } else {
    gdCanvas.width = Math.max(280, Math.floor((sphereW - 12) / 2));
  }
  gdCanvas.height = Math.max(200, Math.round(cCv.height || 200));

  // Also size the big accordion chart canvas
  const bigCv = document.getElementById('gdChartBig');
  if(bigCv){
    bigCv.width = Math.max(400, sphereW);
    bigCv.height = Math.round(bigCv.width * 0.45);
  }

  if(gdData) gdDraw();
}
gdResizeCanvas();
// (resize handled by onLayoutResize above)

function setGapFilter(btn, filter){
  document.querySelectorAll('.gap-filter-btn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  gdFilter = filter;
}

// ‚îÄ‚îÄ Sieves ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function simpleSieve(max){
  const sieve = new Uint8Array(max+1).fill(1);
  sieve[0]=sieve[1]=0;
  for(let i=2;i*i<=max;i++) if(sieve[i]) for(let j=i*i;j<=max;j+=i) sieve[j]=0;
  const primes=[];
  for(let i=2;i<=max;i++) if(sieve[i]) primes.push(i);
  return primes;
}

function segmentedSieve(max, progressCb){
  const sqrtMax = Math.ceil(Math.sqrt(max));
  const small = simpleSieve(sqrtMax);
  const primes = [];
  const SEG = 1<<20;
  for(let lo=0; lo<=max; lo+=SEG){
    const hi = Math.min(lo+SEG-1, max);
    const seg = new Uint8Array(hi-lo+1).fill(1);
    for(const p of small){
      let start = Math.max(p*p, Math.ceil(lo/p)*p);
      for(let j=start; j<=hi; j+=p) seg[j-lo]=0;
    }
    for(let i=(lo<2?2:lo); i<=hi; i++) if(seg[i-lo]) primes.push(i);
    if(progressCb) progressCb(hi, max);
  }
  return primes;
}

// ‚îÄ‚îÄ Core analysis ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function knownZeta(s){
  const k = {2:Math.PI**2/6, 4:Math.PI**4/90, 6:Math.PI**6/945, 8:Math.PI**8/9450, 10:Math.PI**10/93555};
  return k[Math.round(s*100)/100] || null;
}

function gdCompute(maxN, s, filter, progressCb){
  const primes = maxN < 5e6 ? simpleSieve(maxN) : segmentedSieve(maxN, progressCb);

  let target = knownZeta(s);
  if(!target) target = primes.reduce((p, pr) => p * Math.pow(pr,s)/(Math.pow(pr,s)-1), 1);

  const gapFamilies = {};
  for(let i=0; i<primes.length-1; i++){
    const g = primes[i+1]-primes[i];
    if(!gapFamilies[g]) gapFamilies[g]=[];
    gapFamilies[g].push(primes[i]);
  }

  let gaps = Object.keys(gapFamilies).map(Number).sort((a,b)=>a-b);

  if(filter==='tiny')   gaps = gaps.filter(g=>g>=2&&g<=10);
  if(filter==='small')  gaps = gaps.filter(g=>g>=2&&g<=30);
  if(filter==='medium') gaps = gaps.filter(g=>g>=20&&g<=80);
  if(filter==='large')  gaps = gaps.filter(g=>g>=50&&g<=200);

  const gapProducts = {};
  let totalLog = 0;
  gaps.forEach(g=>{
    const ps = gapFamilies[g];
    if(!ps||!ps.length) return;
    let prod=1, logProd=0;
    ps.forEach(p=>{
      const ps_s = Math.pow(p,s);
      const fac = ps_s/(ps_s-1);
      prod *= fac; logProd += Math.log(fac);
    });
    gapProducts[g] = { product:prod, logProduct:logProd, count:ps.length };
    totalLog += logProd;
  });

  // Convergence steps
  const conv = [];
  let cum = 1, prevCum = 1;
  gaps.forEach((g,idx)=>{
    if(!gapProducts[g]) return;
    prevCum = cum;
    cum *= gapProducts[g].product;
    const relErr = Math.abs(cum-target)/target;
    const pi_est = s >= 1.99 && s <= 2.01 ? Math.sqrt(6*cum) : null;
    const delta = cum - prevCum;
    conv.push({ gap:g, value:cum, relErr, prevErr: idx>0?conv[idx-1]?.relErr??null:null,
                pi_est, delta, logProduct:gapProducts[g].logProduct, step:idx+1 });
  });

  const c2 = gapFamilies[2]?.length||0;
  const c4 = gapFamilies[4]?.length||0;
  const c6 = gapFamilies[6]?.length||0;

  let mostCommon = gaps[0], mcCount = 0;
  gaps.forEach(g=>{ if((gapFamilies[g]?.length||0)>mcCount){ mcCount=gapFamilies[g].length; mostCommon=g; }});

  const finalErr = Math.abs(cum-target)/target;
  const pi_calc = (s >= 1.99 && s <= 2.01) ? Math.sqrt(6*cum) : null;

  // Build gap‚Üíindex map for color assignment
  gapIndexMap = {};
  gaps.forEach((g,i) => { gapIndexMap[g] = i; });

  return { primes, gaps, gapFamilies, gapProducts, conv, target, totalLog,
           finalProduct:cum, finalError:finalErr, s, maxN,
           c2,c4,c6, mostCommon, mcCount, pi_calc };
}

// ‚îÄ‚îÄ Run ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function gdRun(){
  const maxN = parseInt(document.getElementById('gdN').value);
  const s = parseFloat(document.getElementById('gdS').value);
  const filter = gdFilter;

  if(maxN > 300000000){
    document.getElementById('gdStatus').textContent = '‚ö† Max N is 300,000,000 (browser limit).';
    return;
  }

  document.getElementById('gdStatus').textContent = 'Sieving primes‚Ä¶';
  document.getElementById('gdRunBtn').disabled = true;
  document.getElementById('gdProgress').style.display = 'block';
  document.getElementById('gdProgressFill').style.width = '0%';

  setTimeout(()=>{
    try {
      const progressCb = (cur, max)=>{
        const pct = Math.min(99, (cur/max*100)).toFixed(0);
        document.getElementById('gdProgressFill').style.width = pct+'%';
        document.getElementById('gdStatus').textContent = `Sieving‚Ä¶ ${pct}%  (${cur.toLocaleString()} / ${max.toLocaleString()})`;
      };

      gdData = gdCompute(maxN, s, filter, progressCb);

      document.getElementById('gdProgressFill').style.width = '100%';
      setTimeout(()=>document.getElementById('gdProgress').style.display='none', 400);

      const errPct = (gdData.finalError*100).toFixed(8);
      document.getElementById('gdStatus').textContent =
        `‚úì N=${maxN.toLocaleString()} ¬∑ ${gdData.primes.length.toLocaleString()} primes ¬∑ `+
        `${gdData.gaps.length} gap families ¬∑ `+
        `Œ∂(${s.toFixed(2)}) target=${gdData.target.toFixed(10)} ¬∑ `+
        `computed=${gdData.finalProduct.toFixed(10)} ¬∑ err=${errPct}%`;

      updateGdStats();

      ['gdExportPNG','gdExportCSV','gdExportTXT'].forEach(id=>document.getElementById(id).style.display='inline-block');
      document.getElementById('gdTabs').style.display='flex';
      document.getElementById('gdStatsGrid').style.display='grid';

      // Show big chart area + screenshot button
      const chartArea = document.getElementById('gdChartArea');
      if(chartArea) chartArea.style.display='block';
      const chartBtn = document.getElementById('gdChartScreenshot');
      if(chartBtn) chartBtn.style.display='inline-block';

      // Open the gap accordion so user sees results
      const accBody = document.getElementById('gapAccBody');
      const accChev = document.getElementById('gapAccChev');
      const accHdr  = document.getElementById('gapAccHeader');
      if(accBody && !accBody.classList.contains('open')){
        accBody.classList.add('open');
        if(accChev) accChev.classList.add('open');
        if(accHdr)  accHdr.classList.add('open');
      }

      // Build gap chip selectors (panel + main area)
      buildGapChips();

      // Build stats table and convergence table
      gdBuildTable();
      gdBuildConvTable();
      document.getElementById('gdTableSection').style.display='block';
      document.getElementById('gdConvSection').style.display='block';

      // Recompute sphere with gap data ‚Äî does NOT reset drawProgress
      precompute();
      invalidateCartBuf();

      gdResizeCanvas();
      gdDraw();

    } catch(e) {
      document.getElementById('gdStatus').textContent = `Error: ${e.message}`;
      console.error(e);
    }
    document.getElementById('gdRunBtn').disabled = false;
  }, 20);
}

function updateGdStats(){
  if(!gdData) return;
  const d = gdData;
  const pi_str = d.pi_calc ? d.pi_calc.toFixed(10) : 'n/a (s‚â†2)';
  const vals = [
    d.primes.length.toLocaleString(), d.gaps.length,
    Math.max(...d.gaps), d.target.toFixed(10), d.finalProduct.toFixed(10),
    (d.finalError*100).toFixed(10)+'%', d.c2.toLocaleString(),
    d.c4.toLocaleString(), d.c6.toLocaleString(),
    `${d.mostCommon} (${d.mcCount.toLocaleString()}√ó)`,
    d.c4>0 ? (d.c2/d.c4).toFixed(6) : 'n/a', pi_str,
  ];
  vals.forEach((v,i)=>{ const el=document.getElementById('gst'+i); if(el) el.textContent=v; });
}

function gdClear(){
  gdData = null; selectedGaps.clear(); gapIndexMap = {};
  gdCtx.clearRect(0,0,gdCanvas.width,gdCanvas.height);
  // Clear big accordion chart
  const bigCv = document.getElementById('gdChartBig');
  if(bigCv){ bigCv.getContext('2d').clearRect(0,0,bigCv.width,bigCv.height); }
  const chartArea = document.getElementById('gdChartArea');
  if(chartArea) chartArea.style.display='none';
  const chartBtn = document.getElementById('gdChartScreenshot');
  if(chartBtn) chartBtn.style.display='none';

  document.getElementById('gdStatus').textContent='Run decomposition to analyze prime gap contributions to Œ∂(s).';
  ['gdExportPNG','gdExportCSV','gdExportTXT'].forEach(id=>document.getElementById(id).style.display='none');
  document.getElementById('gdTabs').style.display='none';
  document.getElementById('gdStatsGrid').style.display='none';
  document.getElementById('gdSelectorWrap').style.display='none';
  document.getElementById('gdTableSection').style.display='none';
  document.getElementById('gdConvSection').style.display='none';
  document.getElementById('gdLegend').innerHTML='';
  document.getElementById('gdChips').innerHTML='';
  precompute(); invalidateCartBuf();
}

function gdSwitchTab(btn, tab){
  gdTab = tab;
  document.querySelectorAll('.gap-tab').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  if(gdData) gdDraw();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  GAP CHIP SELECTOR (multi-select)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function buildGapChips(){
  if(!gdData) return;

  // Build chips in the panel selector only
  const row = document.getElementById('gdChips');
  const wrap = document.getElementById('gdSelectorWrap');
  row.innerHTML = '';
  gdData.gaps.forEach((g, i) => {
    const col = gapColor(g, i);
    const chip = document.createElement('div');
    chip.className = 'gap-chip';
    chip.dataset.gap = g;
    chip.innerHTML = `<span class="chip-dot" style="background:${col}"></span>g=${g}`;
    chip.title = `Gap ${g}: ${(gdData.gapProducts[g]?.count||0).toLocaleString()} primes`;
    chip.addEventListener('click', ()=> toggleGapChipAll(g, i, col));
    row.appendChild(chip);
  });
  wrap.style.display = 'block';
}

// Toggle all chips with matching gap value across both containers
function toggleGapChipAll(g, idx, col){
  onUserInteraction();
  const isSelected = selectedGaps.has(g);
  if(isSelected){
    selectedGaps.delete(g);
  } else {
    selectedGaps.set(g, col);
  }
  // Update ALL chips for this gap
  document.querySelectorAll(`.gap-chip[data-gap="${g}"]`).forEach(chip => {
    if(selectedGaps.has(g)){
      chip.classList.add('selected');
      chip.style.background = col;
      chip.style.borderColor = col;
      chip.style.color = '#000';
    } else {
      chip.classList.remove('selected');
      chip.style.background = '';
      chip.style.borderColor = '';
      chip.style.color = '';
    }
  });
  invalidateCartBuf();
  // Resize cart canvas height to accommodate new lane count
  setSize(); makeCartBuf(); lastCartProg = 0;
}

function toggleGapChip(g, idx, chip, col){
  toggleGapChipAll(g, idx, col);
}

function gdClearSelection(){
  selectedGaps.clear();
  document.querySelectorAll('.gap-chip.selected').forEach(c=>{
    c.classList.remove('selected');
    c.style.background = '';
    c.style.borderColor = '';
    c.style.color = '';
  });
  setSize(); invalidateCartBuf();
  if(gdData) gdDraw();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ALL-GAPS STATS TABLE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function gdBuildTable(){
  if(!gdData) return;
  const {gaps, gapProducts, gapFamilies, totalLog, target, s} = gdData;
  const dec = Math.max(2, Math.min(20, parseInt(document.getElementById('gdTableDec').value)||8));
  const sortBy = document.getElementById('gdTableSort').value;
  const topN = parseInt(document.getElementById('gdTableTop').value)||0;
  const hlSel = document.getElementById('gdTableHighlight').checked;

  let rows = gaps.filter(g=>gapProducts[g]).map((g,i)=>{
    const gp = gapProducts[g];
    const logShare = gp.logProduct / (totalLog||1) * 100;
    let cum=1;
    gaps.forEach(gg=>{ if(gg<=g && gapProducts[gg]) cum*=gapProducts[gg].product; });
    return { g, count:gp.count, product:gp.product, logProduct:gp.logProduct,
             logShare, cumulative:cum, relErr:Math.abs(cum-target)/target,
             pctPrimes:gp.count/(gdData.primes.length||1)*100, i };
  });

  if(sortBy==='count_desc') rows.sort((a,b)=>b.count-a.count);
  else if(sortBy==='logshare_desc') rows.sort((a,b)=>b.logShare-a.logShare);
  else if(sortBy==='product_desc') rows.sort((a,b)=>b.product-a.product);
  else if(sortBy==='cumulative') rows.sort((a,b)=>a.cumulative-b.cumulative);
  else rows.sort((a,b)=>a.g-b.g);

  if(topN>0) rows = rows.slice(0, topN);

  const fmt = (v, d) => typeof v === 'number' ? v.toFixed(d) : v;
  const fmtE = (v, d) => v < 1e-4 ? v.toExponential(d) : v.toFixed(d);

  let html = `<table>
    <thead><tr>
      <th>Gap</th>
      <th>Count</th>
      <th>% of primes</th>
      <th>Product</th>
      <th>log(Product)</th>
      <th>log-Œ∂ share %</th>
      <th>Cumulative</th>
      <th>Rel. error</th>
      <th>Abs. error</th>
    </tr></thead><tbody>`;

  rows.forEach(r=>{
    const col = gapColor(r.g, r.i);
    const isSel = hlSel && selectedGaps.has(r.g);
    const selClass = isSel ? 'gap-row-selected' : '';
    const abErr = Math.abs(r.cumulative - target);
    html += `<tr class="${selClass}">
      <td class="gap-id" style="color:${col}">${r.g}</td>
      <td>${r.count.toLocaleString()}</td>
      <td>${fmt(r.pctPrimes, dec)}%</td>
      <td>${fmt(r.product, dec)}</td>
      <td>${fmt(r.logProduct, dec)}</td>
      <td>${fmt(r.logShare, dec)}%</td>
      <td>${fmt(r.cumulative, dec)}</td>
      <td>${fmtE(r.relErr, dec)}</td>
      <td>${fmtE(abErr, dec)}</td>
    </tr>`;
  });
  html += '</tbody></table>';
  document.getElementById('gdTableWrap').innerHTML = html;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CONVERGENCE TO œÄ¬≤/6 TABLE (dropdown)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
document.getElementById('convDropHeader').addEventListener('click', ()=>{
  document.getElementById('convDropBody').classList.toggle('open');
  document.getElementById('convDropChev').classList.toggle('open');
});

function gdBuildConvTable(){
  if(!gdData) return;
  const {conv, target, s, gaps, gapProducts, totalLog} = gdData;
  const dec = Math.max(2, Math.min(20, parseInt(document.getElementById('convDec').value)||12));
  const sortKey = document.getElementById('convSort').value;
  const topN = parseInt(document.getElementById('convTop').value)||0;
  const showPi = document.getElementById('convShowPi').checked;
  const showLog = document.getElementById('convShowLog').checked;
  const showDelta = document.getElementById('convShowDelta').checked;

  const isZeta2 = s >= 1.99 && s <= 2.01;
  const TARGET_PI2_6 = Math.PI**2/6;

  // Build full row data: one row per gap step
  let rows = conv.map((c, i)=>{
    const gp = gapProducts[c.gap];
    const logShare = gp ? gp.logProduct/(totalLog||1)*100 : 0;
    const logErr = c.relErr > 0 ? Math.log10(c.relErr) : -Infinity;
    const improving = i>0 ? c.relErr < conv[i-1].relErr : true;
    return { ...c, logShare, logErr, improving, step:i+1 };
  });

  if(sortKey==='logshare_desc') rows = [...rows].sort((a,b)=>b.logShare-a.logShare);
  else if(sortKey==='cumulative_asc') rows = [...rows].sort((a,b)=>a.value-b.value);
  else if(sortKey==='relerr_asc') rows = [...rows].sort((a,b)=>a.relErr-b.relErr);
  // else natural gap order

  if(topN>0) rows = rows.slice(0, topN);

  // Best row (minimum relative error)
  const bestRelErr = Math.min(...rows.map(r=>r.relErr));

  const fmt = (v, d) => typeof v === 'number' ? v.toFixed(d) : '‚Äî';
  const fmtE = (v, d) => (v===null||v===undefined) ? '‚Äî' : v < 1e-4 ? v.toExponential(d) : v.toFixed(d);

  let ths = `<th>Step</th><th>Gap</th><th>log-Œ∂ %</th>
    <th class="conv-cell-product">Cumulative product</th>
    <th>Target Œ∂(${s.toFixed(2)})</th>
    <th class="conv-cell-err">Rel. error</th>
    <th>Abs. error</th>`;
  if(showLog) ths += `<th class="conv-cell-logerr">log‚ÇÅ‚ÇÄ(err)</th>`;
  if(showDelta) ths += `<th>Œî product</th>`;
  if(showPi && isZeta2) ths += `<th class="conv-cell-pi">‚àö(6¬∑prod) ‚âà œÄ</th><th class="conv-cell-pi">|œÄ est ‚àí œÄ|</th>`;

  let html = `<table><thead><tr>${ths}</tr></thead><tbody>`;

  rows.forEach(r=>{
    const isBest = r.relErr === bestRelErr;
    const rowClass = isBest ? 'conv-row-best' : r.improving ? 'conv-row-improving' : 'conv-row-worsening';
    const col = gapColor(r.gap, gapIndexMap[r.gap]||0);
    const abErr = Math.abs(r.value - target);
    const pi_est = (showPi && isZeta2 && r.value > 0) ? Math.sqrt(6*r.value) : null;
    const pi_err = pi_est !== null ? Math.abs(pi_est - Math.PI) : null;

    let tds = `
      <td>${r.step}</td>
      <td class="conv-cell-gap" style="color:${col}">g=${r.gap}</td>
      <td>${fmt(r.logShare, dec)}%</td>
      <td class="conv-cell-product">${fmt(r.value, dec)}</td>
      <td>${fmt(target, dec)}</td>
      <td class="conv-cell-err">${fmtE(r.relErr, dec)}</td>
      <td>${fmtE(abErr, dec)}</td>`;
    if(showLog) tds += `<td class="conv-cell-logerr">${isFinite(r.logErr)?fmt(r.logErr,dec):'‚Äî'}</td>`;
    if(showDelta) tds += `<td>${fmtE(Math.abs(r.delta), dec)}</td>`;
    if(showPi && isZeta2){
      tds += `<td class="conv-cell-pi">${pi_est!==null?fmt(pi_est,dec):'‚Äî'}</td>`;
      tds += `<td class="conv-cell-pi">${pi_err!==null?fmtE(pi_err,dec):'‚Äî'}</td>`;
    }

    html += `<tr class="${rowClass}">${tds}</tr>`;
  });
  html += '</tbody></table>';
  document.getElementById('gdConvTableWrap').innerHTML = html;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  REFINED WAVE PRESETS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function buildRefinedWavePresets(){}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CHART DRAWING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function gdDraw(){
  if(!gdData) return;
  const w=gdCanvas.width, h=gdCanvas.height;
  gdCtx.fillStyle='#060608'; gdCtx.fillRect(0,0,w,h);
  if(gdTab==='contrib') gdDrawContrib(w,h);
  else if(gdTab==='dist') gdDrawDist(w,h);
  else if(gdTab==='conv') gdDrawConv(w,h);
  else if(gdTab==='ratio') gdDrawRatio(w,h);
  else if(gdTab==='pct') gdDrawPct(w,h);

  // Mirror to big accordion chart canvas
  const bigCv = document.getElementById('gdChartBig');
  if(bigCv && bigCv.width > 0 && bigCv.height > 0){
    const bigCtx = bigCv.getContext('2d');
    bigCtx.fillStyle='#060608'; bigCtx.fillRect(0,0,bigCv.width,bigCv.height);
    bigCtx.drawImage(gdCanvas, 0, 0, bigCv.width, bigCv.height);
  }
}

function gPad(){ return {l:60,r:14,t:28,b:42}; }
function gdTitle(ctx, w, txt){
  ctx.fillStyle='#ffd700'; ctx.textAlign='left';
  ctx.font=`bold ${Math.max(9,w*.022)}px JetBrains Mono,monospace`;
  ctx.fillText(txt, 60, 18);
}

function gdDrawContrib(w, h){
  const {gaps, gapProducts, totalLog, s} = gdData;
  if(!gaps.length) return;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  const shares = gaps.map(g=>(gapProducts[g]?.logProduct||0)/totalLog*100);
  const maxS = Math.max(...shares);
  const barW = pw/gaps.length;

  ctx.font=`${Math.max(7,w*.018)}px JetBrains Mono,monospace`;
  gaps.forEach((g,i)=>{
    const pct=shares[i], bh=pct/maxS*ph;
    const x=p.l+i*barW, y=p.t+ph-bh;
    const col=gapColor(g,i);
    const isSel = selectedGaps.has(g);
    ctx.fillStyle=col+(isSel?'bb':'33'); ctx.fillRect(x+1,y,barW-2,bh);
    ctx.strokeStyle=col; ctx.lineWidth=isSel?2.5:1.2;
    ctx.strokeRect(x+1,y,barW-2,bh);
    if(barW>18){ ctx.fillStyle=col; ctx.textAlign='center'; ctx.fillText(''+g, x+barW/2, p.t+ph+16); }
    if(barW>28&&pct>0.5){ ctx.fillStyle='#fff'; ctx.globalAlpha=0.8; ctx.fillText(pct.toFixed(1)+'%', x+barW/2, y-3); ctx.globalAlpha=1; }
  });
  [0,25,50,75,100].forEach(pct=>{
    if(pct<=maxS*1.1){ const y=p.t+ph-pct/maxS*ph;
      ctx.strokeStyle='#182018'; ctx.lineWidth=0.5;
      ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(w-p.r,y); ctx.stroke();
      ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle';
      ctx.fillText(pct+'%', p.l-4, y);
    }
  });
  gdTitle(ctx, w, `log-Œ∂(${s.toFixed(2)}) contribution % by gap`);
  gdBuildLegend(gaps.slice(0,16));
}

function gdDrawDist(w, h){
  const {gaps, gapFamilies} = gdData;
  if(!gaps.length) return;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  const counts=gaps.map(g=>gapFamilies[g]?.length||0);
  const maxC=Math.max(...counts);
  const barW=pw/gaps.length;
  gaps.forEach((g,i)=>{
    const c=counts[i], bh=c/maxC*ph;
    const x=p.l+i*barW, y=p.t+ph-bh;
    const col=gapColor(g,i);
    const isSel=selectedGaps.has(g);
    ctx.fillStyle=col+(isSel?'bb':'33'); ctx.fillRect(x+1,y,barW-2,bh);
    ctx.strokeStyle=col; ctx.lineWidth=isSel?2.5:1.2; ctx.strokeRect(x+1,y,barW-2,bh);
    if(barW>18){ ctx.fillStyle=col; ctx.textAlign='center';
      ctx.font=`${Math.max(7,w*.018)}px JetBrains Mono,monospace`;
      ctx.fillText(''+g, x+barW/2, p.t+ph+16); }
  });
  [0,.25,.5,.75,1].forEach(frac=>{ const y=p.t+ph-frac*ph, v=Math.round(frac*maxC);
    ctx.strokeStyle='#182018'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(w-p.r,y); ctx.stroke();
    ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle';
    ctx.font=`${Math.max(7,w*.018)}px JetBrains Mono,monospace`;
    ctx.fillText(v>=1e6?(v/1e6).toFixed(1)+'M':v>=1e3?(v/1e3).toFixed(0)+'k':v, p.l-4, y);
  });
  gdTitle(ctx, w, `Prime count per gap family`);
  gdBuildLegend(gaps.slice(0,16));
}

function gdDrawConv(w, h){
  const {conv, target, s} = gdData;
  if(conv.length<2) return;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  const vals=conv.map(d=>d.value);
  const minV=Math.min(target*0.8,...vals), maxV=Math.max(target*1.1,...vals);
  const xS=pw/(conv.length-1), yS=ph/(maxV-minV);
  ctx.font=`${Math.max(7,w*.018)}px JetBrains Mono,monospace`;
  const ty=p.t+ph-(target-minV)*yS;
  ctx.strokeStyle='#ffd70066'; ctx.lineWidth=1; ctx.setLineDash([6,4]);
  ctx.beginPath(); ctx.moveTo(p.l,ty); ctx.lineTo(w-p.r,ty); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle='#ffd700'; ctx.textAlign='right';
  ctx.fillText(`Œ∂(${s})=${target.toFixed(6)}`, w-p.r-2, ty-5);
  ctx.strokeStyle='var(--blue,#5b9cf6)'; ctx.lineWidth=2;
  ctx.shadowColor='var(--blue,#5b9cf6)'; ctx.shadowBlur=6;
  ctx.beginPath();
  conv.forEach((d,i)=>{ const x=p.l+i*xS, y=p.t+ph-(d.value-minV)*yS; i===0?ctx.moveTo(x,y):ctx.lineTo(x,y); });
  ctx.stroke(); ctx.shadowBlur=0;
  for(let i=0;i<=5;i++){ const frac=i/5, v=minV+frac*(maxV-minV), y=p.t+ph-frac*ph;
    ctx.strokeStyle='#182018'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(w-p.r,y); ctx.stroke();
    ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle';
    ctx.fillText(v.toFixed(4), p.l-4, y);
  }
  ctx.fillStyle='#88cc88'; ctx.textAlign='center';
  const step=Math.max(1,Math.floor(conv.length/8));
  conv.forEach((d,i)=>{ if(i%step===0){ ctx.fillText('g'+d.gap,p.l+i*xS,p.t+ph+18); }});
  gdTitle(ctx, w, `Cumulative Euler product ‚Üí Œ∂(${s.toFixed(2)})`);
  gdBuildLegend([]);
}

function gdDrawRatio(w, h){
  const {c2, c4, c6} = gdData;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  ctx.font=`${Math.max(8,w*.02)}px JetBrains Mono,monospace`;
  const pairs=[
    {lbl:'g‚ÇÇ/g‚ÇÑ\ntwin/cousin', val:c4>0?c2/c4:null, tgt:1.0, col:'#ffd700', note:'HL‚Üí1'},
    {lbl:'g‚ÇÇ/g‚ÇÜ\ntwin/sexy',   val:c6>0?c2/c6:null, tgt:0.5, col:'var(--blue,#5b9cf6)', note:'HL‚Üí0.5'},
    {lbl:'g‚ÇÑ/g‚ÇÜ\ncousin/sexy', val:c6>0?c4/c6:null, tgt:0.5, col:'#4ecdc4', note:'HL‚Üí0.5'},
  ];
  const bW=(pw/pairs.length)-14, maxV=3;
  pairs.forEach((pair,i)=>{
    const x=p.l+i*(pw/pairs.length)+7;
    if(pair.val===null){ ctx.fillStyle='#555'; ctx.textAlign='center'; ctx.fillText('N/A',x+bW/2,p.t+ph/2); return; }
    const bh=Math.min(pair.val/maxV,1)*ph, y=p.t+ph-bh;
    ctx.fillStyle=pair.col+'33'; ctx.fillRect(x,y,bW,bh);
    ctx.strokeStyle=pair.col; ctx.lineWidth=2; ctx.strokeRect(x,y,bW,bh);
    const ty=p.t+ph-(pair.tgt/maxV)*ph;
    ctx.strokeStyle=pair.col+'99'; ctx.lineWidth=1; ctx.setLineDash([4,3]);
    ctx.beginPath(); ctx.moveTo(x-4,ty); ctx.lineTo(x+bW+4,ty); ctx.stroke(); ctx.setLineDash([]);
    ctx.fillStyle=pair.col; ctx.textAlign='center';
    ctx.fillText(pair.val.toFixed(5),x+bW/2,y-6);
    ctx.fillStyle=pair.col+'99'; ctx.fillText(pair.note,x+bW/2,ty-6);
    ctx.fillStyle='#88cc88';
    pair.lbl.split('\n').forEach((ln,li)=>ctx.fillText(ln,x+bW/2,p.t+ph+16+li*12));
  });
  [0,1,2,3].forEach(v=>{ if(v<=maxV){ const y=p.t+ph-(v/maxV)*ph;
    ctx.strokeStyle='#182018'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(w-p.r,y); ctx.stroke();
    ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle'; ctx.fillText(v, p.l-4, y);
  }});
  gdTitle(ctx, w, `Gap count ratios vs Hardy‚ÄìLittlewood`);
  gdBuildLegend([]);
}

function gdDrawPct(w, h){
  const {gaps, gapProducts, totalLog, s} = gdData;
  if(!gaps.length) return;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  const sorted=gaps.filter(g=>gapProducts[g])
    .map((g,i)=>({g, share:gapProducts[g].logProduct/totalLog, i}))
    .sort((a,b)=>b.share-a.share);
  let y=p.t;
  sorted.forEach(({g,share,i})=>{
    const bh=share*ph, col=gapColor(g,i), isSel=selectedGaps.has(g);
    ctx.fillStyle=col+(isSel?'cc':'66'); ctx.fillRect(p.l,y,pw*0.35,bh);
    ctx.strokeStyle=col; ctx.lineWidth=isSel?2:1; ctx.strokeRect(p.l,y,pw*0.35,bh);
    if(bh>10){
      ctx.fillStyle='#fff'; ctx.globalAlpha=0.85; ctx.textAlign='left'; ctx.textBaseline='middle';
      ctx.font=`${Math.max(7,w*.017)}px JetBrains Mono,monospace`;
      ctx.fillText(`g=${g}  ${(share*100).toFixed(2)}%`, p.l+pw*0.35+8, y+bh/2);
      ctx.globalAlpha=1;
    }
    y+=bh;
  });
  gdTitle(ctx, w, `% share of log-Œ∂(${s.toFixed(2)}) by gap class`);
  gdBuildLegend(sorted.slice(0,12).map(({g})=>g));
}

function gdBuildLegend(gapList){
  const el=document.getElementById('gdLegend');
  el.innerHTML=gapList.map((g,i)=>{
    const col=gapColor(g,i);
    const isSel=selectedGaps.has(g);
    return `<div class="gap-leg" style="${isSel?'font-weight:700;':''}" onclick="toggleGapChipByVal(${g})" style="cursor:pointer">
      <div class="gap-leg-sw" style="background:${col};${isSel?'outline:2px solid '+col:''}"></div>
      gap ${g}${isSel?' ‚úì':''}
    </div>`;
  }).join('');
}

function toggleGapChipByVal(g){
  const chip = document.querySelector(`.gap-chip[data-gap="${g}"]`);
  if(chip){ const i = gapIndexMap[g]||0; toggleGapChip(g, i, chip, gapColor(g,i)); gdDraw(); }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  EXPORTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function gdExport4K(){
  if(!gdData) return;
  const SIZE_W=3840, SIZE_H=2160;
  const cv=document.createElement('canvas');
  cv.width=SIZE_W; cv.height=SIZE_H;
  const ctx=cv.getContext('2d');
  ctx.fillStyle='#060608'; ctx.fillRect(0,0,SIZE_W,SIZE_H);
  const origW=gdCanvas.width, origH=gdCanvas.height;
  gdCanvas.width=SIZE_W; gdCanvas.height=SIZE_H;
  gdDraw();
  ctx.drawImage(gdCanvas,0,0);
  gdCanvas.width=origW; gdCanvas.height=origH; gdResizeCanvas();
  ctx.fillStyle='rgba(6,6,8,0.75)'; ctx.fillRect(0,0,SIZE_W,110);
  ctx.fillStyle='#ffd700'; ctx.font='bold 56px JetBrains Mono,monospace';
  ctx.textAlign='left'; ctx.textBaseline='top';
  ctx.fillText(`Gap Decomp ¬∑ Œ∂(${gdData.s.toFixed(2)}) ¬∑ N=${gdData.maxN.toLocaleString()}`, 60, 20);
  ctx.fillStyle='#88cc88'; ctx.font='32px JetBrains Mono,monospace';
  ctx.fillText(`${gdData.primes.length.toLocaleString()} primes ¬∑ ${gdData.gaps.length} families ¬∑ err=${(gdData.finalError*100).toFixed(8)}%`, 60, 78);
  ctx.fillStyle='rgba(91,156,246,0.5)'; ctx.font='28px JetBrains Mono,monospace';
  ctx.textAlign='right'; ctx.fillText('Wessen Getachew ¬∑ @7dview', SIZE_W-60, 78);
  const link=document.createElement('a');
  link.download=`gap_decomp_4K_N${gdData.maxN}_s${gdData.s.toFixed(2)}_${gdTab}.png`;
  link.href=cv.toDataURL('image/png'); link.click();
  gdDraw();
}

function gdExportCSV(){
  if(!gdData) return;
  const d=gdData;
  let csv='Gap,Count,PctPrimes,Product,LogProduct,LogShare(%),CumulativeProduct,RelativeError,AbsoluteError\n';
  let cum=1;
  d.gaps.forEach(g=>{
    const gp=d.gapProducts[g]; if(!gp) return;
    cum*=gp.product;
    const logShare=(gp.logProduct/(d.totalLog||1)*100).toFixed(10);
    const relErr=Math.abs(cum-d.target)/d.target;
    const abErr=Math.abs(cum-d.target);
    const pctPrimes=(gp.count/(d.primes.length||1)*100).toFixed(10);
    csv+=`${g},${gp.count},${pctPrimes},${gp.product.toFixed(15)},${gp.logProduct.toFixed(15)},${logShare},${cum.toFixed(15)},${relErr.toFixed(15)},${abErr.toFixed(15)}\n`;
  });
  csvDownload(csv, `gap_decomp_N${d.maxN}_s${d.s.toFixed(2)}.csv`);
}

function gdExportTXT(){
  if(!gdData) return;
  const d=gdData, now=new Date().toISOString();
  const pi_str=d.pi_calc?`Calculated œÄ  = ${d.pi_calc.toFixed(15)}  (|err|=${Math.abs(d.pi_calc-Math.PI).toExponential(6)})`:'œÄ: only valid at s=2';
  let txt=`
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  PRIME GAP DECOMPOSITION REPORT ‚Äî Œ∂(s) Euler Analysis
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Generated : ${now}  |  Author: Wessen Getachew ¬∑ @7dview

PARAMETERS
  Max N         = ${d.maxN.toLocaleString()}
  Exponent s    = ${d.s.toFixed(4)}
  Gap filter    = ${gdFilter}

PRIME STATISTICS
  Total primes  = ${d.primes.length.toLocaleString()}
  Max prime     = ${d.primes[d.primes.length-1].toLocaleString()}
  Gap families  = ${d.gaps.length}
  Largest gap   = ${Math.max(...d.gaps)}
  Most common g = ${d.mostCommon} (${d.mcCount.toLocaleString()} times)

TWIN / COUSIN / SEXY
  Gap 2 (twin)  = ${d.c2.toLocaleString()}
  Gap 4 (cousin)= ${d.c4.toLocaleString()}
  Gap 6 (sexy)  = ${d.c6.toLocaleString()}
  g2/g4 ratio   = ${d.c4>0?(d.c2/d.c4).toFixed(12):'N/A'}  [HL: 1.0]
  g2/g6 ratio   = ${d.c6>0?(d.c2/d.c6).toFixed(12):'N/A'}  [HL: 0.5]
  g4/g6 ratio   = ${d.c6>0?(d.c4/d.c6).toFixed(12):'N/A'}  [HL: 0.5]

ZETA PRODUCT
  Target Œ∂(${d.s.toFixed(2)}) = ${d.target.toFixed(15)}
  Computed      = ${d.finalProduct.toFixed(15)}
  Abs error     = ${Math.abs(d.finalProduct-d.target).toExponential(10)}
  Rel error     = ${(d.finalError*100).toFixed(12)}%
  ${pi_str}

GAP CLASS TABLE
${'Gap'.padEnd(8)}${'Count'.padEnd(14)}${'Pct%'.padEnd(12)}${'Product'.padEnd(22)}${'LogProd'.padEnd(22)}${'log-Œ∂%'.padEnd(16)}${'Cumulative'.padEnd(22)}RelErr%
${'‚îÄ'.repeat(120)}
`;
  let cum=1;
  d.gaps.forEach(g=>{
    const gp=d.gapProducts[g]; if(!gp) return;
    cum*=gp.product;
    const relErr=Math.abs(cum-d.target)/d.target*100;
    const logShare=gp.logProduct/(d.totalLog||1)*100;
    const pct=gp.count/(d.primes.length||1)*100;
    txt+=`${(''+g).padEnd(8)}${gp.count.toString().padEnd(14)}${pct.toFixed(6).padEnd(12)}${gp.product.toFixed(12).padEnd(22)}${gp.logProduct.toFixed(12).padEnd(22)}${logShare.toFixed(6).padEnd(16)}${cum.toFixed(12).padEnd(22)}${relErr.toFixed(10)}\n`;
  });
  txt+=`\n${'‚ïê'.repeat(60)}\n`;
  const blob=new Blob([txt],{type:'text/plain'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob); a.download=`gap_decomp_report_N${d.maxN}_s${d.s.toFixed(2)}.txt`;
  a.click();
}

function csvDownload(csv, filename){
  const blob=new Blob([csv],{type:'text/csv'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob); a.download=filename; a.click();
}

// ‚îÄ‚îÄ Section / Canvas Screenshot helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// screenshotCanvas: save a canvas element directly as PNG
function screenshotCanvas(canvas, filename){
  if(!canvas || canvas.width===0) return;
  const a = document.createElement('a');
  a.href = canvas.toDataURL('image/png');
  a.download = (filename||'screenshot') + '.png';
  a.click();
}

// screenshotSection: render an HTML element to canvas via html2canvas-like approach
// Uses the DOM element, draws a dark background, then captures to PNG.
function screenshotSection(elementId, filename){
  const el = document.getElementById(elementId);
  if(!el) return;

  // We use a temporary offscreen approach: clone into a styled wrapper,
  // then use the browser's built-in screenshot via a blob URL in an <img>.
  // For table/stats DOM nodes we create a styled SVG foreignObject snapshot.
  const rect = el.getBoundingClientRect();
  const W = Math.max(rect.width, 400);
  const H = Math.max(rect.height, 100);

  const cv = document.createElement('canvas');
  cv.width = Math.ceil(W * window.devicePixelRatio);
  cv.height = Math.ceil(H * window.devicePixelRatio);
  const ctx = cv.getContext('2d');
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

  // Serialize the element + computed styles into an SVG foreignObject
  // (works cross-browser for DOM snapshots)
  const clone = el.cloneNode(true);
  // Apply dark background
  clone.style.background = '#0e1119';
  clone.style.padding = '16px';
  clone.style.boxSizing = 'border-box';
  clone.style.width = W + 'px';

  // Inline critical computed styles for tables
  el.querySelectorAll('*').forEach((node, i) => {
    const cs = window.getComputedStyle(node);
    const cloneNode = clone.querySelectorAll('*')[i];
    if(cloneNode && node.tagName.match(/^(TD|TH|TR|TABLE|THEAD|TBODY|DIV|SPAN)$/)){
      cloneNode.style.color = cs.color;
      cloneNode.style.background = cs.backgroundColor;
      cloneNode.style.fontSize = cs.fontSize;
      cloneNode.style.fontFamily = cs.fontFamily;
      cloneNode.style.padding = cs.padding;
      cloneNode.style.border = cs.border;
      cloneNode.style.borderBottom = cs.borderBottom;
      cloneNode.style.fontWeight = cs.fontWeight;
    }
  });

  const xml = new XMLSerializer().serializeToString(
    (() => {
      const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.setAttribute('xmlns','http://www.w3.org/2000/svg');
      svg.setAttribute('xmlns:xhtml','http://www.w3.org/1999/xhtml');
      svg.setAttribute('width', W);
      svg.setAttribute('height', H);
      const fo = document.createElementNS('http://www.w3.org/2000/svg','foreignObject');
      fo.setAttribute('width', W);
      fo.setAttribute('height', H);
      fo.appendChild(clone);
      svg.appendChild(fo);
      return svg;
    })()
  );

  const img = new Image();
  const blob = new Blob([xml], {type:'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  img.onload = () => {
    ctx.fillStyle = '#0e1119';
    ctx.fillRect(0, 0, W, H);
    ctx.drawImage(img, 0, 0, W, H);
    URL.revokeObjectURL(url);
    const a = document.createElement('a');
    a.href = cv.toDataURL('image/png');
    a.download = (filename||'gap_section') + '.png';
    a.click();
  };
  img.onerror = () => {
    URL.revokeObjectURL(url);
    // Fallback: just screenshot the chart canvas
    screenshotCanvas(document.getElementById('gdChartBig'), filename);
  };
  img.src = url;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  HARMONICS MODULE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Farey harmonic intervals: {ratio, name, p, q} where ratio=p/q
const HARM_INTERVALS = [
  { name:'1:1',   p:1,  q:1,  cents:0 },
  { name:'16:15', p:16, q:15, cents:112 },
  { name:'9:8',   p:9,  q:8,  cents:204 },
  { name:'6:5',   p:6,  q:5,  cents:316 },
  { name:'5:4',   p:5,  q:4,  cents:386 },
  { name:'4:3',   p:4,  q:3,  cents:498 },
  { name:'45:32', p:45, q:32, cents:590 },
  { name:'3:2',   p:3,  q:2,  cents:702 },
  { name:'8:5',   p:8,  q:5,  cents:814 },
  { name:'5:3',   p:5,  q:3,  cents:884 },
  { name:'9:5',   p:9,  q:5,  cents:1018 },
  { name:'15:8',  p:15, q:8,  cents:1088 },
  { name:'2:1',   p:2,  q:1,  cents:1200 },
  { name:'5:2',   p:5,  q:2,  cents:1586 },
  { name:'3:1',   p:3,  q:1,  cents:1902 },
  { name:'4:1',   p:4,  q:1,  cents:2400 },
];

function harmConsonanceColor(p, q){
  const tenney = p * q;
  if(p===1&&q===1) return '#22c55e';
  if(tenney<=4) return '#60a5fa';
  if(tenney<=16) return '#ffd700';
  if(tenney<=64) return '#f97316';
  return '#a855f7';
}

let harmSelectedIntervals = new Set(); // indices into HARM_INTERVALS
let harmCurrentIntervalIndex = 0; // Current interval being played in sequence
let harmColorMode = false;
let harmArnoldK = 0;
let harmBaseArnold = 0; // store original to reset

let audioCtx = null;
let harmOscillators = [];

function harmGetCtx(){
  if(!audioCtx) audioCtx = new(window.AudioContext||window.webkitAudioContext)();
  if(audioCtx.state==='suspended') audioCtx.resume();
  return audioCtx;
}

function harmStop(){
  harmSyncStop();
  harmOscillators.forEach(o=>{ try{o.stop();}catch(e){} });
  harmOscillators=[];
  ['harmPlayBtn','harmChordBtn','harmArpBtn'].forEach(id=>document.getElementById(id)?.classList.remove('on'));
}

function harmGetBaseHz(){ return parseFloat(document.getElementById('harmBaseHz').value)||220; }
function harmGetVol(){ return parseFloat(document.getElementById('harmVol').value)||0.35; }
function harmGetWave(){ return document.getElementById('harmWave').value||'sine'; }

function harmPlayFreq(hz, duration=1.5){
  const ctx=harmGetCtx();
  const osc=ctx.createOscillator();
  const gain=ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type=harmGetWave(); osc.frequency.value=hz;
  const vol=harmGetVol();
  gain.gain.setValueAtTime(vol, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+duration);
  osc.start(); osc.stop(ctx.currentTime+duration);
  harmOscillators.push(osc);
  return osc;
}

function harmPlay(){
  harmStop();
  const base=harmGetBaseHz();
  const sel=[...harmSelectedIntervals];
  if(!sel.length){ harmPlayFreq(base); return; }
  const iv=HARM_INTERVALS[sel[sel.length-1]];
  harmPlayFreq(base * iv.p / iv.q);
  document.getElementById('harmPlayBtn').classList.add('on');
}

function harmChord(){
  harmStop();
  const base=harmGetBaseHz();
  const sel=[...harmSelectedIntervals];
  if(!sel.length) sel.push(0);
  sel.forEach(idx=>{
    const iv=HARM_INTERVALS[idx];
    harmPlayFreq(base*iv.p/iv.q, 2.0);
  });
  document.getElementById('harmChordBtn').classList.add('on');
}

function harmArp(){
  harmStop();
  const base=harmGetBaseHz();
  const sel=[...harmSelectedIntervals];
  if(!sel.length) sel.push(0);
  const ctx=harmGetCtx();
  sel.forEach((idx,i)=>{
    const iv=HARM_INTERVALS[idx];
    const hz=base*iv.p/iv.q;
    const osc=ctx.createOscillator();
    const gain=ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    osc.type=harmGetWave(); osc.frequency.value=hz;
    const t=ctx.currentTime+i*0.35;
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(harmGetVol(), t+0.05);
    gain.gain.exponentialRampToValueAtTime(0.0001, t+0.6);
    osc.start(t); osc.stop(t+0.65);
    harmOscillators.push(osc);
  });
  document.getElementById('harmArpBtn').classList.add('on');
}

function noteFromHz(hz){
  const notes=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const n=Math.round(12*Math.log2(hz/440))+69;
  if(n<0||n>127) return '‚Äî';
  return notes[n%12]+(Math.floor(n/12)-1);
}

function buildHarmIntervalGrid(){
  const grid=document.getElementById('harmIntervalGrid');
  grid.innerHTML='';
  HARM_INTERVALS.forEach((iv,i)=>{
    const col=harmConsonanceColor(iv.p,iv.q);
    const btn=document.createElement('button');
    btn.className='harm-interval-btn';
    btn.style.borderColor=col+'55';
    btn.style.color=col+'aa';
    btn.innerHTML=iv.name;
    btn.title=`${iv.name} ¬∑ ${iv.cents}¬¢ ¬∑ Tenney height: ${iv.p*iv.q}`;
    btn.onclick=()=>toggleHarmInterval(i,btn,iv,col);
    grid.appendChild(btn);
  });
}

function toggleHarmInterval(i, btn, iv, col){
  if(harmSelectedIntervals.has(i)){
    harmSelectedIntervals.delete(i);
    btn.classList.remove('active');
    btn.style.background='';
    btn.style.color=col+'aa';
  } else {
    harmSelectedIntervals.add(i);
    btn.classList.add('active');
    btn.style.background=col;
    btn.style.color='#000';
  }
  updateHarmDisplay();
  if(harmColorMode) precompute(); // recolor sphere
}

function updateHarmDisplay(){
  const sel=[...harmSelectedIntervals];
  if(!sel.length){
    document.getElementById('harmFreqDisplay').textContent='‚Äî Hz';
    document.getElementById('harmNoteDisplay').textContent='‚Äî ¬∑ ‚Äî';
    return;
  }
  const last=HARM_INTERVALS[sel[sel.length-1]];
  const base=harmGetBaseHz();
  const hz=base*last.p/last.q;
  document.getElementById('harmFreqDisplay').textContent=hz.toFixed(2)+' Hz';
  document.getElementById('harmNoteDisplay').textContent=last.name+' ¬∑ '+noteFromHz(hz);
}

// Arnold tongue warp: perturb the sphere rendering with K¬∑sin(2œÄ¬∑ratio)
function applyArnoldWarp(){
  harmArnoldK=parseFloat(document.getElementById('harmArnold').value)||0;
  precompute(); // rebuilds precomputed with warp applied
}
function resetArnold(){
  harmArnoldK=0;
  document.getElementById('harmArnold').value=0;
  document.getElementById('harmArnoldVal').textContent='0.00';
  precompute();
}

// Harmonic color mode: sphere hue based on consonance of selected intervals
// The trail hue cycles through the consonance colors of selected intervals
function harmColorForProgress(frac){
  const sel=[...harmSelectedIntervals];
  if(!sel.length) return null;
  // Cycle through selected intervals by position on curve
  const idx=Math.floor(frac*sel.length)%sel.length;
  const iv=HARM_INTERVALS[sel[idx]];
  return harmConsonanceColor(iv.p,iv.q);
}

// Hook into precompute to apply Arnold warp if K>0
const _origPrecompute = precompute;
// We'll re-override toSphere to apply warp
const _origToSphere = toSphere;

function toSphereWarped(t, r){
  let lon = t;
  if(harmArnoldK > 0){
    // Arnold circle map perturbation: lon += K¬∑sin(2œÄ¬∑lon/(2œÄ))
    lon = t + harmArnoldK * Math.sin(t);
  }
  const polar = (t / thetaTotal) * Math.PI;
  const rn = r / (A + 1.2);
  const x = rn * Math.sin(polar) * Math.cos(lon);
  const y = rn * Math.cos(polar);
  const z = rn * Math.sin(polar) * Math.sin(lon);
  return [x, y, z];
}

// Patch toSphere globally
// (call toSphereWarped from precompute instead of toSphere)

// Harmonic color panel ‚Äî always open in dashboard layout (no toggle needed)

document.getElementById('harmColorMode').addEventListener('change',function(){
  harmColorMode=this.checked;
  document.getElementById('harmModeState').textContent=harmColorMode
    ?'on ‚Äî sphere colored by harmonic consonance'
    :'off ‚Äî sphere uses default colors';
  precompute();
});

document.getElementById('harmBaseHz').addEventListener('input',function(){
  document.getElementById('harmBaseHzVal').textContent=this.value+' Hz';
  updateHarmDisplay();
});
document.getElementById('harmVol').addEventListener('input',function(){
  document.getElementById('harmVolVal').textContent=Math.round(this.value*100)+'%';
});
document.getElementById('harmArnold').addEventListener('input',function(){
  document.getElementById('harmArnoldVal').textContent=parseFloat(this.value).toFixed(2);
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  HARMONIC SYNC ENGINE  (real-time lookahead scheduler)
//
//  Mode A ‚Äî Gap OFF (pure wave):
//    Pitch follows f(Œ∏) at the current draw cursor in real time.
//    base_hz * (normalized f value 0.5..2.0) gives a melodic contour
//    that literally traces the wave shape as sound.
//
//  Mode B ‚Äî Gap ON (gap-aware):
//    The gap family at the current draw position determines:
//      ‚Ä¢ Root pitch: smaller gaps (twin primes g=2) ‚Üí higher consonant tones
//        Larger gaps ‚Üí lower, more dissonant, denser harmonics
//      ‚Ä¢ Timbre: gap families get distinct waveforms
//        g=2: sine (pure)   g=4: triangle   g=6: sawtooth   g‚â•8: square
//      ‚Ä¢ Density: common gaps play more quietly; rare large gaps accent
//
//  Scheduler pattern: every animation frame, schedule ~100ms of audio
//  ahead using Web Audio's currentTime as the reference clock.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

let harmSyncNodes = [];
let harmSyncScheduledUntil = 0;  // ctx.currentTime already scheduled up to
let harmSyncLastPtIdx = -1;      // last drawProgress index scheduled
let harmSyncActive = false;
const LOOKAHEAD_SEC  = 0.12;     // how far ahead to schedule each frame
const NOTE_DUR_BASE  = 0.18;     // base note duration (seconds)

function harmSyncStop(){
  harmSyncActive = false;
  harmSyncScheduledUntil = 0;
  harmSyncLastPtIdx = -1;
  harmSyncNodes.forEach(n=>{ try{n.stop();}catch(e){} });
  harmSyncNodes = [];
  ['harmPlayBtn','harmChordBtn','harmArpBtn'].forEach(id=>{
    const el=document.getElementById(id);
    if(el) el.classList.remove('on');
  });
}

function harmSyncPause(){ harmSyncStop(); }

function harmSyncStart(){
  if(!harmSyncEnabled) return; // respect the on/off toggle
  harmSyncStop();
  const ctx = harmGetCtx();
  if(ctx.state==='suspended') ctx.resume();
  harmSyncActive = true;
  harmSyncScheduledUntil = ctx.currentTime;
  harmSyncLastPtIdx = Math.floor(drawProgress) - 1;
}

// Called every animation frame when harmSyncActive and not paused
function harmSyncTick(){
  if(!harmSyncEnabled || !harmSyncActive || paused) return;
  const ctx = harmGetCtx();
  if(ctx.state==='suspended') ctx.resume();

  const now = ctx.currentTime;
  const scheduleUpTo = now + LOOKAHEAD_SEC;
  if(harmSyncScheduledUntil >= scheduleUpTo) return; // already ahead

  const base   = harmGetBaseHz();
  const vol    = harmGetVol();
  const sel    = [...harmSelectedIntervals];
  const gapOn  = document.getElementById('gapChannelOn')?.checked && gdData;

  // pts per second at current speed (~60fps assumed)
  const ptsPerSec  = speed * 60;
  // time per point in seconds
  const secPerPt   = ptsPerSec > 0 ? 1 / ptsPerSec : 0.001;

  // Figure out which point index corresponds to harmSyncScheduledUntil
  // ctx time ‚Üí drawProgress offset ‚Üí point index
  const ptAtScheduled = Math.floor(drawProgress +
    (harmSyncScheduledUntil - now) * ptsPerSec);

  const ptAtHorizon = Math.floor(drawProgress +
    (scheduleUpTo - now) * ptsPerSec);

  // Note density: one note per N points (target ~8‚Äì12 notes/sec)
  const noteEveryPts = Math.max(1, Math.floor(ptsPerSec / 10));

  for(let pi = Math.max(harmSyncLastPtIdx + 1, ptAtScheduled);
         pi <= ptAtHorizon && pi < TOTAL_PTS;
         pi += noteEveryPts){

    if(pi <= harmSyncLastPtIdx) continue;
    harmSyncLastPtIdx = pi;

    // Time this note should start in ctx time
    const ptDelta = pi - Math.floor(drawProgress);
    const tNote   = now + ptDelta * secPerPt;
    if(tNote < now - 0.01) continue; // in the past
    if(tNote > now + LOOKAHEAD_SEC + 0.05) break;

    // Get f(Œ∏) value at this point
    const fval = precomputed[pi] ? f((pi / TOTAL_PTS) * thetaTotal) : (A || 1);
    // Normalize fval to 0..1 using precomputed min/max
    const fNorm = (fMax > fMin) ? (fval - fMin) / (fMax - fMin) : 0.5;

    let freq, waveType, noteVol, noteDur;

    if(!gapOn){
      // ‚îÄ‚îÄ MODE A: Musical harmonic intervals following wave contour ‚îÄ‚îÄ
      // Each selected interval gets its own "zone" in the wave
      // Within each zone, pitch modulates with f(Œ∏) for expressiveness
      
      if(sel.length > 0){
        // Determine which interval zone we're in
        const zoneSize = TOTAL_PTS / sel.length;
        const zoneIndex = Math.floor(pi / zoneSize) % sel.length;
        const intervalIdx = sel[zoneIndex];
        const interval = HARM_INTERVALS[intervalIdx];
        
        // Base frequency for this interval
        const intervalFreq = base * (interval.p / interval.q);
        
        // Modulate slightly with f(Œ∏) value for musical expression
        // ¬±12% range (about ¬±2 semitones) for subtle pitch bending
        const bendRange = 0.12;
        const bend = 1 + (fNorm - 0.5) * bendRange;
        freq = intervalFreq * bend;
        
        // Volume follows wave amplitude for dynamics
        noteVol = vol * (0.5 + 0.5 * fNorm);
        
      } else {
        // No intervals selected - play base frequency with wide range
        const octaveRange = 1.5;
        freq = base * Math.pow(2, (fNorm - 0.5) * octaveRange);
        noteVol = vol * (0.4 + 0.6 * fNorm);
      }

      waveType = harmGetWave();
      noteDur  = NOTE_DUR_BASE;

    } else {
      // ‚îÄ‚îÄ MODE B: gap-aware ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const gapVal = (precomputed[pi] && precomputed[pi][4]) ? precomputed[pi][4] : 2;

      // Pitch: smaller gaps ‚Üí higher, more consonant
      // g=2 maps to base*2, g=4‚Üíbase*1.5, g=6‚Üíbase*1.25, larger‚Üílower
      const gapPitchMap = {
        2:  base * 2,
        4:  base * 1.5,
        6:  base * 1.25,
        8:  base * 1.0,
        10: base * 0.9,
        12: base * 0.8,
        14: base * 0.75,
        18: base * 0.667,
        24: base * 0.6,
        30: base * 0.5,
      };
      freq = gapPitchMap[gapVal] || base * Math.max(0.4, 2 / Math.max(1, Math.log2(gapVal)));

      // Also modulate by f(Œ∏) value within the gap tier (¬±quarter tone)
      freq *= Math.pow(2, (fNorm - 0.5) * 0.25);

      // Timbre: gap family ‚Üí waveform
      if      (gapVal <= 2)  waveType = 'sine';
      else if (gapVal <= 4)  waveType = 'triangle';
      else if (gapVal <= 6)  waveType = 'sawtooth';
      else if (gapVal <= 12) waveType = 'square';
      else                   waveType = 'sawtooth';

      // Volume: selected gaps accent loudly; common small gaps quieter
      const isSelected = selectedGaps.has(gapVal);
      const rarity = Math.min(1, Math.log2(gapVal) / 6); // rarer = louder accent
      noteVol  = vol * (isSelected ? 0.9 : 0.25 + rarity * 0.35);

      // Duration: large rare gaps get longer notes (they're dramatic)
      noteDur  = NOTE_DUR_BASE * (1 + rarity * 1.5);
    }

    // Clamp freq to audible range
    freq = Math.max(55, Math.min(4400, freq));

    scheduleNote(ctx, freq, waveType, noteVol, noteDur, tNote);
    harmSyncScheduledUntil = tNote + noteDur;
  }

  // Clean up finished nodes
  if(harmSyncNodes.length > 200){
    harmSyncNodes = harmSyncNodes.filter(n => {
      try { return n.context.state !== 'closed'; } catch(e){ return false; }
    });
  }
}

function scheduleNote(ctx, freq, waveType, vol, dur, startTime){
  const osc  = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type = waveType;
  osc.frequency.setValueAtTime(freq, startTime);
  gain.gain.setValueAtTime(0.0001, startTime);
  gain.gain.linearRampToValueAtTime(vol, startTime + dur * 0.15);
  gain.gain.exponentialRampToValueAtTime(0.0001, startTime + dur);
  osc.start(startTime);
  osc.stop(startTime + dur + 0.02);
  harmSyncNodes.push(osc);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ZOOM & PAN
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let zoomLevel = 1.0;
let panX = 0, panY = 0;
let isPan = false, panStartX=0, panStartY=0, panStartPX=0, panStartPY=0;

function setZoom(z){
  zoomLevel = Math.max(0.15, Math.min(10, z));
  document.getElementById('zoomLbl').textContent = zoomLevel.toFixed(1)+'√ó';
}

document.getElementById('btnZoomIn').addEventListener('click', ()=>{ onUserInteraction(); setZoom(zoomLevel*1.25); });
document.getElementById('btnZoomOut').addEventListener('click', ()=>{ onUserInteraction(); setZoom(zoomLevel/1.25); });
document.getElementById('btnZoomReset').addEventListener('click', ()=>{ setZoom(1); panX=0; panY=0; });

// Mouse-wheel zoom on canvas
pCv.addEventListener('wheel', e=>{
  e.preventDefault();
  setZoom(zoomLevel * (e.deltaY < 0 ? 1.12 : 1/1.12));
}, { passive:false });

// Pinch-to-zoom
let lastPinchDist = null;
pCv.addEventListener('touchstart', e=>{
  if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    lastPinchDist=Math.sqrt(dx*dx+dy*dy);
  }
},{passive:true});
pCv.addEventListener('touchmove', e=>{
  if(e.touches.length===2 && lastPinchDist!==null){
    e.preventDefault();
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    const d=Math.sqrt(dx*dx+dy*dy);
    setZoom(zoomLevel*(d/lastPinchDist));
    lastPinchDist=d;
  }
},{passive:false});
pCv.addEventListener('touchend',()=>{ lastPinchDist=null; });

// Shift+drag = pan
pCv.addEventListener('mousedown', e=>{
  if(e.shiftKey){
    isPan=true; pCv.style.cursor='move';
    panStartX=e.clientX; panStartY=e.clientY;
    panStartPX=panX; panStartPY=panY;
    e.stopImmediatePropagation();
  }
}, true);
window.addEventListener('mousemove', e=>{
  if(isPan){ panX=panStartPX+(e.clientX-panStartX); panY=panStartPY+(e.clientY-panStartY); }
});
window.addEventListener('mouseup', ()=>{ isPan=false; pCv.style.cursor=''; });

// Override proj() to incorporate zoom + pan
function proj(rx, ry, rz){
  const fov=2.8, scale=fov/(fov-rz);
  const R=pCv.width*0.37*zoomLevel;
  return [pCv.width/2 + rx*R*scale + panX, pCv.height/2 - ry*R*scale + panY];
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CART CANVAS ‚Äî CLICK TO PROBE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let cartProbeIdx = -1;   // precomputed index of probed point
let cartProbePx  = -1;   // pixel X of probe line

function cartCanvasClick(e) {
  const rect = cCv.getBoundingClientRect();
  const px   = (e.clientX - rect.left) * (cCv.width / rect.width);
  const {l, r: pr, t: pt, b} = PAD;
  const pw = cCv.width - l - pr;

  if (px < l || px > cCv.width - pr) return; // outside plot area

  const frac = (px - l) / pw;
  const idx  = Math.min(TOTAL_PTS - 1, Math.max(0, Math.round(frac * TOTAL_PTS)));

  // Only probe drawn region
  if (idx > Math.floor(drawProgress)) return;

  cartProbeIdx = idx;
  cartProbePx  = px;
  updateCartProbe();
}

function updateCartProbe() {
  if (cartProbeIdx < 0) return;
  const i   = cartProbeIdx;
  const t   = (i / TOTAL_PTS) * thetaTotal;
  const rv  = f(t);
  const [cx, cy] = cartXY(t, rv);

  // ‚îÄ‚îÄ Draw crosshair overlay ‚îÄ‚îÄ
  renderCart(); // redraw base
  const ctx = cCtx;
  // Vertical probe line
  ctx.save();
  ctx.strokeStyle = 'rgba(91,156,246,.7)';
  ctx.lineWidth = 1;
  ctx.setLineDash([4, 3]);
  const {l, r: pr, t: pt, b} = PAD;
  ctx.beginPath();
  ctx.moveTo(cx, pt);
  ctx.lineTo(cx, cCv.height - b);
  ctx.stroke();
  ctx.setLineDash([]);

  // Dot on curve
  ctx.beginPath();
  ctx.arc(cx, cy, 5, 0, Math.PI * 2);
  ctx.fillStyle = '#5b9cf6';
  ctx.shadowColor = '#5b9cf6';
  ctx.shadowBlur = 10;
  ctx.fill();
  ctx.shadowBlur = 0;

  // Œ∏ label on axis
  ctx.fillStyle = 'rgba(91,156,246,.85)';
  ctx.font = `${Math.max(8, cCv.width * 0.018)}px JetBrains Mono,monospace`;
  ctx.textAlign = cx > cCv.width * 0.75 ? 'right' : 'left';
  ctx.textBaseline = 'top';
  const thetaLabel = `Œ∏=${(t/Math.PI).toFixed(3)}œÄ`;
  ctx.fillText(thetaLabel, cx + (ctx.textAlign === 'left' ? 6 : -6), cCv.height - b + 2);
  ctx.restore();

  // ‚îÄ‚îÄ Probe detail panel ‚îÄ‚îÄ
  const panel    = document.getElementById('cartProbePanel');
  const grid     = document.getElementById('cartProbeGrid');
  const gapSec   = document.getElementById('cartProbeGap');
  const gapDet   = document.getElementById('cartProbeGapDetail');
  const sphHint  = document.getElementById('cartProbeSphereHint');

  panel.style.display = 'block';

  const pc = precomputed[i];
  const gapVal = pc ? pc[4] : null;
  const hue = 295 + (i / TOTAL_PTS) * 40;
  const ptColor = gapVal && selectedGaps.has(gapVal)
    ? selectedGaps.get(gapVal)
    : `hsl(${hue},100%,62%)`;

  const primeIdx = pc ? Math.round((i / TOTAL_PTS) * (gdData ? gdData.primes.length - 1 : 0)) : 0;
  const nearPrime = gdData ? gdData.primes[primeIdx] : null;

  const cells = [
    { lbl: 'Œ∏',        val: `${(t / Math.PI).toFixed(5)}œÄ` },
    { lbl: 'f(Œ∏)',     val: rv.toFixed(6) },
    { lbl: 'progress', val: `${((i / TOTAL_PTS) * 100).toFixed(2)}%` },
    { lbl: 'pt index', val: i.toLocaleString() },
    { lbl: 'hue',      val: `${Math.round(hue)}¬∞` },
    { lbl: 'near prime', val: nearPrime ? nearPrime.toLocaleString() : '‚Äî' },
  ];

  grid.innerHTML = cells.map(c =>
    `<div style="font-family:'JetBrains Mono',monospace;">
       <div style="font-size:.42rem;text-transform:uppercase;letter-spacing:.15em;color:rgba(150,175,200,.4);margin-bottom:1px">${c.lbl}</div>
       <div style="font-size:.65rem;color:${ptColor}">${c.val}</div>
     </div>`
  ).join('');

  // Gap section
  if (gapVal && gdData) {
    gapSec.style.display = 'block';
    const gp = gdData.gapProducts[gapVal];
    const gCol = gapVal ? gapColor(gapVal, gdData.gaps.indexOf(gapVal)) : '#aaa';
    const share = gp ? ((gp.logProduct / gdData.totalLog) * 100).toFixed(4) : '‚Äî';
    const cnt   = gp ? gp.count.toLocaleString() : '‚Äî';
    gapDet.innerHTML =
      `<span style="color:${gCol}">g = ${gapVal}</span>  ` +
      `count = ${cnt}  ¬∑  log-Œ∂ share = ${share}%<br>` +
      `<span style="color:rgba(200,180,120,.5);font-size:.52rem">` +
      `This Œ∏ falls in a region where consecutive primes differ by ${gapVal}. ` +
      `The gap family g=${gapVal} contributes ${share}% of Œ∂(${gdData.s.toFixed(2)}) via Euler product.</span>`;
  } else if (gdData && !gapVal) {
    gapSec.style.display = 'block';
    gapDet.innerHTML = `<span style="color:rgba(200,180,120,.4);font-size:.52rem">No gap data for this point. Run Compute with a larger N to cover this Œ∏ range.</span>`;
  } else {
    gapSec.style.display = 'none';
  }

  // Sphere highlight
  highlightSphereProbe(i);
  sphHint.style.display = 'block';
}

// Highlight the probed point on the 3D sphere with a bright flash dot
let probeFlashFrame = 0;
function highlightSphereProbe(idx) {
  probeFlashFrame = 12;
  _probeIdx = idx;
}
let _probeIdx = -1;

// Called inside renderSphere() at the very end
function drawProbeFlash(ctx, w) {
  if (probeFlashFrame <= 0 || _probeIdx < 0) return;
  probeFlashFrame--;
  const pt = precomputed[_probeIdx];
  if (!pt) return;
  const [rx, ry, rz] = applyM(rotMat, pt[0], pt[1], pt[2]);
  if (rz < 0) return; // behind sphere
  const scale = w * 0.38;
  const cx    = w / 2 + rx * scale;
  const cy    = w / 2 - ry * scale;
  const alpha = probeFlashFrame / 12;
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, 9, 0, Math.PI * 2);
  ctx.fillStyle = `rgba(91,156,246,${alpha})`;
  ctx.shadowColor = '#5b9cf6';
  ctx.shadowBlur = 24;
  ctx.fill();
  ctx.strokeStyle = `rgba(255,255,255,${alpha * 0.8})`;
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.restore();
}

// Keep probe dot alive (re-highlight each second if panel open)
function keepProbeAlive() {
  if (cartProbeIdx >= 0 && document.getElementById('cartProbePanel').style.display !== 'none') {
    probeFlashFrame = 6;
    _probeIdx = cartProbeIdx;
  }
  setTimeout(keepProbeAlive, 800);
}
setTimeout(keepProbeAlive, 800);

function clearCartProbe() {
  cartProbeIdx = -1;
  cartProbePx  = -1;
  _probeIdx = -1;
  probeFlashFrame = 0;
  document.getElementById('cartProbePanel').style.display = 'none';
  renderCart(); // remove crosshair
}

cCv.addEventListener('click', cartCanvasClick);
cCv.addEventListener('mousemove', e => {
  // Hover: show crosshair cursor in plot area
  const rect = cCv.getBoundingClientRect();
  const px = (e.clientX - rect.left) * (cCv.width / rect.width);
  const { l, r: pr } = PAD;
  cCv.style.cursor = (px >= l && px <= cCv.width - pr) ? 'crosshair' : 'default';
});

// Show the connection explainer once gap data is available
function showCartGapRelation() {
  const el = document.getElementById('cartGapRelation');
  const txt = document.getElementById('cartGapRelationText');
  if (!gdData || !el) return;
  const N = gdData.primes.length.toLocaleString();
  const s = gdData.s.toFixed(2);
  txt.innerHTML =
    `Each point on this wave corresponds to a specific Œ∏ value.<br>` +
    `Œ∏ is mapped proportionally to a prime index across ${N} primes.<br>` +
    `The prime gap at that index (p[i+1]‚àíp[i]) assigns a <b>gap family</b>.<br>` +
    `Selecting a gap (g=2 twins, g=4 cousins‚Ä¶) colors the sphere arcs<br>` +
    `where those primes live ‚Äî revealing how prime structure rhythmically<br>` +
    `deforms the shape of f(Œ∏).<br>` +
    `<span style="color:rgba(232,197,71,.6)">Œ∂(${s}) = Œ£ gap contributions via Euler product factorization.</span>`;
  el.style.display = 'block';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  KEYBOARD SHORTCUTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
document.addEventListener('keydown', e=>{
  if(['INPUT','SELECT','TEXTAREA'].includes(e.target.tagName)) return;
  switch(e.code){
    case 'Space':
      e.preventDefault();
      document.getElementById('btnPlay').click();
      break;
    case 'KeyR':
      autoRotate=!autoRotate;
      document.getElementById('btnAutoRot').classList.toggle('on',autoRotate);
      document.getElementById('btnAutoRot').textContent=autoRotate?'‚ü≥ Rotating...':'‚ü≥ Rotate';
      break;
    case 'KeyS':
      exportSphere4K();
      break;
    case 'KeyF':
      e.preventDefault();
      toggleFullscreen();
      break;
    case 'ArrowUp':
      e.preventDefault(); setZoom(zoomLevel*1.1); break;
    case 'ArrowDown':
      e.preventDefault(); setZoom(zoomLevel/1.1); break;
    case 'ArrowLeft':
      rotMat=mmul(mrotY(-0.08),rotMat); break;
    case 'ArrowRight':
      rotMat=mmul(mrotY(0.08),rotMat); break;
    case 'Escape':
      setZoom(1); panX=0; panY=0;
      rotMat=[1,0,0,0,1,0,0,0,1];
      break;
  }
});


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  COORDINATE SYSTEM MODES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let coordMode = 'polar';
let coordBlend = 1.0;

const COORD_DESCS = {
  polar:       'Traditional polar/spherical ‚Äî f(Œ∏) mapped onto sphere surface.',
  logcylinder: 'Log-Cylinder: u = ln(Œ∏+1), v = f(Œ∏). Compresses the Œ∏ axis logarithmically, revealing fine structure near origin.',
  logspiral:   'Logarithmic Spiral: radius grows as e^(f(Œ∏)/A), angle = Œ∏. Creates an outward unwinding helix on the sphere.',
  poincare:    'Poincar√© Disk (hyperbolic): maps sphere points through the unit-disk model. Distances compress toward the boundary.'
};

// Coord mode panel ‚Äî always open in dashboard layout

document.getElementById('coordModeGrid').addEventListener('click', e=>{
  const btn=e.target.closest('.coord-mode-btn');
  if(!btn) return;
  onUserInteraction();
  coordMode=btn.dataset.mode;
  document.querySelectorAll('.coord-mode-btn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  document.getElementById('coordModeDesc').textContent=COORD_DESCS[coordMode];
  precompute();
});

document.getElementById('coordBlend').addEventListener('input',function(){
  coordBlend=parseFloat(this.value);
  document.getElementById('coordBlendVal').textContent=Math.round(coordBlend*100)+'%';
  precompute();
});

// Override toSphere to apply coordinate mode transform
function toSphere(t, r){
  // Default polar
  const lon=t;
  const polar=(t/thetaTotal)*Math.PI;
  const rn=r/(A+1.2);
  const px=rn*Math.sin(polar)*Math.cos(lon);
  const py=rn*Math.cos(polar);
  const pz=rn*Math.sin(polar)*Math.sin(lon);
  if(coordMode==='polar' || coordBlend===0) return [px,py,pz];

  let tx=px, ty=py, tz=pz;

  if(coordMode==='logcylinder'){
    const u=Math.log(t+1)/Math.log(thetaTotal+1); // 0‚Üí1
    const v=r/(A+1.2);
    const lon2=u*Math.PI*2;
    tx=v*Math.cos(lon2); ty=(u*2-1); tz=v*Math.sin(lon2);
  } else if(coordMode==='logspiral'){
    const spiralR=Math.exp(r/A - 1)*0.6;
    const polar2=(t/thetaTotal)*Math.PI;
    const lon2=t*0.5;
    tx=spiralR*Math.sin(polar2)*Math.cos(lon2);
    ty=spiralR*Math.cos(polar2);
    tz=spiralR*Math.sin(polar2)*Math.sin(lon2);
    // clamp
    const mag=Math.sqrt(tx*tx+ty*ty+tz*tz)||1;
    if(mag>1.2){tx/=mag*0.85;ty/=mag*0.85;tz/=mag*0.85;}
  } else if(coordMode==='poincare'){
    // Project sphere point through Poincar√© disk: disk coords from (px,py,pz)
    const denom=1-pz*0.8;
    const dx=(denom>0.01)?px/denom:px;
    const dy=(denom>0.01)?py/denom:py;
    const dr=Math.sqrt(dx*dx+dy*dy)||1;
    const clamp=Math.min(1,dr)/Math.max(dr,0.001);
    tx=dx*clamp; ty=dy*clamp; tz=pz*0.3;
  }

  // Blend between polar and transformed
  return [
    px*(1-coordBlend)+tx*coordBlend,
    py*(1-coordBlend)+ty*coordBlend,
    pz*(1-coordBlend)+tz*coordBlend
  ];
}

buildHarmIntervalGrid();

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  INIT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Track whether user has interacted yet (for intro‚Üíloop behavior)
let introPlayed = false;
let userHasInteracted = false;

// Track user interaction (loop stays off ‚Äî user controls it manually)
function onUserInteraction(){
  if(userHasInteracted) return;
  userHasInteracted = true;
  // Loop stays as-is; user toggles it themselves
}

// Patch preset buttons, play btn, gap chips, etc. to trigger interaction
(function patchInteractionListeners(){
  // We'll intercept at a high level ‚Äî any click on the page after intro triggers loop
  document.addEventListener('click', function onFirstClick(e){
    // Only activate after intro has started, and ignore the very first auto-play clicks
    if(introPlayed){ onUserInteraction(); }
  }, true);
})();

buildPresets();
hardReset();
loop();

// ‚îÄ‚îÄ Select initial harmonic intervals (octave, fifth, fourth, major third) ‚îÄ‚îÄ
function selectInitialHarmIntervals(){
  const grid = document.getElementById('harmIntervalGrid');
  // Select indices: 0 (2:1 octave), 1 (3:2 fifth), 2 (4:3 fourth), 3 (5:4 major third)
  const initialIndices = [0, 1, 2, 3];
  
  initialIndices.forEach(i => {
    if(i < HARM_INTERVALS.length){
      harmSelectedIntervals.add(i);
      const btn = grid.children[i];
      if(btn){
        const iv = HARM_INTERVALS[i];
        const col = harmConsonanceColor(iv.p, iv.q);
        btn.classList.add('active');
        btn.style.background = col;
        btn.style.color = '#000';
      }
    }
  });
  updateHarmDisplay();
}
selectInitialHarmIntervals();

// ‚îÄ‚îÄ Harmonic Color Mode ON by default ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
harmColorMode = true;
document.getElementById('harmColorMode').checked = true;
document.getElementById('harmModeState').textContent = 'on ‚Äî sphere colored by harmonic consonance';
precompute();

// ‚îÄ‚îÄ Auto-run zeta decomposition with default N=10M ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function autoRunZeta(callback){
  const maxN = 500000; // lighter default so it loads fast
  document.getElementById('gdStatus').textContent = 'Auto-computing prime gaps‚Ä¶';
  document.getElementById('gdRunBtn').disabled = true;
  document.getElementById('gdProgress').style.display = 'block';
  document.getElementById('gdProgressFill').style.width = '0%';

  setTimeout(()=>{
    try {
      const s = parseFloat(document.getElementById('gdS').value);
      const progressCb = (cur, max)=>{
        const pct = Math.min(99,(cur/max*100)).toFixed(0);
        document.getElementById('gdProgressFill').style.width = pct+'%';
        document.getElementById('gdStatus').textContent = `Sieving‚Ä¶ ${pct}%`;
      };

      gdData = gdCompute(maxN, s, 'all', progressCb);

      document.getElementById('gdProgressFill').style.width = '100%';
      setTimeout(()=>document.getElementById('gdProgress').style.display='none', 400);
      document.getElementById('gdStatus').textContent =
        `‚úì Auto-loaded: ${gdData.primes.length.toLocaleString()} primes ¬∑ ${gdData.gaps.length} gap families`;

      updateGdStats();
      ['gdExportPNG','gdExportCSV','gdExportTXT'].forEach(id=>document.getElementById(id).style.display='inline-block');
      document.getElementById('gdTabs').style.display='flex';
      document.getElementById('gdStatsGrid').style.display='grid';

      // Show big chart
      const chartArea = document.getElementById('gdChartArea');
      if(chartArea) chartArea.style.display='block';
      const chartBtn = document.getElementById('gdChartScreenshot');
      if(chartBtn) chartBtn.style.display='inline-block';

      buildGapChips();
      gdBuildTable();
      gdBuildConvTable();
      document.getElementById('gdTableSection').style.display='block';
      document.getElementById('gdConvSection').style.display='block';
      // Do NOT call enableGapChannel or hardReset ‚Äî preserve current draw state
      precompute();
      invalidateCartBuf();
      showCartGapRelation();
      gdResizeCanvas();
      gdDraw();

      // Auto-select gap=2
      if(gdData.gaps.includes(2)){
        const idx = gdData.gaps.indexOf(2);
        const col = gapColor(2, idx);
        selectedGaps.set(2, col);
        document.querySelectorAll('.gap-chip[data-gap="2"]').forEach(chip=>{
          chip.classList.add('selected');
          chip.style.background = col;
          chip.style.borderColor = col;
          chip.style.color = '#000';
        });
        invalidateCartBuf();
      }

    } catch(e){
      document.getElementById('gdStatus').textContent = 'Auto-compute failed: '+e.message;
      console.error(e);
    }
    document.getElementById('gdRunBtn').disabled = false;
    if(callback) callback();
  }, 50);
}



// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ACCORDION TOGGLES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function toggleHarmAccordion(e){
  const body = document.getElementById('harmAccBody');
  const chev = document.getElementById('harmAccChev');
  const hdr  = document.getElementById('harmAccHeader');
  const open = body.classList.toggle('open');
  chev.classList.toggle('open', open);
  hdr.classList.toggle('open', open);
}

function toggleGapAccordion(e){
  const body = document.getElementById('gapAccBody');
  const chev = document.getElementById('gapAccChev');
  const hdr  = document.getElementById('gapAccHeader');
  const open = body.classList.toggle('open');
  chev.classList.toggle('open', open);
  hdr.classList.toggle('open', open);
}

// ‚îÄ‚îÄ Harmonic sound on/off toggle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Separate from the accordion open/close.
// When OFF: stop the sync engine. When ON: start it if playing.
let harmSyncEnabled = false;

function toggleHarmSync(enabled){
  harmSyncEnabled = enabled;
  const state     = document.getElementById('harmSyncState');
  const indicator = document.getElementById('harmModeIndicator');
  if(enabled){
    const gapOn = document.getElementById('gapChannelOn')?.checked && gdData;
    if(state) state.textContent = 'on';
    if(indicator){
      indicator.textContent = gapOn
        ? '¬∑ gap-aware ¬∑ pitch + timbre follow gap families'
        : '¬∑ following f(Œ∏) wave';
      indicator.style.color = gapOn ? 'rgba(232,197,71,.75)' : 'rgba(91,156,246,.6)';
    }
    if(!paused) harmSyncStart();
  } else {
    if(state) state.textContent = 'off';
    if(indicator){ indicator.textContent = '¬∑ sound is off'; indicator.style.color = 'rgba(91,156,246,.35)'; }
    harmSyncStop();
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  GAP CHANNEL ON/OFF TOGGLE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function toggleGapChannel(enabled){
  const gapWavePanel = document.getElementById('gapWavePanel');
  const state = document.getElementById('gapChannelState');
  const indicator = document.getElementById('harmModeIndicator');
  if(enabled && gdData){
    gapWavePanel.classList.remove('gap-hidden');
    if(state) state.textContent = 'on ‚Äî gap chart visible';
    if(indicator) indicator.textContent = '¬∑ gap-aware ¬∑ pitch + timbre follow gap families';
    if(indicator) indicator.style.color = 'rgba(232,197,71,.75)';
  } else {
    gapWavePanel.classList.add('gap-hidden');
    if(state) state.textContent = enabled ? 'compute first to enable' : 'off';
    if(enabled && !gdData){
      const cb = document.getElementById('gapChannelOn');
      if(cb) cb.checked = false;
    }
    if(indicator) indicator.textContent = '¬∑ following f(Œ∏) wave';
    if(indicator) indicator.style.color = 'rgba(91,156,246,.5)';
  }
  // Resize gap canvas without touching sphere/cart canvas (avoids reset)
  gdResizeCanvas();
  invalidateCartBuf();
  if(harmSyncEnabled && !paused){
    harmSyncStart();
  }
}

// Called after gap data loads ‚Äî auto-enable the channel toggle
function enableGapChannel(){
  const cb = document.getElementById('gapChannelOn');
  if(cb){ cb.checked = true; toggleGapChannel(true); }
  // Update mode indicator
  const indicator = document.getElementById('harmModeIndicator');
  if(indicator){
    indicator.textContent = '¬∑ gap-aware ¬∑ pitch + timbre follow gap families';
    indicator.style.color = 'rgba(232,197,71,.75)';
  }
}

// ‚îÄ‚îÄ Welcome / intro sequence ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1. Play the wave once (no loop) as a welcoming animation + sound
// 2. After wave finishes, mark intro done ‚Üí next user action enables loop
function startIntro(){
  // Ensure NOT looping for intro
  looping = false;
  const cbLoop = document.getElementById('cbLoop');
  if(cbLoop) cbLoop.checked = false;
  document.getElementById('loopState').textContent = 'off ‚Äî stops at end';

  // Set a welcoming speed (not too fast, not too slow)
  setSpeed(12);

  // Auto-rotate OFF by default on first load
  autoRotate = false;
  const rotBtn = document.getElementById('btnAutoRot');
  if(rotBtn){ rotBtn.classList.remove('on'); rotBtn.textContent = '‚ü≥ Rotate'; }

  // Start playback immediately ‚Äî gap decomposition runs only when user clicks Compute
  introPlayed = true;
  hardReset();
  paused = false;
  const playBtn = document.getElementById('btnPlay');
  if(playBtn){ playBtn.textContent = '‚è∏ Pause'; playBtn.classList.add('on'); }

  // Play the welcome harmonic sweep (single pass)
  harmSyncStart();
}

// Small delay so DOM is fully ready
setTimeout(startIntro, 300);
</script>
</body>
</html>
