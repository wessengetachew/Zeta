
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BCP Explorer - Boundary Cancellation Principle</title>
    <style>
        body { margin: 0; background: #050505; color: #e0e0e0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; overflow: hidden; display: flex; }
        #sidebar { width: 320px; background: #111; border-right: 1px solid #333; height: 100vh; padding: 20px; box-sizing: border-box; overflow-y: auto; z-index: 10; }
        #canvas-container { flex-grow: 1; position: relative; cursor: crosshair; }
        canvas { display: block; image-rendering: pixelated; }
        h2 { margin-top: 0; color: #4af; font-size: 1.2rem; }
        .control-group { margin-bottom: 20px; }
        label { display: block; font-size: 0.85rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; margin-bottom: 10px; }
        .stats { background: #000; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 0.8rem; border: 1px solid #222; }
        .stat-line { margin-bottom: 5px; display: flex; justify-content: space-between; }
        .stat-val { color: #4af; }
        button { background: #4af; border: none; color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-weight: bold; width: 100%; margin-top: 10px; }
        button:hover { background: #39d; }
        .equation { font-size: 0.8rem; font-style: italic; color: #888; margin-top: 10px; border-left: 2px solid #4af; padding-left: 10px; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>BCP Explorer</h2>
    
    <div class="control-group">
        <label>Radius ($R$): <span id="radius-val">200</span></label>
        <input type="range" id="radius-slider" min="50" max="2000" value="200">
        
        <label>Filter Type:</label>
        <select id="mode-select" style="width:100%; background:#222; color:white; border:1px solid #444; padding:5px;">
            <option value="coprime">Coprime Pairs (gcd(x,y)=1)</option>
            <option value="squarefree">Squarefree x & y</option>
            <option value="kfree">3-free integers (projection)</option>
        </select>
    </div>

    <div class="stats" id="stats-box">
        <div class="stat-line"><span>Points:</span> <span class="stat-val" id="stat-count">0</span></div>
        <div class="stat-line"><span>Density:</span> <span class="stat-val" id="stat-density">0</span></div>
        <div class="stat-line"><span>Theoretical:</span> <span class="stat-val" id="stat-theory">0</span></div>
        <div class="stat-line"><span>Error $E(R)$:</span> <span class="stat-val" id="stat-error">0</span></div>
    </div>

    <div class="equation">
        $E_k(R) \sim R^{k-1}$<br>
        Main Term: $V \cdot \prod (1 - p^{-k})$
    </div>

    <button id="download-png">Export PNG</button>
    <p style="font-size: 0.7rem; color: #666; margin-top: 20px;">
        Scroll to Zoom | Drag to Pan<br>
        Rendering millions of points via Typed Arrays.
    </p>
</div>

<div id="canvas-container">
    <canvas id="mainCanvas"></canvas>
</div>

<script>
/**
 * MATHEMATICAL IMPLEMENTATION: BOUNDARY CANCELLATION PRINCIPLE
 */

const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const radiusSlider = document.getElementById('radius-slider');
const radiusVal = document.getElementById('radius-val');
const modeSelect = document.getElementById('mode-select');

let width, height;
let R = 200;
let scale = 2.0;
let offsetX = 0;
let offsetY = 0;
let isDragging = false;
let lastMouse = { x: 0, y: 0 };

// GCD Algorithm for Coprimality
function gcd(a, b) {
    a = Math.abs(a);
    b = Math.abs(b);
    while (b) { a %= b; [a, b] = [b, a]; }
    return a;
}

// Check if squarefree (no d^2 divides n)
function isSquareFree(n) {
    if (n === 0) return false;
    n = Math.abs(n);
    if (n % 4 === 0) return false;
    for (let i = 3; i * i <= n; i += 2) {
        if (n % (i * i) === 0) return false;
    }
    return true;
}

// Check if k-free (using k=3 here for projection)
function isKFree(n, k) {
    if (n === 0) return false;
    n = Math.abs(n);
    for (let i = 2; Math.pow(i, k) <= n; i++) {
        if (n % Math.pow(i, k) === 0) return false;
    }
    return true;
}

function resize() {
    width = window.innerWidth - 320;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    draw();
}

function draw() {
    const imgData = ctx.createImageData(width, height);
    const data = new Uint32Array(imgData.data.buffer);
    data.fill(0xFF050505); // Background color (ABGR)

    let pointCount = 0;
    const centerX = width / 2 + offsetX;
    const centerY = height / 2 + offsetY;
    const mode = modeSelect.value;

    // Boundary Cancellation Logic: Iterate through the lattice
    for (let x = -R; x <= R; x++) {
        const screenX = Math.round(centerX + x * scale);
        if (screenX < 0 || screenX >= width) continue;

        for (let y = -R; y <= R; y++) {
            const screenY = Math.round(centerY - y * scale);
            if (screenY < 0 || screenY >= height) continue;

            let valid = false;
            let color = 0xFF44AAFF; // Default Blue-ish

            if (mode === 'coprime') {
                if (gcd(x, y) === 1) {
                    valid = true;
                    if (Math.abs(x - y) === 2) color = 0xFF4444FF; // Highlight twin-like offsets
                }
            } else if (mode === 'squarefree') {
                if (isSquareFree(x) && isSquareFree(y)) {
                    valid = true;
                }
            } else if (mode === 'kfree') {
                if (isKFree(x, 3) && isKFree(y, 3)) {
                    valid = true;
                    color = 0xFFAAFF44;
                }
            }

            if (valid) {
                data[screenY * width + screenX] = color;
                pointCount++;
            }
        }
    }

    ctx.putImageData(imgData, 0, 0);
    updateStats(pointCount);
}

function updateStats(count) {
    document.getElementById('stat-count').innerText = count.toLocaleString();
    const totalArea = (2 * R + 1) ** 2;
    const density = count / totalArea;
    document.getElementById('stat-density').innerText = density.toFixed(4);
    
    let theoretical;
    if (modeSelect.value === 'coprime') theoretical = 6 / (Math.PI ** 2);
    else if (modeSelect.value === 'squarefree') theoretical = (6 / (Math.PI ** 2)) ** 2;
    else theoretical = (1 / 1.202) ** 2; // approx 1/zeta(3)^2

    document.getElementById('stat-theory').innerText = theoretical.toFixed(4);
    const error = Math.abs(count - (theoretical * totalArea));
    document.getElementById('stat-error').innerText = error.toFixed(1);
}

// Interaction Listeners
window.addEventListener('resize', resize);
radiusSlider.oninput = (e) => {
    R = parseInt(e.target.value);
    radiusVal.innerText = R;
    draw();
};

modeSelect.onchange = draw;

canvas.onmousedown = (e) => { isDragging = true; lastMouse = { x: e.clientX, y: e.clientY }; };
window.onmouseup = () => isDragging = false;
window.onmousemove = (e) => {
    if (isDragging) {
        offsetX += (e.clientX - lastMouse.x);
        offsetY += (e.clientY - lastMouse.y);
        lastMouse = { x: e.clientX, y: e.clientY };
        draw();
    }
};

canvas.onwheel = (e) => {
    e.preventDefault();
    const zoomSpeed = 0.1;
    scale *= (e.deltaY > 0 ? (1 - zoomSpeed) : (1 + zoomSpeed));
    draw();
};

document.getElementById('download-png').onclick = () => {
    const link = document.createElement('a');
    link.download = 'bcp-lattice.png';
    link.href = canvas.toDataURL();
    link.click();
};

// Initial Start
resize();
</script>
</body>
</html>
