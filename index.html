
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Boundary Cancellation Principle - Complete Analysis</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=Source+Code+Pro:wght@400;500&display=swap');

:root {
    --bg-primary: #faf9f7;
    --bg-secondary: #f0eeeb;
    --bg-card: #fff;
    --text-primary: #1a1a1a;
    --text-secondary: #555;
    --text-muted: #888;
    --border: #ddd;
    --border-dark: #ccc;
    --accent: #2a2a2a;
    --accent-light: #444;
    --highlight: #fffde7;
    --theorem-bg: #f5f5f0;
    --definition-bg: #f0f5f5;
    --definition-border: #4a7a7a;
    --table-header: #2a2a2a;
    --table-header-text: #fff;
    --table-alt: #f9f9f7;
    --code-bg: #f5f5f5;
    --success: #2e7d32;
    --warning: #f57c00;
    --error: #c62828;
}

body.dark {
    --bg-primary: #0d0d0f;
    --bg-secondary: #161618;
    --bg-card: #1a1a1e;
    --text-primary: #e8e8ec;
    --text-secondary: #a0a0a8;
    --text-muted: #686870;
    --border: #2a2a32;
    --border-dark: #3a3a42;
    --accent: #c9a227;
    --accent-light: #ddb52f;
    --highlight: #2a2820;
    --theorem-bg: #1e1e22;
    --definition-bg: #1a2020;
    --definition-border: #5a9a9a;
    --table-header: #252528;
    --table-header-text: #e8e8ec;
    --table-alt: #141416;
    --code-bg: #1e1e22;
    --success: #66bb6a;
    --warning: #ffa726;
    --error: #ef5350;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: 'Crimson Pro', Georgia, serif;
    font-size: 18px;
    line-height: 1.7;
    color: var(--text-primary);
    background: var(--bg-primary);
    padding: 40px 20px;
    transition: background 0.3s, color 0.3s;
}

.container { max-width: 1000px; margin: 0 auto; }

header {
    text-align: center;
    margin-bottom: 40px;
    padding-bottom: 25px;
    border-bottom: 1px solid var(--border-dark);
    position: relative;
}

.theme-toggle {
    position: absolute;
    top: 0;
    right: 0;
    padding: 8px 16px;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    color: var(--text-primary);
    font-family: 'Source Code Pro', monospace;
    font-size: 0.8rem;
    cursor: pointer;
}

.theme-toggle:hover { background: var(--accent); color: var(--table-header-text); }

h1 { font-size: 2rem; font-weight: 600; margin-bottom: 8px; }
.subtitle { font-size: 1.05rem; color: var(--text-secondary); font-style: italic; }

.controls {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    padding: 20px 25px;
    margin-bottom: 35px;
}

.controls-title {
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-muted);
    margin-bottom: 12px;
}

.controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 15px;
    margin-bottom: 15px;
}

.control-item label {
    display: block;
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 4px;
}

.control-item select, .control-item input {
    width: 100%;
    padding: 7px 10px;
    font-family: 'Source Code Pro', monospace;
    font-size: 0.85rem;
    border: 1px solid var(--border);
    background: var(--bg-card);
    color: var(--text-primary);
}

.compute-btn {
    display: block;
    width: 100%;
    padding: 10px;
    background: var(--accent);
    color: var(--table-header-text);
    border: none;
    font-family: 'Crimson Pro', serif;
    font-size: 0.95rem;
    cursor: pointer;
}

.compute-btn:hover { background: var(--accent-light); }
.compute-btn:disabled { opacity: 0.6; cursor: wait; }

section { margin-bottom: 40px; }

h2 {
    font-size: 1.3rem;
    font-weight: 600;
    margin-bottom: 15px;
    padding-bottom: 6px;
    border-bottom: 2px solid var(--accent);
}

h3 { font-size: 1.1rem; font-weight: 600; margin: 20px 0 10px 0; }

p { margin-bottom: 12px; text-align: justify; }

.theorem {
    background: var(--theorem-bg);
    border-left: 4px solid var(--accent);
    padding: 15px 20px;
    margin: 20px 0;
}

.theorem-title { font-weight: 600; margin-bottom: 8px; }

.definition {
    background: var(--definition-bg);
    border-left: 4px solid var(--definition-border);
    padding: 15px 20px;
    margin: 20px 0;
}

.formula {
    background: var(--code-bg);
    border: 1px solid var(--border);
    padding: 15px;
    margin: 15px 0;
    text-align: center;
    font-family: 'Source Code Pro', monospace;
    font-size: 1rem;
    overflow-x: auto;
}

.data-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    font-size: 0.9rem;
}

.data-table th {
    background: var(--table-header);
    color: var(--table-header-text);
    padding: 10px 12px;
    text-align: left;
    font-weight: 500;
    font-size: 0.85rem;
}

.data-table td {
    padding: 8px 12px;
    border-bottom: 1px solid var(--border);
}

.data-table tr:nth-child(even) { background: var(--table-alt); }
.data-table .num { font-family: 'Source Code Pro', monospace; text-align: right; }
.highlight-row { background: var(--highlight) !important; }

.stat-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin: 20px 0;
}

.stat-card {
    background: var(--bg-card);
    border: 1px solid var(--border);
    padding: 15px;
}

.stat-label {
    font-size: 0.8rem;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.04em;
}

.stat-value {
    font-family: 'Source Code Pro', monospace;
    font-size: 1.5rem;
    font-weight: 500;
    margin: 4px 0;
}

.stat-note { font-size: 0.8rem; color: var(--text-muted); font-style: italic; }

.scrollable-table {
    max-height: 350px;
    overflow-y: auto;
    border: 1px solid var(--border);
}

.scrollable-table table { margin: 0; }

.proof {
    margin: 15px 0;
    padding-left: 18px;
    border-left: 2px solid var(--border-dark);
}

.proof-title { font-style: italic; color: var(--text-secondary); margin-bottom: 8px; }
.qed { text-align: right; font-size: 1.1rem; }

.export-section {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    padding: 15px 20px;
    margin-top: 30px;
}

.export-title {
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-muted);
    margin-bottom: 12px;
}

.export-buttons { display: flex; gap: 8px; flex-wrap: wrap; }

.export-btn {
    padding: 8px 14px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    color: var(--text-primary);
    font-family: 'Crimson Pro', serif;
    font-size: 0.9rem;
    cursor: pointer;
}

.export-btn:hover { background: var(--accent); color: var(--table-header-text); }

.point-list {
    max-height: 250px;
    overflow-y: auto;
    font-family: 'Source Code Pro', monospace;
    font-size: 0.75rem;
    background: var(--code-bg);
    padding: 12px;
    border: 1px solid var(--border);
    white-space: pre;
}

.good { color: var(--success); }
.warn { color: var(--warning); }
.bad { color: var(--error); }

.two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
@media (max-width: 700px) { .two-col { grid-template-columns: 1fr; } }

footer {
    margin-top: 50px;
    padding-top: 15px;
    border-top: 1px solid var(--border-dark);
    text-align: center;
    font-size: 0.8rem;
    color: var(--text-muted);
}

@media print {
    .controls, .export-section, .theme-toggle { display: none; }
    body { padding: 15px; font-size: 11pt; }
    .scrollable-table { max-height: none; overflow: visible; }
}
</style>
</head>
<body>

<div class="container">
    <header>
        <button class="theme-toggle" id="themeBtn" onclick="toggleTheme()">Dark Mode</button>
        <h1>The Boundary Cancellation Principle</h1>
        <p class="subtitle">Complete Computational Analysis of Error Terms in Arithmetic Lattices</p>
    </header>

    <div class="controls">
        <div class="controls-title">Parameters</div>
        <div class="controls-grid">
            <div class="control-item">
                <label>Structure Type</label>
                <select id="structureType">
                    <option value="coprime">Coprime Lattice Points</option>
                    <option value="squarefree">Squarefree Integers</option>
                    <option value="kfree">k-Free Integers</option>
                    <option value="coprime-tuple">Coprime m-Tuples</option>
                </select>
            </div>
            <div class="control-item">
                <label>Dimension (k)</label>
                <select id="dimension">
                    <option value="2" selected>2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                </select>
            </div>
            <div class="control-item">
                <label>Radius / Bound (R)</label>
                <input type="number" id="radius" value="50" min="5" max="200">
            </div>
            <div class="control-item">
                <label>k-free parameter</label>
                <input type="number" id="kfreeK" value="2" min="2" max="10">
            </div>
            <div class="control-item">
                <label>Error series step</label>
                <input type="number" id="errorStep" value="2" min="1" max="10">
            </div>
        </div>
        <button class="compute-btn" id="computeBtn" onclick="runCompute()">Compute Full Analysis</button>
    </div>

    <!-- Section 1: Principle Statement -->
    <section>
        <h2>1. Statement of the Principle</h2>
        
        <div class="theorem">
            <div class="theorem-title">Boundary Cancellation Principle</div>
            <p>Let N(R) denote a counting function associated with a k-dimensional lattice problem subject to Möbius-filtered arithmetic constraints (such as coprimality or k-free conditions). Then</p>
            <div class="formula">N(R) = R<sup>k</sup> / ζ(k) + O(R<sup>k−1</sup>)</div>
            <p>where the error term is controlled by the (k−1)-dimensional boundary measure of the region.</p>
        </div>

        <p>Equivalently, when translating from lattice radius R to an integer counting parameter x ~ R<sup>k</sup>, the error term becomes:</p>
        <div class="formula">N(x) = x / ζ(k) + O(x<sup>(k−1)/k</sup>)</div>
        <p>Thus, the critical error exponent is <strong>(k−1)/k</strong>.</p>
    </section>

    <!-- Section 2: Geometric Interpretation -->
    <section>
        <h2>2. Geometric Interpretation</h2>
        
        <p>The origin of the error term can be understood geometrically:</p>
        
        <div class="definition">
            <p><strong>1. Interior Cancellation.</strong> Möbius inversion produces near-complete cancellation in the interior of the lattice region.</p>
            <p><strong>2. Boundary Truncation.</strong> Near the boundary, arithmetic divisibility constraints are only partially represented due to truncation effects.</p>
            <p><strong>3. Boundary Dominance.</strong> Since the boundary of a k-dimensional region scales as R<sup>k−1</sup>, the surviving error contribution is necessarily of that order.</p>
        </div>
        
        <p>The error term is therefore not an analytic anomaly, but a <em>geometric inevitability</em>.</p>
    </section>

    <!-- Section 3: Configuration -->
    <section>
        <h2>3. Current Configuration</h2>
        
        <div class="stat-grid">
            <div class="stat-card">
                <div class="stat-label">Structure</div>
                <div class="stat-value" id="dispStructure">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Dimension k</div>
                <div class="stat-value" id="dispDim">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Radius R</div>
                <div class="stat-value" id="dispRadius">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Critical Exponent</div>
                <div class="stat-value" id="dispExp">—</div>
            </div>
        </div>

        <div class="definition">
            <div class="theorem-title" id="defTitle">Definition</div>
            <p id="defContent">—</p>
        </div>
    </section>

    <!-- Section 4: Möbius Density -->
    <section>
        <h2>4. Möbius Density</h2>
        
        <p>The main term constant is determined by the classical identity:</p>
        <div class="formula">
            Σ<sub>d=1</sub><sup>∞</sup> μ(d)/d<sup>k</sup> = 1/ζ(k) = Π<sub>p</sub> (1 − 1/p<sup>k</sup>)
        </div>
        <p>which gives the asymptotic density of admissible points.</p>

        <h3>Riemann Zeta Reference</h3>
        <table class="data-table">
            <thead><tr><th>k</th><th>ζ(k)</th><th>1/ζ(k)</th><th>Closed Form</th></tr></thead>
            <tbody>
                <tr><td>2</td><td class="num">1.6449340668</td><td class="num">0.6079271019</td><td>π²/6</td></tr>
                <tr><td>3</td><td class="num">1.2020569032</td><td class="num">0.8319073725</td><td>Apéry's constant</td></tr>
                <tr><td>4</td><td class="num">1.0823232337</td><td class="num">0.9239384669</td><td>π⁴/90</td></tr>
                <tr><td>5</td><td class="num">1.0369277551</td><td class="num">0.9643895748</td><td>—</td></tr>
                <tr><td>6</td><td class="num">1.0173430620</td><td class="num">0.9829523809</td><td>π⁶/945</td></tr>
            </tbody>
        </table>
    </section>

    <!-- Section 5: Classical Examples -->
    <section>
        <h2>5. Classical Examples</h2>
        
        <p>This framework explains several well-known results:</p>
        
        <table class="data-table">
            <thead><tr><th>Structure</th><th>Dimension</th><th>Main Term</th><th>Error Term</th></tr></thead>
            <tbody>
                <tr><td>Squarefree integers</td><td class="num">k = 2</td><td>6x/π²</td><td>O(x<sup>1/2</sup>)</td></tr>
                <tr><td>Cubefree integers</td><td class="num">k = 3</td><td>x/ζ(3)</td><td>O(x<sup>1/3</sup>)</td></tr>
                <tr><td>k-free integers</td><td class="num">k</td><td>x/ζ(k)</td><td>O(x<sup>1/k</sup>)</td></tr>
                <tr><td>Coprime pairs</td><td class="num">k = 2</td><td>6R²/π²</td><td>O(R)</td></tr>
                <tr><td>Coprime m-tuples</td><td class="num">m</td><td>R<sup>m</sup>/ζ(m)</td><td>O(R<sup>m−1</sup>)</td></tr>
            </tbody>
        </table>
        
        <p>In each case, the exponent arises from the codimension-one boundary of the associated Möbius-filtered lattice.</p>
    </section>

    <!-- Section 6: Exact Counting -->
    <section>
        <h2>6. Exact Counting Results</h2>

        <div class="stat-grid">
            <div class="stat-card">
                <div class="stat-label">Total Lattice Points</div>
                <div class="stat-value" id="statTotal">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Surviving Points</div>
                <div class="stat-value" id="statSurv">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Removed Points</div>
                <div class="stat-value" id="statRem">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Empirical Density</div>
                <div class="stat-value" id="statDens">—</div>
            </div>
        </div>

        <h3>Prediction vs Reality</h3>
        <table class="data-table">
            <thead><tr><th>Quantity</th><th>Value</th><th>Notes</th></tr></thead>
            <tbody>
                <tr><td>Predicted (Main Term)</td><td class="num" id="tblPred">—</td><td id="tblPredNote">—</td></tr>
                <tr><td>Actual Count</td><td class="num" id="tblActual">—</td><td>Exact enumeration</td></tr>
                <tr class="highlight-row"><td>Error</td><td class="num" id="tblError">—</td><td>Actual − Predicted</td></tr>
                <tr><td>Error Bound O(R<sup id="tblExpSpan">k−1</sup>)</td><td class="num" id="tblBound">—</td><td id="tblBoundNote">—</td></tr>
                <tr><td>Relative Error</td><td class="num" id="tblRelErr">—</td><td>|Error|/Predicted</td></tr>
                <tr><td>|Error|/Bound Ratio</td><td class="num" id="tblRatio">—</td><td id="tblRatioNote">—</td></tr>
            </tbody>
        </table>
    </section>

    <!-- Section 7: Boundary Analysis -->
    <section>
        <h2>7. Boundary Shell Analysis</h2>

        <p>Testing multiple shell thicknesses to verify error concentration at boundary:</p>

        <div class="scrollable-table">
            <table class="data-table">
                <thead><tr><th>Shell δ</th><th>Range</th><th>Boundary Pts</th><th>Interior Pts</th><th>Boundary %</th><th>Bnd Density</th><th>Int Density</th></tr></thead>
                <tbody id="boundaryBody"></tbody>
            </table>
        </div>

        <h3>Radial Density Distribution</h3>
        <div class="scrollable-table">
            <table class="data-table">
                <thead><tr><th>Radius Range</th><th>Total</th><th>Surviving</th><th>Density</th><th>Deviation</th></tr></thead>
                <tbody id="radialBody"></tbody>
            </table>
        </div>
    </section>

    <!-- Section 8: Error Series -->
    <section>
        <h2>8. Error Term Scaling Analysis</h2>

        <p>Full range computation of error vs theoretical bound O(R<sup id="errExpSpan">k−1</sup>):</p>

        <div class="stat-grid">
            <div class="stat-card">
                <div class="stat-label">Max |Error|/Bound</div>
                <div class="stat-value" id="maxRatio">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg |Error|/Bound</div>
                <div class="stat-value" id="avgRatio">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Fitted Constant C</div>
                <div class="stat-value" id="fittedC">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Fit Quality R²</div>
                <div class="stat-value" id="fitR2">—</div>
            </div>
        </div>

        <div class="scrollable-table">
            <table class="data-table">
                <thead><tr><th>R</th><th>Actual</th><th>Predicted</th><th>Error</th><th>|Error|</th><th>Bound</th><th>Ratio</th></tr></thead>
                <tbody id="errorBody"></tbody>
            </table>
        </div>
    </section>

    <!-- Section 9: Möbius Convergence -->
    <section>
        <h2>9. Möbius Sum Convergence</h2>

        <p>Verifying Σ μ(d)/d<sup>k</sup> → 1/ζ(k):</p>

        <div class="scrollable-table">
            <table class="data-table">
                <thead><tr><th>Truncation N</th><th>Partial Sum</th><th>Target</th><th>Error</th><th>Rel Error</th></tr></thead>
                <tbody id="mobiusBody"></tbody>
            </table>
        </div>
    </section>

    <!-- Section 10: Dimensional Comparison -->
    <section>
        <h2>10. Dimensional Comparison</h2>

        <p>Same radius across dimensions to verify exponent dependence:</p>

        <div class="scrollable-table">
            <table class="data-table">
                <thead><tr><th>k</th><th>Exponent</th><th>Total</th><th>Surviving</th><th>Predicted</th><th>Error</th><th>Bound</th><th>Ratio</th></tr></thead>
                <tbody id="dimBody"></tbody>
            </table>
        </div>
    </section>

    <!-- Section 11: GCD Distribution -->
    <section>
        <h2>11. GCD Distribution of Removed Points</h2>

        <div class="two-col">
            <div class="scrollable-table">
                <table class="data-table">
                    <thead><tr><th>gcd</th><th>Count</th><th>Percentage</th><th>μ(gcd)</th></tr></thead>
                    <tbody id="gcdBody"></tbody>
                </table>
            </div>
            <div>
                <div class="stat-card">
                    <div class="stat-label">Distinct GCD Values</div>
                    <div class="stat-value" id="distinctGcd">—</div>
                </div>
                <div class="stat-card" style="margin-top:15px">
                    <div class="stat-label">Most Common GCD</div>
                    <div class="stat-value" id="commonGcd">—</div>
                </div>
            </div>
        </div>
    </section>

    <!-- Section 12: Scope -->
    <section>
        <h2>12. Scope and Limitations</h2>
        
        <p>This principle does not assert new analytic bounds, nor does it rely on conjectures such as the Riemann Hypothesis. Rather, it provides a geometric explanation for why known error exponents take their observed values across a wide class of arithmetic counting problems.</p>
        
        <p>The Boundary Cancellation Principle should therefore be viewed as an <em>interpretive framework</em>, unifying classical sieve results through boundary geometry.</p>
    </section>

    <!-- Section 13: Sample Data -->
    <section>
        <h2>13. Sample Data</h2>

        <h3>First 50 Surviving Points (by norm)</h3>
        <div class="point-list" id="survList">—</div>

        <h3>First 30 Removed Points (by norm)</h3>
        <div class="point-list" id="remList">—</div>
    </section>

    <!-- Exports -->
    <div class="export-section">
        <div class="export-title">Export All Data (CSV)</div>
        <div class="export-buttons">
            <button class="export-btn" onclick="exportCSV('points')">All Points</button>
            <button class="export-btn" onclick="exportCSV('surviving')">Surviving</button>
            <button class="export-btn" onclick="exportCSV('error')">Error Series</button>
            <button class="export-btn" onclick="exportCSV('boundary')">Boundary</button>
            <button class="export-btn" onclick="exportCSV('density')">Density</button>
            <button class="export-btn" onclick="exportCSV('mobius')">Möbius</button>
            <button class="export-btn" onclick="exportCSV('dim')">Dimensional</button>
            <button class="export-btn" onclick="exportCSV('gcd')">GCD</button>
            <button class="export-btn" onclick="exportCSV('summary')">Summary</button>
            <button class="export-btn" onclick="window.print()">Print/PDF</button>
        </div>
    </div>

    <footer>
        Boundary Cancellation Principle — Complete Analysis<br>
        Computed: <span id="compTime">—</span> | <span id="compDur">—</span>
    </footer>
</div>

<script>
// State
var S = {
    structure: 'coprime',
    dim: 2,
    radius: 50,
    kfreeK: 2,
    step: 2,
    points: [],
    classified: [],
    errorData: [],
    densityData: [],
    boundaryData: [],
    mobiusData: [],
    dimData: [],
    gcdData: [],
    primes: [],
    maxPrime: 0
};

// Theme toggle
function toggleTheme() {
    document.body.classList.toggle('dark');
    var isDark = document.body.classList.contains('dark');
    document.getElementById('themeBtn').textContent = isDark ? 'Light Mode' : 'Dark Mode';
    try { localStorage.setItem('bcpTheme', isDark ? 'dark' : 'light'); } catch(e) {}
}

// Load theme on start
(function() {
    try {
        if (localStorage.getItem('bcpTheme') === 'dark') {
            document.body.classList.add('dark');
        }
    } catch(e) {}
})();

// Prime sieve
function sievePrimes(max) {
    if (max <= S.maxPrime) return;
    var sieve = [];
    for (var i = 0; i <= max; i++) sieve[i] = true;
    sieve[0] = sieve[1] = false;
    for (var i = 2; i * i <= max; i++) {
        if (sieve[i]) {
            for (var j = i * i; j <= max; j += i) sieve[j] = false;
        }
    }
    S.primes = [];
    for (var i = 2; i <= max; i++) {
        if (sieve[i]) S.primes.push(i);
    }
    S.maxPrime = max;
}

// GCD
function gcd(a, b) {
    a = Math.abs(a);
    b = Math.abs(b);
    while (b) {
        var t = b;
        b = a % b;
        a = t;
    }
    return a;
}

function gcdArr(arr) {
    if (!arr || arr.length === 0) return 1;
    var result = arr[0];
    for (var i = 1; i < arr.length; i++) {
        result = gcd(result, arr[i]);
    }
    return result;
}

// Möbius function
function mobius(n) {
    if (n === 1) return 1;
    sievePrimes(Math.ceil(Math.sqrt(n)) + 10);
    var result = 1;
    var temp = n;
    for (var i = 0; i < S.primes.length; i++) {
        var p = S.primes[i];
        if (p * p > temp) break;
        if (temp % p === 0) {
            temp = temp / p;
            result = -result;
            if (temp % p === 0) return 0;
        }
    }
    if (temp > 1) result = -result;
    return result;
}

// k-free test
function isKFree(n, k) {
    if (n <= 0) return false;
    sievePrimes(Math.ceil(Math.pow(n, 1/k)) + 10);
    for (var i = 0; i < S.primes.length; i++) {
        var p = S.primes[i];
        var pk = Math.pow(p, k);
        if (pk > n) break;
        if (n % pk === 0) return false;
    }
    return true;
}

// Zeta values
function zeta(s) {
    if (s === 2) return Math.PI * Math.PI / 6;
    if (s === 3) return 1.2020569031595942;
    if (s === 4) return Math.pow(Math.PI, 4) / 90;
    if (s === 5) return 1.0369277551433699;
    if (s === 6) return Math.pow(Math.PI, 6) / 945;
    var sum = 0;
    for (var n = 1; n < 10000; n++) sum += 1 / Math.pow(n, s);
    return sum;
}

// Generate lattice points
function generatePoints(R, k) {
    var points = [];
    var R2 = R * R;
    
    if (k === 2) {
        for (var x = 1; x <= R; x++) {
            var maxY = Math.floor(Math.sqrt(R2 - x * x));
            for (var y = -maxY; y <= maxY; y++) {
                points.push([x, y]);
            }
        }
    } else if (k === 3) {
        for (var x = 1; x <= R; x++) {
            var rem1 = R2 - x * x;
            if (rem1 < 0) continue;
            var maxY = Math.floor(Math.sqrt(rem1));
            for (var y = -maxY; y <= maxY; y++) {
                var rem2 = rem1 - y * y;
                if (rem2 < 0) continue;
                var maxZ = Math.floor(Math.sqrt(rem2));
                for (var z = -maxZ; z <= maxZ; z++) {
                    points.push([x, y, z]);
                }
            }
        }
    } else {
        // Generic recursive for k >= 4
        function gen(cur, depth, rem) {
            if (depth === k) {
                points.push(cur.slice());
                return;
            }
            var max = Math.floor(Math.sqrt(rem));
            var start = (depth === 0) ? 1 : -max;
            for (var v = start; v <= max; v++) {
                var newRem = rem - v * v;
                if (newRem >= 0) {
                    cur.push(v);
                    gen(cur, depth + 1, newRem);
                    cur.pop();
                }
            }
        }
        gen([], 0, R2);
    }
    
    return points;
}

// Classify a point
function classify(p, structure, kfreeK) {
    var survives = false;
    var g = 1;
    var absP = [];
    for (var i = 0; i < p.length; i++) absP.push(Math.abs(p[i]));
    
    if (structure === 'coprime' || structure === 'coprime-tuple') {
        g = gcdArr(absP);
        survives = (g === 1);
    } else if (structure === 'squarefree') {
        var sum = 0;
        for (var i = 0; i < p.length; i++) sum += p[i] * p[i];
        var n = Math.round(Math.sqrt(sum));
        survives = isKFree(n, 2);
    } else if (structure === 'kfree') {
        var sum = 0;
        for (var i = 0; i < p.length; i++) sum += p[i] * p[i];
        var n = Math.round(Math.sqrt(sum));
        survives = isKFree(n, kfreeK);
    } else {
        g = gcdArr(absP);
        survives = (g === 1);
    }
    
    var normSq = 0;
    for (var i = 0; i < p.length; i++) normSq += p[i] * p[i];
    
    return {
        point: p,
        survives: survives,
        gcd: g,
        norm: Math.sqrt(normSq)
    };
}

// Main term
function mainTerm(R, k, str, kfK) {
    if (str === 'squarefree') return R / zeta(2);
    if (str === 'kfree') return R / zeta(kfK);
    return Math.pow(R, k) / zeta(k);
}

// Error bound
function errorBound(R, k, str, kfK) {
    if (str === 'squarefree') return Math.pow(R, 0.5);
    if (str === 'kfree') return Math.pow(R, 1 / kfK);
    return Math.pow(R, k - 1);
}

// Safe division
function safeDiv(a, b) {
    if (b === 0) return 0;
    return a / b;
}

// Main compute
function runCompute() {
    var btn = document.getElementById('computeBtn');
    btn.textContent = 'Computing...';
    btn.disabled = true;
    
    setTimeout(function() {
        try {
            doCompute();
        } catch(e) {
            console.error('Compute error:', e);
            document.getElementById('compTime').textContent = 'Error: ' + e.message;
        }
        btn.textContent = 'Compute Full Analysis';
        btn.disabled = false;
    }, 50);
}

function doCompute() {
    var t0 = performance.now();
    
    // Read params
    S.structure = document.getElementById('structureType').value;
    S.dim = parseInt(document.getElementById('dimension').value) || 2;
    S.radius = parseInt(document.getElementById('radius').value) || 50;
    S.kfreeK = parseInt(document.getElementById('kfreeK').value) || 2;
    S.step = parseInt(document.getElementById('errorStep').value) || 2;
    
    var k = S.dim;
    var R = S.radius;
    
    // Limit for high dimensions
    if (k >= 5 && R > 25) { R = 25; S.radius = R; document.getElementById('radius').value = R; }
    else if (k >= 4 && R > 40) { R = 40; S.radius = R; document.getElementById('radius').value = R; }
    
    // Generate and classify
    S.points = generatePoints(R, k);
    S.classified = [];
    for (var i = 0; i < S.points.length; i++) {
        S.classified.push(classify(S.points[i], S.structure, S.kfreeK));
    }
    
    // Separate surviving and removed
    var surv = [];
    var removed = [];
    for (var i = 0; i < S.classified.length; i++) {
        if (S.classified[i].survives) surv.push(S.classified[i]);
        else removed.push(S.classified[i]);
    }
    
    var pred = mainTerm(R, k, S.structure, S.kfreeK);
    var err = surv.length - pred;
    var bnd = errorBound(R, k, S.structure, S.kfreeK);
    
    // Update displays
    updateConfig(k, R);
    updateCounting(S.classified.length, surv.length, pred, err, bnd, k);
    computeBoundary(surv, R);
    computeRadial(R);
    computeError(k, R);
    computeMobius(k);
    computeDim(Math.min(R, 20));
    computeGcd(removed);
    updateLists(surv, removed);
    
    var elapsed = performance.now() - t0;
    document.getElementById('compTime').textContent = new Date().toLocaleString();
    document.getElementById('compDur').textContent = elapsed.toFixed(0) + 'ms';
}

function updateConfig(k, R) {
    var names = {
        'coprime': 'Coprime Lattice',
        'squarefree': 'Squarefree',
        'kfree': S.kfreeK + '-Free',
        'coprime-tuple': 'Coprime Tuples'
    };
    document.getElementById('dispStructure').textContent = names[S.structure] || S.structure;
    document.getElementById('dispDim').textContent = k;
    document.getElementById('dispRadius').textContent = R;
    document.getElementById('dispExp').textContent = (k-1) + '/' + k;
    document.getElementById('tblExpSpan').textContent = k - 1;
    document.getElementById('errExpSpan').textContent = k - 1;
    
    // Update theme button text
    var isDark = document.body.classList.contains('dark');
    document.getElementById('themeBtn').textContent = isDark ? 'Light Mode' : 'Dark Mode';
    
    // Definition
    var defs = {
        'coprime': 'A point (a₁,...,a' + k + ') ∈ ℤ' + k + ' is coprime if gcd(a₁,...,a' + k + ') = 1.',
        'squarefree': 'An integer n is squarefree if not divisible by p² for any prime p.',
        'kfree': 'An integer n is ' + S.kfreeK + '-free if not divisible by p^' + S.kfreeK + ' for any prime p.',
        'coprime-tuple': 'A ' + k + '-tuple is coprime if gcd of all components is 1.'
    };
    document.getElementById('defTitle').textContent = 'Definition (' + (names[S.structure] || S.structure) + ')';
    document.getElementById('defContent').textContent = defs[S.structure] || '';
}

function updateCounting(total, survCount, pred, err, bnd, k) {
    document.getElementById('statTotal').textContent = total.toLocaleString();
    document.getElementById('statSurv').textContent = survCount.toLocaleString();
    document.getElementById('statRem').textContent = (total - survCount).toLocaleString();
    document.getElementById('statDens').textContent = (safeDiv(survCount, total) * 100).toFixed(4) + '%';
    
    document.getElementById('tblPred').textContent = pred.toFixed(4);
    document.getElementById('tblPredNote').textContent = 'ζ(' + k + ')=' + zeta(k).toFixed(8);
    document.getElementById('tblActual').textContent = survCount.toLocaleString();
    document.getElementById('tblError').textContent = err.toFixed(4);
    document.getElementById('tblBound').textContent = bnd.toFixed(4);
    document.getElementById('tblBoundNote').textContent = 'R^' + (k-1) + '=' + bnd.toFixed(4);
    document.getElementById('tblRelErr').textContent = (safeDiv(Math.abs(err), pred) * 100).toFixed(6) + '%';
    
    var ratio = safeDiv(Math.abs(err), bnd);
    document.getElementById('tblRatio').textContent = ratio.toFixed(6);
    var note = document.getElementById('tblRatioNote');
    if (ratio < 1) { note.textContent = 'Within bound'; note.className = 'good'; }
    else if (ratio < 2) { note.textContent = 'Near bound'; note.className = 'warn'; }
    else { note.textContent = 'Exceeds bound'; note.className = 'bad'; }
}

function computeBoundary(surv, R) {
    S.boundaryData = [];
    var deltas = [1, 2, 3, 5, Math.floor(R*0.05), Math.floor(R*0.1), Math.floor(R*0.15), Math.floor(R*0.2)];
    var unique = [];
    var seen = {};
    for (var i = 0; i < deltas.length; i++) {
        var d = deltas[i];
        if (d > 0 && d < R && !seen[d]) {
            unique.push(d);
            seen[d] = true;
        }
    }
    unique.sort(function(a,b) { return a - b; });
    
    for (var i = 0; i < unique.length; i++) {
        var delta = unique[i];
        var thresh = R - delta;
        var bndPts = 0, intPts = 0;
        for (var j = 0; j < surv.length; j++) {
            if (surv[j].norm >= thresh) bndPts++;
            else intPts++;
        }
        
        var bTotal = 0, iTotal = 0;
        for (var j = 0; j < S.classified.length; j++) {
            if (S.classified[j].norm >= thresh) bTotal++;
            else iTotal++;
        }
        
        S.boundaryData.push({
            delta: delta,
            range: '[' + thresh.toFixed(1) + ', ' + R + ']',
            bndPts: bndPts,
            intPts: intPts,
            bndPct: safeDiv(bndPts, surv.length) * 100,
            bndDens: safeDiv(bndPts, bTotal),
            intDens: safeDiv(intPts, iTotal)
        });
    }
    
    var html = '';
    for (var i = 0; i < S.boundaryData.length; i++) {
        var d = S.boundaryData[i];
        html += '<tr><td class="num">' + d.delta + '</td><td>' + d.range + '</td>';
        html += '<td class="num">' + d.bndPts.toLocaleString() + '</td>';
        html += '<td class="num">' + d.intPts.toLocaleString() + '</td>';
        html += '<td class="num">' + d.bndPct.toFixed(2) + '%</td>';
        html += '<td class="num">' + (d.bndDens*100).toFixed(4) + '%</td>';
        html += '<td class="num">' + (d.intDens*100).toFixed(4) + '%</td></tr>';
    }
    document.getElementById('boundaryBody').innerHTML = html || '<tr><td colspan="7">No data</td></tr>';
}

function computeRadial(R) {
    var bins = 12;
    var binW = R / bins;
    S.densityData = [];
    var totalDens = 0;
    
    for (var i = 0; i < bins; i++) {
        var rMin = i * binW;
        var rMax = (i + 1) * binW;
        var total = 0, survCount = 0;
        
        for (var j = 0; j < S.classified.length; j++) {
            var n = S.classified[j].norm;
            if (n >= rMin && n < rMax) {
                total++;
                if (S.classified[j].survives) survCount++;
            }
        }
        
        var dens = safeDiv(survCount, total);
        totalDens += dens;
        S.densityData.push({ rMin: rMin, rMax: rMax, total: total, surv: survCount, dens: dens });
    }
    
    var meanDens = totalDens / bins;
    for (var i = 0; i < S.densityData.length; i++) {
        S.densityData[i].dev = S.densityData[i].dens - meanDens;
    }
    
    var html = '';
    for (var i = 0; i < S.densityData.length; i++) {
        var d = S.densityData[i];
        var devClass = d.dev >= 0 ? 'good' : 'bad';
        html += '<tr><td>[' + d.rMin.toFixed(1) + ', ' + d.rMax.toFixed(1) + ')</td>';
        html += '<td class="num">' + d.total.toLocaleString() + '</td>';
        html += '<td class="num">' + d.surv.toLocaleString() + '</td>';
        html += '<td class="num">' + (d.dens*100).toFixed(4) + '%</td>';
        html += '<td class="num ' + devClass + '">' + (d.dev*100).toFixed(4) + '%</td></tr>';
    }
    document.getElementById('radialBody').innerHTML = html || '<tr><td colspan="5">No data</td></tr>';
}

function computeError(k, R) {
    S.errorData = [];
    var step = Math.max(S.step, k >= 4 ? 4 : 2);
    var maxR = k >= 5 ? Math.min(R, 25) : R;
    
    for (var r = 5; r <= maxR; r += step) {
        var pts = generatePoints(r, k);
        var survC = 0;
        for (var i = 0; i < pts.length; i++) {
            var c = classify(pts[i], S.structure, S.kfreeK);
            if (c.survives) survC++;
        }
        var pred = mainTerm(r, k, S.structure, S.kfreeK);
        var err = survC - pred;
        var bnd = errorBound(r, k, S.structure, S.kfreeK);
        S.errorData.push({
            r: r,
            actual: survC,
            pred: pred,
            err: err,
            absErr: Math.abs(err),
            bnd: bnd,
            ratio: safeDiv(Math.abs(err), bnd)
        });
    }
    
    if (S.errorData.length === 0) {
        document.getElementById('maxRatio').textContent = '—';
        document.getElementById('avgRatio').textContent = '—';
        document.getElementById('fittedC').textContent = '—';
        document.getElementById('fitR2').textContent = '—';
        document.getElementById('errorBody').innerHTML = '<tr><td colspan="7">No data</td></tr>';
        return;
    }
    
    var maxR = 0, sumR = 0;
    for (var i = 0; i < S.errorData.length; i++) {
        if (S.errorData[i].ratio > maxR) maxR = S.errorData[i].ratio;
        sumR += S.errorData[i].ratio;
    }
    document.getElementById('maxRatio').textContent = maxR.toFixed(6);
    document.getElementById('avgRatio').textContent = (sumR / S.errorData.length).toFixed(6);
    
    // Least squares fit
    var sumXY = 0, sumX2 = 0;
    for (var i = 0; i < S.errorData.length; i++) {
        sumXY += S.errorData[i].absErr * S.errorData[i].bnd;
        sumX2 += S.errorData[i].bnd * S.errorData[i].bnd;
    }
    var C = safeDiv(sumXY, sumX2);
    document.getElementById('fittedC').textContent = C.toFixed(6);
    
    // R² calculation
    var meanErr = 0;
    for (var i = 0; i < S.errorData.length; i++) meanErr += S.errorData[i].absErr;
    meanErr = meanErr / S.errorData.length;
    
    var ssTot = 0, ssRes = 0;
    for (var i = 0; i < S.errorData.length; i++) {
        ssTot += Math.pow(S.errorData[i].absErr - meanErr, 2);
        ssRes += Math.pow(S.errorData[i].absErr - C * S.errorData[i].bnd, 2);
    }
    var r2 = 1 - safeDiv(ssRes, ssTot);
    document.getElementById('fitR2').textContent = r2.toFixed(6);
    
    var html = '';
    for (var i = 0; i < S.errorData.length; i++) {
        var d = S.errorData[i];
        html += '<tr><td class="num">' + d.r + '</td>';
        html += '<td class="num">' + d.actual.toLocaleString() + '</td>';
        html += '<td class="num">' + d.pred.toFixed(2) + '</td>';
        html += '<td class="num">' + d.err.toFixed(2) + '</td>';
        html += '<td class="num">' + d.absErr.toFixed(2) + '</td>';
        html += '<td class="num">' + d.bnd.toFixed(2) + '</td>';
        html += '<td class="num">' + d.ratio.toFixed(4) + '</td></tr>';
    }
    document.getElementById('errorBody').innerHTML = html;
}

function computeMobius(k) {
    S.mobiusData = [];
    var target = 1 / zeta(k);
    var truncs = [10, 25, 50, 100, 250, 500, 1000, 2500, 5000];
    
    for (var i = 0; i < truncs.length; i++) {
        var N = truncs[i];
        var sum = 0;
        for (var d = 1; d <= N; d++) {
            sum += mobius(d) / Math.pow(d, k);
        }
        var err = sum - target;
        S.mobiusData.push({
            N: N,
            sum: sum,
            target: target,
            err: err,
            relErr: safeDiv(Math.abs(err), Math.abs(target)) * 100
        });
    }
    
    var html = '';
    for (var i = 0; i < S.mobiusData.length; i++) {
        var d = S.mobiusData[i];
        html += '<tr><td class="num">' + d.N.toLocaleString() + '</td>';
        html += '<td class="num">' + d.sum.toFixed(10) + '</td>';
        html += '<td class="num">' + d.target.toFixed(10) + '</td>';
        html += '<td class="num">' + d.err.toFixed(10) + '</td>';
        html += '<td class="num">' + d.relErr.toFixed(6) + '%</td></tr>';
    }
    document.getElementById('mobiusBody').innerHTML = html || '<tr><td colspan="5">No data</td></tr>';
}

function computeDim(R) {
    S.dimData = [];
    var testR = Math.min(R, 18);
    var maxK = testR <= 12 ? 5 : (testR <= 15 ? 4 : 3);
    
    for (var kk = 2; kk <= maxK; kk++) {
        var pts = generatePoints(testR, kk);
        var survC = 0;
        for (var i = 0; i < pts.length; i++) {
            var c = classify(pts[i], S.structure, S.kfreeK);
            if (c.survives) survC++;
        }
        var pred = mainTerm(testR, kk, S.structure, S.kfreeK);
        var err = survC - pred;
        var bnd = errorBound(testR, kk, S.structure, S.kfreeK);
        S.dimData.push({
            k: kk,
            exp: (kk-1)/kk,
            total: pts.length,
            surv: survC,
            pred: pred,
            err: err,
            bnd: bnd,
            ratio: safeDiv(Math.abs(err), bnd)
        });
    }
    
    var html = '';
    for (var i = 0; i < S.dimData.length; i++) {
        var d = S.dimData[i];
        html += '<tr><td class="num">' + d.k + '</td>';
        html += '<td class="num">' + d.exp.toFixed(4) + '</td>';
        html += '<td class="num">' + d.total.toLocaleString() + '</td>';
        html += '<td class="num">' + d.surv.toLocaleString() + '</td>';
        html += '<td class="num">' + d.pred.toFixed(2) + '</td>';
        html += '<td class="num">' + d.err.toFixed(2) + '</td>';
        html += '<td class="num">' + d.bnd.toFixed(2) + '</td>';
        html += '<td class="num">' + d.ratio.toFixed(4) + '</td></tr>';
    }
    document.getElementById('dimBody').innerHTML = html || '<tr><td colspan="8">No data</td></tr>';
}

function computeGcd(removed) {
    var gcdMap = {};
    for (var i = 0; i < removed.length; i++) {
        var g = removed[i].gcd;
        gcdMap[g] = (gcdMap[g] || 0) + 1;
    }
    
    S.gcdData = [];
    for (var g in gcdMap) {
        if (gcdMap.hasOwnProperty(g)) {
            S.gcdData.push({
                gcd: parseInt(g),
                count: gcdMap[g],
                pct: safeDiv(gcdMap[g], removed.length) * 100,
                mu: mobius(parseInt(g))
            });
        }
    }
    S.gcdData.sort(function(a, b) { return b.count - a.count; });
    
    var html = '';
    var limit = Math.min(S.gcdData.length, 20);
    for (var i = 0; i < limit; i++) {
        var d = S.gcdData[i];
        html += '<tr><td class="num">' + d.gcd + '</td>';
        html += '<td class="num">' + d.count.toLocaleString() + '</td>';
        html += '<td class="num">' + d.pct.toFixed(2) + '%</td>';
        html += '<td class="num">' + d.mu + '</td></tr>';
    }
    document.getElementById('gcdBody').innerHTML = html || '<tr><td colspan="4">No data</td></tr>';
    document.getElementById('distinctGcd').textContent = S.gcdData.length;
    document.getElementById('commonGcd').textContent = S.gcdData.length > 0 ? S.gcdData[0].gcd : '—';
}

function updateLists(surv, removed) {
    // Sort by norm
    surv.sort(function(a, b) { return a.norm - b.norm; });
    removed.sort(function(a, b) { return a.norm - b.norm; });
    
    var survText = '';
    var limit = Math.min(surv.length, 50);
    for (var i = 0; i < limit; i++) {
        var p = surv[i];
        survText += String(i+1).padStart(3) + '. (' + p.point.join(', ') + ')  |x|=' + p.norm.toFixed(4) + '\n';
    }
    document.getElementById('survList').textContent = survText || 'No points';
    
    var remText = '';
    limit = Math.min(removed.length, 30);
    for (var i = 0; i < limit; i++) {
        var p = removed[i];
        remText += String(i+1).padStart(3) + '. (' + p.point.join(', ') + ')  gcd=' + p.gcd + '  |x|=' + p.norm.toFixed(4) + '\n';
    }
    document.getElementById('remList').textContent = remText || 'No points';
}

// CSV Export
function exportCSV(type) {
    var csv = '';
    var fn = '';
    var k = S.dim;
    
    if (type === 'points') {
        csv = 'idx';
        for (var i = 0; i < k; i++) csv += ',x' + (i+1);
        csv += ',survives,gcd,norm\n';
        for (var i = 0; i < S.classified.length; i++) {
            var p = S.classified[i];
            csv += i + ',' + p.point.join(',') + ',' + (p.survives?1:0) + ',' + p.gcd + ',' + p.norm.toFixed(6) + '\n';
        }
        fn = 'all-points';
    } else if (type === 'surviving') {
        csv = 'idx';
        for (var i = 0; i < k; i++) csv += ',x' + (i+1);
        csv += ',norm\n';
        var idx = 0;
        for (var i = 0; i < S.classified.length; i++) {
            if (S.classified[i].survives) {
                var p = S.classified[i];
                csv += idx + ',' + p.point.join(',') + ',' + p.norm.toFixed(6) + '\n';
                idx++;
            }
        }
        fn = 'surviving';
    } else if (type === 'error') {
        csv = 'R,actual,predicted,error,abs_error,bound,ratio\n';
        for (var i = 0; i < S.errorData.length; i++) {
            var d = S.errorData[i];
            csv += d.r + ',' + d.actual + ',' + d.pred.toFixed(6) + ',' + d.err.toFixed(6) + ',' + d.absErr.toFixed(6) + ',' + d.bnd.toFixed(6) + ',' + d.ratio.toFixed(6) + '\n';
        }
        fn = 'error-series';
    } else if (type === 'boundary') {
        csv = 'delta,boundary_pts,interior_pts,boundary_pct,boundary_density,interior_density\n';
        for (var i = 0; i < S.boundaryData.length; i++) {
            var d = S.boundaryData[i];
            csv += d.delta + ',' + d.bndPts + ',' + d.intPts + ',' + d.bndPct.toFixed(4) + ',' + d.bndDens.toFixed(6) + ',' + d.intDens.toFixed(6) + '\n';
        }
        fn = 'boundary';
    } else if (type === 'density') {
        csv = 'r_min,r_max,total,surviving,density,deviation\n';
        for (var i = 0; i < S.densityData.length; i++) {
            var d = S.densityData[i];
            csv += d.rMin.toFixed(2) + ',' + d.rMax.toFixed(2) + ',' + d.total + ',' + d.surv + ',' + d.dens.toFixed(6) + ',' + d.dev.toFixed(6) + '\n';
        }
        fn = 'density';
    } else if (type === 'mobius') {
        csv = 'N,partial_sum,target,error,rel_error_pct\n';
        for (var i = 0; i < S.mobiusData.length; i++) {
            var d = S.mobiusData[i];
            csv += d.N + ',' + d.sum.toFixed(10) + ',' + d.target.toFixed(10) + ',' + d.err.toFixed(10) + ',' + d.relErr.toFixed(6) + '\n';
        }
        fn = 'mobius';
    } else if (type === 'dim') {
        csv = 'k,exponent,total,surviving,predicted,error,bound,ratio\n';
        for (var i = 0; i < S.dimData.length; i++) {
            var d = S.dimData[i];
            csv += d.k + ',' + d.exp.toFixed(4) + ',' + d.total + ',' + d.surv + ',' + d.pred.toFixed(4) + ',' + d.err.toFixed(4) + ',' + d.bnd.toFixed(4) + ',' + d.ratio.toFixed(4) + '\n';
        }
        fn = 'dimensional';
    } else if (type === 'gcd') {
        csv = 'gcd,count,percentage,mobius\n';
        for (var i = 0; i < S.gcdData.length; i++) {
            var d = S.gcdData[i];
            csv += d.gcd + ',' + d.count + ',' + d.pct.toFixed(4) + ',' + d.mu + '\n';
        }
        fn = 'gcd';
    } else if (type === 'summary') {
        var survC = 0;
        for (var i = 0; i < S.classified.length; i++) {
            if (S.classified[i].survives) survC++;
        }
        var pred = mainTerm(S.radius, k, S.structure, S.kfreeK);
        csv = 'parameter,value\n';
        csv += 'structure,' + S.structure + '\n';
        csv += 'dimension,' + k + '\n';
        csv += 'radius,' + S.radius + '\n';
        csv += 'total_points,' + S.classified.length + '\n';
        csv += 'surviving,' + survC + '\n';
        csv += 'predicted,' + pred.toFixed(6) + '\n';
        csv += 'error,' + (survC - pred).toFixed(6) + '\n';
        csv += 'error_bound,' + errorBound(S.radius, k, S.structure, S.kfreeK).toFixed(6) + '\n';
        csv += 'critical_exponent,' + ((k-1)/k).toFixed(6) + '\n';
        csv += 'zeta_k,' + zeta(k).toFixed(10) + '\n';
        fn = 'summary';
    }
    
    var blob = new Blob([csv], {type: 'text/csv'});
    var link = document.createElement('a');
    link.download = 'bcp-' + fn + '-' + Date.now() + '.csv';
    link.href = URL.createObjectURL(blob);
    link.click();
}

// Run on load
window.onload = function() {
    var isDark = document.body.classList.contains('dark');
    document.getElementById('themeBtn').textContent = isDark ? 'Light Mode' : 'Dark Mode';
    runCompute();
};
</script>

</body>
    </html>
