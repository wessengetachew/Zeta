<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Polar vs Cartesian Â· Gap Analysis</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=IM+Fell+English:ital@0;1&family=JetBrains+Mono:wght@300;400;700&display=swap');

:root {
  --pink: #ff3db4;
  --gold: #ffd700;
  --bg: #060608;
  --surface: rgba(255,255,255,0.03);
  --border: rgba(255,61,180,0.22);
  --gold-border: rgba(255,215,0,0.22);
  --green: #22c55e;
}

* { margin:0; padding:0; box-sizing:border-box; }

body {
  background: var(--bg);
  color: #d8f0d8;
  font-family: 'JetBrains Mono', monospace;
  min-height: 100vh;
  overflow-x: hidden;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DESKTOP LAYOUT â€” 3-column dashboard
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
.page-shell {
  display: grid;
  grid-template-columns: 300px 1fr 320px;
  grid-template-rows: auto 1fr;
  grid-template-areas:
    "topbar topbar topbar"
    "left   center right";
  min-height: 100vh;
  max-width: 1920px;
  margin: 0 auto;
}

/* Top bar */
.topbar {
  grid-area: topbar;
  display: flex;
  align-items: center;
  gap: 20px;
  padding: 14px 28px;
  border-bottom: 1px solid rgba(255,61,180,0.12);
  background: rgba(6,6,8,0.95);
  backdrop-filter: blur(12px);
  position: sticky; top: 0; z-index: 100;
  flex-wrap: wrap;
}
.topbar-title {
  font-family: 'IM Fell English', serif;
  font-size: clamp(1rem, 2vw, 1.5rem);
  color: var(--pink);
  text-shadow: 0 0 20px rgba(255,61,180,.5);
  white-space: nowrap;
}
.topbar-author {
  font-size: .58rem; text-transform: uppercase; letter-spacing: .2em;
  color: rgba(255,215,0,.45); white-space: nowrap;
}
.topbar-formula {
  flex: 1;
  text-align: center;
  border: 1px solid rgba(255,215,0,.25);
  border-radius: 6px;
  padding: 6px 16px;
  background: rgba(255,215,0,.04);
  font-size: clamp(.7rem, 1.4vw, .95rem);
  color: #fff;
  white-space: nowrap;
  box-shadow: 0 0 14px rgba(255,215,0,.1);
  min-width: 0;
}
.topbar-formula em { color: var(--gold); font-style: normal; }
.topbar-actions { display: flex; gap: 8px; align-items: center; flex-shrink: 0; }
.topbar-kb {
  font-size: .5rem; color: rgba(255,61,180,.35);
  letter-spacing: .1em; white-space: nowrap;
}

/* Left sidebar */
.col-left {
  grid-area: left;
  border-right: 1px solid rgba(255,61,180,.1);
  overflow-y: auto;
  padding: 16px 14px 40px;
  display: flex;
  flex-direction: column;
  gap: 11px;
  background: rgba(6,6,8,.6);
}

/* Center â€” main visualization */
.col-center {
  grid-area: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px 24px 40px;
  gap: 16px;
  overflow-y: auto;
  min-width: 0;
}

/* Right sidebar */
.col-right {
  grid-area: right;
  border-left: 1px solid rgba(255,61,180,.1);
  overflow-y: auto;
  padding: 16px 14px 40px;
  display: flex;
  flex-direction: column;
  gap: 11px;
  background: rgba(6,6,8,.6);
}

/* Sidebar section headers */
.sidebar-section {
  font-size: .5rem; text-transform: uppercase; letter-spacing: .22em;
  color: rgba(255,61,180,.35); padding: 0 2px; margin-top: 4px;
}
.sidebar-section.gold { color: rgba(255,215,0,.35); }

/* Remove old max-width constraints from panels inside sidebars */
.col-left .panel,
.col-left .harm-panel,
.col-left .smith-panel,
.col-left .coord-panel,
.col-right .panel,
.col-right .gap-panel,
.col-right .harm-panel {
  max-width: none;
  width: 100%;
  margin-top: 0;
}

/* Center canvas sizing */
.col-center .sphere-wrap {
  width: 100%;
  max-width: min(100%, 680px);
}
.col-center #polarCanvas {
  width: 100% !important;
  height: auto !important;
}
.col-center #cartCanvas {
  width: 100% !important;
  height: auto !important;
}
.col-center .live-stats {
  max-width: none;
  width: 100%;
}

/* Preset dropdown in topbar context */
.topbar .preset-drop-wrap {
  max-width: 260px;
  margin: 0;
  flex-shrink: 0;
}
.topbar .preset-drop-header {
  padding: 7px 12px;
}

/* Intro block in left col */
.col-left .intro {
  max-width: none;
  width: 100%;
  margin-bottom: 0;
  border-left: 2px solid rgba(255,61,180,.2);
  padding-left: 12px;
}
.col-left .intro h1 { display: none; } /* title is in topbar */

/* Stats in center */
.col-center .live-stats {
  grid-template-columns: repeat(4, 1fr);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MOBILE â€” single column
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
@media (max-width: 900px) {
  .page-shell {
    grid-template-columns: 1fr;
    grid-template-areas:
      "topbar"
      "center"
      "left"
      "right";
  }
  .col-left, .col-right {
    border: none;
    border-top: 1px solid rgba(255,61,180,.1);
    padding: 14px 12px 28px;
  }
  .col-center { padding: 14px 12px 20px; }
  .topbar { padding: 10px 14px; gap: 10px; }
  .topbar-formula { display: none; }
  .col-center .live-stats { grid-template-columns: repeat(2,1fr); }
}

@media (max-width: 1200px) and (min-width: 901px) {
  .page-shell {
    grid-template-columns: 260px 1fr 280px;
  }
}

/* â”€â”€ Presets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.presets-wrap { max-width: 580px; width: 100%; margin-bottom: 16px; }
.pg-label {
  font-size:.57rem; text-transform:uppercase; letter-spacing:.18em;
  color:rgba(255,61,180,.5); margin-bottom:5px; margin-top:8px; margin-left:2px;
}
.pg-label.gold { color:rgba(255,215,0,.6); }
.presets { display:flex; flex-wrap:wrap; gap:6px; }
.preset-btn {
  font-family:'JetBrains Mono',monospace; font-size:.63rem;
  letter-spacing:.07em; text-transform:uppercase;
  padding:5px 12px; border-radius:20px; cursor:pointer;
  border:1px solid rgba(255,61,180,.25); background:rgba(255,255,255,.03);
  color:#8ab88a; transition:all .15s;
}
.preset-btn:hover { border-color:var(--pink); color:var(--pink); }
.preset-btn.active { background:var(--pink); border-color:var(--pink); color:#000; box-shadow:0 0 12px rgba(255,61,180,.45); }
.preset-btn.gap-active { background:var(--gold); border-color:var(--gold); color:#000; box-shadow:0 0 12px rgba(255,215,0,.45); }

/* â”€â”€ Sphere canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.sphere-wrap {
  width:100%;
  display:flex; flex-direction:column; align-items:center; gap:10px;
}
#polarCanvas {
  display:block; border-radius:50%;
  box-shadow: 0 0 60px rgba(255,61,180,.12), 0 0 120px rgba(255,61,180,.04);
  cursor:grab;
}
#polarCanvas:active { cursor:grabbing; }

.formula-box {
  border:2px solid var(--gold); border-radius:8px;
  padding:9px 20px; background:rgba(255,215,0,.05);
  font-size:clamp(.75rem,2.3vw,.96rem); color:#fff;
  text-align:center; box-shadow:0 0 18px rgba(255,215,0,.18);
}
.formula-box em { color:var(--gold); font-style:normal; }
#cartCanvas { display:block; border-radius:4px; }

/* â”€â”€ Live Stats Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.live-stats {
  width:100%;
  background:rgba(255,215,0,.04); border:1px solid var(--gold-border);
  border-radius:8px; padding:8px 14px;
  display:grid; grid-template-columns:repeat(4,1fr); gap:6px 10px;
}
.stat-cell { display:flex; flex-direction:column; gap:2px; }
.stat-lbl { font-size:.5rem; text-transform:uppercase; letter-spacing:.12em; color:rgba(255,215,0,.45); }
.stat-val { font-size:.7rem; color:var(--gold); font-weight:700; }

/* â”€â”€ Rotation controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.rot-controls {
  display:flex; align-items:center; gap:12px;
  flex-wrap:wrap; justify-content:center; margin-top:2px;
}
.rot-hint { font-size:.62rem; color:rgba(255,61,180,.5); letter-spacing:.08em; }

/* â”€â”€ Panels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.panels { display:flex; flex-direction:column; gap:11px; width:100%; }
.panel { background:var(--surface); border:1px solid var(--border); border-radius:12px; padding:16px 18px; }
.panel.gold-panel { border-color:var(--gold-border); }
.panel-title {
  font-size:.59rem; text-transform:uppercase; letter-spacing:.18em;
  color:var(--pink); margin-bottom:13px;
  display:flex; align-items:center; gap:8px;
}
.panel-title.gold { color:var(--gold); }
.panel-title::after { content:''; flex:1; height:1px; background:var(--border); }
.panel-title.gold::after { background:var(--gold-border); }
.grid-2 { display:grid; grid-template-columns:1fr 1fr; gap:11px 20px; }
.cg { display:flex; flex-direction:column; gap:5px; }
label { font-size:.62rem; color:#88cc88; text-transform:uppercase; letter-spacing:.1em; }
input[type=range] {
  -webkit-appearance:none; width:100%; height:3px;
  background:rgba(255,61,180,.22); border-radius:2px; outline:none; cursor:pointer;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none; width:14px; height:14px; border-radius:50%;
  background:var(--pink); box-shadow:0 0 8px rgba(255,61,180,.9); cursor:pointer;
}
.vd { font-size:.72rem; color:var(--gold); text-align:right; }

/* â”€â”€ Playback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.pb-row { display:grid; grid-template-columns:1fr auto; gap:14px; align-items:end; }
.btn-row { display:flex; gap:9px; flex-wrap:wrap; }
button.ctrl {
  font-family:'JetBrains Mono',monospace; font-size:.7rem;
  letter-spacing:.1em; text-transform:uppercase;
  padding:8px 16px; border-radius:6px; cursor:pointer;
  transition:all .15s; border:1px solid var(--pink);
  background:transparent; color:var(--pink); white-space:nowrap;
}
button.ctrl:hover, button.ctrl.on { background:var(--pink); color:#000; box-shadow:0 0 14px rgba(255,61,180,.5); }
button.ctrl.gold-ctrl { border-color:var(--gold); color:var(--gold); }
button.ctrl.gold-ctrl:hover, button.ctrl.gold-ctrl.on { background:var(--gold); color:#000; box-shadow:0 0 14px rgba(255,215,0,.5); }
.speed-sub { font-size:.58rem; color:rgba(255,215,0,.5); margin-top:-2px; }
.qrow { display:flex; gap:6px; flex-wrap:wrap; margin-top:11px; align-items:center; }
.qlabel { font-size:.59rem; color:#88aa88; text-transform:uppercase; letter-spacing:.1em; }

/* loop toggle */
.loop-row {
  display:flex; align-items:center; gap:10px; margin-top:9px;
  padding-top:9px; border-top:1px solid rgba(255,61,180,.1);
}
.loop-check {
  -webkit-appearance:none; width:32px; height:17px; border-radius:9px;
  background:rgba(255,61,180,.15); border:1px solid rgba(255,61,180,.3);
  cursor:pointer; position:relative; transition:background .2s; flex-shrink:0;
}
.loop-check:checked { background:var(--pink); border-color:var(--pink); }
.loop-check::after {
  content:''; position:absolute; top:2px; left:2px;
  width:11px; height:11px; border-radius:50%; background:#fff;
  transition:transform .2s; box-shadow:0 1px 4px rgba(0,0,0,.4);
}
.loop-check:checked::after { transform:translateX(15px); }
.loop-lbl { font-size:.62rem; color:#88cc88; text-transform:uppercase; letter-spacing:.1em; }
.loop-state { font-size:.57rem; color:rgba(255,215,0,.45); }

/* â”€â”€ Gap Decomposition Panel â”€â”€â”€â”€â”€â”€â”€ */
.gap-panel {
  width:100%; margin-top:0;
  background:var(--surface); border:1px solid var(--gold-border);
  border-radius:12px; overflow:hidden;
}
.gap-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:14px 18px; cursor:pointer; user-select:none;
  border-bottom:1px solid transparent; transition:border-color .2s;
}
.gap-header.open { border-bottom-color:var(--gold-border); }
.gap-header-title {
  font-size:.59rem; text-transform:uppercase; letter-spacing:.18em; color:var(--gold);
}
.gap-chevron { font-size:.75rem; color:var(--gold); transition:transform .25s; }
.gap-chevron.open { transform:rotate(180deg); }
.gap-body { display:none; padding:16px 18px 18px; }
.gap-body.open { display:block; }

/* Gap controls grid */
.gap-ctrl-grid { display:grid; grid-template-columns:1fr 1fr; gap:10px 20px; margin-bottom:12px; }
.gap-ctrl-grid label { color:#88bb88; }
.gap-ctrl-grid input[type=range] { background:rgba(255,215,0,.18); }
.gap-ctrl-grid input[type=range]::-webkit-slider-thumb { background:var(--gold); box-shadow:0 0 8px rgba(255,215,0,.8); }
.gap-vd { font-size:.72rem; color:var(--gold); text-align:right; }

.gap-filter-row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:12px; }
.gap-filter-lbl { font-size:.57rem; color:rgba(255,215,0,.5); text-transform:uppercase; letter-spacing:.12em; }
.gap-filter-btn {
  font-family:'JetBrains Mono',monospace; font-size:.57rem; letter-spacing:.06em;
  text-transform:uppercase; padding:3px 9px; border-radius:12px; cursor:pointer;
  border:1px solid rgba(255,215,0,.25); background:transparent; color:#88aa55; transition:all .12s;
}
.gap-filter-btn:hover { border-color:var(--gold); color:var(--gold); }
.gap-filter-btn.active { background:var(--gold); color:#000; }

.gap-run-row { display:flex; gap:8px; margin-bottom:12px; flex-wrap:wrap; }

/* Status */
.gap-status {
  font-size:.62rem; color:#88cc88; min-height:1.4em;
  border-left:2px solid var(--gold); padding-left:8px;
  margin-bottom:10px; line-height:1.7;
}

/* Progress bar */
.gap-progress { height:3px; background:rgba(255,215,0,.12); border-radius:2px; margin-bottom:10px; overflow:hidden; display:none; }
.gap-progress-fill { height:100%; background:var(--gold); border-radius:2px; width:0%; transition:width .1s; }

/* Live stats grid for gap */
.gap-live-stats {
  display:grid; grid-template-columns:repeat(3,1fr); gap:6px; margin-bottom:12px;
}
.gap-stat {
  background:rgba(255,215,0,.04); border:1px solid rgba(255,215,0,.1);
  border-radius:6px; padding:6px 8px;
}
.gap-stat-lbl { font-size:.48rem; text-transform:uppercase; letter-spacing:.1em; color:rgba(255,215,0,.4); margin-bottom:2px; }
.gap-stat-val { font-size:.68rem; color:var(--gold); font-weight:700; word-break:break-all; }

/* Chart tabs */
.gap-tabs { display:flex; gap:5px; margin-bottom:10px; flex-wrap:wrap; }
.gap-tab {
  font-family:'JetBrains Mono',monospace; font-size:.57rem; letter-spacing:.06em;
  text-transform:uppercase; padding:4px 10px; border-radius:12px; cursor:pointer;
  border:1px solid rgba(255,215,0,.25); background:transparent; color:#88aa55; transition:all .12s;
}
.gap-tab:hover { border-color:var(--gold); color:var(--gold); }
.gap-tab.active { background:var(--gold); color:#000; border-color:var(--gold); }

#gapCanvas { display:block; border-radius:4px; width:100%; background:#060608; }

.gap-legend { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
.gap-leg { display:flex; align-items:center; gap:4px; font-size:.55rem; color:#88aa66; }
.gap-leg-sw { width:9px; height:9px; border-radius:2px; flex-shrink:0; }

/* Export row */
.export-row { display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; padding-top:12px; border-top:1px solid rgba(255,215,0,.1); }

/* Gap presets inside the gap panel */
.gap-wave-presets { margin-bottom:14px; }
.gap-wave-presets .pg-label { font-size:.52rem; margin-top:0; margin-bottom:6px; color:rgba(255,215,0,.5); }
.gap-wave-row { display:flex; flex-wrap:wrap; gap:5px; }
.gap-wave-btn {
  font-family:'JetBrains Mono',monospace; font-size:.57rem; letter-spacing:.06em;
  text-transform:uppercase; padding:4px 10px; border-radius:16px; cursor:pointer;
  border:1px solid rgba(255,215,0,.2); background:rgba(255,215,0,.03);
  color:#88aa55; transition:all .15s;
}
.gap-wave-btn:hover { border-color:var(--gold); color:var(--gold); }
.gap-wave-btn.active { background:var(--gold); border-color:var(--gold); color:#000; }
.gap-wave-btn .n-badge {
  font-size:.48rem; opacity:.7; margin-left:3px;
}

/* â”€â”€ Multi-gap selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.gap-selector-wrap {
  margin-bottom:13px;
}
.gap-selector-label {
  font-size:.55rem; text-transform:uppercase; letter-spacing:.14em;
  color:rgba(255,215,0,.55); margin-bottom:6px;
  display:flex; align-items:center; gap:10px; flex-wrap:wrap;
}
.gap-selector-label span { opacity:.6; font-size:.5rem; }
.gap-chips { display:flex; flex-wrap:wrap; gap:5px; }
.gap-chip {
  font-family:'JetBrains Mono',monospace; font-size:.6rem;
  letter-spacing:.06em; padding:3px 9px; border-radius:14px;
  cursor:pointer; border:2px solid transparent;
  background:rgba(255,255,255,.04); color:#667766;
  transition:all .12s; position:relative; user-select:none;
}
.gap-chip:hover { color:#aaccaa; border-color:rgba(255,255,255,.15); }
.gap-chip.selected {
  color:#000 !important; font-weight:700;
  box-shadow:0 0 10px currentColor;
}
.gap-chip .chip-dot {
  display:inline-block; width:6px; height:6px; border-radius:50%;
  margin-right:4px; vertical-align:middle; background:currentColor;
}

/* â”€â”€ Thickness slider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.thick-row {
  display:flex; align-items:center; gap:12px; margin-bottom:12px;
  padding:8px 10px; background:rgba(255,215,0,.03);
  border:1px solid rgba(255,215,0,.1); border-radius:8px;
}
.thick-row label { color:#88bb88; font-size:.6rem; white-space:nowrap; flex-shrink:0; }
.thick-row input[type=range] { flex:1; background:rgba(255,215,0,.18); }
.thick-row input[type=range]::-webkit-slider-thumb { background:var(--gold); box-shadow:0 0 8px rgba(255,215,0,.8); }
.thick-val { font-size:.7rem; color:var(--gold); min-width:28px; text-align:right; }

/* â”€â”€ All-gaps stats table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.gap-table-wrap {
  margin-top:12px; overflow-x:auto;
  border:1px solid rgba(255,215,0,.15); border-radius:8px;
}
.gap-table-controls {
  display:flex; gap:8px; flex-wrap:wrap; align-items:center;
  padding:8px 12px; background:rgba(255,215,0,.03);
  border-bottom:1px solid rgba(255,215,0,.1);
}
.gap-table-controls label { font-size:.55rem; color:#88bb88; white-space:nowrap; }
.gap-table-controls select, .gap-table-controls input {
  font-family:'JetBrains Mono',monospace; font-size:.6rem;
  background:#0a0c0a; border:1px solid rgba(255,215,0,.25); color:var(--gold);
  padding:3px 6px; border-radius:4px; cursor:pointer;
}
#gdTableWrap table {
  width:100%; border-collapse:collapse; font-size:.6rem;
  font-family:'JetBrains Mono',monospace;
}
#gdTableWrap th {
  position:sticky; top:0; background:#0a0a08;
  color:rgba(255,215,0,.7); font-size:.52rem; text-transform:uppercase;
  letter-spacing:.1em; padding:5px 8px; text-align:right;
  border-bottom:1px solid rgba(255,215,0,.2); white-space:nowrap;
}
#gdTableWrap th:first-child { text-align:left; }
#gdTableWrap td {
  padding:4px 8px; text-align:right; border-bottom:1px solid rgba(255,215,0,.05);
  white-space:nowrap; color:#8aaa8a;
}
#gdTableWrap td:first-child { text-align:left; }
#gdTableWrap tr:hover td { background:rgba(255,215,0,.04); }
#gdTableWrap tr.gap-row-selected td { background:rgba(255,215,0,.06); }
#gdTableWrap td.gap-id { font-weight:700; }
#gdTableWrap { max-height:340px; overflow-y:auto; }

/* â”€â”€ Convergence dropdown table â”€â”€â”€â”€â”€ */
.conv-dropdown-wrap {
  margin-top:14px;
  border:1px solid rgba(255,215,0,.15); border-radius:8px; overflow:hidden;
}
.conv-dropdown-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:9px 14px; background:rgba(255,215,0,.04); cursor:pointer;
  user-select:none;
}
.conv-dropdown-title { font-size:.57rem; text-transform:uppercase; letter-spacing:.16em; color:var(--gold); }
.conv-dropdown-chevron { font-size:.7rem; color:var(--gold); transition:transform .2s; }
.conv-dropdown-chevron.open { transform:rotate(180deg); }
.conv-dropdown-body { display:none; }
.conv-dropdown-body.open { display:block; }
.conv-table-controls {
  display:flex; gap:10px; flex-wrap:wrap; align-items:center;
  padding:8px 12px; background:rgba(255,215,0,.02);
  border-bottom:1px solid rgba(255,215,0,.08);
}
.conv-table-controls label { font-size:.55rem; color:#88bb88; white-space:nowrap; }
.conv-table-controls select, .conv-table-controls input[type=number] {
  font-family:'JetBrains Mono',monospace; font-size:.6rem;
  background:#0a0c0a; border:1px solid rgba(255,215,0,.25); color:var(--gold);
  padding:3px 6px; border-radius:4px; width:56px;
}
.conv-table-controls select { width:auto; }
#gdConvTableWrap { max-height:400px; overflow-y:auto; }
#gdConvTableWrap table { width:100%; border-collapse:collapse; font-size:.58rem; font-family:'JetBrains Mono',monospace; }
#gdConvTableWrap th {
  position:sticky; top:0; background:#0a0a08;
  color:rgba(255,215,0,.65); font-size:.5rem; text-transform:uppercase;
  letter-spacing:.1em; padding:5px 7px; text-align:right;
  border-bottom:1px solid rgba(255,215,0,.2); white-space:nowrap;
}
#gdConvTableWrap th:first-child, #gdConvTableWrap th:nth-child(2) { text-align:left; }
#gdConvTableWrap td {
  padding:3px 7px; text-align:right; border-bottom:1px solid rgba(255,215,0,.04);
  white-space:nowrap;
}
#gdConvTableWrap td:first-child, #gdConvTableWrap td:nth-child(2) { text-align:left; }
#gdConvTableWrap tr:hover td { background:rgba(255,215,0,.04); }
.conv-row-improving td { color:#88cc88; }
.conv-row-worsening td { color:#cc8888; }
.conv-row-best td { color:#ffd700 !important; font-weight:700; }
.conv-cell-product { color:#4ecdc4; }
.conv-cell-pi { color:#ff3db4; }
.conv-cell-err { color:#f97316; }
.conv-cell-logerr { color:#a855f7; }
.conv-cell-gap { color:var(--gold); font-weight:700; }

/* â”€â”€ Harmonics Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.harm-panel {
  max-width:560px; width:100%; margin-top:0;
  background:var(--surface); border:1px solid rgba(100,180,255,.2);
  border-radius:12px; overflow:hidden;
}
.harm-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:13px 18px; cursor:pointer; user-select:none;
  border-bottom:1px solid transparent; transition:border-color .2s;
}
.harm-header.open { border-bottom-color:rgba(100,180,255,.2); }
.harm-header-title { font-size:.59rem; text-transform:uppercase; letter-spacing:.18em; color:#60a5fa; }
.harm-chevron { font-size:.75rem; color:#60a5fa; transition:transform .25s; }
.harm-chevron.open { transform:rotate(180deg); }
.harm-body { display:none; padding:14px 18px 18px; }
.harm-body.open { display:block; }

.harm-section-title {
  font-size:.52rem; text-transform:uppercase; letter-spacing:.14em;
  color:rgba(100,180,255,.55); margin-bottom:8px; margin-top:12px;
}
.harm-section-title:first-child { margin-top:0; }

/* Interval grid */
.harm-interval-grid {
  display:flex; flex-wrap:wrap; gap:5px; margin-bottom:10px;
}
.harm-interval-btn {
  font-family:'JetBrains Mono',monospace; font-size:.6rem;
  letter-spacing:.06em; padding:4px 10px; border-radius:14px;
  cursor:pointer; border:1px solid rgba(100,180,255,.25);
  background:rgba(100,180,255,.04); color:#60a5fa66;
  transition:all .12s;
}
.harm-interval-btn:hover { border-color:#60a5fa; color:#60a5fa; }
.harm-interval-btn.active {
  background:#60a5fa; border-color:#60a5fa; color:#000; font-weight:700;
  box-shadow:0 0 10px rgba(96,165,250,.4);
}
.harm-interval-btn .ratio-badge { font-size:.48rem; opacity:.7; margin-left:3px; }

/* Consonance color key */
.harm-consonance-key {
  display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px;
}
.harm-cons-pill {
  font-size:.53rem; padding:2px 8px; border-radius:10px;
  display:flex; align-items:center; gap:4px;
}
.harm-cons-dot { width:7px; height:7px; border-radius:50%; flex-shrink:0; }

/* Audio row */
.harm-audio-row {
  display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:10px;
}
.harm-freq-display {
  font-size:.9rem; color:#60a5fa; font-weight:700; text-align:center;
  padding:8px; background:rgba(96,165,250,.08); border:1px solid rgba(96,165,250,.2);
  border-radius:6px; letter-spacing:.05em;
}
.harm-note-display {
  font-size:.7rem; color:#a3e635; text-align:center;
  padding:8px; background:rgba(163,230,53,.06); border:1px solid rgba(163,230,53,.15);
  border-radius:6px;
}

.harm-btn-row { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px; }
.harm-btn {
  font-family:'JetBrains Mono',monospace; font-size:.65rem;
  letter-spacing:.08em; text-transform:uppercase; padding:7px 14px;
  border-radius:6px; cursor:pointer; border:1px solid rgba(96,165,250,.35);
  background:transparent; color:#60a5fa; transition:all .15s;
}
.harm-btn:hover, .harm-btn.on { background:#60a5fa; color:#000; box-shadow:0 0 12px rgba(96,165,250,.4); }

/* Harmonic mode toggle */
.harm-mode-row {
  display:flex; align-items:center; gap:10px; margin-top:8px;
  padding-top:8px; border-top:1px solid rgba(96,165,250,.1);
}
.harm-toggle {
  -webkit-appearance:none; width:32px; height:17px; border-radius:9px;
  background:rgba(96,165,250,.15); border:1px solid rgba(96,165,250,.3);
  cursor:pointer; position:relative; transition:background .2s; flex-shrink:0;
}
.harm-toggle:checked { background:#60a5fa; border-color:#60a5fa; }
.harm-toggle::after {
  content:''; position:absolute; top:2px; left:2px;
  width:11px; height:11px; border-radius:50%; background:#fff;
  transition:transform .2s; box-shadow:0 1px 4px rgba(0,0,0,.4);
}
.harm-toggle:checked::after { transform:translateX(15px); }
.harm-lbl { font-size:.62rem; color:#88cc88; text-transform:uppercase; letter-spacing:.1em; }
.harm-state { font-size:.57rem; color:rgba(96,165,250,.45); }

/* Arnold tongue mini display */
.arnold-row { display:flex; gap:10px; align-items:center; margin-bottom:8px; }
.arnold-val { font-size:.65rem; color:#e879f9; min-width:32px; text-align:right; }


/* â”€â”€ Zoom & Pan overlay controls â”€â”€â”€ */
.zoom-bar {
  display:flex; align-items:center; gap:8px; margin-top:6px;
  justify-content:center; flex-wrap:wrap;
}
.zoom-btn {
  font-family:'JetBrains Mono',monospace; font-size:.75rem;
  width:32px; height:32px; border-radius:50%; cursor:pointer;
  border:1px solid rgba(255,61,180,.35); background:rgba(255,61,180,.07);
  color:var(--pink); display:flex; align-items:center; justify-content:center;
  transition:all .15s; flex-shrink:0; font-weight:700;
}
.zoom-btn:hover { background:var(--pink); color:#000; box-shadow:0 0 10px rgba(255,61,180,.5); }
.zoom-level-lbl {
  font-size:.6rem; color:rgba(255,215,0,.7); min-width:44px; text-align:center;
  letter-spacing:.08em;
}
.zoom-reset-btn {
  font-family:'JetBrains Mono',monospace; font-size:.58rem;
  padding:4px 10px; border-radius:12px; cursor:pointer;
  border:1px solid rgba(255,215,0,.3); background:transparent;
  color:rgba(255,215,0,.7); transition:all .15s;
}
.zoom-reset-btn:hover { background:var(--gold); color:#000; }

/* canvas pan cursor */
#polarCanvas.panning { cursor:move !important; }

/* â”€â”€ Smith / Cayley panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.smith-panel {
  max-width:560px; width:100%; margin-top:0;
  background:var(--surface); border:1px solid rgba(96,165,250,.22);
  border-radius:12px; overflow:hidden;
}
.smith-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:13px 18px; cursor:pointer; user-select:none;
  border-bottom:1px solid transparent; transition:border-color .2s;
}
.smith-header.open { border-bottom-color:rgba(96,165,250,.22); }
.smith-header-title { font-size:.59rem; text-transform:uppercase; letter-spacing:.18em; color:#60a5fa; }
.smith-chevron { font-size:.75rem; color:#60a5fa; transition:transform .25s; }
.smith-chevron.open { transform:rotate(180deg); }
.smith-body { display:none; padding:14px 18px 18px; }
.smith-body.open { display:block; }
.smith-info {
  font-size:.6rem; color:rgba(96,165,250,.6); line-height:1.8;
  background:rgba(96,165,250,.04); border:1px solid rgba(96,165,250,.12);
  border-radius:6px; padding:10px 12px; margin-top:10px;
}
.smith-info strong { color:#60a5fa; }

/* â”€â”€ Coord Mode panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.coord-panel {
  max-width:560px; width:100%; margin-top:0;
  background:var(--surface); border:1px solid rgba(163,230,53,.18);
  border-radius:12px; overflow:hidden;
}
.coord-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:13px 18px; cursor:pointer; user-select:none;
  border-bottom:1px solid transparent; transition:border-color .2s;
}
.coord-header.open { border-bottom-color:rgba(163,230,53,.2); }
.coord-header-title { font-size:.59rem; text-transform:uppercase; letter-spacing:.18em; color:#a3e635; }
.coord-chevron { font-size:.75rem; color:#a3e635; transition:transform .25s; }
.coord-chevron.open { transform:rotate(180deg); }
.coord-body { display:none; padding:14px 18px 18px; }
.coord-body.open { display:block; }
.coord-mode-grid { display:flex; flex-wrap:wrap; gap:6px; margin-bottom:12px; }
.coord-mode-btn {
  font-family:'JetBrains Mono',monospace; font-size:.6rem; letter-spacing:.06em;
  text-transform:uppercase; padding:5px 12px; border-radius:14px; cursor:pointer;
  border:1px solid rgba(163,230,53,.25); background:rgba(163,230,53,.04);
  color:#a3e635aa; transition:all .14s;
}
.coord-mode-btn:hover { border-color:#a3e635; color:#a3e635; }
.coord-mode-btn.active { background:#a3e635; color:#000; border-color:#a3e635; box-shadow:0 0 10px rgba(163,230,53,.35); }

/* â”€â”€ Keyboard shortcuts hint â”€â”€â”€â”€â”€â”€â”€â”€ */
.kb-hint {
  font-size:.52rem; color:rgba(255,61,180,.35); text-align:center;
  letter-spacing:.1em; margin-top:4px;
}


.intro-body {
  font-size:.63rem; line-height:1.7; color:rgba(216,240,216,.5);
  font-family:'JetBrains Mono',monospace;
}
.intro-body p { margin-bottom:.5em; }
.intro-body p:last-child { margin-bottom:0; }

/* â”€â”€ Side cards & labels â”€â”€â”€â”€â”€â”€â”€â”€ */
.sidebar-label {
  font-size:.48rem; text-transform:uppercase; letter-spacing:.24em;
  color:rgba(255,61,180,.4); padding:0 2px; margin-top:6px;
}
.sidebar-label.gold { color:rgba(255,215,0,.4); }
.sidebar-label:first-child { margin-top:0; }

.side-card {
  background:var(--surface); border:1px solid var(--border);
  border-radius:10px; padding:13px 14px; width:100%;
}
.side-card.gap-card { border-color:var(--gold-border); padding:0; overflow:hidden; }
.side-card.gap-card .gap-panel { border:none; border-radius:0; }
.intro-card { border-color:rgba(255,61,180,.12); }

/* Topbar brand */
.topbar-brand { display:flex; flex-direction:column; gap:2px; flex-shrink:0; }

/* Center canvas sizing */
.col-center .sphere-wrap {
  width:100%; max-width:640px;
  display:flex; flex-direction:column; align-items:center; gap:10px;
}
.col-center #polarCanvas { width:100% !important; height:auto !important; }
.col-center #cartCanvas  { width:100% !important; height:auto !important; max-width:640px; border-radius:4px; }
.col-center .live-stats  { max-width:640px; width:100%; grid-template-columns:repeat(4,1fr); }

/* â”€â”€ Preset dropdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.preset-drop-wrap { width:100%; margin-bottom:0; }
.preset-drop-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:9px 12px; cursor:pointer; user-select:none;
  background:rgba(255,61,180,.04); border:1px solid rgba(255,61,180,.18);
  border-radius:8px; transition:border-color .2s;
}
.preset-drop-header.open { border-radius:8px 8px 0 0; border-color:rgba(255,61,180,.32); }
.preset-drop-title { font-size:.56rem; text-transform:uppercase; letter-spacing:.2em; color:var(--pink); }
.preset-active-name { font-size:.56rem; color:rgba(255,215,0,.7); letter-spacing:.06em; }
.preset-drop-chevron { font-size:.7rem; color:var(--pink); transition:transform .22s; }
.preset-drop-chevron.open { transform:rotate(180deg); }
.preset-drop-body {
  display:none; padding:12px 12px 14px;
  background:rgba(255,61,180,.02); border:1px solid rgba(255,61,180,.18);
  border-top:none; border-radius:0 0 8px 8px;
}
.preset-drop-body.open { display:block; }

</style>
</head>
<body>
<div class="page-shell">

  <!-- â•â• TOP BAR â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <header class="topbar">
    <div class="topbar-brand">
      <div class="topbar-title">Polar vs Cartesian</div>
      <div class="topbar-author">Wessen Getachew</div>
    </div>

    <div class="topbar-formula">
      f(Î¸) = <em id="fA">1.9</em> + sin(<em id="fB">3</em>Î¸) Â· sin(<em id="fC">3</em>Î¸ / <em id="fD">32</em>)
    </div>

    <div class="topbar-actions">
      <button class="ctrl" id="btnPlay">â–¶ Play</button>
      <button class="ctrl" id="btnReset">â†º Reset</button>
      <button class="ctrl gold-ctrl" id="btnExport4K" title="Export 4K PNG">â¬‡ 4K</button>
      <button class="ctrl" id="btnAutoRot">âŸ³ Rotate</button>
    </div>
  </header>

  <!-- â•â• LEFT SIDEBAR â€” Controls â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <aside class="col-left">

    <!-- About -->
    <div class="sidebar-label">About</div>
    <div class="side-card intro-card">
      <div class="intro-body">
        <p>f(Î¸) = A + sin(BÎ¸)Â·sin(CÎ¸/D) drawn polar and Cartesian simultaneously. Polar trace wraps onto a 3D sphere; Cartesian runs in the center panel.</p>
        <p>Gap decomposition sieves primes up to N, groups by consecutive gap, shows each family's contribution to Î¶(s) â€” select any gap to highlight it across both views.</p>
        <p>Harmonics play Farey intervals in sync with the animation, coloring the sphere by consonance. Smith Chart maps the curve through Î“ = (zâˆ’1)/(z+1) onto the unit disk.</p>
      </div>
    </div>

    <!-- Presets -->
    <div class="sidebar-label">Presets</div>
    <div class="side-card">
      <div class="preset-drop-wrap" style="max-width:none;margin:0">
        <div class="preset-drop-header" id="presetDropHeader">
          <div class="preset-drop-title">Select Preset</div>
          <span class="preset-active-name" id="presetActiveName">Original</span>
          <span class="preset-drop-chevron" id="presetDropChev">â–¼</span>
        </div>
        <div class="preset-drop-body" id="presetDropBody">
          <div class="pg-label">Classics</div><div class="presets" id="pgClassic"></div>
          <div class="pg-label">Complex</div><div class="presets" id="pgComplex"></div>
          <div class="pg-label">Organic</div><div class="presets" id="pgOrganic"></div>
          <div class="pg-label">Geometric</div><div class="presets" id="pgGeo"></div>
          <div class="pg-label">Ethereal</div><div class="presets" id="pgEth"></div>
        </div>
      </div>
    </div>

    <!-- Formula Parameters -->
    <div class="sidebar-label">Formula Parameters</div>
    <div class="side-card">
      <div class="grid-2">
        <div class="cg"><label>A â€” offset</label><input type="range" id="sA" min="0.1" max="4" step="0.05" value="1.9"><div class="vd" id="dA">1.9</div></div>
        <div class="cg"><label>B â€” outer freq</label><input type="range" id="sB" min="1" max="12" step="0.5" value="3"><div class="vd" id="dB">3</div></div>
        <div class="cg"><label>C â€” inner freq</label><input type="range" id="sC" min="1" max="12" step="0.5" value="3"><div class="vd" id="dC">3</div></div>
        <div class="cg"><label>D â€” modulation</label><input type="range" id="sD" min="4" max="128" step="1" value="32"><div class="vd" id="dD">32</div></div>
        <div class="cg"><label>Î¸ range (Ã— Ï€)</label><input type="range" id="sTheta" min="2" max="300" step="1" value="64"><div class="vd" id="dTheta">64Ï€</div></div>
        <div class="cg"><label>Trail / History</label><input type="range" id="sTrail" min="1" max="40" step="1" value="6"><div class="vd" id="dTrail">6</div></div>
      </div>
    </div>

    <!-- Playback -->
    <div class="sidebar-label">Playback</div>
    <div class="side-card">
      <div class="cg" style="margin-bottom:10px">
        <label>Draw speed</label>
        <input type="range" id="sSpeed" min="0.05" max="40" step="0.05" value="8">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="speed-sub" id="speedDesc">normal</div>
          <div class="vd" id="dSpeed">8.0</div>
        </div>
      </div>
      <div class="loop-row">
        <input type="checkbox" class="loop-check" id="cbLoop">
        <span class="loop-lbl">Loop</span>
        <span class="loop-state" id="loopState">off â€” stops at end</span>
      </div>
      <div class="qrow" style="margin-top:10px">
        <span class="qlabel">Quick:</span>
        <button class="ctrl" style="font-size:.58rem;padding:3px 7px" onclick="setSpeed(0.1)">Ã—0.1</button>
        <button class="ctrl" style="font-size:.58rem;padding:3px 7px" onclick="setSpeed(2)">Slow</button>
        <button class="ctrl" style="font-size:.58rem;padding:3px 7px" onclick="setSpeed(8)">Normal</button>
        <button class="ctrl" style="font-size:.58rem;padding:3px 7px" onclick="setSpeed(20)">Fast</button>
        <button class="ctrl" style="font-size:.58rem;padding:3px 7px" onclick="setSpeed(40)">Max</button>
      </div>
    </div>

    <!-- Coordinate Mode -->
    <div class="sidebar-label">Coordinate Mode</div>
    <div class="side-card" id="coordPanel">
      <div class="coord-mode-grid" id="coordModeGrid">
        <button class="coord-mode-btn active" data-mode="polar">âŠ™ Polar</button>
        <button class="coord-mode-btn" data-mode="logcylinder">âŒ‡ Log-Cyl</button>
        <button class="coord-mode-btn" data-mode="logspiral">ğŸŒ€ Spiral</button>
        <button class="coord-mode-btn" data-mode="poincare">â¬¤ PoincarÃ©</button>
      </div>
      <div style="font-size:.58rem;color:rgba(163,230,53,.5);line-height:1.6;margin:8px 0" id="coordModeDesc">Polar/spherical â€” default.</div>
      <div class="cg">
        <label style="color:#88cc88">Blend</label>
        <input type="range" id="coordBlend" min="0" max="1" step="0.01" value="1" style="background:rgba(163,230,53,.2)">
        <div style="font-size:.65rem;color:#a3e635;text-align:right" id="coordBlendVal">100%</div>
      </div>
    </div>

    <!-- Smith Chart -->
    <div class="sidebar-label">Smith Chart Â· Cayley Map</div>
    <div class="side-card" id="smithPanel">
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">
        <input type="checkbox" class="harm-toggle" id="smithEnable">
        <span class="harm-lbl">Enable Overlay</span>
        <span class="harm-state" id="smithState">off</span>
      </div>
      <div class="grid-2">
        <div class="cg">
          <label style="color:#88bb88">Phase Shift Î±</label>
          <input type="range" id="smithAlpha" min="0" max="360" step="1" value="0" style="background:rgba(96,165,250,.2)">
          <div class="vd" id="smithAlphaVal" style="color:#60a5fa">0Â°</div>
        </div>
        <div class="cg">
          <label style="color:#88bb88">Opacity</label>
          <input type="range" id="smithOpacity" min="0.05" max="1" step="0.05" value="0.4" style="background:rgba(96,165,250,.2)">
          <div class="vd" id="smithOpacityVal" style="color:#60a5fa">40%</div>
        </div>
      </div>
      <select id="smithRadiusMode" style="font-family:'JetBrains Mono',monospace;font-size:.6rem;background:#0a0c0a;border:1px solid rgba(96,165,250,.25);color:#60a5fa;padding:4px 6px;border-radius:4px;width:100%;margin:8px 0">
        <option value="unit">Unit Radius (R=1)</option>
        <option value="index" selected>Scaled by Index</option>
        <option value="modulus">By Modulus Value</option>
      </select>
      <div style="display:flex;gap:10px;flex-wrap:wrap">
        <label style="display:flex;align-items:center;gap:5px;font-size:.58rem;color:#88cc88;cursor:pointer"><input type="checkbox" id="smithShowGrid" checked> Grid</label>
        <label style="display:flex;align-items:center;gap:5px;font-size:.58rem;color:#88cc88;cursor:pointer"><input type="checkbox" id="smithShowR" checked> R-Circles</label>
        <label style="display:flex;align-items:center;gap:5px;font-size:.58rem;color:#88cc88;cursor:pointer"><input type="checkbox" id="smithShowX" checked> X-Arcs</label>
      </div>
      <div style="font-size:.55rem;color:rgba(96,165,250,.45);margin-top:8px;line-height:1.6">Î“ = (zâˆ’1)/(z+1) Â· conformal map to unit disk</div>
    </div>

  </aside>

  <!-- â•â• CENTER â€” Visualization â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <main class="col-center">

    <!-- Sphere canvas -->
    <div class="sphere-wrap">
      <canvas id="polarCanvas"></canvas>

      <div class="rot-controls">
        <span class="rot-hint">drag to rotate Â· shift+drag to pan</span>
        <button class="ctrl" id="btnResetRot" style="font-size:.6rem;padding:5px 10px">â†º Reset View</button>
      </div>

      <div class="zoom-bar">
        <button class="zoom-btn" id="btnZoomOut">âˆ’</button>
        <span class="zoom-level-lbl" id="zoomLbl">1.0Ã—</span>
        <button class="zoom-btn" id="btnZoomIn">+</button>
        <button class="zoom-reset-btn" id="btnZoomReset">Reset Zoom</button>
      </div>
      <div class="kb-hint">Space=Play Â· R=Rotate Â· S=Screenshot Â· â†‘â†“=Zoom Â· â†â†’=Spin</div>
    </div>

    <!-- Cartesian canvas -->
    <canvas id="cartCanvas"></canvas>

    <!-- Live stats bar -->
    <div class="live-stats" id="liveStats">
      <div class="stat-cell"><div class="stat-lbl">Progress</div><div class="stat-val" id="stProg">0%</div></div>
      <div class="stat-cell"><div class="stat-lbl">Î¸ current</div><div class="stat-val" id="stTheta">0</div></div>
      <div class="stat-cell"><div class="stat-lbl">f(Î¸) now</div><div class="stat-val" id="stFTheta">â€”</div></div>
      <div class="stat-cell"><div class="stat-lbl">f(Î¸) min</div><div class="stat-val" id="stFMin">â€”</div></div>
      <div class="stat-cell"><div class="stat-lbl">f(Î¸) max</div><div class="stat-val" id="stFMax">â€”</div></div>
      <div class="stat-cell"><div class="stat-lbl">f(Î¸) mean</div><div class="stat-val" id="stFMean">â€”</div></div>
      <div class="stat-cell"><div class="stat-lbl">Pts drawn</div><div class="stat-val" id="stPts">0</div></div>
      <div class="stat-cell"><div class="stat-lbl">Î¸ total</div><div class="stat-val" id="stThetaMax">64Ï€</div></div>
    </div>

  </main>

  <!-- â•â• RIGHT SIDEBAR â€” Analysis â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•= -->
  <aside class="col-right">

    <!-- Harmonics -->
    <div class="sidebar-label">Harmonics Â· Farey Intervals</div>
    <div class="side-card" id="harmPanel">
      <div class="harm-mode-row" style="margin-top:0;padding-top:0;border-top:none;margin-bottom:10px">
        <input type="checkbox" class="harm-toggle" id="harmColorMode">
        <span class="harm-lbl">Color Mode</span>
        <span class="harm-state" id="harmModeState">off</span>
      </div>
      <div class="harm-section-title">Farey Intervals</div>
      <div class="harm-interval-grid" id="harmIntervalGrid"></div>
      <div class="harm-consonance-key" style="margin-top:6px">
        <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#22c55e"></div><span style="color:#22c55e;font-size:.5rem">1:1</span></div>
        <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#60a5fa"></div><span style="color:#60a5fa;font-size:.5rem">qâ‰¤4</span></div>
        <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#ffd700"></div><span style="color:#ffd700;font-size:.5rem">qâ‰¤16</span></div>
        <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#f97316"></div><span style="color:#f97316;font-size:.5rem">qâ‰¤64</span></div>
        <div class="harm-cons-pill"><div class="harm-cons-dot" style="background:#a855f7"></div><span style="color:#a855f7;font-size:.5rem">q>64</span></div>
      </div>
      <div class="harm-audio-row" style="margin-top:8px">
        <div class="harm-freq-display" id="harmFreqDisplay">â€” Hz</div>
        <div class="harm-note-display" id="harmNoteDisplay">â€” Â· â€”</div>
      </div>
      <div class="harm-section-title">Audio</div>
      <div class="harm-btn-row">
        <button class="harm-btn" id="harmPlayBtn" onclick="harmPlay()">â–¶ Play</button>
        <button class="harm-btn" id="harmChordBtn" onclick="harmChord()">â™ª Chord</button>
        <button class="harm-btn" id="harmArpBtn" onclick="harmArp()">âˆ¿ Arp</button>
        <button class="harm-btn" onclick="harmStop()">â–  Stop</button>
      </div>
      <div style="display:flex;gap:10px;margin-top:6px">
        <div class="cg" style="flex:1">
          <label style="font-size:.55rem;color:#88bb88">Base Hz</label>
          <input type="range" id="harmBaseHz" min="110" max="880" step="1" value="220" style="background:rgba(96,165,250,.2)">
          <div class="vd" id="harmBaseHzVal" style="color:#60a5fa;font-size:.62rem">220 Hz</div>
        </div>
        <div class="cg" style="flex:1">
          <label style="font-size:.55rem;color:#88bb88">Volume</label>
          <input type="range" id="harmVol" min="0" max="5" step="0.05" value="0.35" style="background:rgba(96,165,250,.2)">
          <div class="vd" id="harmVolVal" style="color:#60a5fa;font-size:.62rem">35%</div>
        </div>
        <div class="cg" style="flex:1">
          <label style="font-size:.55rem;color:#88bb88">Wave</label>
          <select id="harmWave" style="font-family:'JetBrains Mono',monospace;font-size:.58rem;background:#0a0c0a;border:1px solid rgba(96,165,250,.25);color:#60a5fa;padding:3px 4px;border-radius:4px;width:100%">
            <option value="sine">Sine</option>
            <option value="triangle">Triangle</option>
            <option value="square">Square</option>
            <option value="sawtooth">Saw</option>
          </select>
        </div>
      </div>
      <div class="harm-section-title">Arnold Tongue Â· Warp</div>
      <div class="arnold-row">
        <label style="font-size:.55rem;color:#88bb88;flex-shrink:0">K</label>
        <input type="range" id="harmArnold" min="0" max="2" step="0.01" value="0" style="flex:1;background:rgba(232,121,249,.2)">
        <span class="arnold-val" id="harmArnoldVal">0.00</span>
        <button class="harm-btn" style="font-size:.52rem;padding:3px 7px" onclick="applyArnoldWarp()">Apply</button>
        <button class="harm-btn" style="font-size:.52rem;padding:3px 7px" onclick="resetArnold()">Reset</button>
      </div>
    </div>

    <!-- Gap Decomposition -->
    <div class="sidebar-label gold">Gap Decomposition Â· Î¶(s)</div>
    <div class="side-card gap-card" id="gapPanelWrap">

<!-- â•â• Gap Decomposition Panel â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="gap-panel panels" style="margin-top:11px">
  <div class="gap-header" id="gapHeader">
    <div class="gap-header-title">âš¡ Gap Decomposition &amp; Î¶(s) Analysis</div>
    <span class="gap-chevron" id="gapChevron">â–¼</span>
  </div>
  <div class="gap-body" id="gapBody">

    <!-- Controls -->
    <div class="gap-ctrl-grid">
      <div class="cg">
        <label>Max N (primes up to)</label>
        <input type="range" id="gdN" min="100000" max="300000000" step="100000" value="10000000">
        <div class="gap-vd" id="gdND">10,000,000</div>
      </div>
      <div class="cg">
        <label>Î¶ exponent s</label>
        <input type="range" id="gdS" min="1.01" max="10" step="0.01" value="2">
        <div class="gap-vd" id="gdSD" style="color:var(--gold)">s = 2.00</div>
      </div>
    </div>

    <div class="gap-filter-row">
      <span class="gap-filter-lbl">Gap filter:</span>
      <button class="gap-filter-btn active" data-filter="all" onclick="setGapFilter(this,'all')">All</button>
      <button class="gap-filter-btn" data-filter="tiny" onclick="setGapFilter(this,'tiny')">2â€“10</button>
      <button class="gap-filter-btn" data-filter="small" onclick="setGapFilter(this,'small')">2â€“30</button>
      <button class="gap-filter-btn" data-filter="medium" onclick="setGapFilter(this,'medium')">20â€“80</button>
      <button class="gap-filter-btn" data-filter="large" onclick="setGapFilter(this,'large')">50â€“200</button>
    </div>

    <div class="gap-run-row">
      <button class="ctrl gold-ctrl" id="gdRunBtn" onclick="gdRun()">â–¶ Compute</button>
      <button class="ctrl gold-ctrl" onclick="gdClear()" style="font-size:.63rem;padding:6px 11px">âœ• Clear</button>
      <button class="ctrl gold-ctrl" id="gdExportPNG" onclick="gdExport4K()" style="display:none">â¬‡ 4K PNG</button>
      <button class="ctrl gold-ctrl" id="gdExportCSV" onclick="gdExportCSV()" style="display:none">â¬‡ Full CSV</button>
      <button class="ctrl gold-ctrl" id="gdExportTXT" onclick="gdExportTXT()" style="display:none">â¬‡ Report TXT</button>
    </div>

    <!-- Thickness & gap multi-selector (always visible for viz panel) -->
    <div class="thick-row">
      <label>Trace Thickness</label>
      <input type="range" id="gdThick" min="0.5" max="8" step="0.5" value="1.35">
      <span class="thick-val" id="gdThickVal">1.35px</span>
    </div>

    <!-- Multi-gap color selector â€” populated after compute -->
    <div class="gap-selector-wrap" id="gdSelectorWrap" style="display:none">
      <div class="gap-selector-label">
        Click gaps to highlight on sphere &amp; cart
        <span>â€” each gets its own color; deselect to remove</span>
        <button class="gap-filter-btn" onclick="gdClearSelection()" style="margin-left:auto">âœ• Clear all</button>
      </div>
      <div class="gap-chips" id="gdChips"></div>
    </div>

    <div class="gap-progress" id="gdProgress"><div class="gap-progress-fill" id="gdProgressFill"></div></div>
    <div class="gap-status" id="gdStatus">Run decomposition to analyze prime gap contributions to Î¶(s). Default: 10M primes.</div>

    <!-- Live stats -->
    <div class="gap-live-stats" id="gdStatsGrid" style="display:none">
      <div class="gap-stat"><div class="gap-stat-lbl">Total primes</div><div class="gap-stat-val" id="gst0">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Gap families</div><div class="gap-stat-val" id="gst1">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Max gap</div><div class="gap-stat-val" id="gst2">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Target Î¶(s)</div><div class="gap-stat-val" id="gst3">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Computed product</div><div class="gap-stat-val" id="gst4">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Rel. error</div><div class="gap-stat-val" id="gst5">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Twin primes (g=2)</div><div class="gap-stat-val" id="gst6">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Cousin primes (g=4)</div><div class="gap-stat-val" id="gst7">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Sexy primes (g=6)</div><div class="gap-stat-val" id="gst8">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Most common gap</div><div class="gap-stat-val" id="gst9">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Twin ratio (g2/g4)</div><div class="gap-stat-val" id="gst10">â€”</div></div>
      <div class="gap-stat"><div class="gap-stat-lbl">Calculated Ï€</div><div class="gap-stat-val" id="gst11">â€”</div></div>
    </div>


    <!-- Chart tabs -->
    <div class="gap-tabs" id="gdTabs" style="display:none">
      <button class="gap-tab active" onclick="gdSwitchTab(this,'contrib')">Contributions</button>
      <button class="gap-tab" onclick="gdSwitchTab(this,'dist')">Distribution</button>
      <button class="gap-tab" onclick="gdSwitchTab(this,'conv')">Convergence</button>
      <button class="gap-tab" onclick="gdSwitchTab(this,'ratio')">Gap Ratios</button>
      <button class="gap-tab" onclick="gdSwitchTab(this,'pct')">% Share</button>
    </div>

    <canvas id="gapCanvas" height="300"></canvas>
    <div class="gap-legend" id="gdLegend"></div>

    <!-- All-gaps stats table -->
    <div class="gap-table-wrap" id="gdTableSection" style="display:none">
      <div class="gap-table-controls">
        <label>Sort by:
          <select id="gdTableSort" onchange="gdBuildTable()">
            <option value="gap">Gap â†‘</option>
            <option value="count_desc">Count â†“</option>
            <option value="logshare_desc">Log-Î¶ share â†“</option>
            <option value="product_desc">Product â†“</option>
            <option value="cumulative">Cumulative â†‘</option>
          </select>
        </label>
        <label>Decimals:
          <input type="number" id="gdTableDec" min="2" max="20" value="8" style="width:46px" onchange="gdBuildTable()">
        </label>
        <label>Show top:
          <select id="gdTableTop" onchange="gdBuildTable()">
            <option value="0">All</option>
            <option value="10">10</option>
            <option value="25">25</option>
            <option value="50">50</option>
            <option value="100">100</option>
          </select>
        </label>
        <label><input type="checkbox" id="gdTableHighlight" checked onchange="gdBuildTable()"> Highlight selected</label>
      </div>
      <div id="gdTableWrap"></div>
    </div>

    <!-- Convergence to Ï€Â²/6 dropdown table -->
    <div class="conv-dropdown-wrap" id="gdConvSection" style="display:none">
      <div class="conv-dropdown-header" id="convDropHeader">
        <div class="conv-dropdown-title">âŸ¶ Step-by-step convergence to Ï€Â²/6 = Î¶(2)</div>
        <span class="conv-dropdown-chevron" id="convDropChev">â–¼</span>
      </div>
      <div class="conv-dropdown-body" id="convDropBody">
        <div class="conv-table-controls">
          <label>Sort:
            <select id="convSort" onchange="gdBuildConvTable()">
              <option value="gap_asc">Gap â†‘ (natural order)</option>
              <option value="logshare_desc">Log-share â†“</option>
              <option value="cumulative_asc">Cumulative product â†‘</option>
              <option value="relerr_asc">Rel. error â†‘ (best first)</option>
            </select>
          </label>
          <label>Decimals:
            <input type="number" id="convDec" min="2" max="20" value="12" onchange="gdBuildConvTable()">
          </label>
          <label>Show top:
            <select id="convTop" onchange="gdBuildConvTable()">
              <option value="0">All steps</option>
              <option value="10">10</option>
              <option value="25">25</option>
              <option value="50">50</option>
            </select>
          </label>
          <label><input type="checkbox" id="convShowPi" checked onchange="gdBuildConvTable()"> Show Ï€ estimate</label>
          <label><input type="checkbox" id="convShowLog" checked onchange="gdBuildConvTable()"> logâ‚â‚€ error</label>
          <label><input type="checkbox" id="convShowDelta" checked onchange="gdBuildConvTable()"> Î” product</label>
        </div>
        <div id="gdConvTableWrap"></div>
      </div>
    </div>

  </div><!-- /.gap-body -->
</div><!-- /.gap-panel -->

    </div><!-- /.side-card.gap-card -->
  </aside><!-- /.col-right -->

</div><!-- /.page-shell -->

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PRESETS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PRESET_GROUPS = {
  pgClassic: [
    { name:'Original',   A:1.9, B:3,  C:3,  D:32,  theta:64,  trail:6  },
    { name:'Halo',       A:2,   B:1,  C:1,  D:128, theta:4,   trail:1  },
    { name:'Daisy',      A:1.0, B:5,  C:5,  D:20,  theta:40,  trail:6  },
    { name:'Sunflower',  A:1.0, B:5,  C:5,  D:21,  theta:42,  trail:5  },
    { name:'Rose',       A:2.0, B:4,  C:4,  D:16,  theta:32,  trail:6  },
    { name:'Lily',       A:1.5, B:6,  C:6,  D:18,  theta:36,  trail:6  },
  ],
  pgComplex: [
    { name:'Hypnotic',   A:0.5, B:7,  C:7,  D:16,  theta:64,  trail:8  },
    { name:'Galaxy',     A:1.5, B:9,  C:1,  D:64,  theta:128, trail:4  },
    { name:'Fractal',    A:0.8, B:11, C:11, D:43,  theta:86,  trail:8  },
    { name:'Mandala',    A:1.2, B:8,  C:8,  D:40,  theta:80,  trail:6  },
    { name:'Deep Space', A:0.6, B:12, C:3,  D:96,  theta:128, trail:3  },
    { name:'Cosmos',     A:1.0, B:10, C:2,  D:80,  theta:128, trail:4  },
    { name:'Nebula',     A:1.3, B:9,  C:4,  D:72,  theta:108, trail:5  },
    { name:'Quasar',     A:0.7, B:11, C:7,  D:55,  theta:110, trail:3  },
  ],
  pgOrganic: [
    { name:'Butterfly',  A:2.0, B:2,  C:4,  D:8,   theta:32,  trail:10 },
    { name:'Jellyfish',  A:1.8, B:3,  C:2,  D:12,  theta:48,  trail:8  },
    { name:'Fern',       A:1.1, B:2,  C:5,  D:10,  theta:40,  trail:7  },
    { name:'Coral',      A:1.4, B:4,  C:2,  D:28,  theta:56,  trail:6  },
    { name:'Anemone',    A:1.6, B:5,  C:3,  D:15,  theta:60,  trail:6  },
    { name:'Seashell',   A:2.2, B:3,  C:1,  D:24,  theta:48,  trail:5  },
    { name:'Vine',       A:1.0, B:3,  C:7,  D:14,  theta:56,  trail:6  },
    { name:'Mycelium',   A:0.9, B:6,  C:2,  D:36,  theta:72,  trail:4  },
  ],
  pgGeo: [
    { name:'Crystal',    A:2.5, B:4,  C:4,  D:24,  theta:48,  trail:6  },
    { name:'Spiral',     A:1.2, B:1,  C:6,  D:12,  theta:96,  trail:5  },
    { name:'Hexagon',    A:2.0, B:6,  C:6,  D:36,  theta:72,  trail:6  },
    { name:'Star-12',    A:1.8, B:12, C:12, D:48,  theta:96,  trail:7  },
    { name:'Diamond',    A:2.1, B:4,  C:8,  D:20,  theta:40,  trail:6  },
    { name:'Pinwheel',   A:1.3, B:3,  C:9,  D:18,  theta:54,  trail:6  },
    { name:'Web',        A:0.9, B:7,  C:3,  D:42,  theta:84,  trail:5  },
    { name:'Lattice',    A:1.7, B:5,  C:7,  D:35,  theta:70,  trail:5  },
  ],
  pgEth: [
    { name:'Whisper',    A:3.5, B:2,  C:1,  D:16,  theta:8,   trail:2  },
    { name:'Phantom',    A:0.3, B:8,  C:8,  D:32,  theta:64,  trail:2  },
    { name:'Aurora',     A:1.9, B:4,  C:1,  D:48,  theta:96,  trail:3  },
    { name:'Mirage',     A:2.3, B:5,  C:2,  D:30,  theta:60,  trail:4  },
    { name:'Specter',    A:1.5, B:7,  C:2,  D:56,  theta:112, trail:2  },
    { name:'Wraith',     A:0.5, B:10, C:5,  D:100, theta:100, trail:1  },
    { name:'Solstice',   A:2.8, B:3,  C:3,  D:64,  theta:64,  trail:5  },
    { name:'Eclipse',    A:1.9, B:2,  C:6,  D:12,  theta:24,  trail:3  },
  ],
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAP COLOR PALETTE (shared everywhere)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const GAP_PALETTE = {
  2:'#ffd700', 4:'#4ecdc4', 6:'#a855f7', 8:'#f97316',
  10:'#22c55e', 12:'#38bdf8', 14:'#fb7185', 18:'#e879f9',
  24:'#facc15', 30:'#34d399', 36:'#60a5fa', 42:'#f87171',
  48:'#a3e635', 72:'#fb923c', 86:'#c084fc',
};
const FALLBACK_COLORS = [
  '#ffd700','#4ecdc4','#a855f7','#f97316','#22c55e','#38bdf8',
  '#fb7185','#e879f9','#facc15','#34d399','#60a5fa','#f87171',
  '#a3e635','#fb923c','#c084fc','#ff6b9d','#00d2ff','#7fff00',
];
function gapColor(g, idx){ return GAP_PALETTE[g] || FALLBACK_COLORS[idx % FALLBACK_COLORS.length]; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MULTI-GAP SELECTION STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Map: gapValue â†’ color string (when selected)
let selectedGaps = new Map();
// Lookup: gapValue â†’ index in allGaps array (for color assignment)
let gapIndexMap = {};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  VISUALIZATION STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let A=1.9, B=3, C=3, D=32, thetaTotal=64*Math.PI, trailFade=6;
let speed=8, paused=true, looping=false;
let traceThickness = 1.35;

const TOTAL_PTS = 8000;
let precomputed = [];
let drawProgress = 0;
let lastCartProg = 0;

// Precomputed stats
let fMin=Infinity, fMax=-Infinity, fSum=0;

// 3D rotation
let rotMat = [1,0,0, 0,1,0, 0,0,1];
let autoRotate = false;
let isDrag=false, lastMX=0, lastMY=0;

const PAD = {l:38,r:14,t:12,b:26};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CANVASES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const pCv = document.getElementById('polarCanvas');
const pCtx = pCv.getContext('2d');
const cCv = document.getElementById('cartCanvas');
const cCtx = cCv.getContext('2d');
let cBuf;

function setSize() {
  const w = Math.min(window.innerWidth - 40, 520);
  pCv.width = pCv.height = w;
  cCv.width = w; cCv.height = Math.round(w * 0.38);
}
setSize();
window.addEventListener('resize', () => { setSize(); hardReset(); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  3D MATH
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function mmul(a, b) {
  return [
    a[0]*b[0]+a[1]*b[3]+a[2]*b[6], a[0]*b[1]+a[1]*b[4]+a[2]*b[7], a[0]*b[2]+a[1]*b[5]+a[2]*b[8],
    a[3]*b[0]+a[4]*b[3]+a[5]*b[6], a[3]*b[1]+a[4]*b[4]+a[5]*b[7], a[3]*b[2]+a[4]*b[5]+a[5]*b[8],
    a[6]*b[0]+a[7]*b[3]+a[8]*b[6], a[6]*b[1]+a[7]*b[4]+a[8]*b[7], a[6]*b[2]+a[7]*b[5]+a[8]*b[8]
  ];
}
function mrotX(a) { const c=Math.cos(a),s=Math.sin(a); return [1,0,0, 0,c,-s, 0,s,c]; }
function mrotY(a) { const c=Math.cos(a),s=Math.sin(a); return [c,0,s, 0,1,0, -s,0,c]; }
function applyM(m, x, y, z) {
  return [m[0]*x+m[1]*y+m[2]*z, m[3]*x+m[4]*y+m[5]*z, m[6]*x+m[7]*y+m[8]*z];
}
function proj(rx, ry, rz) {
  const fov = 2.8, scale = fov / (fov - rz);
  const R = pCv.width * 0.37;
  return [pCv.width/2 + rx*R*scale, pCv.height/2 - ry*R*scale];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FORMULA & SPHERE MAPPING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function f(t) { return A + Math.sin(B*t) * Math.sin(C*t/D); }

function toSphere(t, r) {
  const lon = t;
  const polar = (t / thetaTotal) * Math.PI;
  const rn = r / (A + 1.2);
  const x = rn * Math.sin(polar) * Math.cos(lon);
  const y = rn * Math.cos(polar);
  const z = rn * Math.sin(polar) * Math.sin(lon);
  return [x, y, z];
}

function updateFormula() {
  document.getElementById('fA').textContent = A;
  document.getElementById('fB').textContent = B;
  document.getElementById('fC').textContent = C;
  document.getElementById('fD').textContent = D;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PRECOMPUTE â€” now stores gap-class identity per point
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function precompute() {
  precomputed = new Array(TOTAL_PTS);
  fMin=Infinity; fMax=-Infinity; fSum=0;

  // Build a fast lookup: for each point index â†’ which gap class does it visually correspond to
  // We derive this from the gdData if available: primes falling inside [t, t+dt] map to gap families.
  // For the sphere rendering, gap assignment is computed from visualization parameters (B, C, D)
  // We use a simpler approach: tag each point by the nearest gap class from gapFamilies if data exists.
  // Without data, gap = null (no coloring).
  let gapAtPoint = null;
  if (gdData) {
    gapAtPoint = buildGapAtPoint();
  }

  for (let i = 0; i < TOTAL_PTS; i++) {
    const t = (i / TOTAL_PTS) * thetaTotal;
    const r = f(t);
    if (r < fMin) fMin = r;
    if (r > fMax) fMax = r;
    fSum += r;
    const [x,y,z] = harmArnoldK > 0 ? toSphereWarped(t, r) : toSphere(t, r);
    const hue = harmColorMode
      ? null  // will be set to harmonic color below
      : 295 + (i/TOTAL_PTS)*40;
    const gap = gapAtPoint ? gapAtPoint[i] : null;
    const harmCol = harmColorMode ? harmColorForProgress(i/TOTAL_PTS) : null;
    precomputed[i] = [x, y, z, hue, gap, harmCol];
  }
  document.getElementById('stFMin').textContent = fMin.toFixed(4);
  document.getElementById('stFMax').textContent = fMax.toFixed(4);
  document.getElementById('stFMean').textContent = (fSum/TOTAL_PTS).toFixed(4);
  document.getElementById('stThetaMax').textContent = Math.round(thetaTotal/Math.PI);
}

// Map each point index to a gap class by finding which prime gap the Î¸ value falls within.
// Î¸ at point i â†’ t = (i/TOTAL_PTS)*thetaTotal. We scale t into [0, maxPrime] range and find
// the surrounding prime pair. The gap between that prime pair gives the gap class.
function buildGapAtPoint() {
  const { primes, gapFamilies } = gdData;
  if (!primes || primes.length < 2) return null;
  const maxP = primes[primes.length-1];

  // Build sorted list of [prime, gap] pairs for binary search
  // gap[i] = primes[i+1] - primes[i], associated with primes[i]
  const pArr = primes; // already sorted
  const result = new Array(TOTAL_PTS).fill(null);

  for (let i = 0; i < TOTAL_PTS; i++) {
    const t = (i / TOTAL_PTS) * thetaTotal;
    // Map t (0..thetaTotal) â†’ prime index using t/thetaTotal * primes.length
    const pIdx = Math.min(pArr.length - 2, Math.floor((t / thetaTotal) * (pArr.length - 1)));
    if (pIdx >= 0 && pIdx < pArr.length - 1) {
      result[i] = pArr[pIdx+1] - pArr[pIdx];
    }
  }
  return result;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CARTESIAN BUFFER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function makeCartBuf() {
  cBuf = document.createElement('canvas');
  cBuf.width = cCv.width; cBuf.height = cCv.height;
  drawCartGrid(cBuf.getContext('2d'));
  lastCartProg = 0;
}

function drawCartGrid(ctx) {
  const w=ctx.canvas.width, h=ctx.canvas.height;
  const {l,r:pr,t,b}=PAD, pw=w-l-pr, ph=h-t-b;
  const yMax=Math.ceil(A+1.2);
  ctx.fillStyle='#060608'; ctx.fillRect(0,0,w,h);
  ctx.font=`${Math.max(8,w*.021)}px JetBrains Mono,monospace`;
  for(let yv=0;yv<=yMax;yv++){
    const py=h-b-(yv/yMax)*ph;
    ctx.strokeStyle='#182018'; ctx.lineWidth=0.7;
    ctx.beginPath(); ctx.moveTo(l,py); ctx.lineTo(w-pr,py); ctx.stroke();
    ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle';
    ctx.fillText(yv,l-5,py);
  }
  const tmPi=Math.round(thetaTotal/Math.PI);
  [4,8,16,32,48,64,96,128,160,192,240,300].filter(v=>v<=tmPi).forEach(tv=>{
    const px=l+(tv/tmPi)*pw;
    if(px<w-pr){
      ctx.strokeStyle='#182018'; ctx.lineWidth=0.7;
      ctx.beginPath(); ctx.moveTo(px,t); ctx.lineTo(px,h-b); ctx.stroke();
      ctx.fillStyle='#3a7040'; ctx.textAlign='center'; ctx.textBaseline='top';
      ctx.fillText(tv+'Ï€',px,h-b+4);
    }
  });
  ctx.strokeStyle='#ff3db4'; ctx.fillStyle='#ff3db4'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.moveTo(l,t); ctx.lineTo(l,h-b+6); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(l-4,t+4); ctx.lineTo(l,t-5); ctx.lineTo(l+4,t+4); ctx.fill();
  ctx.beginPath(); ctx.moveTo(l-6,h-b); ctx.lineTo(w-pr+6,h-b); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(w-pr+2,h-b-4); ctx.lineTo(w-pr+7,h-b); ctx.lineTo(w-pr+2,h-b+4); ctx.fill();
}

function cartXY(t, rv) {
  const {l,r:pr,t:pt,b}=PAD, pw=cCv.width-l-pr, ph=cCv.height-pt-b;
  const yMax=Math.ceil(A+1.2);
  return [l+(t/thetaTotal)*pw, cCv.height-b-(rv/yMax)*ph];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPHERE WIREFRAME
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawSphereGrid(ctx) {
  ctx.lineWidth=0.55;
  for(let li=-2; li<=2; li++){
    const lat=(li/3)*Math.PI/2;
    const cosLat=Math.cos(lat), sinLat=Math.sin(lat);
    ctx.beginPath(); let first=true;
    for(let lo=0; lo<=Math.PI*2+0.05; lo+=0.08){
      const x=cosLat*Math.cos(lo), y=sinLat, z=cosLat*Math.sin(lo);
      const [rx,ry,rz]=applyM(rotMat,x,y,z);
      const [px,py]=proj(rx,ry,rz);
      ctx.globalAlpha=Math.max(0.05, 0.06+(rz+1)*0.12);
      ctx.strokeStyle='#3a7040';
      if(first){ctx.moveTo(px,py);first=false;}else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }
  for(let lo=0; lo<8; lo++){
    const lon=(lo/8)*Math.PI*2;
    const cosLon=Math.cos(lon), sinLon=Math.sin(lon);
    ctx.beginPath(); let first=true;
    for(let la=-Math.PI/2; la<=Math.PI/2+0.05; la+=0.08){
      const x=Math.cos(la)*cosLon, y=Math.sin(la), z=Math.cos(la)*sinLon;
      const [rx,ry,rz]=applyM(rotMat,x,y,z);
      const [px,py]=proj(rx,ry,rz);
      ctx.globalAlpha=Math.max(0.05, 0.06+(rz+1)*0.12);
      ctx.strokeStyle='#3a7040';
      if(first){ctx.moveTo(px,py);first=false;}else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }
  ctx.globalAlpha=1;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER â€” sphere base + per-gap isolated paths
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const HUE_BANDS = 24;

function renderSphere() {
  pCtx.fillStyle='#060608';
  pCtx.fillRect(0,0,pCv.width,pCv.height);
  drawSphereGrid(pCtx);

  const end = Math.floor(drawProgress);
  if (end < 2) return;

  const histFrac = 1 - ((trailFade-1)/39)*0.9;
  const histLen = Math.max(2, Math.floor(end * histFrac));
  const startIdx = Math.max(1, end - histLen);
  const hasGapSel = selectedGaps.size > 0;
  const dimBase = hasGapSel;

  // â”€â”€ Base continuous curve with Catmull-Rom smoothing â”€â”€
  // Sub-divide each segment to preserve smoothness at high speed
  const N_SUB = Math.max(1, Math.min(8, Math.ceil(speed / 4)));
  const bands = [];
  for(let b=0; b<HUE_BANDS; b++) bands.push({segs:[], bright:0, n:0});

  // Catmull-Rom interpolation in 3D sphere-space (before projection)
  function crPoint(p0, p1, p2, p3, t) {
    // p0..p3 are [x,y,z,...] arrays; t in [0,1]
    const t2=t*t, t3=t2*t;
    return [
      0.5*((-p0[0]+3*p1[0]-3*p2[0]+p3[0])*t3+(2*p0[0]-5*p1[0]+4*p2[0]-p3[0])*t2+(-p0[0]+p2[0])*t+2*p1[0]),
      0.5*((-p0[1]+3*p1[1]-3*p2[1]+p3[1])*t3+(2*p0[1]-5*p1[1]+4*p2[1]-p3[1])*t2+(-p0[1]+p2[1])*t+2*p1[1]),
      0.5*((-p0[2]+3*p1[2]-3*p2[2]+p3[2])*t3+(2*p0[2]-5*p1[2]+4*p2[2]-p3[2])*t2+(-p0[2]+p2[2])*t+2*p1[2]),
    ];
  }

  for(let i=startIdx; i<end; i++){
    const p0=precomputed[Math.max(0,i-1)];
    const p1=precomputed[i];
    const p2=precomputed[Math.min(TOTAL_PTS-1,i+1)];
    const p3=precomputed[Math.min(TOTAL_PTS-1,i+2)];
    if(!p0||!p1||!p2||!p3) continue;
    const bi=Math.min(HUE_BANDS-1, Math.floor((i-startIdx)/histLen*HUE_BANDS));
    // Walk N_SUB sub-intervals
    for(let s=0; s<N_SUB; s++){
      const ta=s/N_SUB, tb=(s+1)/N_SUB;
      const [ax,ay,az]=crPoint(p0,p1,p2,p3,ta);
      const [bx,by,bz]=crPoint(p0,p1,p2,p3,tb);
      const [rxa,rya,rza]=applyM(rotMat,ax,ay,az);
      const [rxb,ryb,rzb]=applyM(rotMat,bx,by,bz);
      const [pxa,pya]=proj(rxa,rya,rza);
      const [pxb,pyb]=proj(rxb,ryb,rzb);
      const depth=(rza+rzb)*0.5;
      bands[bi].segs.push(pxa,pya,pxb,pyb);
      bands[bi].bright+=depth; bands[bi].n++;
    }
  }

  if(dimBase){
    for(let bi=0; bi<HUE_BANDS; bi++){
      const bd=bands[bi]; if(!bd.segs.length) continue;
      const avgZ=bd.n>0?bd.bright/bd.n:0;
      pCtx.strokeStyle=`rgba(55,75,55,${Math.max(0.04,0.08+avgZ*0.06)})`;
      pCtx.lineWidth=traceThickness*0.5; pCtx.globalAlpha=1; pCtx.shadowBlur=0;
      pCtx.beginPath();
      for(let j=0;j<bd.segs.length;j+=4){ pCtx.moveTo(bd.segs[j],bd.segs[j+1]); pCtx.lineTo(bd.segs[j+2],bd.segs[j+3]); }
      pCtx.stroke();
    }
  } else {
    pCtx.lineWidth=traceThickness; pCtx.shadowColor='#ff3db4'; pCtx.shadowBlur=4;
    for(let bi=0; bi<HUE_BANDS; bi++){
      const bd=bands[bi]; if(!bd.segs.length) continue;
      const hue=295+(bi/HUE_BANDS)*40;
      const avgZ=bd.n>0?bd.bright/bd.n:0;
      const bright=48+avgZ*22;
      // Use harmonic color if mode active, else standard hue
      const harmBandCol = harmColorMode ? (harmColorForProgress(bi/HUE_BANDS)||`hsl(${hue},100%,${bright}%)`) : `hsl(${hue},100%,${bright}%)`;
      pCtx.strokeStyle = harmBandCol;
      pCtx.globalAlpha=Math.max(0.2, 0.4+avgZ*0.55);
      pCtx.beginPath();
      for(let j=0;j<bd.segs.length;j+=4){ pCtx.moveTo(bd.segs[j],bd.segs[j+1]); pCtx.lineTo(bd.segs[j+2],bd.segs[j+3]); }
      pCtx.stroke();
    }
    pCtx.globalAlpha=1; pCtx.shadowBlur=0;
  }

  // â”€â”€ Per-gap smooth Catmull-Rom arcs on sphere â”€â”€
  if(hasGapSel){
    selectedGaps.forEach((col, gv) => {
      const pts = [];
      for(let i=startIdx; i<end; i++){
        if(precomputed[i] && precomputed[i][4]===gv) pts.push(i);
      }
      if(!pts.length) return;

      // Glowing dots at each occurrence
      pCtx.shadowColor=col; pCtx.shadowBlur=10; pCtx.globalAlpha=0.9;
      pCtx.fillStyle=col;
      pts.forEach(i=>{
        const p=precomputed[i];
        const [rx,ry,rz]=applyM(rotMat,p[0],p[1],p[2]);
        if(rz < -0.5) return;
        const [px,py]=proj(rx,ry,rz);
        pCtx.beginPath(); pCtx.arc(px,py,Math.max(2,traceThickness),0,Math.PI*2); pCtx.fill();
      });
      pCtx.shadowBlur=0; pCtx.globalAlpha=1;

      // Catmull-Rom smooth arc connecting occurrences
      if(pts.length >= 2){
        pCtx.strokeStyle=col; pCtx.lineWidth=traceThickness*1.3;
        pCtx.shadowColor=col; pCtx.shadowBlur=7; pCtx.globalAlpha=0.75;
        pCtx.beginPath();
        let penDown=false;
        const GAP_THRESH=60; // max index gap to connect
        for(let k=0; k<pts.length-1; k++){
          const i=pts[k], j=pts[k+1];
          if(j-i > GAP_THRESH){ penDown=false; continue; }
          // Use 4 control points for Catmull-Rom
          const pi0=precomputed[Math.max(0,k>0?pts[k-1]:i)];
          const pi1=precomputed[i];
          const pi2=precomputed[j];
          const pi3=precomputed[Math.min(TOTAL_PTS-1,k+2<pts.length?pts[k+2]:j)];
          const CR_STEPS=8;
          for(let s=0; s<=CR_STEPS; s++){
            const t=s/CR_STEPS;
            const t2=t*t, t3=t2*t;
            const x=0.5*((-pi0[0]+3*pi1[0]-3*pi2[0]+pi3[0])*t3+(2*pi0[0]-5*pi1[0]+4*pi2[0]-pi3[0])*t2+(-pi0[0]+pi2[0])*t+2*pi1[0]);
            const y=0.5*((-pi0[1]+3*pi1[1]-3*pi2[1]+pi3[1])*t3+(2*pi0[1]-5*pi1[1]+4*pi2[1]-pi3[1])*t2+(-pi0[1]+pi2[1])*t+2*pi1[1]);
            const z=0.5*((-pi0[2]+3*pi1[2]-3*pi2[2]+pi3[2])*t3+(2*pi0[2]-5*pi1[2]+4*pi2[2]-pi3[2])*t2+(-pi0[2]+pi2[2])*t+2*pi1[2]);
            const [rx,ry,rz]=applyM(rotMat,x,y,z);
            if(rz<-0.6){ penDown=false; continue; }
            const [px,py]=proj(rx,ry,rz);
            if(!penDown){ pCtx.moveTo(px,py); penDown=true; } else pCtx.lineTo(px,py);
          }
        }
        pCtx.stroke();
        pCtx.globalAlpha=1; pCtx.shadowBlur=0;
      }
    });
  }

  // Moving dot
  const cur=precomputed[Math.max(0,end-1)];
  if(cur){
    const [cx,cy,cz]=cur;
    const [rx,ry,rz]=applyM(rotMat,cx,cy,cz);
    const [px,py]=proj(rx,ry,rz);
    pCtx.globalAlpha=Math.max(0.5, 0.5+(rz+1)*0.4);
    pCtx.beginPath(); pCtx.arc(px,py,3.5,0,Math.PI*2);
    pCtx.fillStyle='#fff'; pCtx.shadowColor='#fff'; pCtx.shadowBlur=14;
    pCtx.fill(); pCtx.shadowBlur=0; pCtx.globalAlpha=1;
  }

  // Center glow
  const [crx,cry,crz]=applyM(rotMat,0,0,0);
  const [cpx,cpy]=proj(crx,cry,crz);
  pCtx.beginPath(); pCtx.arc(cpx,cpy,3,0,Math.PI*2);
  pCtx.fillStyle='#ffd700'; pCtx.shadowColor='#ffd700'; pCtx.shadowBlur=16;
  pCtx.fill(); pCtx.shadowBlur=0;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER CART â€” smooth base + FFT-style per-gap stacked lanes
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// FFT canvas: drawn on top of main cart, shows gap waveform lanes
let fftCanvas = null;

function ensureFftCanvas(){
  if(!fftCanvas || fftCanvas.width !== cCv.width || fftCanvas.height !== cCv.height){
    fftCanvas = document.createElement('canvas');
    fftCanvas.width = cCv.width; fftCanvas.height = cCv.height;
  }
}

// Build FFT lane display: for each selected gap, show a local density
// waveform in a horizontal lane. Lane height = cartCanvas.height / nGaps.
// X axis = Î¸ (same as cart), Y axis = local occurrence density in that lane.
function drawFftLanes(end){
  if(!selectedGaps.size || !precomputed.length) return;
  ensureFftCanvas();
  const ctx = fftCanvas.getContext('2d');
  const w=fftCanvas.width, h=fftCanvas.height;
  ctx.clearRect(0,0,w,h);

  const {l,r:pr,t:pt,b}=PAD;
  const pw=w-l-pr, ph=h-pt-b;
  const gapList=[...selectedGaps.entries()]; // [[gv,col],...]
  const nGaps=gapList.length;
  const laneH=Math.floor(ph/nGaps);
  const BINS=Math.min(pw, 256); // FFT-style resolution bins

  // For each gap, count occurrences per Î¸-bin up to current progress
  const maxIdx=Math.min(end, TOTAL_PTS-1);

  gapList.forEach(([gv,col],li)=>{
    const laneTop=pt + li*laneH;
    const laneMid=laneTop+laneH/2;
    const laneAmp=laneH*0.42;

    // Count density in each bin
    const bins=new Float32Array(BINS).fill(0);
    for(let i=1; i<=maxIdx; i++){
      if(precomputed[i]&&precomputed[i][4]===gv){
        const binIdx=Math.floor((i/maxIdx)*BINS);
        if(binIdx<BINS) bins[binIdx]++;
      }
    }

    // Smooth bins with 3-tap gaussian
    const smooth=new Float32Array(BINS);
    for(let b=0;b<BINS;b++){
      smooth[b]=(bins[Math.max(0,b-1)]*0.25+bins[b]*0.5+bins[Math.min(BINS-1,b+1)]*0.25);
    }
    const maxBin=Math.max(1,...smooth);

    // Draw lane background
    ctx.fillStyle=`${col}0d`;
    ctx.fillRect(l,laneTop,pw,laneH);
    // Lane label
    ctx.fillStyle=col+'aa';
    ctx.font=`${Math.max(8,w*0.018)}px JetBrains Mono,monospace`;
    ctx.textAlign='left'; ctx.textBaseline='middle';
    ctx.fillText(`g=${gv}`,l+4,laneMid);
    // Baseline
    ctx.strokeStyle=col+'22'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(l,laneMid); ctx.lineTo(l+pw,laneMid); ctx.stroke();

    // Draw FFT-style waveform using Catmull-Rom smooth path
    ctx.strokeStyle=col; ctx.lineWidth=traceThickness;
    ctx.shadowColor=col; ctx.shadowBlur=6; ctx.globalAlpha=0.9;
    ctx.beginPath();
    let first=true;
    for(let b=0;b<BINS;b++){
      const x=l+(b/BINS)*pw;
      const amp=(smooth[b]/maxBin)*laneAmp;
      const y=laneMid-amp;
      if(first){ ctx.moveTo(x,y); first=false; } else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Mirror (filled area below baseline = symmetric FFT look)
    ctx.globalAlpha=0.35;
    ctx.fillStyle=col;
    ctx.beginPath();
    ctx.moveTo(l,laneMid);
    for(let b=0;b<BINS;b++){
      const x=l+(b/BINS)*pw;
      const amp=(smooth[b]/maxBin)*laneAmp;
      ctx.lineTo(x,laneMid-amp);
    }
    for(let b=BINS-1;b>=0;b--){
      const x=l+(b/BINS)*pw;
      const amp=(smooth[b]/maxBin)*laneAmp;
      ctx.lineTo(x,laneMid+amp);
    }
    ctx.closePath(); ctx.fill();
    ctx.globalAlpha=1; ctx.shadowBlur=0;

    // Vertical cursor at drawProgress
    if(end<TOTAL_PTS){
      const cx2=l+(end/TOTAL_PTS)*pw;
      ctx.strokeStyle=col; ctx.lineWidth=1; ctx.globalAlpha=0.6;
      ctx.setLineDash([3,3]);
      ctx.beginPath(); ctx.moveTo(cx2,laneTop); ctx.lineTo(cx2,laneTop+laneH); ctx.stroke();
      ctx.setLineDash([]); ctx.globalAlpha=1;
    }

    // Lane separator
    ctx.strokeStyle='rgba(255,255,255,0.04)'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(l,laneTop+laneH); ctx.lineTo(l+pw,laneTop+laneH); ctx.stroke();
  });
}

function renderCart() {
  const newEnd=Math.floor(drawProgress);
  const hasGapSel = selectedGaps.size > 0;

  if(newEnd===0 && lastCartProg>0){ makeCartBuf(); }

  // Draw base f(Î¸) curve with sub-step smoothing
  if(newEnd > lastCartProg){
    const cbCtx=cBuf.getContext('2d');
    const C_SUB=Math.max(1,Math.min(8,Math.ceil(speed/4)));

    for(let i=lastCartProg; i<newEnd; i++){
      for(let s=0; s<C_SUB; s++){
        const ta=((i+s/C_SUB)/TOTAL_PTS)*thetaTotal;
        const tb=((i+(s+1)/C_SUB)/TOTAL_PTS)*thetaTotal;
        const ra=f(ta), rb=f(tb);
        const [cxa,cya]=cartXY(ta,ra);
        const [cxb,cyb]=cartXY(tb,rb);
        const fracA=(i+s/C_SUB)/TOTAL_PTS;
        const hue=295+fracA*40;
        // Dim if gaps selected so FFT lanes read clearly
        if(hasGapSel){
          cbCtx.strokeStyle='rgba(40,60,40,0.12)'; cbCtx.lineWidth=traceThickness*0.35;
        } else {
          cbCtx.strokeStyle=`hsl(${hue},100%,62%)`; cbCtx.lineWidth=traceThickness;
          cbCtx.shadowColor='#ff3db4'; cbCtx.shadowBlur=3;
        }
        cbCtx.beginPath(); cbCtx.moveTo(cxa,cya); cbCtx.lineTo(cxb,cyb); cbCtx.stroke();
        cbCtx.shadowBlur=0;
      }
    }
    lastCartProg=newEnd;
  }

  cCtx.clearRect(0,0,cCv.width,cCv.height);
  cCtx.drawImage(cBuf,0,0);

  // Overlay FFT gap lanes (always redrawn since they show full history up to cursor)
  if(hasGapSel){ drawFftLanes(newEnd); cCtx.drawImage(fftCanvas,0,0); }
}

// When gap selection changes, we need to redraw the cart buffer from scratch
function invalidateCartBuf(){
  makeCartBuf();
  lastCartProg = 0;
  fftCanvas = null; // force FFT redraw
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LIVE STATS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateLiveStats() {
  const end = Math.floor(drawProgress);
  const pct = TOTAL_PTS > 0 ? ((end / TOTAL_PTS) * 100).toFixed(1) : '0.0';
  const t = (end / TOTAL_PTS) * thetaTotal;
  const tPi = (t / Math.PI).toFixed(2);
  const fv = end > 0 ? f(t).toFixed(4) : 'â€”';
  document.getElementById('stProg').textContent = pct + '%';
  document.getElementById('stTheta').textContent = tPi + 'Ï€';
  document.getElementById('stFTheta').textContent = fv;
  document.getElementById('stPts').textContent = end.toLocaleString();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ANIMATION LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function loop() {
  requestAnimationFrame(loop);
  if(autoRotate) rotMat=mmul(mrotY(0.008), rotMat);
  if(!paused){
    drawProgress += speed;
    if(drawProgress >= TOTAL_PTS){
      if(looping){
        drawProgress = 0;
        harmSyncStart(); // restart harmonics on loop
      } else {
        drawProgress = TOTAL_PTS; paused = true;
        const btn = document.getElementById('btnPlay');
        btn.textContent = 'â–¶ Play'; btn.classList.remove('on');
        harmSyncStop();
      }
    }
  }
  renderSphere();
  renderCart();
  updateLiveStats();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HARD RESET
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function hardReset() {
  drawProgress=0; lastCartProg=0;
  harmSyncStop();
  precompute(); makeCartBuf(); updateFormula();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DRAG ROTATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function onDragStart(ex,ey){ isDrag=true; lastMX=ex; lastMY=ey; }
function onDragMove(ex,ey){
  if(!isDrag) return;
  const dx=ex-lastMX, dy=ey-lastMY;
  lastMX=ex; lastMY=ey;
  const s=0.012;
  rotMat=mmul(mrotY(dx*s), rotMat);
  rotMat=mmul(mrotX(dy*s), rotMat);
}
function onDragEnd(){ isDrag=false; }

pCv.addEventListener('mousedown', e=>{ e.preventDefault(); onDragStart(e.clientX,e.clientY); });
window.addEventListener('mousemove', e=>onDragMove(e.clientX,e.clientY));
window.addEventListener('mouseup', onDragEnd);
pCv.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.touches[0]; onDragStart(t.clientX,t.clientY); },{passive:false});
pCv.addEventListener('touchmove',  e=>{ e.preventDefault(); const t=e.touches[0]; onDragMove(t.clientX,t.clientY); },{passive:false});
pCv.addEventListener('touchend',   onDragEnd);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ROTATION BUTTONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.getElementById('btnAutoRot').addEventListener('click',function(){
  autoRotate=!autoRotate;
  this.classList.toggle('on',autoRotate);
  this.textContent=autoRotate?'âŸ³ Rotating...':'âŸ³ Auto-Rotate';
});
document.getElementById('btnResetRot').addEventListener('click',()=>{
  rotMat=[1,0,0, 0,1,0, 0,0,1];
  autoRotate=false;
  const b=document.getElementById('btnAutoRot');
  b.classList.remove('on'); b.textContent='âŸ³ Auto-Rotate';
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPEED & THICKNESS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setSpeed(v){
  speed=v;
  document.getElementById('sSpeed').value=v;
  document.getElementById('dSpeed').textContent=v.toFixed(2);
  updateSpeedDesc(v);
}
function updateSpeedDesc(v){
  const el=document.getElementById('speedDesc');
  if(v<0.2) el.textContent='ultra slow';
  else if(v<1) el.textContent='crawl';
  else if(v<4) el.textContent='slow';
  else if(v<12) el.textContent='normal';
  else if(v<25) el.textContent='fast';
  else el.textContent='maximum';
}

// Thickness slider
document.getElementById('gdThick').addEventListener('input', function(){
  traceThickness = parseFloat(this.value);
  document.getElementById('gdThickVal').textContent = traceThickness.toFixed(2)+'px';
  // Invalidate cart buf so it redraws with new thickness
  invalidateCartBuf();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LOOP TOGGLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.getElementById('cbLoop').addEventListener('change', function(){
  looping = this.checked;
  document.getElementById('loopState').textContent = looping ? 'on â€” loops forever' : 'off â€” stops at end';
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SLIDER BINDINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function bind(id,dId,setter,fmt,noReset){
  document.getElementById(id).addEventListener('input',function(){
    const v=parseFloat(this.value);
    setter(v);
    document.getElementById(dId).textContent=fmt?fmt(v):v;
    if(!noReset) hardReset();
  });
}
bind('sA','dA',v=>A=v);
bind('sB','dB',v=>B=v);
bind('sC','dC',v=>C=v);
bind('sD','dD',v=>D=v);
bind('sTheta','dTheta',v=>thetaTotal=v*Math.PI,v=>v+'Ï€');
bind('sTrail','dTrail',v=>trailFade=v,null,true);
bind('sSpeed','dSpeed',v=>{speed=v;updateSpeedDesc(v); if(!paused) harmSyncStart(); },v=>v.toFixed(2),true);

document.getElementById('btnPlay').addEventListener('click',function(){
  onUserInteraction(); // switches to loop mode after intro
  paused=!paused;
  this.textContent=paused?'â–¶ Play':'â¸ Pause';
  this.classList.toggle('on',!paused);
  if(!paused){ harmSyncStart(); }
  else { harmSyncPause(); }
});
document.getElementById('btnReset').addEventListener('click',()=>{ harmSyncStop(); hardReset(); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  4K SPHERE EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.getElementById('btnExport4K').addEventListener('click', exportSphere4K);

function exportSphere4K() {
  // â”€â”€ Composite 4K export: sphere + formula + cart canvas + stats bar â”€â”€
  // Target output: 3840 Ã— 2160 (16:9)
  const W = 3840, H = 2160;
  const cv = document.createElement('canvas');
  cv.width = W; cv.height = H;
  const ctx = cv.getContext('2d');

  // Background
  ctx.fillStyle = '#060608';
  ctx.fillRect(0, 0, W, H);

  // â”€â”€ Layout constants (scaled to 4K) â”€â”€
  const SCALE   = W / pCv.width;       // how much bigger 4K is vs live canvas
  const PADDING = 80;                   // outer padding px at 4K
  const SPHERE_W = Math.round(W * 0.54);
  const SPHERE_H = SPHERE_W;           // sphere is square
  const RIGHT_X  = SPHERE_W + PADDING * 2;
  const RIGHT_W  = W - RIGHT_X - PADDING;

  // â•â• LEFT COLUMN: sphere (scaled up from live canvas) â•â•
  // Draw sphere at 4K res using the same geometry
  const sphereOff = document.createElement('canvas');
  sphereOff.width = sphereOff.height = SPHERE_W;
  const sc = sphereOff.getContext('2d');
  sc.fillStyle = '#060608';
  sc.fillRect(0, 0, SPHERE_W, SPHERE_W);

  // Wireframe grid scaled to SPHERE_W
  const sphereR4K = SPHERE_W * 0.37;
  function proj4K(rx, ry, rz){
    const fov=2.8, scale=fov/(fov-rz);
    return [SPHERE_W/2 + rx*sphereR4K*scale*zoomLevel + panX*SCALE*0.5,
            SPHERE_W/2 - ry*sphereR4K*scale*zoomLevel + panY*SCALE*0.5];
  }
  sc.lineWidth = 1.2;
  for(let li=-2; li<=2; li++){
    const lat=(li/3)*Math.PI/2, cosLat=Math.cos(lat), sinLat=Math.sin(lat);
    sc.beginPath(); let first=true;
    for(let lo=0; lo<=Math.PI*2+0.05; lo+=0.04){
      const x=cosLat*Math.cos(lo), y=sinLat, z=cosLat*Math.sin(lo);
      const [rx,ry,rz]=applyM(rotMat,x,y,z);
      const [px,py]=proj4K(rx,ry,rz);
      sc.globalAlpha=Math.max(0.05,0.06+(rz+1)*0.12); sc.strokeStyle='#3a7040';
      if(first){sc.moveTo(px,py);first=false;}else sc.lineTo(px,py);
    } sc.stroke();
  }
  for(let lo=0; lo<8; lo++){
    const lon=(lo/8)*Math.PI*2, cosLon=Math.cos(lon), sinLon=Math.sin(lon);
    sc.beginPath(); let first=true;
    for(let la=-Math.PI/2; la<=Math.PI/2+0.05; la+=0.04){
      const x=Math.cos(la)*cosLon, y=Math.sin(la), z=Math.cos(la)*sinLon;
      const [rx,ry,rz]=applyM(rotMat,x,y,z);
      const [px,py]=proj4K(rx,ry,rz);
      sc.globalAlpha=Math.max(0.05,0.06+(rz+1)*0.12); sc.strokeStyle='#3a7040';
      if(first){sc.moveTo(px,py);first=false;}else sc.lineTo(px,py);
    } sc.stroke();
  }
  sc.globalAlpha=1;

  // Curve trace on sphere
  const end=Math.floor(drawProgress);
  if(end>=2){
    const histFrac=1-((trailFade-1)/39)*0.9;
    const histLen=Math.max(2,Math.floor(end*histFrac));
    const startIdx=Math.max(1,end-histLen);
    sc.lineWidth=traceThickness*2.2;
    for(let i=startIdx;i<end;i++){
      const p0=precomputed[i-1],p1=precomputed[i];
      if(!p0||!p1) continue;
      const [rx1,ry1,rz1]=applyM(rotMat,p0[0],p0[1],p0[2]);
      const [rx2,ry2,rz2]=applyM(rotMat,p1[0],p1[1],p1[2]);
      const [px1,py1]=proj4K(rx1,ry1,rz1);
      const [px2,py2]=proj4K(rx2,ry2,rz2);
      const gap=p1[4];
      const selCol=gap!==null?selectedGaps.get(gap):undefined;
      const frac=i/TOTAL_PTS;
      if(selCol){
        sc.strokeStyle=selCol; sc.shadowColor=selCol; sc.shadowBlur=14;
      } else if(harmColorMode){
        const hc=harmColorForProgress(frac);
        sc.strokeStyle=hc||`hsl(${295+frac*40},100%,55%)`;
        sc.shadowColor=sc.strokeStyle; sc.shadowBlur=6;
      } else {
        const bi=Math.min(HUE_BANDS-1,Math.floor((i-startIdx)/histLen*HUE_BANDS));
        const hue=295+(bi/HUE_BANDS)*40;
        const avgZ=(rz1+rz2)*0.5, bright=48+avgZ*22;
        sc.strokeStyle=`hsl(${hue},100%,${bright}%)`;
        sc.shadowColor='#ff3db4'; sc.shadowBlur=8;
      }
      sc.globalAlpha=Math.max(0.2,0.5);
      sc.beginPath(); sc.moveTo(px1,py1); sc.lineTo(px2,py2); sc.stroke();
    }
    sc.shadowBlur=0; sc.globalAlpha=1;

    // Center glow
    const [crx,cry,crz]=applyM(rotMat,0,0,0);
    const [cpx,cpy]=proj4K(crx,cry,crz);
    sc.beginPath(); sc.arc(cpx,cpy,5,0,Math.PI*2);
    sc.fillStyle='#ffd700'; sc.shadowColor='#ffd700'; sc.shadowBlur=20;
    sc.fill(); sc.shadowBlur=0;
  }

  // Blit sphere onto main 4K canvas (vertically centered in left col)
  const SPHERE_TOP = Math.round((H - SPHERE_H) / 2);
  ctx.drawImage(sphereOff, PADDING, SPHERE_TOP, SPHERE_W, SPHERE_H);

  // â•â• RIGHT COLUMN â•â•
  const COL_Y = PADDING;
  let ry = COL_Y;

  // â”€â”€ Formula box â”€â”€
  const FORMULA_H = 160;
  // Box
  ctx.save();
  ctx.fillStyle='rgba(255,215,0,0.05)';
  ctx.strokeStyle='#ffd700'; ctx.lineWidth=3;
  ctx.shadowColor='rgba(255,215,0,0.35)'; ctx.shadowBlur=28;
  ctx.beginPath(); ctx.roundRect(RIGHT_X, ry, RIGHT_W, FORMULA_H, 16);
  ctx.fill(); ctx.stroke(); ctx.restore();

  // Draw formula with gold numbers, white text
  ctx.textBaseline='middle';
  ctx.font=`bold 54px 'JetBrains Mono', monospace`;
  const FY = ry + FORMULA_H / 2;
  // Measure total width so we can centre it
  const parts = [
    { text:'f(Î¸) = ',      color:'#d8f0d8' },
    { text:`${A}`,         color:'#ffd700' },
    { text:' + sin(',      color:'#d8f0d8' },
    { text:`${B}`,         color:'#ffd700' },
    { text:'Î¸) Â· sin(',    color:'#d8f0d8' },
    { text:`${C}`,         color:'#ffd700' },
    { text:'Î¸ / ',         color:'#d8f0d8' },
    { text:`${D}`,         color:'#ffd700' },
    { text:')',             color:'#d8f0d8' },
  ];
  const totalW = parts.reduce((s,p)=>s+ctx.measureText(p.text).width,0);
  let fx = RIGHT_X + (RIGHT_W - totalW) / 2;
  ctx.textAlign='left';
  parts.forEach(p=>{ ctx.fillStyle=p.color; ctx.fillText(p.text,fx,FY); fx+=ctx.measureText(p.text).width; });
  ry += FORMULA_H + 48;

  // â”€â”€ Cartesian canvas (scaled up) â”€â”€
  const CART_H = Math.round(RIGHT_W * (cCv.height / cCv.width));
  ctx.save();
  ctx.shadowColor='rgba(255,61,180,0.15)'; ctx.shadowBlur=30;
  ctx.drawImage(cCv, RIGHT_X, ry, RIGHT_W, CART_H);
  ctx.restore();
  // Border around cart
  ctx.strokeStyle='rgba(255,61,180,0.25)'; ctx.lineWidth=2;
  ctx.strokeRect(RIGHT_X, ry, RIGHT_W, CART_H);
  ry += CART_H + 48;

  // â”€â”€ Live stats bar â”€â”€
  const STATS = [
    { lbl:'PROGRESS',      val: `${((drawProgress/TOTAL_PTS)*100).toFixed(1)}%` },
    { lbl:'Î¸ CURRENT',     val: `${((drawProgress/TOTAL_PTS)*thetaTotal/Math.PI).toFixed(2)}Ï€` },
    { lbl:'F(Î¸) CURRENT',  val: end>0 ? f((drawProgress/TOTAL_PTS)*thetaTotal).toFixed(4) : 'â€”' },
    { lbl:'F(Î¸) MIN',      val: fMin.toFixed(4) },
    { lbl:'F(Î¸) MAX',      val: fMax.toFixed(4) },
    { lbl:'F(Î¸) MEAN',     val: (fSum/TOTAL_PTS).toFixed(4) },
    { lbl:'PTS DRAWN',     val: Math.floor(drawProgress).toLocaleString() },
    { lbl:'Î¸ TOTAL (Ã—Î )',  val: Math.round(thetaTotal/Math.PI).toString() },
  ];
  const STATS_H = 220;
  const cellW   = RIGHT_W / 4;
  const cellH   = STATS_H / 2;

  ctx.fillStyle='rgba(255,215,0,0.04)';
  ctx.strokeStyle='rgba(255,215,0,0.18)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.roundRect(RIGHT_X, ry, RIGHT_W, STATS_H, 12); ctx.fill(); ctx.stroke();

  STATS.forEach((s,i)=>{
    const col=i%4, row=Math.floor(i/4);
    const cx=RIGHT_X+col*cellW, cy=ry+row*cellH;
    ctx.textAlign='left'; ctx.textBaseline='top';
    ctx.fillStyle='rgba(255,215,0,0.45)';
    ctx.font=`500 22px 'JetBrains Mono', monospace`;
    ctx.fillText(s.lbl, cx+18, cy+18);
    ctx.fillStyle='#ffd700';
    ctx.font=`bold 40px 'JetBrains Mono', monospace`;
    ctx.fillText(s.val, cx+18, cy+52);
  });
  ry += STATS_H + 48;

  // â”€â”€ Watermark â”€â”€
  ctx.textAlign='left'; ctx.textBaseline='bottom';
  ctx.fillStyle='rgba(255,61,180,0.35)';
  ctx.font=`500 28px 'JetBrains Mono', monospace`;
  ctx.fillText('Polar vs Cartesian Â· Wessen Getachew Â· @7dview', PADDING, H - PADDING);

  // â”€â”€ Î¸ range label top-right â”€â”€
  ctx.textAlign='right'; ctx.textBaseline='top';
  ctx.fillStyle='rgba(255,215,0,0.4)';
  ctx.font=`500 26px 'JetBrains Mono', monospace`;
  ctx.fillText(`Î¸ âˆˆ [0, ${Math.round(thetaTotal/Math.PI)}Ï€]`, W - PADDING, PADDING);

  // â”€â”€ Download â”€â”€
  const link = document.createElement('a');
  link.download = `polar_cart_4K_A${A}_B${B}_C${C}_D${D}.png`;
  link.href = cv.toDataURL('image/png');
  link.click();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BUILD PRESETS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let activePresetBtn = null;

// Preset dropdown toggle
document.getElementById('presetDropHeader').addEventListener('click',()=>{
  document.getElementById('presetDropBody').classList.toggle('open');
  document.getElementById('presetDropChev').classList.toggle('open');
  document.getElementById('presetDropHeader').classList.toggle('open');
});

function buildPresets(){
  Object.entries(PRESET_GROUPS).forEach(([gid, list])=>{
    const row = document.getElementById(gid);
    if(!row) return;
    list.forEach((p,i)=>{
      const btn = document.createElement('button');
      btn.className = 'preset-btn';
      btn.textContent = p.name;
      if(gid==='pgClassic'&&i===0){ btn.classList.add('active'); activePresetBtn=btn; }
      btn.onclick = ()=> applyPreset(p, btn, gid==='pgGapWave');
      row.appendChild(btn);
    });
  });
}

function applyPreset(p, btn, isGap){
  onUserInteraction(); // first preset click switches to loop mode
  A=p.A; B=p.B; C=p.C; D=p.D; thetaTotal=p.theta*Math.PI; trailFade=p.trail||6;
  const sl=(id,v,fmt)=>{ document.getElementById(id).value=v; document.getElementById('d'+id.slice(1)).textContent=fmt?fmt(v):v; };
  sl('sA',A); sl('sB',B); sl('sC',C); sl('sD',D);
  sl('sTheta',p.theta,v=>v+'Ï€');
  sl('sTrail',trailFade);
  if(activePresetBtn) activePresetBtn.classList.remove('active','gap-active');
  if(btn){ btn.classList.add(isGap?'gap-active':'active'); activePresetBtn=btn; }

  // Update active name in dropdown header
  const nameEl=document.getElementById('presetActiveName');
  if(nameEl) nameEl.textContent=p.name;

  // Loop ON (user has interacted)
  looping=true;
  const cbLoop=document.getElementById('cbLoop');
  if(cbLoop){ cbLoop.checked=true; }
  document.getElementById('loopState').textContent='on â€” loops forever';

  // Fast speed
  setSpeed(20);

  // Auto-rotate on
  autoRotate=true;
  const rotBtn=document.getElementById('btnAutoRot');
  if(rotBtn){ rotBtn.classList.add('on'); rotBtn.textContent='âŸ³ Rotating...'; }

  // Reset then play
  hardReset();
  paused=false;
  const playBtn=document.getElementById('btnPlay');
  if(playBtn){ playBtn.textContent='â¸ Pause'; playBtn.classList.add('on'); }
  // Sync harmonics with wave
  harmSyncStart();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAP DECOMPOSITION MODULE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Gap panel toggle (still collapsible inside right sidebar)
const _gapHdr = document.getElementById('gapHeader');
if(_gapHdr) _gapHdr.addEventListener('click',()=>{
  const body = document.getElementById('gapBody');
  const chev = document.getElementById('gapChevron');
  const hdr  = document.getElementById('gapHeader');
  if(body) body.classList.toggle('open');
  if(chev) chev.classList.toggle('open');
  if(hdr)  hdr.classList.toggle('open');
});

document.getElementById('gdN').addEventListener('input', function(){
  document.getElementById('gdND').textContent = parseInt(this.value).toLocaleString();
});
document.getElementById('gdS').addEventListener('input', function(){
  document.getElementById('gdSD').textContent = `s = ${parseFloat(this.value).toFixed(2)}`;
});

let gdData = null;
let gdTab = 'contrib';
let gdFilter = 'all';
const gdCanvas = document.getElementById('gapCanvas');
const gdCtx = gdCanvas.getContext('2d');
let gdActiveWaveBtn = null;

function gdResizeCanvas(){
  const w = Math.min(window.innerWidth - 68, 524);
  gdCanvas.width = Math.max(280, w);
  if(gdData) gdDraw();
}
window.addEventListener('resize', gdResizeCanvas);
gdResizeCanvas();

function setGapFilter(btn, filter){
  document.querySelectorAll('.gap-filter-btn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  gdFilter = filter;
}

// â”€â”€ Sieves â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function simpleSieve(max){
  const sieve = new Uint8Array(max+1).fill(1);
  sieve[0]=sieve[1]=0;
  for(let i=2;i*i<=max;i++) if(sieve[i]) for(let j=i*i;j<=max;j+=i) sieve[j]=0;
  const primes=[];
  for(let i=2;i<=max;i++) if(sieve[i]) primes.push(i);
  return primes;
}

function segmentedSieve(max, progressCb){
  const sqrtMax = Math.ceil(Math.sqrt(max));
  const small = simpleSieve(sqrtMax);
  const primes = [];
  const SEG = 1<<20;
  for(let lo=0; lo<=max; lo+=SEG){
    const hi = Math.min(lo+SEG-1, max);
    const seg = new Uint8Array(hi-lo+1).fill(1);
    for(const p of small){
      let start = Math.max(p*p, Math.ceil(lo/p)*p);
      for(let j=start; j<=hi; j+=p) seg[j-lo]=0;
    }
    for(let i=(lo<2?2:lo); i<=hi; i++) if(seg[i-lo]) primes.push(i);
    if(progressCb) progressCb(hi, max);
  }
  return primes;
}

// â”€â”€ Core analysis â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function knownZeta(s){
  const k = {2:Math.PI**2/6, 4:Math.PI**4/90, 6:Math.PI**6/945, 8:Math.PI**8/9450, 10:Math.PI**10/93555};
  return k[Math.round(s*100)/100] || null;
}

function gdCompute(maxN, s, filter, progressCb){
  const primes = maxN < 5e6 ? simpleSieve(maxN) : segmentedSieve(maxN, progressCb);

  let target = knownZeta(s);
  if(!target) target = primes.reduce((p, pr) => p * Math.pow(pr,s)/(Math.pow(pr,s)-1), 1);

  const gapFamilies = {};
  for(let i=0; i<primes.length-1; i++){
    const g = primes[i+1]-primes[i];
    if(!gapFamilies[g]) gapFamilies[g]=[];
    gapFamilies[g].push(primes[i]);
  }

  let gaps = Object.keys(gapFamilies).map(Number).sort((a,b)=>a-b);

  if(filter==='tiny')   gaps = gaps.filter(g=>g>=2&&g<=10);
  if(filter==='small')  gaps = gaps.filter(g=>g>=2&&g<=30);
  if(filter==='medium') gaps = gaps.filter(g=>g>=20&&g<=80);
  if(filter==='large')  gaps = gaps.filter(g=>g>=50&&g<=200);

  const gapProducts = {};
  let totalLog = 0;
  gaps.forEach(g=>{
    const ps = gapFamilies[g];
    if(!ps||!ps.length) return;
    let prod=1, logProd=0;
    ps.forEach(p=>{
      const ps_s = Math.pow(p,s);
      const fac = ps_s/(ps_s-1);
      prod *= fac; logProd += Math.log(fac);
    });
    gapProducts[g] = { product:prod, logProduct:logProd, count:ps.length };
    totalLog += logProd;
  });

  // Convergence steps
  const conv = [];
  let cum = 1, prevCum = 1;
  gaps.forEach((g,idx)=>{
    if(!gapProducts[g]) return;
    prevCum = cum;
    cum *= gapProducts[g].product;
    const relErr = Math.abs(cum-target)/target;
    const pi_est = s >= 1.99 && s <= 2.01 ? Math.sqrt(6*cum) : null;
    const delta = cum - prevCum;
    conv.push({ gap:g, value:cum, relErr, prevErr: idx>0?conv[idx-1]?.relErr??null:null,
                pi_est, delta, logProduct:gapProducts[g].logProduct, step:idx+1 });
  });

  const c2 = gapFamilies[2]?.length||0;
  const c4 = gapFamilies[4]?.length||0;
  const c6 = gapFamilies[6]?.length||0;

  let mostCommon = gaps[0], mcCount = 0;
  gaps.forEach(g=>{ if((gapFamilies[g]?.length||0)>mcCount){ mcCount=gapFamilies[g].length; mostCommon=g; }});

  const finalErr = Math.abs(cum-target)/target;
  const pi_calc = (s >= 1.99 && s <= 2.01) ? Math.sqrt(6*cum) : null;

  // Build gapâ†’index map for color assignment
  gapIndexMap = {};
  gaps.forEach((g,i) => { gapIndexMap[g] = i; });

  return { primes, gaps, gapFamilies, gapProducts, conv, target, totalLog,
           finalProduct:cum, finalError:finalErr, s, maxN,
           c2,c4,c6, mostCommon, mcCount, pi_calc };
}

// â”€â”€ Run â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gdRun(){
  const maxN = parseInt(document.getElementById('gdN').value);
  const s = parseFloat(document.getElementById('gdS').value);
  const filter = gdFilter;

  if(maxN > 300000000){
    document.getElementById('gdStatus').textContent = 'âš  Max N is 300,000,000 (browser limit).';
    return;
  }

  document.getElementById('gdStatus').textContent = 'Sieving primesâ€¦';
  document.getElementById('gdRunBtn').disabled = true;
  document.getElementById('gdProgress').style.display = 'block';
  document.getElementById('gdProgressFill').style.width = '0%';

  setTimeout(()=>{
    try {
      const progressCb = (cur, max)=>{
        const pct = Math.min(99, (cur/max*100)).toFixed(0);
        document.getElementById('gdProgressFill').style.width = pct+'%';
        document.getElementById('gdStatus').textContent = `Sievingâ€¦ ${pct}%  (${cur.toLocaleString()} / ${max.toLocaleString()})`;
      };

      gdData = gdCompute(maxN, s, filter, progressCb);

      document.getElementById('gdProgressFill').style.width = '100%';
      setTimeout(()=>document.getElementById('gdProgress').style.display='none', 400);

      const errPct = (gdData.finalError*100).toFixed(8);
      document.getElementById('gdStatus').textContent =
        `âœ“ N=${maxN.toLocaleString()} Â· ${gdData.primes.length.toLocaleString()} primes Â· `+
        `${gdData.gaps.length} gap families Â· `+
        `Î¶(${s.toFixed(2)}) target=${gdData.target.toFixed(10)} Â· `+
        `computed=${gdData.finalProduct.toFixed(10)} Â· err=${errPct}%`;

      updateGdStats();

      ['gdExportPNG','gdExportCSV','gdExportTXT'].forEach(id=>document.getElementById(id).style.display='inline-block');
      document.getElementById('gdTabs').style.display='flex';
      document.getElementById('gdStatsGrid').style.display='grid';

      // Build gap chip selectors (panel + main area)
      buildGapChips();

      // Build stats table and convergence table
      gdBuildTable();
      gdBuildConvTable();
      document.getElementById('gdTableSection').style.display='block';
      document.getElementById('gdConvSection').style.display='block';


      // Recompute sphere with gap data
      precompute();
      invalidateCartBuf();

      gdResizeCanvas();
      gdDraw();

    } catch(e) {
      document.getElementById('gdStatus').textContent = `Error: ${e.message}`;
      console.error(e);
    }
    document.getElementById('gdRunBtn').disabled = false;
  }, 20);
}

function updateGdStats(){
  if(!gdData) return;
  const d = gdData;
  const pi_str = d.pi_calc ? d.pi_calc.toFixed(10) : 'n/a (sâ‰ 2)';
  const vals = [
    d.primes.length.toLocaleString(), d.gaps.length,
    Math.max(...d.gaps), d.target.toFixed(10), d.finalProduct.toFixed(10),
    (d.finalError*100).toFixed(10)+'%', d.c2.toLocaleString(),
    d.c4.toLocaleString(), d.c6.toLocaleString(),
    `${d.mostCommon} (${d.mcCount.toLocaleString()}Ã—)`,
    d.c4>0 ? (d.c2/d.c4).toFixed(6) : 'n/a', pi_str,
  ];
  vals.forEach((v,i)=>{ const el=document.getElementById('gst'+i); if(el) el.textContent=v; });
}

function gdClear(){
  gdData = null; selectedGaps.clear(); gapIndexMap = {};
  gdCtx.clearRect(0,0,gdCanvas.width,gdCanvas.height);
  document.getElementById('gdStatus').textContent='Run decomposition to analyze prime gap contributions to Î¶(s).';
  ['gdExportPNG','gdExportCSV','gdExportTXT'].forEach(id=>document.getElementById(id).style.display='none');
  document.getElementById('gdTabs').style.display='none';
  document.getElementById('gdStatsGrid').style.display='none';
    document.getElementById('gdSelectorWrap').style.display='none';
  document.getElementById('gdTableSection').style.display='none';
  document.getElementById('gdConvSection').style.display='none';
  document.getElementById('gdLegend').innerHTML='';
  document.getElementById('gdChips').innerHTML='';
  precompute(); invalidateCartBuf();
}

function gdSwitchTab(btn, tab){
  gdTab = tab;
  document.querySelectorAll('.gap-tab').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  if(gdData) gdDraw();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAP CHIP SELECTOR (multi-select)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildGapChips(){
  if(!gdData) return;

  // Build chips in the panel selector only
  const row = document.getElementById('gdChips');
  const wrap = document.getElementById('gdSelectorWrap');
  row.innerHTML = '';
  gdData.gaps.forEach((g, i) => {
    const col = gapColor(g, i);
    const chip = document.createElement('div');
    chip.className = 'gap-chip';
    chip.dataset.gap = g;
    chip.innerHTML = `<span class="chip-dot" style="background:${col}"></span>g=${g}`;
    chip.title = `Gap ${g}: ${(gdData.gapProducts[g]?.count||0).toLocaleString()} primes`;
    chip.addEventListener('click', ()=> toggleGapChipAll(g, i, col));
    row.appendChild(chip);
  });
  wrap.style.display = 'block';
}

// Toggle all chips with matching gap value across both containers
function toggleGapChipAll(g, idx, col){
  onUserInteraction();
  const isSelected = selectedGaps.has(g);
  if(isSelected){
    selectedGaps.delete(g);
  } else {
    selectedGaps.set(g, col);
  }
  // Update ALL chips for this gap
  document.querySelectorAll(`.gap-chip[data-gap="${g}"]`).forEach(chip => {
    if(selectedGaps.has(g)){
      chip.classList.add('selected');
      chip.style.background = col;
      chip.style.borderColor = col;
      chip.style.color = '#000';
    } else {
      chip.classList.remove('selected');
      chip.style.background = '';
      chip.style.borderColor = '';
      chip.style.color = '';
    }
  });
  invalidateCartBuf();
}

function toggleGapChip(g, idx, chip, col){
  toggleGapChipAll(g, idx, col);
}

function gdClearSelection(){
  selectedGaps.clear();
  document.querySelectorAll('.gap-chip.selected').forEach(c=>{
    c.classList.remove('selected');
    c.style.background = '';
    c.style.borderColor = '';
    c.style.color = '';
  });
  invalidateCartBuf();
  if(gdData) gdDraw();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ALL-GAPS STATS TABLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function gdBuildTable(){
  if(!gdData) return;
  const {gaps, gapProducts, gapFamilies, totalLog, target, s} = gdData;
  const dec = Math.max(2, Math.min(20, parseInt(document.getElementById('gdTableDec').value)||8));
  const sortBy = document.getElementById('gdTableSort').value;
  const topN = parseInt(document.getElementById('gdTableTop').value)||0;
  const hlSel = document.getElementById('gdTableHighlight').checked;

  let rows = gaps.filter(g=>gapProducts[g]).map((g,i)=>{
    const gp = gapProducts[g];
    const logShare = gp.logProduct / (totalLog||1) * 100;
    let cum=1;
    gaps.forEach(gg=>{ if(gg<=g && gapProducts[gg]) cum*=gapProducts[gg].product; });
    return { g, count:gp.count, product:gp.product, logProduct:gp.logProduct,
             logShare, cumulative:cum, relErr:Math.abs(cum-target)/target,
             pctPrimes:gp.count/(gdData.primes.length||1)*100, i };
  });

  if(sortBy==='count_desc') rows.sort((a,b)=>b.count-a.count);
  else if(sortBy==='logshare_desc') rows.sort((a,b)=>b.logShare-a.logShare);
  else if(sortBy==='product_desc') rows.sort((a,b)=>b.product-a.product);
  else if(sortBy==='cumulative') rows.sort((a,b)=>a.cumulative-b.cumulative);
  else rows.sort((a,b)=>a.g-b.g);

  if(topN>0) rows = rows.slice(0, topN);

  const fmt = (v, d) => typeof v === 'number' ? v.toFixed(d) : v;
  const fmtE = (v, d) => v < 1e-4 ? v.toExponential(d) : v.toFixed(d);

  let html = `<table>
    <thead><tr>
      <th>Gap</th>
      <th>Count</th>
      <th>% of primes</th>
      <th>Product</th>
      <th>log(Product)</th>
      <th>log-Î¶ share %</th>
      <th>Cumulative</th>
      <th>Rel. error</th>
      <th>Abs. error</th>
    </tr></thead><tbody>`;

  rows.forEach(r=>{
    const col = gapColor(r.g, r.i);
    const isSel = hlSel && selectedGaps.has(r.g);
    const selClass = isSel ? 'gap-row-selected' : '';
    const abErr = Math.abs(r.cumulative - target);
    html += `<tr class="${selClass}">
      <td class="gap-id" style="color:${col}">${r.g}</td>
      <td>${r.count.toLocaleString()}</td>
      <td>${fmt(r.pctPrimes, dec)}%</td>
      <td>${fmt(r.product, dec)}</td>
      <td>${fmt(r.logProduct, dec)}</td>
      <td>${fmt(r.logShare, dec)}%</td>
      <td>${fmt(r.cumulative, dec)}</td>
      <td>${fmtE(r.relErr, dec)}</td>
      <td>${fmtE(abErr, dec)}</td>
    </tr>`;
  });
  html += '</tbody></table>';
  document.getElementById('gdTableWrap').innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONVERGENCE TO Ï€Â²/6 TABLE (dropdown)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.getElementById('convDropHeader').addEventListener('click', ()=>{
  document.getElementById('convDropBody').classList.toggle('open');
  document.getElementById('convDropChev').classList.toggle('open');
});

function gdBuildConvTable(){
  if(!gdData) return;
  const {conv, target, s, gaps, gapProducts, totalLog} = gdData;
  const dec = Math.max(2, Math.min(20, parseInt(document.getElementById('convDec').value)||12));
  const sortKey = document.getElementById('convSort').value;
  const topN = parseInt(document.getElementById('convTop').value)||0;
  const showPi = document.getElementById('convShowPi').checked;
  const showLog = document.getElementById('convShowLog').checked;
  const showDelta = document.getElementById('convShowDelta').checked;

  const isZeta2 = s >= 1.99 && s <= 2.01;
  const TARGET_PI2_6 = Math.PI**2/6;

  // Build full row data: one row per gap step
  let rows = conv.map((c, i)=>{
    const gp = gapProducts[c.gap];
    const logShare = gp ? gp.logProduct/(totalLog||1)*100 : 0;
    const logErr = c.relErr > 0 ? Math.log10(c.relErr) : -Infinity;
    const improving = i>0 ? c.relErr < conv[i-1].relErr : true;
    return { ...c, logShare, logErr, improving, step:i+1 };
  });

  if(sortKey==='logshare_desc') rows = [...rows].sort((a,b)=>b.logShare-a.logShare);
  else if(sortKey==='cumulative_asc') rows = [...rows].sort((a,b)=>a.value-b.value);
  else if(sortKey==='relerr_asc') rows = [...rows].sort((a,b)=>a.relErr-b.relErr);
  // else natural gap order

  if(topN>0) rows = rows.slice(0, topN);

  // Best row (minimum relative error)
  const bestRelErr = Math.min(...rows.map(r=>r.relErr));

  const fmt = (v, d) => typeof v === 'number' ? v.toFixed(d) : 'â€”';
  const fmtE = (v, d) => (v===null||v===undefined) ? 'â€”' : v < 1e-4 ? v.toExponential(d) : v.toFixed(d);

  let ths = `<th>Step</th><th>Gap</th><th>log-Î¶ %</th>
    <th class="conv-cell-product">Cumulative product</th>
    <th>Target Î¶(${s.toFixed(2)})</th>
    <th class="conv-cell-err">Rel. error</th>
    <th>Abs. error</th>`;
  if(showLog) ths += `<th class="conv-cell-logerr">logâ‚â‚€(err)</th>`;
  if(showDelta) ths += `<th>Î” product</th>`;
  if(showPi && isZeta2) ths += `<th class="conv-cell-pi">âˆš(6Â·prod) â‰ˆ Ï€</th><th class="conv-cell-pi">|Ï€ est âˆ’ Ï€|</th>`;

  let html = `<table><thead><tr>${ths}</tr></thead><tbody>`;

  rows.forEach(r=>{
    const isBest = r.relErr === bestRelErr;
    const rowClass = isBest ? 'conv-row-best' : r.improving ? 'conv-row-improving' : 'conv-row-worsening';
    const col = gapColor(r.gap, gapIndexMap[r.gap]||0);
    const abErr = Math.abs(r.value - target);
    const pi_est = (showPi && isZeta2 && r.value > 0) ? Math.sqrt(6*r.value) : null;
    const pi_err = pi_est !== null ? Math.abs(pi_est - Math.PI) : null;

    let tds = `
      <td>${r.step}</td>
      <td class="conv-cell-gap" style="color:${col}">g=${r.gap}</td>
      <td>${fmt(r.logShare, dec)}%</td>
      <td class="conv-cell-product">${fmt(r.value, dec)}</td>
      <td>${fmt(target, dec)}</td>
      <td class="conv-cell-err">${fmtE(r.relErr, dec)}</td>
      <td>${fmtE(abErr, dec)}</td>`;
    if(showLog) tds += `<td class="conv-cell-logerr">${isFinite(r.logErr)?fmt(r.logErr,dec):'â€”'}</td>`;
    if(showDelta) tds += `<td>${fmtE(Math.abs(r.delta), dec)}</td>`;
    if(showPi && isZeta2){
      tds += `<td class="conv-cell-pi">${pi_est!==null?fmt(pi_est,dec):'â€”'}</td>`;
      tds += `<td class="conv-cell-pi">${pi_err!==null?fmtE(pi_err,dec):'â€”'}</td>`;
    }

    html += `<tr class="${rowClass}">${tds}</tr>`;
  });
  html += '</tbody></table>';
  document.getElementById('gdConvTableWrap').innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  REFINED WAVE PRESETS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function buildRefinedWavePresets(){}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHART DRAWING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function gdDraw(){
  if(!gdData) return;
  const w=gdCanvas.width, h=gdCanvas.height;
  gdCtx.fillStyle='#060608'; gdCtx.fillRect(0,0,w,h);
  if(gdTab==='contrib') gdDrawContrib(w,h);
  else if(gdTab==='dist') gdDrawDist(w,h);
  else if(gdTab==='conv') gdDrawConv(w,h);
  else if(gdTab==='ratio') gdDrawRatio(w,h);
  else if(gdTab==='pct') gdDrawPct(w,h);
}

function gPad(){ return {l:60,r:14,t:28,b:42}; }
function gdTitle(ctx, w, txt){
  ctx.fillStyle='#ffd700'; ctx.textAlign='left';
  ctx.font=`bold ${Math.max(9,w*.022)}px JetBrains Mono,monospace`;
  ctx.fillText(txt, 60, 18);
}

function gdDrawContrib(w, h){
  const {gaps, gapProducts, totalLog, s} = gdData;
  if(!gaps.length) return;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  const shares = gaps.map(g=>(gapProducts[g]?.logProduct||0)/totalLog*100);
  const maxS = Math.max(...shares);
  const barW = pw/gaps.length;

  ctx.font=`${Math.max(7,w*.018)}px JetBrains Mono,monospace`;
  gaps.forEach((g,i)=>{
    const pct=shares[i], bh=pct/maxS*ph;
    const x=p.l+i*barW, y=p.t+ph-bh;
    const col=gapColor(g,i);
    const isSel = selectedGaps.has(g);
    ctx.fillStyle=col+(isSel?'bb':'33'); ctx.fillRect(x+1,y,barW-2,bh);
    ctx.strokeStyle=col; ctx.lineWidth=isSel?2.5:1.2;
    ctx.strokeRect(x+1,y,barW-2,bh);
    if(barW>18){ ctx.fillStyle=col; ctx.textAlign='center'; ctx.fillText(''+g, x+barW/2, p.t+ph+16); }
    if(barW>28&&pct>0.5){ ctx.fillStyle='#fff'; ctx.globalAlpha=0.8; ctx.fillText(pct.toFixed(1)+'%', x+barW/2, y-3); ctx.globalAlpha=1; }
  });
  [0,25,50,75,100].forEach(pct=>{
    if(pct<=maxS*1.1){ const y=p.t+ph-pct/maxS*ph;
      ctx.strokeStyle='#182018'; ctx.lineWidth=0.5;
      ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(w-p.r,y); ctx.stroke();
      ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle';
      ctx.fillText(pct+'%', p.l-4, y);
    }
  });
  gdTitle(ctx, w, `log-Î¶(${s.toFixed(2)}) contribution % by gap`);
  gdBuildLegend(gaps.slice(0,16));
}

function gdDrawDist(w, h){
  const {gaps, gapFamilies} = gdData;
  if(!gaps.length) return;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  const counts=gaps.map(g=>gapFamilies[g]?.length||0);
  const maxC=Math.max(...counts);
  const barW=pw/gaps.length;
  gaps.forEach((g,i)=>{
    const c=counts[i], bh=c/maxC*ph;
    const x=p.l+i*barW, y=p.t+ph-bh;
    const col=gapColor(g,i);
    const isSel=selectedGaps.has(g);
    ctx.fillStyle=col+(isSel?'bb':'33'); ctx.fillRect(x+1,y,barW-2,bh);
    ctx.strokeStyle=col; ctx.lineWidth=isSel?2.5:1.2; ctx.strokeRect(x+1,y,barW-2,bh);
    if(barW>18){ ctx.fillStyle=col; ctx.textAlign='center';
      ctx.font=`${Math.max(7,w*.018)}px JetBrains Mono,monospace`;
      ctx.fillText(''+g, x+barW/2, p.t+ph+16); }
  });
  [0,.25,.5,.75,1].forEach(frac=>{ const y=p.t+ph-frac*ph, v=Math.round(frac*maxC);
    ctx.strokeStyle='#182018'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(w-p.r,y); ctx.stroke();
    ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle';
    ctx.font=`${Math.max(7,w*.018)}px JetBrains Mono,monospace`;
    ctx.fillText(v>=1e6?(v/1e6).toFixed(1)+'M':v>=1e3?(v/1e3).toFixed(0)+'k':v, p.l-4, y);
  });
  gdTitle(ctx, w, `Prime count per gap family`);
  gdBuildLegend(gaps.slice(0,16));
}

function gdDrawConv(w, h){
  const {conv, target, s} = gdData;
  if(conv.length<2) return;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  const vals=conv.map(d=>d.value);
  const minV=Math.min(target*0.8,...vals), maxV=Math.max(target*1.1,...vals);
  const xS=pw/(conv.length-1), yS=ph/(maxV-minV);
  ctx.font=`${Math.max(7,w*.018)}px JetBrains Mono,monospace`;
  const ty=p.t+ph-(target-minV)*yS;
  ctx.strokeStyle='#ffd70066'; ctx.lineWidth=1; ctx.setLineDash([6,4]);
  ctx.beginPath(); ctx.moveTo(p.l,ty); ctx.lineTo(w-p.r,ty); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle='#ffd700'; ctx.textAlign='right';
  ctx.fillText(`Î¶(${s})=${target.toFixed(6)}`, w-p.r-2, ty-5);
  ctx.strokeStyle='#ff3db4'; ctx.lineWidth=2;
  ctx.shadowColor='#ff3db4'; ctx.shadowBlur=6;
  ctx.beginPath();
  conv.forEach((d,i)=>{ const x=p.l+i*xS, y=p.t+ph-(d.value-minV)*yS; i===0?ctx.moveTo(x,y):ctx.lineTo(x,y); });
  ctx.stroke(); ctx.shadowBlur=0;
  for(let i=0;i<=5;i++){ const frac=i/5, v=minV+frac*(maxV-minV), y=p.t+ph-frac*ph;
    ctx.strokeStyle='#182018'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(w-p.r,y); ctx.stroke();
    ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle';
    ctx.fillText(v.toFixed(4), p.l-4, y);
  }
  ctx.fillStyle='#88cc88'; ctx.textAlign='center';
  const step=Math.max(1,Math.floor(conv.length/8));
  conv.forEach((d,i)=>{ if(i%step===0){ ctx.fillText('g'+d.gap,p.l+i*xS,p.t+ph+18); }});
  gdTitle(ctx, w, `Cumulative Euler product â†’ Î¶(${s.toFixed(2)})`);
  gdBuildLegend([]);
}

function gdDrawRatio(w, h){
  const {c2, c4, c6} = gdData;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  ctx.font=`${Math.max(8,w*.02)}px JetBrains Mono,monospace`;
  const pairs=[
    {lbl:'gâ‚‚/gâ‚„\ntwin/cousin', val:c4>0?c2/c4:null, tgt:1.0, col:'#ffd700', note:'HLâ†’1'},
    {lbl:'gâ‚‚/gâ‚†\ntwin/sexy',   val:c6>0?c2/c6:null, tgt:0.5, col:'#ff3db4', note:'HLâ†’0.5'},
    {lbl:'gâ‚„/gâ‚†\ncousin/sexy', val:c6>0?c4/c6:null, tgt:0.5, col:'#4ecdc4', note:'HLâ†’0.5'},
  ];
  const bW=(pw/pairs.length)-14, maxV=3;
  pairs.forEach((pair,i)=>{
    const x=p.l+i*(pw/pairs.length)+7;
    if(pair.val===null){ ctx.fillStyle='#555'; ctx.textAlign='center'; ctx.fillText('N/A',x+bW/2,p.t+ph/2); return; }
    const bh=Math.min(pair.val/maxV,1)*ph, y=p.t+ph-bh;
    ctx.fillStyle=pair.col+'33'; ctx.fillRect(x,y,bW,bh);
    ctx.strokeStyle=pair.col; ctx.lineWidth=2; ctx.strokeRect(x,y,bW,bh);
    const ty=p.t+ph-(pair.tgt/maxV)*ph;
    ctx.strokeStyle=pair.col+'99'; ctx.lineWidth=1; ctx.setLineDash([4,3]);
    ctx.beginPath(); ctx.moveTo(x-4,ty); ctx.lineTo(x+bW+4,ty); ctx.stroke(); ctx.setLineDash([]);
    ctx.fillStyle=pair.col; ctx.textAlign='center';
    ctx.fillText(pair.val.toFixed(5),x+bW/2,y-6);
    ctx.fillStyle=pair.col+'99'; ctx.fillText(pair.note,x+bW/2,ty-6);
    ctx.fillStyle='#88cc88';
    pair.lbl.split('\n').forEach((ln,li)=>ctx.fillText(ln,x+bW/2,p.t+ph+16+li*12));
  });
  [0,1,2,3].forEach(v=>{ if(v<=maxV){ const y=p.t+ph-(v/maxV)*ph;
    ctx.strokeStyle='#182018'; ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(w-p.r,y); ctx.stroke();
    ctx.fillStyle='#3a7040'; ctx.textAlign='right'; ctx.textBaseline='middle'; ctx.fillText(v, p.l-4, y);
  }});
  gdTitle(ctx, w, `Gap count ratios vs Hardyâ€“Littlewood`);
  gdBuildLegend([]);
}

function gdDrawPct(w, h){
  const {gaps, gapProducts, totalLog, s} = gdData;
  if(!gaps.length) return;
  const p=gPad(), pw=w-p.l-p.r, ph=h-p.t-p.b;
  const ctx=gdCtx;
  const sorted=gaps.filter(g=>gapProducts[g])
    .map((g,i)=>({g, share:gapProducts[g].logProduct/totalLog, i}))
    .sort((a,b)=>b.share-a.share);
  let y=p.t;
  sorted.forEach(({g,share,i})=>{
    const bh=share*ph, col=gapColor(g,i), isSel=selectedGaps.has(g);
    ctx.fillStyle=col+(isSel?'cc':'66'); ctx.fillRect(p.l,y,pw*0.35,bh);
    ctx.strokeStyle=col; ctx.lineWidth=isSel?2:1; ctx.strokeRect(p.l,y,pw*0.35,bh);
    if(bh>10){
      ctx.fillStyle='#fff'; ctx.globalAlpha=0.85; ctx.textAlign='left'; ctx.textBaseline='middle';
      ctx.font=`${Math.max(7,w*.017)}px JetBrains Mono,monospace`;
      ctx.fillText(`g=${g}  ${(share*100).toFixed(2)}%`, p.l+pw*0.35+8, y+bh/2);
      ctx.globalAlpha=1;
    }
    y+=bh;
  });
  gdTitle(ctx, w, `% share of log-Î¶(${s.toFixed(2)}) by gap class`);
  gdBuildLegend(sorted.slice(0,12).map(({g})=>g));
}

function gdBuildLegend(gapList){
  const el=document.getElementById('gdLegend');
  el.innerHTML=gapList.map((g,i)=>{
    const col=gapColor(g,i);
    const isSel=selectedGaps.has(g);
    return `<div class="gap-leg" style="${isSel?'font-weight:700;':''}" onclick="toggleGapChipByVal(${g})" style="cursor:pointer">
      <div class="gap-leg-sw" style="background:${col};${isSel?'outline:2px solid '+col:''}"></div>
      gap ${g}${isSel?' âœ“':''}
    </div>`;
  }).join('');
}

function toggleGapChipByVal(g){
  const chip = document.querySelector(`.gap-chip[data-gap="${g}"]`);
  if(chip){ const i = gapIndexMap[g]||0; toggleGapChip(g, i, chip, gapColor(g,i)); gdDraw(); }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXPORTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function gdExport4K(){
  if(!gdData) return;
  const SIZE_W=3840, SIZE_H=2160;
  const cv=document.createElement('canvas');
  cv.width=SIZE_W; cv.height=SIZE_H;
  const ctx=cv.getContext('2d');
  ctx.fillStyle='#060608'; ctx.fillRect(0,0,SIZE_W,SIZE_H);
  const origW=gdCanvas.width, origH=gdCanvas.height;
  gdCanvas.width=SIZE_W; gdCanvas.height=SIZE_H;
  gdDraw();
  ctx.drawImage(gdCanvas,0,0);
  gdCanvas.width=origW; gdCanvas.height=origH; gdResizeCanvas();
  ctx.fillStyle='rgba(6,6,8,0.75)'; ctx.fillRect(0,0,SIZE_W,110);
  ctx.fillStyle='#ffd700'; ctx.font='bold 56px JetBrains Mono,monospace';
  ctx.textAlign='left'; ctx.textBaseline='top';
  ctx.fillText(`Gap Decomp Â· Î¶(${gdData.s.toFixed(2)}) Â· N=${gdData.maxN.toLocaleString()}`, 60, 20);
  ctx.fillStyle='#88cc88'; ctx.font='32px JetBrains Mono,monospace';
  ctx.fillText(`${gdData.primes.length.toLocaleString()} primes Â· ${gdData.gaps.length} families Â· err=${(gdData.finalError*100).toFixed(8)}%`, 60, 78);
  ctx.fillStyle='rgba(255,61,180,0.5)'; ctx.font='28px JetBrains Mono,monospace';
  ctx.textAlign='right'; ctx.fillText('Wessen Getachew Â· @7dview', SIZE_W-60, 78);
  const link=document.createElement('a');
  link.download=`gap_decomp_4K_N${gdData.maxN}_s${gdData.s.toFixed(2)}_${gdTab}.png`;
  link.href=cv.toDataURL('image/png'); link.click();
  gdDraw();
}

function gdExportCSV(){
  if(!gdData) return;
  const d=gdData;
  let csv='Gap,Count,PctPrimes,Product,LogProduct,LogShare(%),CumulativeProduct,RelativeError,AbsoluteError\n';
  let cum=1;
  d.gaps.forEach(g=>{
    const gp=d.gapProducts[g]; if(!gp) return;
    cum*=gp.product;
    const logShare=(gp.logProduct/(d.totalLog||1)*100).toFixed(10);
    const relErr=Math.abs(cum-d.target)/d.target;
    const abErr=Math.abs(cum-d.target);
    const pctPrimes=(gp.count/(d.primes.length||1)*100).toFixed(10);
    csv+=`${g},${gp.count},${pctPrimes},${gp.product.toFixed(15)},${gp.logProduct.toFixed(15)},${logShare},${cum.toFixed(15)},${relErr.toFixed(15)},${abErr.toFixed(15)}\n`;
  });
  csvDownload(csv, `gap_decomp_N${d.maxN}_s${d.s.toFixed(2)}.csv`);
}

function gdExportTXT(){
  if(!gdData) return;
  const d=gdData, now=new Date().toISOString();
  const pi_str=d.pi_calc?`Calculated Ï€  = ${d.pi_calc.toFixed(15)}  (|err|=${Math.abs(d.pi_calc-Math.PI).toExponential(6)})`:'Ï€: only valid at s=2';
  let txt=`
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  PRIME GAP DECOMPOSITION REPORT â€” Î¶(s) Euler Analysis
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Generated : ${now}  |  Author: Wessen Getachew Â· @7dview

PARAMETERS
  Max N         = ${d.maxN.toLocaleString()}
  Exponent s    = ${d.s.toFixed(4)}
  Gap filter    = ${gdFilter}

PRIME STATISTICS
  Total primes  = ${d.primes.length.toLocaleString()}
  Max prime     = ${d.primes[d.primes.length-1].toLocaleString()}
  Gap families  = ${d.gaps.length}
  Largest gap   = ${Math.max(...d.gaps)}
  Most common g = ${d.mostCommon} (${d.mcCount.toLocaleString()} times)

TWIN / COUSIN / SEXY
  Gap 2 (twin)  = ${d.c2.toLocaleString()}
  Gap 4 (cousin)= ${d.c4.toLocaleString()}
  Gap 6 (sexy)  = ${d.c6.toLocaleString()}
  g2/g4 ratio   = ${d.c4>0?(d.c2/d.c4).toFixed(12):'N/A'}  [HL: 1.0]
  g2/g6 ratio   = ${d.c6>0?(d.c2/d.c6).toFixed(12):'N/A'}  [HL: 0.5]
  g4/g6 ratio   = ${d.c6>0?(d.c4/d.c6).toFixed(12):'N/A'}  [HL: 0.5]

ZETA PRODUCT
  Target Î¶(${d.s.toFixed(2)}) = ${d.target.toFixed(15)}
  Computed      = ${d.finalProduct.toFixed(15)}
  Abs error     = ${Math.abs(d.finalProduct-d.target).toExponential(10)}
  Rel error     = ${(d.finalError*100).toFixed(12)}%
  ${pi_str}

GAP CLASS TABLE
${'Gap'.padEnd(8)}${'Count'.padEnd(14)}${'Pct%'.padEnd(12)}${'Product'.padEnd(22)}${'LogProd'.padEnd(22)}${'log-Î¶%'.padEnd(16)}${'Cumulative'.padEnd(22)}RelErr%
${'â”€'.repeat(120)}
`;
  let cum=1;
  d.gaps.forEach(g=>{
    const gp=d.gapProducts[g]; if(!gp) return;
    cum*=gp.product;
    const relErr=Math.abs(cum-d.target)/d.target*100;
    const logShare=gp.logProduct/(d.totalLog||1)*100;
    const pct=gp.count/(d.primes.length||1)*100;
    txt+=`${(''+g).padEnd(8)}${gp.count.toString().padEnd(14)}${pct.toFixed(6).padEnd(12)}${gp.product.toFixed(12).padEnd(22)}${gp.logProduct.toFixed(12).padEnd(22)}${logShare.toFixed(6).padEnd(16)}${cum.toFixed(12).padEnd(22)}${relErr.toFixed(10)}\n`;
  });
  txt+=`\n${'â•'.repeat(60)}\n`;
  const blob=new Blob([txt],{type:'text/plain'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob); a.download=`gap_decomp_report_N${d.maxN}_s${d.s.toFixed(2)}.txt`;
  a.click();
}

function csvDownload(csv, filename){
  const blob=new Blob([csv],{type:'text/csv'});
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob); a.download=filename; a.click();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HARMONICS MODULE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Farey harmonic intervals: {ratio, name, p, q} where ratio=p/q
const HARM_INTERVALS = [
  { name:'1:1',   p:1,  q:1,  cents:0 },
  { name:'16:15', p:16, q:15, cents:112 },
  { name:'9:8',   p:9,  q:8,  cents:204 },
  { name:'6:5',   p:6,  q:5,  cents:316 },
  { name:'5:4',   p:5,  q:4,  cents:386 },
  { name:'4:3',   p:4,  q:3,  cents:498 },
  { name:'45:32', p:45, q:32, cents:590 },
  { name:'3:2',   p:3,  q:2,  cents:702 },
  { name:'8:5',   p:8,  q:5,  cents:814 },
  { name:'5:3',   p:5,  q:3,  cents:884 },
  { name:'9:5',   p:9,  q:5,  cents:1018 },
  { name:'15:8',  p:15, q:8,  cents:1088 },
  { name:'2:1',   p:2,  q:1,  cents:1200 },
  { name:'5:2',   p:5,  q:2,  cents:1586 },
  { name:'3:1',   p:3,  q:1,  cents:1902 },
  { name:'4:1',   p:4,  q:1,  cents:2400 },
];

function harmConsonanceColor(p, q){
  const tenney = p * q;
  if(p===1&&q===1) return '#22c55e';
  if(tenney<=4) return '#60a5fa';
  if(tenney<=16) return '#ffd700';
  if(tenney<=64) return '#f97316';
  return '#a855f7';
}

let harmSelectedIntervals = new Set(); // indices into HARM_INTERVALS
let harmColorMode = false;
let harmArnoldK = 0;
let harmBaseArnold = 0; // store original to reset

let audioCtx = null;
let harmOscillators = [];

function harmGetCtx(){
  if(!audioCtx) audioCtx = new(window.AudioContext||window.webkitAudioContext)();
  if(audioCtx.state==='suspended') audioCtx.resume();
  return audioCtx;
}

function harmStop(){
  harmSyncStop();
  harmOscillators.forEach(o=>{ try{o.stop();}catch(e){} });
  harmOscillators=[];
  ['harmPlayBtn','harmChordBtn','harmArpBtn'].forEach(id=>document.getElementById(id)?.classList.remove('on'));
}

function harmGetBaseHz(){ return parseFloat(document.getElementById('harmBaseHz').value)||220; }
function harmGetVol(){ return parseFloat(document.getElementById('harmVol').value)||0.35; }
function harmGetWave(){ return document.getElementById('harmWave').value||'sine'; }

function harmPlayFreq(hz, duration=1.5){
  const ctx=harmGetCtx();
  const osc=ctx.createOscillator();
  const gain=ctx.createGain();
  osc.connect(gain); gain.connect(ctx.destination);
  osc.type=harmGetWave(); osc.frequency.value=hz;
  const vol=harmGetVol();
  gain.gain.setValueAtTime(vol, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+duration);
  osc.start(); osc.stop(ctx.currentTime+duration);
  harmOscillators.push(osc);
  return osc;
}

function harmPlay(){
  harmStop();
  const base=harmGetBaseHz();
  const sel=[...harmSelectedIntervals];
  if(!sel.length){ harmPlayFreq(base); return; }
  const iv=HARM_INTERVALS[sel[sel.length-1]];
  harmPlayFreq(base * iv.p / iv.q);
  document.getElementById('harmPlayBtn').classList.add('on');
}

function harmChord(){
  harmStop();
  const base=harmGetBaseHz();
  const sel=[...harmSelectedIntervals];
  if(!sel.length) sel.push(0);
  sel.forEach(idx=>{
    const iv=HARM_INTERVALS[idx];
    harmPlayFreq(base*iv.p/iv.q, 2.0);
  });
  document.getElementById('harmChordBtn').classList.add('on');
}

function harmArp(){
  harmStop();
  const base=harmGetBaseHz();
  const sel=[...harmSelectedIntervals];
  if(!sel.length) sel.push(0);
  const ctx=harmGetCtx();
  sel.forEach((idx,i)=>{
    const iv=HARM_INTERVALS[idx];
    const hz=base*iv.p/iv.q;
    const osc=ctx.createOscillator();
    const gain=ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    osc.type=harmGetWave(); osc.frequency.value=hz;
    const t=ctx.currentTime+i*0.35;
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(harmGetVol(), t+0.05);
    gain.gain.exponentialRampToValueAtTime(0.0001, t+0.6);
    osc.start(t); osc.stop(t+0.65);
    harmOscillators.push(osc);
  });
  document.getElementById('harmArpBtn').classList.add('on');
}

function noteFromHz(hz){
  const notes=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const n=Math.round(12*Math.log2(hz/440))+69;
  if(n<0||n>127) return 'â€”';
  return notes[n%12]+(Math.floor(n/12)-1);
}

function buildHarmIntervalGrid(){
  const grid=document.getElementById('harmIntervalGrid');
  grid.innerHTML='';
  HARM_INTERVALS.forEach((iv,i)=>{
    const col=harmConsonanceColor(iv.p,iv.q);
    const btn=document.createElement('button');
    btn.className='harm-interval-btn';
    btn.style.borderColor=col+'55';
    btn.style.color=col+'aa';
    btn.innerHTML=iv.name;
    btn.title=`${iv.name} Â· ${iv.cents}Â¢ Â· Tenney height: ${iv.p*iv.q}`;
    btn.onclick=()=>toggleHarmInterval(i,btn,iv,col);
    grid.appendChild(btn);
  });
}

function toggleHarmInterval(i, btn, iv, col){
  if(harmSelectedIntervals.has(i)){
    harmSelectedIntervals.delete(i);
    btn.classList.remove('active');
    btn.style.background='';
    btn.style.color=col+'aa';
  } else {
    harmSelectedIntervals.add(i);
    btn.classList.add('active');
    btn.style.background=col;
    btn.style.color='#000';
  }
  updateHarmDisplay();
  if(harmColorMode) precompute(); // recolor sphere
}

function updateHarmDisplay(){
  const sel=[...harmSelectedIntervals];
  if(!sel.length){
    document.getElementById('harmFreqDisplay').textContent='â€” Hz';
    document.getElementById('harmNoteDisplay').textContent='â€” Â· â€”';
    return;
  }
  const last=HARM_INTERVALS[sel[sel.length-1]];
  const base=harmGetBaseHz();
  const hz=base*last.p/last.q;
  document.getElementById('harmFreqDisplay').textContent=hz.toFixed(2)+' Hz';
  document.getElementById('harmNoteDisplay').textContent=last.name+' Â· '+noteFromHz(hz);
}

// Arnold tongue warp: perturb the sphere rendering with KÂ·sin(2Ï€Â·ratio)
function applyArnoldWarp(){
  harmArnoldK=parseFloat(document.getElementById('harmArnold').value)||0;
  precompute(); // rebuilds precomputed with warp applied
}
function resetArnold(){
  harmArnoldK=0;
  document.getElementById('harmArnold').value=0;
  document.getElementById('harmArnoldVal').textContent='0.00';
  precompute();
}

// Harmonic color mode: sphere hue based on consonance of selected intervals
// The trail hue cycles through the consonance colors of selected intervals
function harmColorForProgress(frac){
  const sel=[...harmSelectedIntervals];
  if(!sel.length) return null;
  // Cycle through selected intervals by position on curve
  const idx=Math.floor(frac*sel.length)%sel.length;
  const iv=HARM_INTERVALS[sel[idx]];
  return harmConsonanceColor(iv.p,iv.q);
}

// Hook into precompute to apply Arnold warp if K>0
const _origPrecompute = precompute;
// We'll re-override toSphere to apply warp
const _origToSphere = toSphere;

function toSphereWarped(t, r){
  let lon = t;
  if(harmArnoldK > 0){
    // Arnold circle map perturbation: lon += KÂ·sin(2Ï€Â·lon/(2Ï€))
    lon = t + harmArnoldK * Math.sin(t);
  }
  const polar = (t / thetaTotal) * Math.PI;
  const rn = r / (A + 1.2);
  const x = rn * Math.sin(polar) * Math.cos(lon);
  const y = rn * Math.cos(polar);
  const z = rn * Math.sin(polar) * Math.sin(lon);
  return [x, y, z];
}

// Patch toSphere globally
// (call toSphereWarped from precompute instead of toSphere)

// Harmonic color panel â€” always open in dashboard layout (no toggle needed)

document.getElementById('harmColorMode').addEventListener('change',function(){
  harmColorMode=this.checked;
  document.getElementById('harmModeState').textContent=harmColorMode
    ?'on â€” sphere colored by harmonic consonance'
    :'off â€” sphere uses default colors';
  precompute();
});

document.getElementById('harmBaseHz').addEventListener('input',function(){
  document.getElementById('harmBaseHzVal').textContent=this.value+' Hz';
  updateHarmDisplay();
});
document.getElementById('harmVol').addEventListener('input',function(){
  document.getElementById('harmVolVal').textContent=Math.round(this.value*100)+'%';
});
document.getElementById('harmArnold').addEventListener('input',function(){
  document.getElementById('harmArnoldVal').textContent=parseFloat(this.value).toFixed(2);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HARMONIC SYNC ENGINE
//  Plays harmonics in sync with the wave animation.
//  - Schedules an arpeggio sweep that spans the full wave draw duration
//  - Loops if looping is on, stops cleanly at wave end
//  - Gap class presence modulates note intensity/timing when gdData exists
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let harmSyncNodes = [];      // all running oscillator/gain nodes
let harmSyncLoopId = null;   // setInterval for scheduling next batch
let harmSyncPaused = false;
let harmSyncStartCtxTime = 0;
let harmSyncStartDrawProg = 0;
let harmSyncWaveDuration = 0; // seconds the wave takes at current speed

function harmSyncStop(){
  if(harmSyncLoopId){ clearInterval(harmSyncLoopId); harmSyncLoopId=null; }
  harmSyncNodes.forEach(n=>{ try{n.stop();}catch(e){} });
  harmSyncNodes=[];
  harmSyncPaused=false;
  ['harmPlayBtn','harmChordBtn','harmArpBtn'].forEach(id=>{
    const el=document.getElementById(id);
    if(el) el.classList.remove('on');
  });
}

function harmSyncPause(){
  // When paused, stop all audio. Resume via harmSyncStart when unpaused.
  harmSyncStop();
}

function harmSyncStart(){
  harmSyncStop(); // clean slate

  const ctx = harmGetCtx();
  if(ctx.state==='suspended') ctx.resume();

  const base = harmGetBaseHz();
  const vol  = harmGetVol();
  const wave = harmGetWave();
  const sel  = [...harmSelectedIntervals];

  // Build frequency list: always include base + all selected intervals (no octave doubling yet)
  const freqs = [base];
  sel.forEach(idx=>{
    const iv = HARM_INTERVALS[idx];
    freqs.push(base * iv.p / iv.q);
  });

  // Add gap-aware freqs if gap data & selections exist
  if(gdData && selectedGaps.size > 0){
    selectedGaps.forEach((col, gv) => {
      const ratio = Math.max(1, Math.min(8, gv / 2));
      freqs.push(base * ratio);
    });
  }

  // Unique, in-range freqs
  const allFreqs = [...new Set(freqs.map(f => Math.round(f * 10) / 10))]
    .filter(f => f >= 40 && f <= 8000);
  if(!allFreqs.length) allFreqs.push(base);

  // How long the FULL wave takes at current speed (seconds)
  // drawProgress advances by `speed` pts per frame at ~60fps
  const estFPS = 60;
  const remainingPts = TOTAL_PTS - drawProgress; // pts left to draw
  const waveSec = Math.max(0.5, remainingPts / (speed * estFPS));
  harmSyncWaveDuration = waveSec;

  // Note spacing: aim for one note every ~0.35s, cycling through allFreqs
  // This guarantees notes play continuously for the entire wave duration
  const noteSpacing = 0.35; // seconds between note onsets
  const noteDur     = 0.55; // each note duration (overlaps slightly for legato feel)
  const totalNotes  = Math.ceil(waveSec / noteSpacing) + 1;

  const now = ctx.currentTime;
  harmSyncStartCtxTime = now;

  // Schedule all notes across full wave duration
  for(let i = 0; i < totalNotes; i++){
    const t = now + i * noteSpacing;
    if(t > now + waveSec + noteDur) break; // don't schedule past wave end

    const freq = allFreqs[i % allFreqs.length];
    const osc  = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.connect(gain); gain.connect(ctx.destination);
    osc.type = wave;
    osc.frequency.setValueAtTime(freq, t);

    // Progress fraction: notes near end of wave are softer
    const frac = i / totalNotes;
    const vPeak = vol * (0.7 + 0.3 * Math.sin(Math.PI * frac)); // bell curve volume

    gain.gain.setValueAtTime(0.0001, t);
    gain.gain.linearRampToValueAtTime(vPeak, t + noteDur * 0.2);
    gain.gain.exponentialRampToValueAtTime(0.0001, t + noteDur);

    osc.start(t);
    osc.stop(t + noteDur + 0.05);
    harmSyncNodes.push(osc);
  }

  // Sustained sub-octave drone for the full wave duration
  const droneOsc  = ctx.createOscillator();
  const droneGain = ctx.createGain();
  droneOsc.connect(droneGain); droneGain.connect(ctx.destination);
  droneOsc.type = 'sine';
  droneOsc.frequency.value = allFreqs[0] * 0.5;
  droneGain.gain.setValueAtTime(0.0001, now);
  droneGain.gain.linearRampToValueAtTime(vol * 0.07, now + 0.5);
  droneGain.gain.setValueAtTime(vol * 0.07, now + waveSec - 0.4);
  droneGain.gain.exponentialRampToValueAtTime(0.0001, now + waveSec + 0.1);
  droneOsc.start(now);
  droneOsc.stop(now + waveSec + 0.2);
  harmSyncNodes.push(droneOsc);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ZOOM & PAN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let zoomLevel = 1.0;
let panX = 0, panY = 0;
let isPan = false, panStartX=0, panStartY=0, panStartPX=0, panStartPY=0;

function setZoom(z){
  zoomLevel = Math.max(0.15, Math.min(10, z));
  document.getElementById('zoomLbl').textContent = zoomLevel.toFixed(1)+'Ã—';
}

document.getElementById('btnZoomIn').addEventListener('click', ()=>{ onUserInteraction(); setZoom(zoomLevel*1.25); });
document.getElementById('btnZoomOut').addEventListener('click', ()=>{ onUserInteraction(); setZoom(zoomLevel/1.25); });
document.getElementById('btnZoomReset').addEventListener('click', ()=>{ setZoom(1); panX=0; panY=0; });

// Mouse-wheel zoom on canvas
pCv.addEventListener('wheel', e=>{
  e.preventDefault();
  setZoom(zoomLevel * (e.deltaY < 0 ? 1.12 : 1/1.12));
}, { passive:false });

// Pinch-to-zoom
let lastPinchDist = null;
pCv.addEventListener('touchstart', e=>{
  if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    lastPinchDist=Math.sqrt(dx*dx+dy*dy);
  }
},{passive:true});
pCv.addEventListener('touchmove', e=>{
  if(e.touches.length===2 && lastPinchDist!==null){
    e.preventDefault();
    const dx=e.touches[0].clientX-e.touches[1].clientX;
    const dy=e.touches[0].clientY-e.touches[1].clientY;
    const d=Math.sqrt(dx*dx+dy*dy);
    setZoom(zoomLevel*(d/lastPinchDist));
    lastPinchDist=d;
  }
},{passive:false});
pCv.addEventListener('touchend',()=>{ lastPinchDist=null; });

// Shift+drag = pan
pCv.addEventListener('mousedown', e=>{
  if(e.shiftKey){
    isPan=true; pCv.style.cursor='move';
    panStartX=e.clientX; panStartY=e.clientY;
    panStartPX=panX; panStartPY=panY;
    e.stopImmediatePropagation();
  }
}, true);
window.addEventListener('mousemove', e=>{
  if(isPan){ panX=panStartPX+(e.clientX-panStartX); panY=panStartPY+(e.clientY-panStartY); }
});
window.addEventListener('mouseup', ()=>{ isPan=false; pCv.style.cursor=''; });

// Override proj() to incorporate zoom + pan
function proj(rx, ry, rz){
  const fov=2.8, scale=fov/(fov-rz);
  const R=pCv.width*0.37*zoomLevel;
  return [pCv.width/2 + rx*R*scale + panX, pCv.height/2 - ry*R*scale + panY];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  KEYBOARD SHORTCUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('keydown', e=>{
  if(['INPUT','SELECT','TEXTAREA'].includes(e.target.tagName)) return;
  switch(e.code){
    case 'Space':
      e.preventDefault();
      document.getElementById('btnPlay').click();
      break;
    case 'KeyR':
      autoRotate=!autoRotate;
      document.getElementById('btnAutoRot').classList.toggle('on',autoRotate);
      document.getElementById('btnAutoRot').textContent=autoRotate?'âŸ³ Rotating...':'âŸ³ Auto-Rotate';
      break;
    case 'KeyS':
      exportSphere4K();
      break;
    case 'ArrowUp':
      e.preventDefault(); setZoom(zoomLevel*1.1); break;
    case 'ArrowDown':
      e.preventDefault(); setZoom(zoomLevel/1.1); break;
    case 'ArrowLeft':
      rotMat=mmul(mrotY(-0.08),rotMat); break;
    case 'ArrowRight':
      rotMat=mmul(mrotY(0.08),rotMat); break;
    case 'Escape':
      setZoom(1); panX=0; panY=0;
      rotMat=[1,0,0,0,1,0,0,0,1];
      break;
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SMITH CHART / CAYLEY MAP OVERLAY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let smithEnabled = false;
let smithAlpha   = 0;
let smithOpacity = 0.4;
let smithRadiusMode = 'index';
let smithShowGrid = true, smithShowR = true, smithShowX = true;

// Smith Chart panel â€” always open in dashboard layout
document.getElementById('smithEnable').addEventListener('change',function(){
  smithEnabled=this.checked;
  document.getElementById('smithState').textContent=smithEnabled?'on':'off';
});
document.getElementById('smithAlpha').addEventListener('input',function(){
  smithAlpha=parseFloat(this.value);
  document.getElementById('smithAlphaVal').textContent=smithAlpha+'Â°';
});
document.getElementById('smithOpacity').addEventListener('input',function(){
  smithOpacity=parseFloat(this.value);
  document.getElementById('smithOpacityVal').textContent=Math.round(smithOpacity*100)+'%';
});
document.getElementById('smithRadiusMode').addEventListener('change',function(){ smithRadiusMode=this.value; });
document.getElementById('smithShowGrid').addEventListener('change',function(){ smithShowGrid=this.checked; });
document.getElementById('smithShowR').addEventListener('change',function(){ smithShowR=this.checked; });
document.getElementById('smithShowX').addEventListener('change',function(){ smithShowX=this.checked; });

function drawSmithOverlay(){
  if(!smithEnabled) return;
  const ctx=pCtx, w=pCv.width, h=pCv.height;
  const cx=w/2+panX, cy=h/2+panY;
  const R=Math.min(w,h)*0.37*zoomLevel;
  ctx.save();

  // Unit-circle boundary
  ctx.globalAlpha=smithOpacity; ctx.lineWidth=1.5;
  ctx.strokeStyle='#60a5fa';
  ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.stroke();

  // Constant-R circles (resistance)
  if(smithShowR){
    [0.2,0.5,1,2,5].forEach((rv,i)=>{
      const rcx=cx+R*rv/(rv+1), rcr=R/(rv+1);
      ctx.strokeStyle=`hsl(${190+i*22},80%,60%)`;
      ctx.lineWidth=0.8; ctx.globalAlpha=smithOpacity*0.75;
      ctx.beginPath(); ctx.arc(rcx,cy,rcr,0,Math.PI*2); ctx.stroke();
      // label
      ctx.fillStyle=`hsl(${190+i*22},80%,70%)`;
      ctx.font=`${Math.max(8,w*0.017)}px JetBrains Mono,monospace`;
      ctx.textAlign='center'; ctx.globalAlpha=smithOpacity;
      ctx.fillText('R='+rv, rcx-rcr*0.5, cy-4);
    });
  }

  // Constant-X arcs (reactance)
  if(smithShowX){
    [0.5,1,2,5].forEach((xv,i)=>{
      ctx.lineWidth=0.8; ctx.globalAlpha=smithOpacity*0.7;
      [-1,1].forEach(sign=>{
        const arcCx=cx+R, arcCy=cy-sign*R/xv, arcR=R/xv;
        ctx.strokeStyle=`hsl(${280+i*18},80%,65%)`;
        ctx.beginPath(); ctx.arc(arcCx,arcCy,arcR,0,Math.PI*2); ctx.stroke();
      });
    });
  }

  // Smith grid (radial + concentric rings)
  if(smithShowGrid){
    ctx.globalAlpha=smithOpacity*0.3; ctx.lineWidth=0.4;
    ctx.strokeStyle='rgba(96,165,250,0.5)';
    for(let i=0;i<12;i++){
      const a=(i/12)*Math.PI*2;
      ctx.beginPath(); ctx.moveTo(cx,cy);
      ctx.lineTo(cx+R*Math.cos(a), cy+R*Math.sin(a)); ctx.stroke();
    }
    [0.25,0.5,0.75,1].forEach(ri=>{
      ctx.beginPath(); ctx.arc(cx,cy,R*ri,0,Math.PI*2); ctx.stroke();
    });
  }

  // Plot Cayley-transformed wave curve
  const end=Math.floor(drawProgress);
  if(end>2){
    const aRad=(smithAlpha*Math.PI/180);
    ctx.lineWidth=Math.max(1,traceThickness*0.9);
    ctx.shadowColor='#60a5fa'; ctx.shadowBlur=6;
    ctx.beginPath(); let penDown=false;
    for(let i=1;i<end;i++){
      const t=(i/TOTAL_PTS)*thetaTotal;
      const rv=f(t);
      // Radius: scale by mode
      let Rv;
      if(smithRadiusMode==='unit') Rv=1;
      else if(smithRadiusMode==='modulus') Rv=Math.max(0.1,rv);
      else Rv=0.5+0.5*(i/TOTAL_PTS); // index
      const theta=t+aRad;
      const re=Rv*Math.cos(theta), im=Rv*Math.sin(theta);
      // Cayley: Î“ = (z-1)/(z+1)
      const A2=re-1, B2=im, C2=re+1;
      const denom=C2*C2+B2*B2;
      if(denom<1e-9){ penDown=false; continue; }
      const gre=(A2*C2+B2*B2)/denom;
      const gim=(B2*(C2-A2))/denom;
      // Map Î“ âˆˆ unit disk â†’ canvas
      const px=cx+gre*R, py=cy-gim*R;
      const frac=i/TOTAL_PTS;
      ctx.strokeStyle=harmColorMode?(harmColorForProgress(frac)||`hsl(${200+frac*100},90%,60%)`): `hsl(${200+frac*80},90%,${55+frac*10}%)`;
      ctx.globalAlpha=smithOpacity*0.9;
      if(!penDown){ ctx.beginPath(); ctx.moveTo(px,py); penDown=true; }
      else{ ctx.lineTo(px,py); ctx.stroke(); ctx.beginPath(); ctx.moveTo(px,py); }
    }
    ctx.shadowBlur=0;
  }
  ctx.globalAlpha=1;
  ctx.restore();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  COORDINATE SYSTEM MODES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let coordMode = 'polar';
let coordBlend = 1.0;

const COORD_DESCS = {
  polar:       'Traditional polar/spherical â€” f(Î¸) mapped onto sphere surface.',
  logcylinder: 'Log-Cylinder: u = ln(Î¸+1), v = f(Î¸). Compresses the Î¸ axis logarithmically, revealing fine structure near origin.',
  logspiral:   'Logarithmic Spiral: radius grows as e^(f(Î¸)/A), angle = Î¸. Creates an outward unwinding helix on the sphere.',
  poincare:    'PoincarÃ© Disk (hyperbolic): maps sphere points through the unit-disk model. Distances compress toward the boundary.'
};

// Coord mode panel â€” always open in dashboard layout

document.getElementById('coordModeGrid').addEventListener('click', e=>{
  const btn=e.target.closest('.coord-mode-btn');
  if(!btn) return;
  onUserInteraction();
  coordMode=btn.dataset.mode;
  document.querySelectorAll('.coord-mode-btn').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  document.getElementById('coordModeDesc').textContent=COORD_DESCS[coordMode];
  precompute();
});

document.getElementById('coordBlend').addEventListener('input',function(){
  coordBlend=parseFloat(this.value);
  document.getElementById('coordBlendVal').textContent=Math.round(coordBlend*100)+'%';
  precompute();
});

// Override toSphere to apply coordinate mode transform
function toSphere(t, r){
  // Default polar
  const lon=t;
  const polar=(t/thetaTotal)*Math.PI;
  const rn=r/(A+1.2);
  const px=rn*Math.sin(polar)*Math.cos(lon);
  const py=rn*Math.cos(polar);
  const pz=rn*Math.sin(polar)*Math.sin(lon);
  if(coordMode==='polar' || coordBlend===0) return [px,py,pz];

  let tx=px, ty=py, tz=pz;

  if(coordMode==='logcylinder'){
    const u=Math.log(t+1)/Math.log(thetaTotal+1); // 0â†’1
    const v=r/(A+1.2);
    const lon2=u*Math.PI*2;
    tx=v*Math.cos(lon2); ty=(u*2-1); tz=v*Math.sin(lon2);
  } else if(coordMode==='logspiral'){
    const spiralR=Math.exp(r/A - 1)*0.6;
    const polar2=(t/thetaTotal)*Math.PI;
    const lon2=t*0.5;
    tx=spiralR*Math.sin(polar2)*Math.cos(lon2);
    ty=spiralR*Math.cos(polar2);
    tz=spiralR*Math.sin(polar2)*Math.sin(lon2);
    // clamp
    const mag=Math.sqrt(tx*tx+ty*ty+tz*tz)||1;
    if(mag>1.2){tx/=mag*0.85;ty/=mag*0.85;tz/=mag*0.85;}
  } else if(coordMode==='poincare'){
    // Project sphere point through PoincarÃ© disk: disk coords from (px,py,pz)
    const denom=1-pz*0.8;
    const dx=(denom>0.01)?px/denom:px;
    const dy=(denom>0.01)?py/denom:py;
    const dr=Math.sqrt(dx*dx+dy*dy)||1;
    const clamp=Math.min(1,dr)/Math.max(dr,0.001);
    tx=dx*clamp; ty=dy*clamp; tz=pz*0.3;
  }

  // Blend between polar and transformed
  return [
    px*(1-coordBlend)+tx*coordBlend,
    py*(1-coordBlend)+ty*coordBlend,
    pz*(1-coordBlend)+tz*coordBlend
  ];
}

// Hook Smith overlay into renderSphere â€” append after each frame
const _rsOrig = renderSphere;
renderSphere = function(){
  _rsOrig();
  drawSmithOverlay();
};

buildHarmIntervalGrid();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Track whether user has interacted yet (for introâ†’loop behavior)
let introPlayed = false;
let userHasInteracted = false;

// Call this on any meaningful user interaction to switch to loop mode
function onUserInteraction(){
  if(userHasInteracted) return;
  userHasInteracted = true;
  // Enable loop mode
  looping = true;
  const cbLoop = document.getElementById('cbLoop');
  if(cbLoop){ cbLoop.checked = true; }
  document.getElementById('loopState').textContent = 'on â€” loops forever';
}

// Patch preset buttons, play btn, gap chips, etc. to trigger interaction
(function patchInteractionListeners(){
  // We'll intercept at a high level â€” any click on the page after intro triggers loop
  document.addEventListener('click', function onFirstClick(e){
    // Only activate after intro has started, and ignore the very first auto-play clicks
    if(introPlayed){ onUserInteraction(); }
  }, true);
})();

buildPresets();
hardReset();
loop();

// â”€â”€ Select ALL harmonic intervals by default â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function selectAllHarmIntervals(){
  const grid = document.getElementById('harmIntervalGrid');
  HARM_INTERVALS.forEach((iv, i) => {
    harmSelectedIntervals.add(i);
    const btn = grid.children[i];
    if(btn){
      const col = harmConsonanceColor(iv.p, iv.q);
      btn.classList.add('active');
      btn.style.background = col;
      btn.style.color = '#000';
    }
  });
  updateHarmDisplay();
}
selectAllHarmIntervals();

// â”€â”€ Harmonic Color Mode ON by default â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
harmColorMode = true;
document.getElementById('harmColorMode').checked = true;
document.getElementById('harmModeState').textContent = 'on â€” sphere colored by harmonic consonance';
precompute();

// â”€â”€ Auto-run zeta decomposition with default N=10M â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function autoRunZeta(callback){
  const maxN = 500000; // lighter default so it loads fast
  document.getElementById('gdStatus').textContent = 'Auto-computing prime gapsâ€¦';
  document.getElementById('gdRunBtn').disabled = true;
  document.getElementById('gdProgress').style.display = 'block';
  document.getElementById('gdProgressFill').style.width = '0%';

  // Open the gap panel so user sees it
  const body = document.getElementById('gapBody');
  const chev = document.getElementById('gapChevron');
  const hdr  = document.getElementById('gapHeader');
  if(body) body.classList.add('open');
  if(chev) chev.classList.add('open');
  if(hdr)  hdr.classList.add('open');

  setTimeout(()=>{
    try {
      const s = parseFloat(document.getElementById('gdS').value);
      const progressCb = (cur, max)=>{
        const pct = Math.min(99,(cur/max*100)).toFixed(0);
        document.getElementById('gdProgressFill').style.width = pct+'%';
        document.getElementById('gdStatus').textContent = `Sievingâ€¦ ${pct}%`;
      };

      gdData = gdCompute(maxN, s, 'all', progressCb);

      document.getElementById('gdProgressFill').style.width = '100%';
      setTimeout(()=>document.getElementById('gdProgress').style.display='none', 400);
      document.getElementById('gdStatus').textContent =
        `âœ“ Auto-loaded: ${gdData.primes.length.toLocaleString()} primes Â· ${gdData.gaps.length} gap families`;

      updateGdStats();
      ['gdExportPNG','gdExportCSV','gdExportTXT'].forEach(id=>document.getElementById(id).style.display='inline-block');
      document.getElementById('gdTabs').style.display='flex';
      document.getElementById('gdStatsGrid').style.display='grid';
      buildGapChips();
      gdBuildTable();
      gdBuildConvTable();
      document.getElementById('gdTableSection').style.display='block';
      document.getElementById('gdConvSection').style.display='block';
      precompute();
      invalidateCartBuf();
      gdResizeCanvas();
      gdDraw();

      // Auto-select gap=2
      if(gdData.gaps.includes(2)){
        const idx = gdData.gaps.indexOf(2);
        const col = gapColor(2, idx);
        selectedGaps.set(2, col);
        document.querySelectorAll('.gap-chip[data-gap="2"]').forEach(chip=>{
          chip.classList.add('selected');
          chip.style.background = col;
          chip.style.borderColor = col;
          chip.style.color = '#000';
        });
        invalidateCartBuf();
      }

    } catch(e){
      document.getElementById('gdStatus').textContent = 'Auto-compute failed: '+e.message;
      console.error(e);
    }
    document.getElementById('gdRunBtn').disabled = false;
    if(callback) callback();
  }, 50);
}

// â”€â”€ Welcome / intro sequence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. Play the wave once (no loop) as a welcoming animation + sound
// 2. After wave finishes, mark intro done â†’ next user action enables loop
function startIntro(){
  // Ensure NOT looping for intro
  looping = false;
  const cbLoop = document.getElementById('cbLoop');
  if(cbLoop) cbLoop.checked = false;
  document.getElementById('loopState').textContent = 'off â€” stops at end';

  // Set a welcoming speed (not too fast, not too slow)
  setSpeed(12);

  // Auto-rotate for visual drama
  autoRotate = true;
  const rotBtn = document.getElementById('btnAutoRot');
  if(rotBtn){ rotBtn.classList.add('on'); rotBtn.textContent = 'âŸ³ Rotatingâ€¦'; }

  // Run zeta first, then play
  autoRunZeta(()=>{
    introPlayed = true;
    // Start playback
    hardReset();
    paused = false;
    const playBtn = document.getElementById('btnPlay');
    if(playBtn){ playBtn.textContent = 'â¸ Pause'; playBtn.classList.add('on'); }

    // Play the welcome harmonic sweep (single pass)
    harmSyncStart();
  });
}

// Small delay so DOM is fully ready
setTimeout(startIntro, 300);
</script>
</body>
</html>
