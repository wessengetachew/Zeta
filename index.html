
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Boundary Cancellation Principle - Complete Analysis</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=Source+Code+Pro:wght@400;500&display=swap');

:root {
    --bg-primary: #faf9f7;
    --bg-secondary: #f0eeeb;
    --bg-card: #fff;
    --text-primary: #1a1a1a;
    --text-secondary: #555;
    --text-muted: #888;
    --border: #ddd;
    --border-dark: #ccc;
    --accent: #2a2a2a;
    --accent-light: #444;
    --highlight: #fffde7;
    --theorem-bg: #f5f5f0;
    --definition-bg: #f0f5f5;
    --definition-border: #4a7a7a;
    --table-header: #2a2a2a;
    --table-header-text: #fff;
    --table-alt: #f9f9f7;
    --code-bg: #f5f5f5;
    --success: #2e7d32;
    --warning: #f57c00;
    --error: #c62828;
}

body.dark {
    --bg-primary: #0d0d0f;
    --bg-secondary: #161618;
    --bg-card: #1a1a1e;
    --text-primary: #e8e8ec;
    --text-secondary: #a0a0a8;
    --text-muted: #686870;
    --border: #2a2a32;
    --border-dark: #3a3a42;
    --accent: #c9a227;
    --accent-light: #ddb52f;
    --highlight: #2a2820;
    --theorem-bg: #1e1e22;
    --definition-bg: #1a2020;
    --definition-border: #5a9a9a;
    --table-header: #252528;
    --table-header-text: #e8e8ec;
    --table-alt: #141416;
    --code-bg: #1e1e22;
    --success: #66bb6a;
    --warning: #ffa726;
    --error: #ef5350;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    font-family: 'Crimson Pro', Georgia, serif;
    font-size: 18px;
    line-height: 1.7;
    color: var(--text-primary);
    background: var(--bg-primary);
    padding: 40px 20px;
    transition: background 0.3s, color 0.3s;
}

.container {
    max-width: 1000px;
    margin: 0 auto;
}

header {
    text-align: center;
    margin-bottom: 40px;
    padding-bottom: 25px;
    border-bottom: 1px solid var(--border-dark);
    position: relative;
}

.theme-toggle {
    position: absolute;
    top: 0;
    right: 0;
    padding: 8px 16px;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    color: var(--text-primary);
    font-family: 'Source Code Pro', monospace;
    font-size: 0.8rem;
    cursor: pointer;
    transition: all 0.2s;
}

.theme-toggle:hover {
    background: var(--accent);
    color: var(--table-header-text);
    border-color: var(--accent);
}

h1 {
    font-size: 2rem;
    font-weight: 600;
    margin-bottom: 8px;
    letter-spacing: -0.02em;
}

.subtitle {
    font-size: 1.05rem;
    color: var(--text-secondary);
    font-style: italic;
}

.controls {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    padding: 20px 25px;
    margin-bottom: 35px;
}

.controls-title {
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-muted);
    margin-bottom: 12px;
}

.controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 15px;
    margin-bottom: 15px;
}

.control-item label {
    display: block;
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 4px;
}

.control-item select,
.control-item input {
    width: 100%;
    padding: 7px 10px;
    font-family: 'Source Code Pro', monospace;
    font-size: 0.85rem;
    border: 1px solid var(--border);
    background: var(--bg-card);
    color: var(--text-primary);
}

.compute-btn {
    display: block;
    width: 100%;
    padding: 10px;
    background: var(--accent);
    color: var(--table-header-text);
    border: none;
    font-family: 'Crimson Pro', serif;
    font-size: 0.95rem;
    cursor: pointer;
    transition: background 0.2s;
}

.compute-btn:hover {
    background: var(--accent-light);
}

section {
    margin-bottom: 40px;
}

h2 {
    font-size: 1.3rem;
    font-weight: 600;
    margin-bottom: 15px;
    padding-bottom: 6px;
    border-bottom: 2px solid var(--accent);
}

h3 {
    font-size: 1.1rem;
    font-weight: 600;
    margin: 20px 0 10px 0;
    color: var(--text-primary);
}

p {
    margin-bottom: 12px;
    text-align: justify;
}

.theorem {
    background: var(--theorem-bg);
    border-left: 4px solid var(--accent);
    padding: 15px 20px;
    margin: 20px 0;
}

.theorem-title {
    font-weight: 600;
    margin-bottom: 8px;
}

.definition {
    background: var(--definition-bg);
    border-left: 4px solid var(--definition-border);
    padding: 15px 20px;
    margin: 20px 0;
}

.formula {
    background: var(--code-bg);
    border: 1px solid var(--border);
    padding: 15px;
    margin: 15px 0;
    text-align: center;
    font-family: 'Source Code Pro', monospace;
    font-size: 1rem;
    overflow-x: auto;
}

.formula-label {
    font-size: 0.75rem;
    color: var(--text-muted);
    text-align: right;
    margin-top: 6px;
}

.data-table {
    width: 100%;
    border-collapse: collapse;
    margin: 15px 0;
    font-size: 0.9rem;
}

.data-table th {
    background: var(--table-header);
    color: var(--table-header-text);
    padding: 10px 12px;
    text-align: left;
    font-weight: 500;
    font-size: 0.85rem;
}

.data-table td {
    padding: 8px 12px;
    border-bottom: 1px solid var(--border);
}

.data-table tr:nth-child(even) {
    background: var(--table-alt);
}

.data-table .number {
    font-family: 'Source Code Pro', monospace;
    text-align: right;
}

.highlight-row {
    background: var(--highlight) !important;
}

.stat-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin: 20px 0;
}

.stat-card {
    background: var(--bg-card);
    border: 1px solid var(--border);
    padding: 15px;
}

.stat-label {
    font-size: 0.8rem;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.04em;
}

.stat-value {
    font-family: 'Source Code Pro', monospace;
    font-size: 1.5rem;
    font-weight: 500;
    color: var(--text-primary);
    margin: 4px 0;
}

.stat-note {
    font-size: 0.8rem;
    color: var(--text-muted);
    font-style: italic;
}

.scrollable-table {
    max-height: 350px;
    overflow-y: auto;
    border: 1px solid var(--border);
}

.scrollable-table table {
    margin: 0;
}

.proof {
    margin: 15px 0;
    padding-left: 18px;
    border-left: 2px solid var(--border-dark);
}

.proof-title {
    font-style: italic;
    color: var(--text-secondary);
    margin-bottom: 8px;
}

.qed {
    text-align: right;
    font-size: 1.1rem;
}

.code {
    font-family: 'Source Code Pro', monospace;
    font-size: 0.85rem;
    background: var(--code-bg);
    padding: 2px 5px;
    border-radius: 2px;
}

.export-section {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    padding: 15px 20px;
    margin-top: 30px;
}

.export-title {
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--text-muted);
    margin-bottom: 12px;
}

.export-buttons {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.export-btn {
    padding: 8px 14px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    color: var(--text-primary);
    font-family: 'Crimson Pro', serif;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s;
}

.export-btn:hover {
    background: var(--accent);
    color: var(--table-header-text);
    border-color: var(--accent);
}

.point-list {
    max-height: 250px;
    overflow-y: auto;
    font-family: 'Source Code Pro', monospace;
    font-size: 0.75rem;
    background: var(--code-bg);
    padding: 12px;
    border: 1px solid var(--border);
    white-space: pre;
}

.status-good { color: var(--success); }
.status-warn { color: var(--warning); }
.status-bad { color: var(--error); }

.two-col {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}

@media (max-width: 700px) {
    .two-col { grid-template-columns: 1fr; }
}

.mini-table {
    font-size: 0.85rem;
}

.mini-table td, .mini-table th {
    padding: 6px 10px;
}

footer {
    margin-top: 50px;
    padding-top: 15px;
    border-top: 1px solid var(--border-dark);
    text-align: center;
    font-size: 0.8rem;
    color: var(--text-muted);
}

@media print {
    .controls, .export-section, .theme-toggle { display: none; }
    body { padding: 15px; font-size: 11pt; }
    .scrollable-table { max-height: none; overflow: visible; }
}
</style>
</head>
<body>

<div class="container">
    <header>
        <button class="theme-toggle" onclick="toggleTheme()">Dark Mode</button>
        <h1>The Boundary Cancellation Principle</h1>
        <p class="subtitle">Complete Computational Analysis of Error Terms in Arithmetic Lattices</p>
    </header>

    <div class="controls">
        <div class="controls-title">Parameters</div>
        <div class="controls-grid">
            <div class="control-item">
                <label>Structure Type</label>
                <select id="structureType">
                    <option value="coprime">Coprime Lattice Points</option>
                    <option value="squarefree">Squarefree Integers</option>
                    <option value="kfree">k-Free Integers</option>
                    <option value="coprime-tuple">Coprime m-Tuples</option>
                </select>
            </div>
            <div class="control-item">
                <label>Dimension (k)</label>
                <select id="dimension">
                    <option value="2" selected>2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                </select>
            </div>
            <div class="control-item">
                <label>Radius / Bound (R)</label>
                <input type="number" id="radius" value="60" min="10" max="200">
            </div>
            <div class="control-item">
                <label>k-free parameter</label>
                <input type="number" id="kfreeK" value="2" min="2" max="10">
            </div>
            <div class="control-item">
                <label>Error series step</label>
                <input type="number" id="errorStep" value="2" min="1" max="10">
            </div>
        </div>
        <button class="compute-btn" onclick="compute()">Compute Full Analysis</button>
    </div>

    <!-- Section 1: Principle -->
    <section>
        <h2>1. Statement of the Principle</h2>
        
        <div class="theorem">
            <div class="theorem-title">Boundary Cancellation Principle</div>
            <p>Let an arithmetic counting problem be defined on a <em>k</em>-dimensional lattice with constraints imposed via Möbius inclusion-exclusion. If the main term scales with volume, then the dominant error scales with boundary measure. The error exponent is (k−1)/k.</p>
        </div>

        <div class="formula">
            Error(R) = O(R<sup>k−1</sup>) where k = lattice dimension
        </div>
    </section>

    <!-- Section 2: Configuration -->
    <section>
        <h2>2. Current Configuration</h2>
        
        <div class="stat-grid">
            <div class="stat-card">
                <div class="stat-label">Structure</div>
                <div class="stat-value" id="displayStructure">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Dimension k</div>
                <div class="stat-value" id="displayDimension">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Radius R</div>
                <div class="stat-value" id="displayRadius">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Critical Exponent</div>
                <div class="stat-value" id="displayExponent">—</div>
            </div>
        </div>

        <div class="definition">
            <div class="theorem-title" id="defTitle">Definition</div>
            <p id="defContent">—</p>
        </div>
    </section>

    <!-- Section 3: Main Term -->
    <section>
        <h2>3. Main Term Analysis</h2>

        <div class="two-col">
            <div>
                <h3>Predicted Count</h3>
                <div class="stat-card">
                    <div class="stat-label">Main Term Value</div>
                    <div class="stat-value" id="predictedCount">—</div>
                    <div class="stat-note" id="predictedFormula">—</div>
                </div>
            </div>
            <div>
                <h3>Density Constant</h3>
                <div class="stat-card">
                    <div class="stat-label">1/ζ(k)</div>
                    <div class="stat-value" id="densityConstant">—</div>
                    <div class="stat-note" id="densityNote">—</div>
                </div>
            </div>
        </div>

        <h3>Riemann Zeta Reference Table</h3>
        <table class="data-table mini-table">
            <thead>
                <tr><th>k</th><th>ζ(k)</th><th>1/ζ(k)</th><th>Closed Form</th></tr>
            </thead>
            <tbody>
                <tr><td>2</td><td class="number">1.6449340668</td><td class="number">0.6079271019</td><td>π²/6</td></tr>
                <tr><td>3</td><td class="number">1.2020569032</td><td class="number">0.8319073725</td><td>Apéry's ζ(3)</td></tr>
                <tr><td>4</td><td class="number">1.0823232337</td><td class="number">0.9239384669</td><td>π⁴/90</td></tr>
                <tr><td>5</td><td class="number">1.0369277551</td><td class="number">0.9643895748</td><td>—</td></tr>
                <tr><td>6</td><td class="number">1.0173430620</td><td class="number">0.9829523809</td><td>π⁶/945</td></tr>
            </tbody>
        </table>
    </section>

    <!-- Section 4: Counting -->
    <section>
        <h2>4. Exact Counting Results</h2>

        <div class="stat-grid">
            <div class="stat-card">
                <div class="stat-label">Total Lattice Points</div>
                <div class="stat-value" id="totalPoints">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Surviving Points</div>
                <div class="stat-value" id="survivingPoints">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Removed Points</div>
                <div class="stat-value" id="removedPoints">—</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Empirical Density</div>
                <div class="stat-value" id="empiricalDensity">—</div>
            </div>
        </div>

        <h3>Prediction vs Reality</h3>
        <table class="data-table">
            <thead>
                <tr><th>Quantity</th><th>Value</th><th>Notes</th></tr>
            </thead>
            <tbody>
                <tr><td>Predicted (Main Term)</td><td class="number" id="tablePredicted">—</td><td id="tablePredictedNote">—</td></tr>
                <tr><td>Actual Count</td><td class="number" id="tableActual">—</td><td>Exact enumeration</td></tr>
                <tr class="highlight-row"><td>Error</td><td class="number" id="tableError">—</td><td>Actual − Predicted</td></tr>
                <tr><td>Error Bound O(R<sup id="expInTable">k−1</sup>)</td><td class="number" id="tableErrorBound">—</td><td id="tableErrorBoundNote">—</td></tr>
                <tr><td>Relative Error</td><td class="number" id="tableRelError">—</td><td>|Error|/Predicted</td></tr>
                <tr><td>Error/Bound Ratio</td><td class="number" id="tableErrorRatio">—</td><td id="tableErrorRatioStatus">—</td></tr>
            </tbody>
        </table>
    </section>

    <!-- Section 5: Boundary Analysis -->
    <section>
        <h2>5. Boundary Shell Analysis</h2>

        <p>Testing multiple shell thicknesses to verify error concentration at boundary:</p>

        <div class="scrollable-table">
            <table class="data-table" id="boundaryTable">
                <thead>
                    <tr>
                        <th>Shell δ</th>
                        <th>Range</th>
                        <th>Boundary Pts</th>
                        <th>Interior Pts</th>
                        <th>Boundary %</th>
                        <th>Boundary Density</th>
                        <th>Interior Density</th>
                    </tr>
                </thead>
                <tbody id="boundaryBody"></tbody>
            </table>
        </div>

        <h3>Radial Density Distribution</h3>
        <div class="scrollable-table">
            <table class="data-table" id="radialTable">
                <thead>
                    <tr><th>Radius Range</th><th>Total</th><th>Surviving</th><th>Density</th><th>Deviation from Mean</th></tr>
                </thead>
                <tbody id="radialBody"></tbody>
            </table>
        </div>
    </section>

    <!-- Section 6: Error Series -->
    <section>
        <h2>6. Error Term Scaling Analysis</h2>

        <p>Full range computation of error vs theoretical bound O(R<sup id="errorExpText">k−1</sup>):</p>

        <div class="stat-grid">
            <div class="stat-card">
                <div class="stat-label">Max |Error|/Bound</div>
                <div class="stat-value" id="maxErrorRatio">—</div>
                <div class="stat-note">Should stay bounded</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg |Error|/Bound</div>
                <div class="stat-value" id="avgErrorRatio">—</div>
                <div class="stat-note">Typical ratio</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Estimated Constant C</div>
                <div class="stat-value" id="fittedConstant">—</div>
                <div class="stat-note">From least squares fit</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Fit Quality R²</div>
                <div class="stat-value" id="fitQuality">—</div>
                <div class="stat-note">Coefficient of determination</div>
            </div>
        </div>

        <div class="scrollable-table">
            <table class="data-table">
                <thead>
                    <tr><th>R</th><th>Actual</th><th>Predicted</th><th>Error</th><th>|Error|</th><th>Bound</th><th>|Err|/Bound</th></tr>
                </thead>
                <tbody id="errorSeriesBody"></tbody>
            </table>
        </div>
    </section>

    <!-- Section 7: Möbius Verification -->
    <section>
        <h2>7. Möbius Sum Verification</h2>

        <p>The identity Σ μ(d)/d<sup>k</sup> = 1/ζ(k) underlies the main term. We verify convergence:</p>

        <div class="scrollable-table">
            <table class="data-table">
                <thead>
                    <tr><th>Truncation N</th><th>Partial Sum</th><th>Target 1/ζ(k)</th><th>Error</th><th>Relative Error</th></tr>
                </thead>
                <tbody id="mobiusSumBody"></tbody>
            </table>
        </div>
    </section>

    <!-- Section 8: Dimensional Comparison -->
    <section>
        <h2>8. Dimensional Comparison</h2>

        <p>Same radius R across different dimensions to verify exponent dependence:</p>

        <div class="scrollable-table">
            <table class="data-table">
                <thead>
                    <tr><th>Dim k</th><th>Exponent (k−1)/k</th><th>Total Pts</th><th>Surviving</th><th>Predicted</th><th>Error</th><th>Bound</th><th>|Err|/Bound</th></tr>
                </thead>
                <tbody id="dimCompareBody"></tbody>
            </table>
        </div>
    </section>

    <!-- Section 9: GCD Distribution -->
    <section>
        <h2>9. GCD Distribution of Removed Points</h2>

        <p>For non-coprime points, distribution of gcd values:</p>

        <div class="two-col">
            <div class="scrollable-table">
                <table class="data-table">
                    <thead>
                        <tr><th>gcd</th><th>Count</th><th>Percentage</th><th>μ(gcd)</th></tr>
                    </thead>
                    <tbody id="gcdDistBody"></tbody>
                </table>
            </div>
            <div>
                <h3>Summary</h3>
                <div class="stat-card">
                    <div class="stat-label">Distinct GCD Values</div>
                    <div class="stat-value" id="distinctGcds">—</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Most Common GCD</div>
                    <div class="stat-value" id="commonGcd">—</div>
                </div>
            </div>
        </div>
    </section>

    <!-- Section 10: Proof -->
    <section>
        <h2>10. Proof Sketch</h2>

        <div class="proof">
            <div class="proof-title">Proof (Coprime lattice case)</div>
            
            <p><strong>1.</strong> Möbius inversion: #{coprime in B(R)} = Σ<sub>d≤R</sub> μ(d) · #{lattice in B(R/d)}</p>
            
            <p><strong>2.</strong> Lattice count: #{lattice in B(r)} = Vol(B(r)) + O(r<sup>k−1</sup>)</p>
            
            <p><strong>3.</strong> Main term extraction: Σ<sub>d</sub> μ(d)·Vol(B(R/d)) = R<sup>k</sup>·Σ<sub>d</sub> μ(d)/d<sup>k</sup> = R<sup>k</sup>/ζ(k)</p>
            
            <p><strong>4.</strong> Error accumulation: Boundary errors from each sublattice sum to O(R<sup>k−1</sup>)</p>
            
            <p class="qed">∎</p>
        </div>
    </section>

    <!-- Section 11: Sample Points -->
    <section>
        <h2>11. Sample Data</h2>

        <h3>First 50 Surviving Points (by norm)</h3>
        <div class="point-list" id="pointListSurviving">—</div>

        <h3>First 30 Removed Points (by norm)</h3>
        <div class="point-list" id="pointListRemoved">—</div>
    </section>

    <!-- Exports -->
    <div class="export-section">
        <div class="export-title">Export All Data (CSV)</div>
        <div class="export-buttons">
            <button class="export-btn" onclick="exportCSV('points')">All Points</button>
            <button class="export-btn" onclick="exportCSV('surviving')">Surviving Only</button>
            <button class="export-btn" onclick="exportCSV('error')">Error Series</button>
            <button class="export-btn" onclick="exportCSV('boundary')">Boundary Analysis</button>
            <button class="export-btn" onclick="exportCSV('density')">Radial Density</button>
            <button class="export-btn" onclick="exportCSV('mobius')">Möbius Sums</button>
            <button class="export-btn" onclick="exportCSV('dimensional')">Dim Comparison</button>
            <button class="export-btn" onclick="exportCSV('gcd')">GCD Distribution</button>
            <button class="export-btn" onclick="exportCSV('summary')">Summary</button>
            <button class="export-btn" onclick="exportLaTeX()">LaTeX Tables</button>
            <button class="export-btn" onclick="window.print()">Print / PDF</button>
        </div>
    </div>

    <footer>
        Boundary Cancellation Principle — Complete Analysis<br>
        Computed: <span id="computeTime">—</span> | <span id="computeDuration">—</span>
    </footer>
</div>

<script>
const S = {
    structure: 'coprime',
    dimension: 2,
    radius: 60,
    kfreeK: 2,
    errorStep: 2,
    points: [],
    classified: [],
    errorSeries: [],
    densityData: [],
    boundaryData: [],
    mobiusData: [],
    dimCompare: [],
    gcdDist: [],
    primes: [],
    maxPrime: 0
};

function toggleTheme() {
    const body = document.body;
    const btn = document.querySelector('.theme-toggle');
    body.classList.toggle('dark');
    const isDark = body.classList.contains('dark');
    btn.textContent = isDark ? 'Light Mode' : 'Dark Mode';
    try { localStorage.setItem('theme', isDark ? 'dark' : 'light'); } catch(e) {}
}

// Load saved theme
try {
    if (localStorage.getItem('theme') === 'dark') {
        document.body.classList.add('dark');
    }
} catch(e) {}

document.addEventListener('DOMContentLoaded', function() {
    const btn = document.querySelector('.theme-toggle');
    if (document.body.classList.contains('dark')) {
        btn.textContent = 'Light Mode';
    }
    compute();
});

function sievePrimes(max) {
    if (max <= S.maxPrime) return;
    const sieve = new Array(max + 1).fill(true);
    sieve[0] = sieve[1] = false;
    for (let i = 2; i * i <= max; i++) {
        if (sieve[i]) for (let j = i * i; j <= max; j += i) sieve[j] = false;
    }
    S.primes = [];
    for (let i = 2; i <= max; i++) if (sieve[i]) S.primes.push(i);
    S.maxPrime = max;
}

function gcd(a, b) {
    a = Math.abs(a); b = Math.abs(b);
    while (b) [a, b] = [b, a % b];
    return a;
}

function gcdArr(arr) { return arr.reduce((a, b) => gcd(a, b)); }

function mobius(n) {
    if (n === 1) return 1;
    sievePrimes(Math.ceil(Math.sqrt(n)) + 10);
    let result = 1, temp = n;
    for (const p of S.primes) {
        if (p * p > temp) break;
        if (temp % p === 0) {
            temp /= p;
            result *= -1;
            if (temp % p === 0) return 0;
        }
    }
    if (temp > 1) result *= -1;
    return result;
}

function isKFree(n, k) {
    if (n <= 0) return false;
    sievePrimes(Math.ceil(Math.pow(n, 1/k)) + 10);
    for (const p of S.primes) {
        const pk = Math.pow(p, k);
        if (pk > n) break;
        if (n % pk === 0) return false;
    }
    return true;
}

function generatePoints(R, k) {
    const points = [], R2 = R * R;
    if (k === 2) {
        for (let x = 1; x <= R; x++) {
            const maxY = Math.floor(Math.sqrt(R2 - x * x));
            for (let y = -maxY; y <= maxY; y++) points.push([x, y]);
        }
    } else if (k === 3) {
        for (let x = 1; x <= R; x++) {
            const rem1 = R2 - x * x;
            const maxY = Math.floor(Math.sqrt(rem1));
            for (let y = -maxY; y <= maxY; y++) {
                const rem2 = rem1 - y * y;
                if (rem2 < 0) continue;
                const maxZ = Math.floor(Math.sqrt(rem2));
                for (let z = -maxZ; z <= maxZ; z++) points.push([x, y, z]);
            }
        }
    } else {
        const gen = (cur, d, rem) => {
            if (d === k) { points.push([...cur]); return; }
            const max = Math.floor(Math.sqrt(rem));
            for (let v = (d === 0 ? 1 : -max); v <= max; v++) {
                const nr = rem - v * v;
                if (nr >= 0) { cur.push(v); gen(cur, d + 1, nr); cur.pop(); }
            }
        };
        gen([], 0, R2);
    }
    return points;
}

function classify(p, structure, kfreeK) {
    let survives = false, g = 1;
    switch (structure) {
        case 'coprime':
        case 'coprime-tuple':
            g = gcdArr(p.map(Math.abs));
            survives = g === 1;
            break;
        case 'squarefree':
            survives = isKFree(Math.round(Math.sqrt(p.reduce((s, x) => s + x*x, 0))), 2);
            break;
        case 'kfree':
            survives = isKFree(Math.round(Math.sqrt(p.reduce((s, x) => s + x*x, 0))), kfreeK);
            break;
        default:
            g = gcdArr(p.map(Math.abs));
            survives = g === 1;
    }
    return { point: p, survives, gcd: g, norm: Math.sqrt(p.reduce((s, x) => s + x*x, 0)) };
}

function zeta(s) {
    const v = { 2: Math.PI**2/6, 3: 1.2020569031595942, 4: Math.PI**4/90, 5: 1.0369277551433699, 6: Math.PI**6/945 };
    if (v[s]) return v[s];
    let sum = 0;
    for (let n = 1; n < 10000; n++) sum += 1/Math.pow(n, s);
    return sum;
}

function mainTerm(R, k, str, kfK) {
    switch (str) {
        case 'coprime': case 'coprime-tuple': return Math.pow(R, k) / zeta(k);
        case 'squarefree': return R / zeta(2);
        case 'kfree': return R / zeta(kfK);
        default: return Math.pow(R, k) / zeta(k);
    }
}

function errorBound(R, k, str, kfK) {
    switch (str) {
        case 'squarefree': return Math.pow(R, 0.5);
        case 'kfree': return Math.pow(R, 1/kfK);
        default: return Math.pow(R, k - 1);
    }
}

function compute() {
    // Show loading state
    document.querySelector('.compute-btn').textContent = 'Computing...';
    document.querySelector('.compute-btn').disabled = true;
    
    // Use setTimeout to allow UI to update
    setTimeout(function() {
        try {
            const t0 = performance.now();
            
            S.structure = document.getElementById('structureType').value;
            S.dimension = parseInt(document.getElementById('dimension').value);
            S.radius = parseInt(document.getElementById('radius').value);
            S.kfreeK = parseInt(document.getElementById('kfreeK').value);
            S.errorStep = parseInt(document.getElementById('errorStep').value);
            
            // Limit radius for higher dimensions to prevent freeze
            let R = S.radius;
            const k = S.dimension;
            if (k >= 5 && R > 30) R = 30;
            else if (k >= 4 && R > 50) R = 50;
            S.radius = R;
            document.getElementById('radius').value = R;
            
            S.points = generatePoints(R, k);
            S.classified = S.points.map(p => classify(p, S.structure, S.kfreeK));
            
            const surv = S.classified.filter(p => p.survives);
            const removed = S.classified.filter(p => !p.survives);
            const pred = mainTerm(R, k, S.structure, S.kfreeK);
            const err = surv.length - pred;
            const bnd = errorBound(R, k, S.structure, S.kfreeK);
            
            updateConfig(k, R);
            updateMainTerm(pred, k);
            updateCounting(S.classified.length, surv.length, pred, err, bnd, k);
            computeBoundaryAnalysis(surv, R);
            computeRadialDensity(R);
            computeErrorSeries(k, R);
            computeMobiusSums(k);
            computeDimComparison(Math.min(R, 25)); // Limit for dim comparison
            computeGcdDist(removed);
            updatePointLists(surv, removed);
            
            const elapsed = performance.now() - t0;
            document.getElementById('computeTime').textContent = new Date().toLocaleString();
            document.getElementById('computeDuration').textContent = elapsed.toFixed(0) + 'ms';
        } catch(e) {
            console.error('Compute error:', e);
            document.getElementById('computeTime').textContent = 'Error: ' + e.message;
        }
        
        document.querySelector('.compute-btn').textContent = 'Compute Full Analysis';
        document.querySelector('.compute-btn').disabled = false;
    }, 50);
}

function updateConfig(k, R) {
    const names = { 'coprime': 'Coprime Lattice', 'squarefree': 'Squarefree', 'kfree': `${S.kfreeK}-Free`, 'coprime-tuple': 'Coprime Tuples' };
    document.getElementById('displayStructure').textContent = names[S.structure];
    document.getElementById('displayDimension').textContent = k;
    document.getElementById('displayRadius').textContent = R;
    document.getElementById('displayExponent').textContent = `${k-1}/${k}`;
    document.getElementById('expInTable').textContent = k - 1;
    document.getElementById('errorExpText').textContent = k - 1;
    
    const defs = {
        'coprime': `A point (a₁,...,a${k}) ∈ ℤ${k} is coprime if gcd(a₁,...,a${k}) = 1.`,
        'squarefree': 'An integer n is squarefree if not divisible by p² for any prime p.',
        'kfree': `An integer n is ${S.kfreeK}-free if not divisible by p^${S.kfreeK} for any prime p.`,
        'coprime-tuple': `A ${k}-tuple is coprime if gcd of all components is 1.`
    };
    document.getElementById('defTitle').textContent = `Definition (${names[S.structure]})`;
    document.getElementById('defContent').textContent = defs[S.structure];
}

function updateMainTerm(pred, k) {
    document.getElementById('predictedCount').textContent = pred.toFixed(4);
    document.getElementById('predictedFormula').textContent = S.structure === 'squarefree' ? '6R/π²' : `R^${k}/ζ(${k})`;
    document.getElementById('densityConstant').textContent = (1/zeta(k)).toFixed(10);
    document.getElementById('densityNote').textContent = `ζ(${k}) = ${zeta(k).toFixed(10)}`;
}

function updateCounting(total, survCount, pred, err, bnd, k) {
    document.getElementById('totalPoints').textContent = total.toLocaleString();
    document.getElementById('survivingPoints').textContent = survCount.toLocaleString();
    document.getElementById('removedPoints').textContent = (total - survCount).toLocaleString();
    document.getElementById('empiricalDensity').textContent = total > 0 ? (survCount/total*100).toFixed(4) + '%' : '—';
    
    document.getElementById('tablePredicted').textContent = pred.toFixed(6);
    document.getElementById('tablePredictedNote').textContent = `ζ(${k})=${zeta(k).toFixed(8)}`;
    document.getElementById('tableActual').textContent = survCount.toLocaleString();
    document.getElementById('tableError').textContent = err.toFixed(4);
    document.getElementById('tableErrorBound').textContent = bnd.toFixed(4);
    document.getElementById('tableErrorBoundNote').textContent = `R^${k-1}=${bnd.toFixed(4)}`;
    document.getElementById('tableRelError').textContent = pred > 0 ? (Math.abs(err)/pred*100).toFixed(6) + '%' : '—';
    
    const ratio = bnd > 0 ? Math.abs(err)/bnd : 0;
    document.getElementById('tableErrorRatio').textContent = ratio.toFixed(6);
    const status = document.getElementById('tableErrorRatioStatus');
    if (ratio < 1) { status.textContent = 'Within bound'; status.className = 'status-good'; }
    else if (ratio < 2) { status.textContent = 'Near bound'; status.className = 'status-warn'; }
    else { status.textContent = 'Exceeds bound'; status.className = 'status-bad'; }
}

function computeBoundaryAnalysis(surv, R) {
    S.boundaryData = [];
    const deltas = [1, 2, 3, 5, Math.floor(R*0.05), Math.floor(R*0.1), Math.floor(R*0.15), Math.floor(R*0.2)];
    const unique = [...new Set(deltas.filter(d => d > 0 && d < R))].sort((a,b) => a-b);
    
    for (const delta of unique) {
        const thresh = R - delta;
        const boundary = surv.filter(p => p.norm >= thresh);
        const interior = surv.filter(p => p.norm < thresh);
        
        const bTotal = S.classified.filter(p => p.norm >= thresh).length;
        const iTotal = S.classified.filter(p => p.norm < thresh).length;
        
        S.boundaryData.push({
            delta,
            range: `[${thresh.toFixed(1)}, ${R}]`,
            boundaryPts: boundary.length,
            interiorPts: interior.length,
            boundaryPct: surv.length > 0 ? boundary.length / surv.length * 100 : 0,
            boundaryDensity: bTotal > 0 ? boundary.length / bTotal : 0,
            interiorDensity: iTotal > 0 ? interior.length / iTotal : 0
        });
    }
    
    document.getElementById('boundaryBody').innerHTML = S.boundaryData.map(d => `
        <tr>
            <td class="number">${d.delta}</td>
            <td>${d.range}</td>
            <td class="number">${d.boundaryPts.toLocaleString()}</td>
            <td class="number">${d.interiorPts.toLocaleString()}</td>
            <td class="number">${d.boundaryPct.toFixed(2)}%</td>
            <td class="number">${(d.boundaryDensity*100).toFixed(4)}%</td>
            <td class="number">${(d.interiorDensity*100).toFixed(4)}%</td>
        </tr>
    `).join('');
}

function computeRadialDensity(R) {
    const bins = 15;
    const binW = R / bins;
    S.densityData = [];
    
    let totalDensity = 0;
    for (let i = 0; i < bins; i++) {
        const rMin = i * binW, rMax = (i+1) * binW;
        const inBin = S.classified.filter(p => p.norm >= rMin && p.norm < rMax);
        const survInBin = inBin.filter(p => p.survives).length;
        const density = inBin.length > 0 ? survInBin / inBin.length : 0;
        totalDensity += density;
        S.densityData.push({ rMin, rMax, total: inBin.length, surviving: survInBin, density });
    }
    
    const meanDensity = totalDensity / bins;
    S.densityData.forEach(d => d.deviation = d.density - meanDensity);
    
    document.getElementById('radialBody').innerHTML = S.densityData.map(d => `
        <tr>
            <td>[${d.rMin.toFixed(1)}, ${d.rMax.toFixed(1)})</td>
            <td class="number">${d.total.toLocaleString()}</td>
            <td class="number">${d.surviving.toLocaleString()}</td>
            <td class="number">${(d.density*100).toFixed(4)}%</td>
            <td class="number ${d.deviation >= 0 ? 'status-good' : 'status-bad'}">${(d.deviation*100).toFixed(4)}%</td>
        </tr>
    `).join('');
}

function computeErrorSeries(k, R) {
    S.errorSeries = [];
    const step = Math.max(S.errorStep, k >= 4 ? 5 : 2); // Larger step for higher dims
    const maxR = k >= 5 ? Math.min(R, 30) : R;
    
    for (let r = 5; r <= maxR; r += step) {
        try {
            const pts = generatePoints(r, k);
            const cls = pts.map(p => classify(p, S.structure, S.kfreeK));
            const survC = cls.filter(p => p.survives).length;
            const pred = mainTerm(r, k, S.structure, S.kfreeK);
            const err = survC - pred;
            const bnd = errorBound(r, k, S.structure, S.kfreeK);
            S.errorSeries.push({ r, actual: survC, predicted: pred, error: err, absError: Math.abs(err), bound: bnd, ratio: bnd > 0 ? Math.abs(err)/bnd : 0 });
        } catch(e) {
            console.error('Error series error at r=' + r, e);
        }
    }
    
    const ratios = S.errorSeries.map(d => d.ratio);
    if (ratios.length === 0) {
        document.getElementById('maxErrorRatio').textContent = '—';
        document.getElementById('avgErrorRatio').textContent = '—';
        document.getElementById('fittedConstant').textContent = '—';
        document.getElementById('fitQuality').textContent = '—';
        document.getElementById('errorSeriesBody').innerHTML = '<tr><td colspan="7">No data (radius too small)</td></tr>';
        return;
    }
    document.getElementById('maxErrorRatio').textContent = Math.max(...ratios).toFixed(6);
    document.getElementById('avgErrorRatio').textContent = (ratios.reduce((a,b)=>a+b,0)/ratios.length).toFixed(6);
    
    // Least squares fit for constant C
    const absErrs = S.errorSeries.map(d => d.absError);
    const bounds = S.errorSeries.map(d => d.bound);
    const sumXY = absErrs.reduce((s, e, i) => s + e * bounds[i], 0);
    const sumX2 = bounds.reduce((s, b) => s + b * b, 0);
    const C = sumXY / sumX2;
    document.getElementById('fittedConstant').textContent = C.toFixed(6);
    
    // R² calculation
    const meanErr = absErrs.reduce((a,b)=>a+b,0) / absErrs.length;
    const ssTot = absErrs.reduce((s, e) => s + (e - meanErr)**2, 0);
    const ssRes = absErrs.reduce((s, e, i) => s + (e - C * bounds[i])**2, 0);
    const r2 = 1 - ssRes / ssTot;
    document.getElementById('fitQuality').textContent = r2.toFixed(6);
    
    document.getElementById('errorSeriesBody').innerHTML = S.errorSeries.map(d => `
        <tr>
            <td class="number">${d.r}</td>
            <td class="number">${d.actual.toLocaleString()}</td>
            <td class="number">${d.predicted.toFixed(2)}</td>
            <td class="number">${d.error.toFixed(2)}</td>
            <td class="number">${d.absError.toFixed(2)}</td>
            <td class="number">${d.bound.toFixed(2)}</td>
            <td class="number">${d.ratio.toFixed(4)}</td>
        </tr>
    `).join('');
}

function computeMobiusSums(k) {
    S.mobiusData = [];
    const target = 1 / zeta(k);
    const truncations = [10, 25, 50, 100, 250, 500, 1000, 2500, 5000];
    
    for (const N of truncations) {
        let sum = 0;
        for (let d = 1; d <= N; d++) sum += mobius(d) / Math.pow(d, k);
        const err = sum - target;
        S.mobiusData.push({ N, sum, target, error: err, relError: Math.abs(err)/Math.abs(target)*100 });
    }
    
    document.getElementById('mobiusSumBody').innerHTML = S.mobiusData.map(d => `
        <tr>
            <td class="number">${d.N.toLocaleString()}</td>
            <td class="number">${d.sum.toFixed(10)}</td>
            <td class="number">${d.target.toFixed(10)}</td>
            <td class="number">${d.error.toFixed(10)}</td>
            <td class="number">${d.relError.toFixed(6)}%</td>
        </tr>
    `).join('');
}

function computeDimComparison(R) {
    S.dimCompare = [];
    const testR = Math.min(R, 25); // Keep small for safety
    const maxK = testR <= 15 ? 5 : (testR <= 20 ? 4 : 3);
    
    for (let k = 2; k <= maxK; k++) {
        try {
            const pts = generatePoints(testR, k);
            const cls = pts.map(p => classify(p, S.structure, S.kfreeK));
            const survC = cls.filter(p => p.survives).length;
            const pred = mainTerm(testR, k, S.structure, S.kfreeK);
            const err = survC - pred;
            const bnd = errorBound(testR, k, S.structure, S.kfreeK);
            S.dimCompare.push({ k, exp: (k-1)/k, total: pts.length, surviving: survC, predicted: pred, error: err, bound: bnd, ratio: bnd > 0 ? Math.abs(err)/bnd : 0 });
        } catch(e) {
            console.error('Dim compare error at k=' + k, e);
        }
    }
    
    document.getElementById('dimCompareBody').innerHTML = S.dimCompare.map(d => `
        <tr>
            <td class="number">${d.k}</td>
            <td class="number">${d.exp.toFixed(4)}</td>
            <td class="number">${d.total.toLocaleString()}</td>
            <td class="number">${d.surviving.toLocaleString()}</td>
            <td class="number">${d.predicted.toFixed(2)}</td>
            <td class="number">${d.error.toFixed(2)}</td>
            <td class="number">${d.bound.toFixed(2)}</td>
            <td class="number">${d.ratio.toFixed(4)}</td>
        </tr>
    `).join('');
}

function computeGcdDist(removed) {
    const gcdMap = new Map();
    for (const p of removed) {
        const g = p.gcd;
        gcdMap.set(g, (gcdMap.get(g) || 0) + 1);
    }
    
    S.gcdDist = [...gcdMap.entries()]
        .map(([g, count]) => ({ gcd: g, count, pct: removed.length > 0 ? count/removed.length*100 : 0, mu: mobius(g) }))
        .sort((a, b) => b.count - a.count);
    
    document.getElementById('gcdDistBody').innerHTML = S.gcdDist.slice(0, 20).map(d => `
        <tr>
            <td class="number">${d.gcd}</td>
            <td class="number">${d.count.toLocaleString()}</td>
            <td class="number">${d.pct.toFixed(2)}%</td>
            <td class="number">${d.mu}</td>
        </tr>
    `).join('');
    
    document.getElementById('distinctGcds').textContent = S.gcdDist.length;
    document.getElementById('commonGcd').textContent = S.gcdDist.length > 0 ? S.gcdDist[0].gcd : '—';
}

function updatePointLists(surv, removed) {
    const sortedSurv = surv.sort((a, b) => a.norm - b.norm).slice(0, 50);
    document.getElementById('pointListSurviving').textContent = sortedSurv
        .map((p, i) => `${String(i+1).padStart(3)}. (${p.point.join(', ')})  |x|=${p.norm.toFixed(4)}`)
        .join('\n') || '—';
    
    const sortedRem = removed.sort((a, b) => a.norm - b.norm).slice(0, 30);
    document.getElementById('pointListRemoved').textContent = sortedRem
        .map((p, i) => `${String(i+1).padStart(3)}. (${p.point.join(', ')})  gcd=${p.gcd}  |x|=${p.norm.toFixed(4)}`)
        .join('\n') || '—';
}

function exportCSV(type) {
    let csv = '', fn = '';
    const k = S.dimension;
    
    switch (type) {
        case 'points':
            csv = 'idx,' + Array.from({length:k},(_,i)=>`x${i+1}`).join(',') + ',survives,gcd,norm\n';
            S.classified.forEach((p, i) => { csv += `${i},${p.point.join(',')},${p.survives?1:0},${p.gcd},${p.norm.toFixed(6)}\n`; });
            fn = 'all-points'; break;
        case 'surviving':
            csv = 'idx,' + Array.from({length:k},(_,i)=>`x${i+1}`).join(',') + ',norm\n';
            S.classified.filter(p=>p.survives).forEach((p, i) => { csv += `${i},${p.point.join(',')},${p.norm.toFixed(6)}\n`; });
            fn = 'surviving-points'; break;
        case 'error':
            csv = 'R,actual,predicted,error,abs_error,bound,ratio\n';
            S.errorSeries.forEach(d => { csv += `${d.r},${d.actual},${d.predicted.toFixed(6)},${d.error.toFixed(6)},${d.absError.toFixed(6)},${d.bound.toFixed(6)},${d.ratio.toFixed(6)}\n`; });
            fn = 'error-series'; break;
        case 'boundary':
            csv = 'delta,boundary_pts,interior_pts,boundary_pct,boundary_density,interior_density\n';
            S.boundaryData.forEach(d => { csv += `${d.delta},${d.boundaryPts},${d.interiorPts},${d.boundaryPct.toFixed(4)},${d.boundaryDensity.toFixed(6)},${d.interiorDensity.toFixed(6)}\n`; });
            fn = 'boundary-analysis'; break;
        case 'density':
            csv = 'r_min,r_max,total,surviving,density,deviation\n';
            S.densityData.forEach(d => { csv += `${d.rMin.toFixed(2)},${d.rMax.toFixed(2)},${d.total},${d.surviving},${d.density.toFixed(6)},${d.deviation.toFixed(6)}\n`; });
            fn = 'radial-density'; break;
        case 'mobius':
            csv = 'N,partial_sum,target,error,rel_error_pct\n';
            S.mobiusData.forEach(d => { csv += `${d.N},${d.sum.toFixed(10)},${d.target.toFixed(10)},${d.error.toFixed(10)},${d.relError.toFixed(6)}\n`; });
            fn = 'mobius-sums'; break;
        case 'dimensional':
            csv = 'k,exponent,total,surviving,predicted,error,bound,ratio\n';
            S.dimCompare.forEach(d => { csv += `${d.k},${d.exp.toFixed(4)},${d.total},${d.surviving},${d.predicted.toFixed(4)},${d.error.toFixed(4)},${d.bound.toFixed(4)},${d.ratio.toFixed(4)}\n`; });
            fn = 'dim-comparison'; break;
        case 'gcd':
            csv = 'gcd,count,percentage,mobius\n';
            S.gcdDist.forEach(d => { csv += `${d.gcd},${d.count},${d.pct.toFixed(4)},${d.mu}\n`; });
            fn = 'gcd-distribution'; break;
        case 'summary':
            const surv = S.classified.filter(p=>p.survives).length;
            const pred = mainTerm(S.radius, k, S.structure, S.kfreeK);
            csv = 'parameter,value\n';
            csv += `structure,${S.structure}\ndimension,${k}\nradius,${S.radius}\n`;
            csv += `total_points,${S.classified.length}\nsurviving,${surv}\npredicted,${pred.toFixed(6)}\n`;
            csv += `error,${(surv-pred).toFixed(6)}\nerror_bound,${errorBound(S.radius,k,S.structure,S.kfreeK).toFixed(6)}\n`;
            csv += `critical_exponent,${((k-1)/k).toFixed(6)}\nzeta_k,${zeta(k).toFixed(10)}\n`;
            fn = 'summary'; break;
    }
    
    const blob = new Blob([csv], {type:'text/csv'});
    const link = document.createElement('a');
    link.download = `bcp-${fn}-${Date.now()}.csv`;
    link.href = URL.createObjectURL(blob);
    link.click();
}

function exportLaTeX() {
    const k = S.dimension, R = S.radius;
    const surv = S.classified.filter(p=>p.survives).length;
    const pred = mainTerm(R, k, S.structure, S.kfreeK);
    
    let tex = `% BCP Analysis - ${S.structure}, k=${k}, R=${R}
\\begin{table}[h]\\centering
\\begin{tabular}{lrr}\\toprule
Quantity & Value & Notes \\\\\\midrule
Dimension $k$ & ${k} & \\\\
Radius $R$ & ${R} & \\\\
Surviving & ${surv.toLocaleString()} & Exact \\\\
Predicted & ${pred.toFixed(4)} & $R^k/\\zeta(k)$ \\\\
Error & ${(surv-pred).toFixed(4)} & \\\\
Bound & ${errorBound(R,k,S.structure,S.kfreeK).toFixed(4)} & $O(R^{${k-1}})$ \\\\
\\bottomrule\\end{tabular}
\\caption{BCP verification}\\end{table}

\\begin{table}[h]\\centering
\\begin{tabular}{rrrrrrr}\\toprule
$R$ & Actual & Pred & Error & Bound & Ratio \\\\\\midrule
`;
    S.errorSeries.slice(0, 15).forEach(d => {
        tex += `${d.r} & ${d.actual} & ${d.predicted.toFixed(1)} & ${d.error.toFixed(1)} & ${d.bound.toFixed(1)} & ${d.ratio.toFixed(3)} \\\\\n`;
    });
    tex += `\\bottomrule\\end{tabular}\\caption{Error scaling}\\end{table}`;
    
    const blob = new Blob([tex], {type:'text/plain'});
    const link = document.createElement('a');
    link.download = `bcp-latex-${Date.now()}.tex`;
    link.href = URL.createObjectURL(blob);
    link.click();
}

// compute() is called in DOMContentLoaded above
</script>

</body>
</html>
